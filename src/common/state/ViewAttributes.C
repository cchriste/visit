/*****************************************************************************
*
* Copyright (c) 2000 - 2006, The Regents of the University of California
* Produced at the Lawrence Livermore National Laboratory
* All rights reserved.
*
* This file is part of VisIt. For details, see http://www.llnl.gov/visit/. The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or materials provided with the distribution.
*  - Neither the name of the UC/LLNL nor  the names of its contributors may be
*    used to  endorse or  promote products derived from  this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED.  IN  NO  EVENT  SHALL  THE  REGENTS  OF  THE  UNIVERSITY OF
* CALIFORNIA, THE U.S.  DEPARTMENT  OF  ENERGY OR CONTRIBUTORS BE  LIABLE  FOR
* ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

#include <ViewAttributes.h>
#include <DataNode.h>

// ****************************************************************************
// Method: ViewAttributes::ViewAttributes
//
// Purpose: 
//   Constructor for the ViewAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Thu Dec 18 11:24:37 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

ViewAttributes::ViewAttributes() : AttributeSubject("DDDdbdddDdbDDd")
{
    viewNormal[0] = 0;
    viewNormal[1] = 0;
    viewNormal[2] = 1;
    focus[0] = 0;
    focus[1] = 0;
    focus[2] = 0;
    viewUp[0] = 0;
    viewUp[1] = 1;
    viewUp[2] = 0;
    viewAngle = 30;
    setScale = false;
    parallelScale = 1;
    nearPlane = 0.001;
    farPlane = 100;
    imagePan[0] = 0;
    imagePan[1] = 0;
    imageZoom = 1;
    perspective = true;
    windowCoords[0] = 0;
    windowCoords[1] = 0;
    windowCoords[2] = 1;
    windowCoords[3] = 1;
    viewportCoords[0] = 0.1;
    viewportCoords[1] = 0.1;
    viewportCoords[2] = 0.9;
    viewportCoords[3] = 0.9;
    eyeAngle = 2;
}

// ****************************************************************************
// Method: ViewAttributes::ViewAttributes
//
// Purpose: 
//   Copy constructor for the ViewAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Thu Dec 18 11:24:37 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

ViewAttributes::ViewAttributes(const ViewAttributes &obj) : AttributeSubject("DDDdbdddDdbDDd")
{
    int i;

    viewNormal[0] = obj.viewNormal[0];
    viewNormal[1] = obj.viewNormal[1];
    viewNormal[2] = obj.viewNormal[2];

    focus[0] = obj.focus[0];
    focus[1] = obj.focus[1];
    focus[2] = obj.focus[2];

    viewUp[0] = obj.viewUp[0];
    viewUp[1] = obj.viewUp[1];
    viewUp[2] = obj.viewUp[2];

    viewAngle = obj.viewAngle;
    setScale = obj.setScale;
    parallelScale = obj.parallelScale;
    nearPlane = obj.nearPlane;
    farPlane = obj.farPlane;
    imagePan[0] = obj.imagePan[0];
    imagePan[1] = obj.imagePan[1];

    imageZoom = obj.imageZoom;
    perspective = obj.perspective;
    for(i = 0; i < 4; ++i)
        windowCoords[i] = obj.windowCoords[i];

    for(i = 0; i < 4; ++i)
        viewportCoords[i] = obj.viewportCoords[i];

    eyeAngle = obj.eyeAngle;

    SelectAll();
}

// ****************************************************************************
// Method: ViewAttributes::~ViewAttributes
//
// Purpose: 
//   Destructor for the ViewAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Thu Dec 18 11:24:37 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

ViewAttributes::~ViewAttributes()
{
    // nothing here
}

// ****************************************************************************
// Method: ViewAttributes::operator = 
//
// Purpose: 
//   Assignment operator for the ViewAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Thu Dec 18 11:24:37 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

void
ViewAttributes::operator = (const ViewAttributes &obj)
{
    int i;

    viewNormal[0] = obj.viewNormal[0];
    viewNormal[1] = obj.viewNormal[1];
    viewNormal[2] = obj.viewNormal[2];

    focus[0] = obj.focus[0];
    focus[1] = obj.focus[1];
    focus[2] = obj.focus[2];

    viewUp[0] = obj.viewUp[0];
    viewUp[1] = obj.viewUp[1];
    viewUp[2] = obj.viewUp[2];

    viewAngle = obj.viewAngle;
    setScale = obj.setScale;
    parallelScale = obj.parallelScale;
    nearPlane = obj.nearPlane;
    farPlane = obj.farPlane;
    imagePan[0] = obj.imagePan[0];
    imagePan[1] = obj.imagePan[1];

    imageZoom = obj.imageZoom;
    perspective = obj.perspective;
    for(i = 0; i < 4; ++i)
        windowCoords[i] = obj.windowCoords[i];

    for(i = 0; i < 4; ++i)
        viewportCoords[i] = obj.viewportCoords[i];

    eyeAngle = obj.eyeAngle;

    SelectAll();
}

// ****************************************************************************
// Method: ViewAttributes::operator == 
//
// Purpose: 
//   Comparison operator == for the ViewAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Thu Dec 18 11:24:37 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

bool
ViewAttributes::operator == (const ViewAttributes &obj) const
{
    int i;

    // Compare the viewNormal arrays.
    bool viewNormal_equal = true;
    for(i = 0; i < 3 && viewNormal_equal; ++i)
        viewNormal_equal = (viewNormal[i] == obj.viewNormal[i]);

    // Compare the focus arrays.
    bool focus_equal = true;
    for(i = 0; i < 3 && focus_equal; ++i)
        focus_equal = (focus[i] == obj.focus[i]);

    // Compare the viewUp arrays.
    bool viewUp_equal = true;
    for(i = 0; i < 3 && viewUp_equal; ++i)
        viewUp_equal = (viewUp[i] == obj.viewUp[i]);

    // Compare the imagePan arrays.
    bool imagePan_equal = true;
    for(i = 0; i < 2 && imagePan_equal; ++i)
        imagePan_equal = (imagePan[i] == obj.imagePan[i]);

    // Compare the windowCoords arrays.
    bool windowCoords_equal = true;
    for(i = 0; i < 4 && windowCoords_equal; ++i)
        windowCoords_equal = (windowCoords[i] == obj.windowCoords[i]);

    // Compare the viewportCoords arrays.
    bool viewportCoords_equal = true;
    for(i = 0; i < 4 && viewportCoords_equal; ++i)
        viewportCoords_equal = (viewportCoords[i] == obj.viewportCoords[i]);

    // Create the return value
    return (viewNormal_equal &&
            focus_equal &&
            viewUp_equal &&
            (viewAngle == obj.viewAngle) &&
            (setScale == obj.setScale) &&
            (parallelScale == obj.parallelScale) &&
            (nearPlane == obj.nearPlane) &&
            (farPlane == obj.farPlane) &&
            imagePan_equal &&
            (imageZoom == obj.imageZoom) &&
            (perspective == obj.perspective) &&
            windowCoords_equal &&
            viewportCoords_equal &&
            (eyeAngle == obj.eyeAngle));
}

// ****************************************************************************
// Method: ViewAttributes::operator != 
//
// Purpose: 
//   Comparison operator != for the ViewAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Thu Dec 18 11:24:37 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

bool
ViewAttributes::operator != (const ViewAttributes &obj) const
{
    return !(this->operator == (obj));
}

// ****************************************************************************
// Method: ViewAttributes::TypeName
//
// Purpose: 
//   Type name method for the ViewAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Thu Dec 18 11:24:37 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

const std::string
ViewAttributes::TypeName() const
{
    return "ViewAttributes";
}

// ****************************************************************************
// Method: ViewAttributes::CopyAttributes
//
// Purpose: 
//   CopyAttributes method for the ViewAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Thu Dec 18 11:24:37 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

bool
ViewAttributes::CopyAttributes(const AttributeGroup *atts)
{
    if(TypeName() != atts->TypeName())
        return false;

    // Call assignment operator.
    const ViewAttributes *tmp = (const ViewAttributes *)atts;
    *this = *tmp;

    return true;
}

// ****************************************************************************
// Method: ViewAttributes::CreateCompatible
//
// Purpose: 
//   CreateCompatible method for the ViewAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Thu Dec 18 11:24:37 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

AttributeSubject *
ViewAttributes::CreateCompatible(const std::string &tname) const
{
    AttributeSubject *retval = 0;
    if(TypeName() == tname)
        retval = new ViewAttributes(*this);
    // Other cases could go here too. 

    return retval;
}

// ****************************************************************************
// Method: ViewAttributes::NewInstance
//
// Purpose: 
//   NewInstance method for the ViewAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Thu Dec 18 11:24:37 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

AttributeSubject *
ViewAttributes::NewInstance(bool copy) const
{
    AttributeSubject *retval = 0;
    if(copy)
        retval = new ViewAttributes(*this);
    else
        retval = new ViewAttributes;

    return retval;
}

// ****************************************************************************
// Method: ViewAttributes::SelectAll
//
// Purpose: 
//   Selects all attributes.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Thu Dec 18 11:24:37 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

void
ViewAttributes::SelectAll()
{
    Select(0, (void *)viewNormal, 3);
    Select(1, (void *)focus, 3);
    Select(2, (void *)viewUp, 3);
    Select(3, (void *)&viewAngle);
    Select(4, (void *)&setScale);
    Select(5, (void *)&parallelScale);
    Select(6, (void *)&nearPlane);
    Select(7, (void *)&farPlane);
    Select(8, (void *)imagePan, 2);
    Select(9, (void *)&imageZoom);
    Select(10, (void *)&perspective);
    Select(11, (void *)windowCoords, 4);
    Select(12, (void *)viewportCoords, 4);
    Select(13, (void *)&eyeAngle);
}

///////////////////////////////////////////////////////////////////////////////
// Persistence methods
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: ViewAttributes::CreateNode
//
// Purpose: 
//   This method creates a DataNode representation of the object so it can be saved to a config file.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Thu Dec 18 11:24:37 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

bool
ViewAttributes::CreateNode(DataNode *parentNode, bool completeSave, bool forceAdd)
{
    if(parentNode == 0)
        return false;

    ViewAttributes defaultObject;
    bool addToParent = false;
    // Create a node for ViewAttributes.
    DataNode *node = new DataNode("ViewAttributes");

    if(completeSave || !FieldsEqual(0, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("viewNormal", viewNormal, 3));
    }

    if(completeSave || !FieldsEqual(1, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("focus", focus, 3));
    }

    if(completeSave || !FieldsEqual(2, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("viewUp", viewUp, 3));
    }

    if(completeSave || !FieldsEqual(3, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("viewAngle", viewAngle));
    }

    if(completeSave || !FieldsEqual(4, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("setScale", setScale));
    }

    if(completeSave || !FieldsEqual(5, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("parallelScale", parallelScale));
    }

    if(completeSave || !FieldsEqual(6, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("nearPlane", nearPlane));
    }

    if(completeSave || !FieldsEqual(7, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("farPlane", farPlane));
    }

    if(completeSave || !FieldsEqual(8, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("imagePan", imagePan, 2));
    }

    if(completeSave || !FieldsEqual(9, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("imageZoom", imageZoom));
    }

    if(completeSave || !FieldsEqual(10, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("perspective", perspective));
    }

    if(completeSave || !FieldsEqual(11, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("windowCoords", windowCoords, 4));
    }

    if(completeSave || !FieldsEqual(12, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("viewportCoords", viewportCoords, 4));
    }

    if(completeSave || !FieldsEqual(13, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("eyeAngle", eyeAngle));
    }


    // Add the node to the parent node.
    if(addToParent || forceAdd)
        parentNode->AddNode(node);
    else
        delete node;

    return (addToParent || forceAdd);
}

// ****************************************************************************
// Method: ViewAttributes::SetFromNode
//
// Purpose: 
//   This method sets attributes in this object from values in a DataNode representation of the object.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Thu Dec 18 11:24:37 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

void
ViewAttributes::SetFromNode(DataNode *parentNode)
{
    int i;
    if(parentNode == 0)
        return;

    DataNode *searchNode = parentNode->GetNode("ViewAttributes");
    if(searchNode == 0)
        return;

    DataNode *node;
    if((node = searchNode->GetNode("viewNormal")) != 0)
        SetViewNormal(node->AsDoubleArray());
    if((node = searchNode->GetNode("focus")) != 0)
        SetFocus(node->AsDoubleArray());
    if((node = searchNode->GetNode("viewUp")) != 0)
        SetViewUp(node->AsDoubleArray());
    if((node = searchNode->GetNode("viewAngle")) != 0)
        SetViewAngle(node->AsDouble());
    if((node = searchNode->GetNode("setScale")) != 0)
        SetSetScale(node->AsBool());
    if((node = searchNode->GetNode("parallelScale")) != 0)
        SetParallelScale(node->AsDouble());
    if((node = searchNode->GetNode("nearPlane")) != 0)
        SetNearPlane(node->AsDouble());
    if((node = searchNode->GetNode("farPlane")) != 0)
        SetFarPlane(node->AsDouble());
    if((node = searchNode->GetNode("imagePan")) != 0)
        SetImagePan(node->AsDoubleArray());
    if((node = searchNode->GetNode("imageZoom")) != 0)
        SetImageZoom(node->AsDouble());
    if((node = searchNode->GetNode("perspective")) != 0)
        SetPerspective(node->AsBool());
    if((node = searchNode->GetNode("windowCoords")) != 0)
        SetWindowCoords(node->AsDoubleArray());
    if((node = searchNode->GetNode("viewportCoords")) != 0)
        SetViewportCoords(node->AsDoubleArray());
    if((node = searchNode->GetNode("eyeAngle")) != 0)
        SetEyeAngle(node->AsDouble());
}

///////////////////////////////////////////////////////////////////////////////
// Set property methods
///////////////////////////////////////////////////////////////////////////////

void
ViewAttributes::SetViewNormal(const double *viewNormal_)
{
    viewNormal[0] = viewNormal_[0];
    viewNormal[1] = viewNormal_[1];
    viewNormal[2] = viewNormal_[2];
    Select(0, (void *)viewNormal, 3);
}

void
ViewAttributes::SetFocus(const double *focus_)
{
    focus[0] = focus_[0];
    focus[1] = focus_[1];
    focus[2] = focus_[2];
    Select(1, (void *)focus, 3);
}

void
ViewAttributes::SetViewUp(const double *viewUp_)
{
    viewUp[0] = viewUp_[0];
    viewUp[1] = viewUp_[1];
    viewUp[2] = viewUp_[2];
    Select(2, (void *)viewUp, 3);
}

void
ViewAttributes::SetViewAngle(double viewAngle_)
{
    viewAngle = viewAngle_;
    Select(3, (void *)&viewAngle);
}

void
ViewAttributes::SetSetScale(bool setScale_)
{
    setScale = setScale_;
    Select(4, (void *)&setScale);
}

void
ViewAttributes::SetParallelScale(double parallelScale_)
{
    parallelScale = parallelScale_;
    Select(5, (void *)&parallelScale);
}

void
ViewAttributes::SetNearPlane(double nearPlane_)
{
    nearPlane = nearPlane_;
    Select(6, (void *)&nearPlane);
}

void
ViewAttributes::SetFarPlane(double farPlane_)
{
    farPlane = farPlane_;
    Select(7, (void *)&farPlane);
}

void
ViewAttributes::SetImagePan(const double *imagePan_)
{
    imagePan[0] = imagePan_[0];
    imagePan[1] = imagePan_[1];
    Select(8, (void *)imagePan, 2);
}

void
ViewAttributes::SetImageZoom(double imageZoom_)
{
    imageZoom = imageZoom_;
    Select(9, (void *)&imageZoom);
}

void
ViewAttributes::SetPerspective(bool perspective_)
{
    perspective = perspective_;
    Select(10, (void *)&perspective);
}

void
ViewAttributes::SetWindowCoords(const double *windowCoords_)
{
    windowCoords[0] = windowCoords_[0];
    windowCoords[1] = windowCoords_[1];
    windowCoords[2] = windowCoords_[2];
    windowCoords[3] = windowCoords_[3];
    Select(11, (void *)windowCoords, 4);
}

void
ViewAttributes::SetViewportCoords(const double *viewportCoords_)
{
    viewportCoords[0] = viewportCoords_[0];
    viewportCoords[1] = viewportCoords_[1];
    viewportCoords[2] = viewportCoords_[2];
    viewportCoords[3] = viewportCoords_[3];
    Select(12, (void *)viewportCoords, 4);
}

void
ViewAttributes::SetEyeAngle(double eyeAngle_)
{
    eyeAngle = eyeAngle_;
    Select(13, (void *)&eyeAngle);
}

///////////////////////////////////////////////////////////////////////////////
// Get property methods
///////////////////////////////////////////////////////////////////////////////

const double *
ViewAttributes::GetViewNormal() const
{
    return viewNormal;
}

double *
ViewAttributes::GetViewNormal()
{
    return viewNormal;
}

const double *
ViewAttributes::GetFocus() const
{
    return focus;
}

double *
ViewAttributes::GetFocus()
{
    return focus;
}

const double *
ViewAttributes::GetViewUp() const
{
    return viewUp;
}

double *
ViewAttributes::GetViewUp()
{
    return viewUp;
}

double
ViewAttributes::GetViewAngle() const
{
    return viewAngle;
}

bool
ViewAttributes::GetSetScale() const
{
    return setScale;
}

double
ViewAttributes::GetParallelScale() const
{
    return parallelScale;
}

double
ViewAttributes::GetNearPlane() const
{
    return nearPlane;
}

double
ViewAttributes::GetFarPlane() const
{
    return farPlane;
}

const double *
ViewAttributes::GetImagePan() const
{
    return imagePan;
}

double *
ViewAttributes::GetImagePan()
{
    return imagePan;
}

double
ViewAttributes::GetImageZoom() const
{
    return imageZoom;
}

bool
ViewAttributes::GetPerspective() const
{
    return perspective;
}

const double *
ViewAttributes::GetWindowCoords() const
{
    return windowCoords;
}

double *
ViewAttributes::GetWindowCoords()
{
    return windowCoords;
}

const double *
ViewAttributes::GetViewportCoords() const
{
    return viewportCoords;
}

double *
ViewAttributes::GetViewportCoords()
{
    return viewportCoords;
}

double
ViewAttributes::GetEyeAngle() const
{
    return eyeAngle;
}

///////////////////////////////////////////////////////////////////////////////
// Select property methods
///////////////////////////////////////////////////////////////////////////////

void
ViewAttributes::SelectViewNormal()
{
    Select(0, (void *)viewNormal, 3);
}

void
ViewAttributes::SelectFocus()
{
    Select(1, (void *)focus, 3);
}

void
ViewAttributes::SelectViewUp()
{
    Select(2, (void *)viewUp, 3);
}

void
ViewAttributes::SelectImagePan()
{
    Select(8, (void *)imagePan, 2);
}

void
ViewAttributes::SelectWindowCoords()
{
    Select(11, (void *)windowCoords, 4);
}

void
ViewAttributes::SelectViewportCoords()
{
    Select(12, (void *)viewportCoords, 4);
}

///////////////////////////////////////////////////////////////////////////////
// Keyframing methods
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: ViewAttributes::GetFieldName
//
// Purpose: 
//   This method returns the name of a field given its index.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Thu Dec 18 11:24:37 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

std::string
ViewAttributes::GetFieldName(int index) const
{
    switch (index)
    {
        case 0:  return "viewNormal";
        case 1:  return "focus";
        case 2:  return "viewUp";
        case 3:  return "viewAngle";
        case 4:  return "setScale";
        case 5:  return "parallelScale";
        case 6:  return "nearPlane";
        case 7:  return "farPlane";
        case 8:  return "imagePan";
        case 9:  return "imageZoom";
        case 10:  return "perspective";
        case 11:  return "windowCoords";
        case 12:  return "viewportCoords";
        case 13:  return "eyeAngle";
        default:  return "invalid index";
    }
}

// ****************************************************************************
// Method: ViewAttributes::GetFieldType
//
// Purpose: 
//   This method returns the type of a field given its index.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Thu Dec 18 11:24:37 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

AttributeGroup::FieldType
ViewAttributes::GetFieldType(int index) const
{
    switch (index)
    {
        case 0:  return FieldType_doubleArray;
        case 1:  return FieldType_doubleArray;
        case 2:  return FieldType_doubleArray;
        case 3:  return FieldType_double;
        case 4:  return FieldType_bool;
        case 5:  return FieldType_double;
        case 6:  return FieldType_double;
        case 7:  return FieldType_double;
        case 8:  return FieldType_doubleArray;
        case 9:  return FieldType_double;
        case 10:  return FieldType_bool;
        case 11:  return FieldType_doubleArray;
        case 12:  return FieldType_doubleArray;
        case 13:  return FieldType_double;
        default:  return FieldType_unknown;
    }
}

// ****************************************************************************
// Method: ViewAttributes::GetFieldTypeName
//
// Purpose: 
//   This method returns the name of a field type given its index.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Thu Dec 18 11:24:37 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

std::string
ViewAttributes::GetFieldTypeName(int index) const
{
    switch (index)
    {
        case 0:  return "doubleArray";
        case 1:  return "doubleArray";
        case 2:  return "doubleArray";
        case 3:  return "double";
        case 4:  return "bool";
        case 5:  return "double";
        case 6:  return "double";
        case 7:  return "double";
        case 8:  return "doubleArray";
        case 9:  return "double";
        case 10:  return "bool";
        case 11:  return "doubleArray";
        case 12:  return "doubleArray";
        case 13:  return "double";
        default:  return "invalid index";
    }
}

// ****************************************************************************
// Method: ViewAttributes::FieldsEqual
//
// Purpose: 
//   This method compares two fields and return true if they are equal.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Thu Dec 18 11:24:37 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

bool
ViewAttributes::FieldsEqual(int index_, const AttributeGroup *rhs) const
{
    int i;

    const ViewAttributes &obj = *((const ViewAttributes*)rhs);
    bool retval = false;
    switch (index_)
    {
    case 0:
        {  // new scope
        // Compare the viewNormal arrays.
        bool viewNormal_equal = true;
        for(i = 0; i < 3 && viewNormal_equal; ++i)
            viewNormal_equal = (viewNormal[i] == obj.viewNormal[i]);

        retval = viewNormal_equal;
        }
        break;
    case 1:
        {  // new scope
        // Compare the focus arrays.
        bool focus_equal = true;
        for(i = 0; i < 3 && focus_equal; ++i)
            focus_equal = (focus[i] == obj.focus[i]);

        retval = focus_equal;
        }
        break;
    case 2:
        {  // new scope
        // Compare the viewUp arrays.
        bool viewUp_equal = true;
        for(i = 0; i < 3 && viewUp_equal; ++i)
            viewUp_equal = (viewUp[i] == obj.viewUp[i]);

        retval = viewUp_equal;
        }
        break;
    case 3:
        {  // new scope
        retval = (viewAngle == obj.viewAngle);
        }
        break;
    case 4:
        {  // new scope
        retval = (setScale == obj.setScale);
        }
        break;
    case 5:
        {  // new scope
        retval = (parallelScale == obj.parallelScale);
        }
        break;
    case 6:
        {  // new scope
        retval = (nearPlane == obj.nearPlane);
        }
        break;
    case 7:
        {  // new scope
        retval = (farPlane == obj.farPlane);
        }
        break;
    case 8:
        {  // new scope
        // Compare the imagePan arrays.
        bool imagePan_equal = true;
        for(i = 0; i < 2 && imagePan_equal; ++i)
            imagePan_equal = (imagePan[i] == obj.imagePan[i]);

        retval = imagePan_equal;
        }
        break;
    case 9:
        {  // new scope
        retval = (imageZoom == obj.imageZoom);
        }
        break;
    case 10:
        {  // new scope
        retval = (perspective == obj.perspective);
        }
        break;
    case 11:
        {  // new scope
        // Compare the windowCoords arrays.
        bool windowCoords_equal = true;
        for(i = 0; i < 4 && windowCoords_equal; ++i)
            windowCoords_equal = (windowCoords[i] == obj.windowCoords[i]);

        retval = windowCoords_equal;
        }
        break;
    case 12:
        {  // new scope
        // Compare the viewportCoords arrays.
        bool viewportCoords_equal = true;
        for(i = 0; i < 4 && viewportCoords_equal; ++i)
            viewportCoords_equal = (viewportCoords[i] == obj.viewportCoords[i]);

        retval = viewportCoords_equal;
        }
        break;
    case 13:
        {  // new scope
        retval = (eyeAngle == obj.eyeAngle);
        }
        break;
    default: retval = false;
    }

    return retval;
}

///////////////////////////////////////////////////////////////////////////////
// User-defined methods.
///////////////////////////////////////////////////////////////////////////////


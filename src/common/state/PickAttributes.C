#include <PickAttributes.h>
#include <DataNode.h>
#include <stdio.h>
#include <PickVarInfo.h>

// ****************************************************************************
// Method: PickAttributes::PickAttributes
//
// Purpose: 
//   Constructor for the PickAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

PickAttributes::PickAttributes() : AttributeSubject("bbbsiiiissFFi*s*a*bbs*FFb")
{
    clearWindow = false;
    fulfilled = false;
    validPick = false;
    pickLetter = " ";
    zoneNumber = -1;
    timeStep = -1;
    domain = -1;
    dimension = -1;
    databaseName = " ";
    activeVariable = " ";
    pickPoint[0] = 0;
    pickPoint[1] = 0;
    pickPoint[2] = 0;
    cellPoint[0] = 0;
    cellPoint[1] = 0;
    cellPoint[2] = 0;
    userSelectedVars.push_back("default");
    useNodeCoords = false;
    logicalCoords = false;
    rayPoint1[0] = 0;
    rayPoint1[1] = 0;
    rayPoint1[2] = 0;
    rayPoint2[0] = 0;
    rayPoint2[1] = 0;
    rayPoint2[2] = 0;
    needTransformMessage = false;
}

// ****************************************************************************
// Method: PickAttributes::PickAttributes
//
// Purpose: 
//   Copy constructor for the PickAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

PickAttributes::PickAttributes(const PickAttributes &obj) : AttributeSubject("bbbsiiiissFFi*s*a*bbs*FFb")
{
    AttributeGroupVector::const_iterator pos;

    clearWindow = obj.clearWindow;
    fulfilled = obj.fulfilled;
    validPick = obj.validPick;
    pickLetter = obj.pickLetter;
    zoneNumber = obj.zoneNumber;
    timeStep = obj.timeStep;
    domain = obj.domain;
    dimension = obj.dimension;
    databaseName = obj.databaseName;
    activeVariable = obj.activeVariable;
    pickPoint[0] = obj.pickPoint[0];
    pickPoint[1] = obj.pickPoint[1];
    pickPoint[2] = obj.pickPoint[2];

    cellPoint[0] = obj.cellPoint[0];
    cellPoint[1] = obj.cellPoint[1];
    cellPoint[2] = obj.cellPoint[2];

    nodes = obj.nodes;
    userSelectedVars = obj.userSelectedVars;
    // *** Copy the varInfo field ***
    // Delete the AttributeGroup objects and clear the vector.
    for(pos = varInfo.begin(); pos != varInfo.end(); ++pos)
        delete *pos;
    varInfo.clear();
    if(obj.varInfo.size() > 0)
        varInfo.reserve(obj.varInfo.size());
    // Duplicate the varInfo from obj.
    for(pos = obj.varInfo.begin(); pos != obj.varInfo.end(); ++pos)
    {
        PickVarInfo *oldPickVarInfo = (PickVarInfo *)(*pos);
        PickVarInfo *newPickVarInfo = new PickVarInfo(*oldPickVarInfo);
        varInfo.push_back(newPickVarInfo);
    }

    useNodeCoords = obj.useNodeCoords;
    logicalCoords = obj.logicalCoords;
    nodeCoords = obj.nodeCoords;
    rayPoint1[0] = obj.rayPoint1[0];
    rayPoint1[1] = obj.rayPoint1[1];
    rayPoint1[2] = obj.rayPoint1[2];

    rayPoint2[0] = obj.rayPoint2[0];
    rayPoint2[1] = obj.rayPoint2[1];
    rayPoint2[2] = obj.rayPoint2[2];

    needTransformMessage = obj.needTransformMessage;

    SelectAll();
}

// ****************************************************************************
// Method: PickAttributes::~PickAttributes
//
// Purpose: 
//   Destructor for the PickAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

PickAttributes::~PickAttributes()
{
    AttributeGroupVector::iterator pos;

    // Destroy the varInfo field.
    for(pos = varInfo.begin(); pos != varInfo.end(); ++pos)
        delete *pos;
}

// ****************************************************************************
// Method: PickAttributes::operator = 
//
// Purpose: 
//   Assignment operator for the PickAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

void
PickAttributes::operator = (const PickAttributes &obj)
{
    AttributeGroupVector::const_iterator pos;

    clearWindow = obj.clearWindow;
    fulfilled = obj.fulfilled;
    validPick = obj.validPick;
    pickLetter = obj.pickLetter;
    zoneNumber = obj.zoneNumber;
    timeStep = obj.timeStep;
    domain = obj.domain;
    dimension = obj.dimension;
    databaseName = obj.databaseName;
    activeVariable = obj.activeVariable;
    pickPoint[0] = obj.pickPoint[0];
    pickPoint[1] = obj.pickPoint[1];
    pickPoint[2] = obj.pickPoint[2];

    cellPoint[0] = obj.cellPoint[0];
    cellPoint[1] = obj.cellPoint[1];
    cellPoint[2] = obj.cellPoint[2];

    nodes = obj.nodes;
    userSelectedVars = obj.userSelectedVars;
    // *** Copy the varInfo field ***
    // Delete the AttributeGroup objects and clear the vector.
    for(pos = varInfo.begin(); pos != varInfo.end(); ++pos)
        delete *pos;
    varInfo.clear();
    if(obj.varInfo.size() > 0)
        varInfo.reserve(obj.varInfo.size());
    // Duplicate the varInfo from obj.
    for(pos = obj.varInfo.begin(); pos != obj.varInfo.end(); ++pos)
    {
        PickVarInfo *oldPickVarInfo = (PickVarInfo *)(*pos);
        PickVarInfo *newPickVarInfo = new PickVarInfo(*oldPickVarInfo);
        varInfo.push_back(newPickVarInfo);
    }

    useNodeCoords = obj.useNodeCoords;
    logicalCoords = obj.logicalCoords;
    nodeCoords = obj.nodeCoords;
    rayPoint1[0] = obj.rayPoint1[0];
    rayPoint1[1] = obj.rayPoint1[1];
    rayPoint1[2] = obj.rayPoint1[2];

    rayPoint2[0] = obj.rayPoint2[0];
    rayPoint2[1] = obj.rayPoint2[1];
    rayPoint2[2] = obj.rayPoint2[2];

    needTransformMessage = obj.needTransformMessage;

    SelectAll();
}

// ****************************************************************************
// Method: PickAttributes::operator == 
//
// Purpose: 
//   Comparison operator == for the PickAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

bool
PickAttributes::operator == (const PickAttributes &obj) const
{
    int i;

    // Compare the pickPoint arrays.
    bool pickPoint_equal = true;
    for(i = 0; i < 3 && pickPoint_equal; ++i)
        pickPoint_equal = (pickPoint[i] == obj.pickPoint[i]);

    // Compare the cellPoint arrays.
    bool cellPoint_equal = true;
    for(i = 0; i < 3 && cellPoint_equal; ++i)
        cellPoint_equal = (cellPoint[i] == obj.cellPoint[i]);

    bool varInfo_equal = (obj.varInfo.size() == varInfo.size());
    for(i = 0; (i < varInfo.size()) && varInfo_equal; ++i)
    {
        // Make references to PickVarInfo from AttributeGroup *.
        const PickVarInfo &varInfo1 = *((const PickVarInfo *)(varInfo[i]));
        const PickVarInfo &varInfo2 = *((const PickVarInfo *)(obj.varInfo[i]));
        varInfo_equal = (varInfo1 == varInfo2);
    }

    // Compare the rayPoint1 arrays.
    bool rayPoint1_equal = true;
    for(i = 0; i < 3 && rayPoint1_equal; ++i)
        rayPoint1_equal = (rayPoint1[i] == obj.rayPoint1[i]);

    // Compare the rayPoint2 arrays.
    bool rayPoint2_equal = true;
    for(i = 0; i < 3 && rayPoint2_equal; ++i)
        rayPoint2_equal = (rayPoint2[i] == obj.rayPoint2[i]);

    // Create the return value
    return ((clearWindow == obj.clearWindow) &&
            (fulfilled == obj.fulfilled) &&
            (validPick == obj.validPick) &&
            (pickLetter == obj.pickLetter) &&
            (zoneNumber == obj.zoneNumber) &&
            (timeStep == obj.timeStep) &&
            (domain == obj.domain) &&
            (dimension == obj.dimension) &&
            (databaseName == obj.databaseName) &&
            (activeVariable == obj.activeVariable) &&
            pickPoint_equal &&
            cellPoint_equal &&
            (nodes == obj.nodes) &&
            (userSelectedVars == obj.userSelectedVars) &&
            varInfo_equal &&
            (useNodeCoords == obj.useNodeCoords) &&
            (logicalCoords == obj.logicalCoords) &&
            (nodeCoords == obj.nodeCoords) &&
            rayPoint1_equal &&
            rayPoint2_equal &&
            (needTransformMessage == obj.needTransformMessage));
}

// ****************************************************************************
// Method: PickAttributes::operator != 
//
// Purpose: 
//   Comparison operator != for the PickAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

bool
PickAttributes::operator != (const PickAttributes &obj) const
{
    return !(this->operator == (obj));
}

// ****************************************************************************
// Method: PickAttributes::TypeName
//
// Purpose: 
//   Type name method for the PickAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

const std::string
PickAttributes::TypeName() const
{
    return "PickAttributes";
}

// ****************************************************************************
// Method: PickAttributes::CopyAttributes
//
// Purpose: 
//   CopyAttributes method for the PickAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

bool
PickAttributes::CopyAttributes(const AttributeGroup *atts)
{
    if(TypeName() != atts->TypeName())
        return false;

    // Call assignment operator.
    const PickAttributes *tmp = (const PickAttributes *)atts;
    *this = *tmp;

    return true;
}

// ****************************************************************************
// Method: PickAttributes::CreateCompatible
//
// Purpose: 
//   CreateCompatible method for the PickAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

AttributeSubject *
PickAttributes::CreateCompatible(const std::string &tname) const
{
    AttributeSubject *retval = 0;
    if(TypeName() == tname)
        retval = new PickAttributes(*this);
    // Other cases could go here too. 

    return retval;
}

// ****************************************************************************
// Method: PickAttributes::SelectAll
//
// Purpose: 
//   Selects all attributes.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

void
PickAttributes::SelectAll()
{
    Select(0, (void *)&clearWindow);
    Select(1, (void *)&fulfilled);
    Select(2, (void *)&validPick);
    Select(3, (void *)&pickLetter);
    Select(4, (void *)&zoneNumber);
    Select(5, (void *)&timeStep);
    Select(6, (void *)&domain);
    Select(7, (void *)&dimension);
    Select(8, (void *)&databaseName);
    Select(9, (void *)&activeVariable);
    Select(10, (void *)pickPoint, 3);
    Select(11, (void *)cellPoint, 3);
    Select(12, (void *)&nodes);
    Select(13, (void *)&userSelectedVars);
    Select(14, (void *)&varInfo);
    Select(15, (void *)&useNodeCoords);
    Select(16, (void *)&logicalCoords);
    Select(17, (void *)&nodeCoords);
    Select(18, (void *)rayPoint1, 3);
    Select(19, (void *)rayPoint2, 3);
    Select(20, (void *)&needTransformMessage);
}

// ****************************************************************************
// Method: PickAttributes::CreateSubAttributeGroup
//
// Purpose: 
//   This class contains attributes used for pick.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

AttributeGroup *
PickAttributes::CreateSubAttributeGroup(int)
{
    return new PickVarInfo;
}

///////////////////////////////////////////////////////////////////////////////
// Persistence methods
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: PickAttributes::CreateNode
//
// Purpose: 
//   This method creates a DataNode representation of the object so it can be saved to a config file.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

bool
PickAttributes::CreateNode(DataNode *parentNode, bool forceAdd)
{
    if(parentNode == 0)
        return false;

    PickAttributes defaultObject;
    bool addToParent = false;
    // Create a node for PickAttributes.
    DataNode *node = new DataNode("PickAttributes");

    if(!FieldsEqual(0, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("clearWindow", clearWindow));
    }

    if(!FieldsEqual(1, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("fulfilled", fulfilled));
    }

    if(!FieldsEqual(2, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("validPick", validPick));
    }

    if(!FieldsEqual(3, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("pickLetter", pickLetter));
    }

    if(!FieldsEqual(4, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("zoneNumber", zoneNumber));
    }

    if(!FieldsEqual(5, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("timeStep", timeStep));
    }

    if(!FieldsEqual(6, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("domain", domain));
    }

    if(!FieldsEqual(7, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("dimension", dimension));
    }

    if(!FieldsEqual(8, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("databaseName", databaseName));
    }

    if(!FieldsEqual(9, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("activeVariable", activeVariable));
    }

    if(!FieldsEqual(10, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("pickPoint", pickPoint, 3));
    }

    if(!FieldsEqual(11, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("cellPoint", cellPoint, 3));
    }

    if(!FieldsEqual(12, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("nodes", nodes));
    }

    if(!FieldsEqual(13, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("userSelectedVars", userSelectedVars));
    }

    if(!FieldsEqual(14, &defaultObject))
    {
        addToParent = true;
        for(int i = 0; i < varInfo.size(); ++i)
            varInfo[i]->CreateNode(node, true);
    }

    if(!FieldsEqual(15, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("useNodeCoords", useNodeCoords));
    }

    if(!FieldsEqual(16, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("logicalCoords", logicalCoords));
    }

    if(!FieldsEqual(17, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("nodeCoords", nodeCoords));
    }

    if(!FieldsEqual(18, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("rayPoint1", rayPoint1, 3));
    }

    if(!FieldsEqual(19, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("rayPoint2", rayPoint2, 3));
    }

    if(!FieldsEqual(20, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("needTransformMessage", needTransformMessage));
    }


    // Add the node to the parent node.
    if(addToParent || forceAdd)
        parentNode->AddNode(node);
    else
        delete node;

    return (addToParent || forceAdd);
}

// ****************************************************************************
// Method: PickAttributes::SetFromNode
//
// Purpose: 
//   This method sets attributes in this object from values in a DataNode representation of the object.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

void
PickAttributes::SetFromNode(DataNode *parentNode)
{
    if(parentNode == 0)
        return;

    DataNode *searchNode = parentNode->GetNode("PickAttributes");
    if(searchNode == 0)
        return;

    DataNode *node;
    DataNode **children;
    if((node = searchNode->GetNode("clearWindow")) != 0)
        SetClearWindow(node->AsBool());
    if((node = searchNode->GetNode("fulfilled")) != 0)
        SetFulfilled(node->AsBool());
    if((node = searchNode->GetNode("validPick")) != 0)
        SetValidPick(node->AsBool());
    if((node = searchNode->GetNode("pickLetter")) != 0)
        SetPickLetter(node->AsString());
    if((node = searchNode->GetNode("zoneNumber")) != 0)
        SetZoneNumber(node->AsInt());
    if((node = searchNode->GetNode("timeStep")) != 0)
        SetTimeStep(node->AsInt());
    if((node = searchNode->GetNode("domain")) != 0)
        SetDomain(node->AsInt());
    if((node = searchNode->GetNode("dimension")) != 0)
        SetDimension(node->AsInt());
    if((node = searchNode->GetNode("databaseName")) != 0)
        SetDatabaseName(node->AsString());
    if((node = searchNode->GetNode("activeVariable")) != 0)
        SetActiveVariable(node->AsString());
    if((node = searchNode->GetNode("pickPoint")) != 0)
        SetPickPoint(node->AsFloatArray());
    if((node = searchNode->GetNode("cellPoint")) != 0)
        SetCellPoint(node->AsFloatArray());
    if((node = searchNode->GetNode("nodes")) != 0)
        SetNodes(node->AsIntVector());
    if((node = searchNode->GetNode("userSelectedVars")) != 0)
        SetUserSelectedVars(node->AsStringVector());
    // Clear all the PickVarInfos.
    ClearPickVarInfos();

    // Go through all of the children and construct a new
    // PickVarInfo for each one of them.
    children = searchNode->GetChildren();
    for(int i = 0; i < searchNode->GetNumChildren(); ++i)
    {
        if(children[i]->GetKey() == std::string("PickVarInfo"))
        {
            PickVarInfo temp;
            temp.SetFromNode(children[i]);
            AddPickVarInfo(temp);
        }
    }

    if((node = searchNode->GetNode("useNodeCoords")) != 0)
        SetUseNodeCoords(node->AsBool());
    if((node = searchNode->GetNode("logicalCoords")) != 0)
        SetLogicalCoords(node->AsBool());
    if((node = searchNode->GetNode("nodeCoords")) != 0)
        SetNodeCoords(node->AsStringVector());
    if((node = searchNode->GetNode("rayPoint1")) != 0)
        SetRayPoint1(node->AsFloatArray());
    if((node = searchNode->GetNode("rayPoint2")) != 0)
        SetRayPoint2(node->AsFloatArray());
    if((node = searchNode->GetNode("needTransformMessage")) != 0)
        SetNeedTransformMessage(node->AsBool());
}

///////////////////////////////////////////////////////////////////////////////
// Set property methods
///////////////////////////////////////////////////////////////////////////////

void
PickAttributes::SetClearWindow(bool clearWindow_)
{
    clearWindow = clearWindow_;
    Select(0, (void *)&clearWindow);
}

void
PickAttributes::SetFulfilled(bool fulfilled_)
{
    fulfilled = fulfilled_;
    Select(1, (void *)&fulfilled);
}

void
PickAttributes::SetValidPick(bool validPick_)
{
    validPick = validPick_;
    Select(2, (void *)&validPick);
}

void
PickAttributes::SetPickLetter(const std::string &pickLetter_)
{
    pickLetter = pickLetter_;
    Select(3, (void *)&pickLetter);
}

void
PickAttributes::SetZoneNumber(int zoneNumber_)
{
    zoneNumber = zoneNumber_;
    Select(4, (void *)&zoneNumber);
}

void
PickAttributes::SetTimeStep(int timeStep_)
{
    timeStep = timeStep_;
    Select(5, (void *)&timeStep);
}

void
PickAttributes::SetDomain(int domain_)
{
    domain = domain_;
    Select(6, (void *)&domain);
}

void
PickAttributes::SetDimension(int dimension_)
{
    dimension = dimension_;
    Select(7, (void *)&dimension);
}

void
PickAttributes::SetDatabaseName(const std::string &databaseName_)
{
    databaseName = databaseName_;
    Select(8, (void *)&databaseName);
}

void
PickAttributes::SetActiveVariable(const std::string &activeVariable_)
{
    activeVariable = activeVariable_;
    Select(9, (void *)&activeVariable);
}

void
PickAttributes::SetPickPoint(const float *pickPoint_)
{
    pickPoint[0] = pickPoint_[0];
    pickPoint[1] = pickPoint_[1];
    pickPoint[2] = pickPoint_[2];
    Select(10, (void *)pickPoint, 3);
}

void
PickAttributes::SetCellPoint(const float *cellPoint_)
{
    cellPoint[0] = cellPoint_[0];
    cellPoint[1] = cellPoint_[1];
    cellPoint[2] = cellPoint_[2];
    Select(11, (void *)cellPoint, 3);
}

void
PickAttributes::SetNodes(const intVector &nodes_)
{
    nodes = nodes_;
    Select(12, (void *)&nodes);
}

void
PickAttributes::SetUserSelectedVars(const stringVector &userSelectedVars_)
{
    userSelectedVars = userSelectedVars_;
    Select(13, (void *)&userSelectedVars);
}

void
PickAttributes::SetUseNodeCoords(bool useNodeCoords_)
{
    useNodeCoords = useNodeCoords_;
    Select(15, (void *)&useNodeCoords);
}

void
PickAttributes::SetLogicalCoords(bool logicalCoords_)
{
    logicalCoords = logicalCoords_;
    Select(16, (void *)&logicalCoords);
}

void
PickAttributes::SetNodeCoords(const stringVector &nodeCoords_)
{
    nodeCoords = nodeCoords_;
    Select(17, (void *)&nodeCoords);
}

void
PickAttributes::SetRayPoint1(const float *rayPoint1_)
{
    rayPoint1[0] = rayPoint1_[0];
    rayPoint1[1] = rayPoint1_[1];
    rayPoint1[2] = rayPoint1_[2];
    Select(18, (void *)rayPoint1, 3);
}

void
PickAttributes::SetRayPoint2(const float *rayPoint2_)
{
    rayPoint2[0] = rayPoint2_[0];
    rayPoint2[1] = rayPoint2_[1];
    rayPoint2[2] = rayPoint2_[2];
    Select(19, (void *)rayPoint2, 3);
}

void
PickAttributes::SetNeedTransformMessage(bool needTransformMessage_)
{
    needTransformMessage = needTransformMessage_;
    Select(20, (void *)&needTransformMessage);
}

///////////////////////////////////////////////////////////////////////////////
// Get property methods
///////////////////////////////////////////////////////////////////////////////

bool
PickAttributes::GetClearWindow() const
{
    return clearWindow;
}

bool
PickAttributes::GetFulfilled() const
{
    return fulfilled;
}

bool
PickAttributes::GetValidPick() const
{
    return validPick;
}

const std::string &
PickAttributes::GetPickLetter() const
{
    return pickLetter;
}

std::string &
PickAttributes::GetPickLetter()
{
    return pickLetter;
}

int
PickAttributes::GetZoneNumber() const
{
    return zoneNumber;
}

int
PickAttributes::GetTimeStep() const
{
    return timeStep;
}

int
PickAttributes::GetDomain() const
{
    return domain;
}

int
PickAttributes::GetDimension() const
{
    return dimension;
}

const std::string &
PickAttributes::GetDatabaseName() const
{
    return databaseName;
}

std::string &
PickAttributes::GetDatabaseName()
{
    return databaseName;
}

const std::string &
PickAttributes::GetActiveVariable() const
{
    return activeVariable;
}

std::string &
PickAttributes::GetActiveVariable()
{
    return activeVariable;
}

const float *
PickAttributes::GetPickPoint() const
{
    return pickPoint;
}

float *
PickAttributes::GetPickPoint()
{
    return pickPoint;
}

const float *
PickAttributes::GetCellPoint() const
{
    return cellPoint;
}

float *
PickAttributes::GetCellPoint()
{
    return cellPoint;
}

const intVector &
PickAttributes::GetNodes() const
{
    return nodes;
}

intVector &
PickAttributes::GetNodes()
{
    return nodes;
}

const stringVector &
PickAttributes::GetUserSelectedVars() const
{
    return userSelectedVars;
}

stringVector &
PickAttributes::GetUserSelectedVars()
{
    return userSelectedVars;
}

const AttributeGroupVector &
PickAttributes::GetVarInfo() const
{
    return varInfo;
}

AttributeGroupVector &
PickAttributes::GetVarInfo()
{
    return varInfo;
}

bool
PickAttributes::GetUseNodeCoords() const
{
    return useNodeCoords;
}

bool
PickAttributes::GetLogicalCoords() const
{
    return logicalCoords;
}

const stringVector &
PickAttributes::GetNodeCoords() const
{
    return nodeCoords;
}

stringVector &
PickAttributes::GetNodeCoords()
{
    return nodeCoords;
}

const float *
PickAttributes::GetRayPoint1() const
{
    return rayPoint1;
}

float *
PickAttributes::GetRayPoint1()
{
    return rayPoint1;
}

const float *
PickAttributes::GetRayPoint2() const
{
    return rayPoint2;
}

float *
PickAttributes::GetRayPoint2()
{
    return rayPoint2;
}

bool
PickAttributes::GetNeedTransformMessage() const
{
    return needTransformMessage;
}

///////////////////////////////////////////////////////////////////////////////
// Select property methods
///////////////////////////////////////////////////////////////////////////////

void
PickAttributes::SelectPickLetter()
{
    Select(3, (void *)&pickLetter);
}

void
PickAttributes::SelectDatabaseName()
{
    Select(8, (void *)&databaseName);
}

void
PickAttributes::SelectActiveVariable()
{
    Select(9, (void *)&activeVariable);
}

void
PickAttributes::SelectPickPoint()
{
    Select(10, (void *)pickPoint, 3);
}

void
PickAttributes::SelectCellPoint()
{
    Select(11, (void *)cellPoint, 3);
}

void
PickAttributes::SelectNodes()
{
    Select(12, (void *)&nodes);
}

void
PickAttributes::SelectUserSelectedVars()
{
    Select(13, (void *)&userSelectedVars);
}

void
PickAttributes::SelectVarInfo()
{
    Select(14, (void *)&varInfo);
}

void
PickAttributes::SelectNodeCoords()
{
    Select(17, (void *)&nodeCoords);
}

void
PickAttributes::SelectRayPoint1()
{
    Select(18, (void *)rayPoint1, 3);
}

void
PickAttributes::SelectRayPoint2()
{
    Select(19, (void *)rayPoint2, 3);
}

///////////////////////////////////////////////////////////////////////////////
// AttributeGroupVector convenience methods.
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: PickAttributes::AddPickVarInfo
//
// Purpose: 
//   This class contains attributes used for pick.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

void
PickAttributes::AddPickVarInfo(const PickVarInfo &obj)
{
    PickVarInfo *newPickVarInfo = new PickVarInfo(obj);
    varInfo.push_back(newPickVarInfo);

    // Indicate that things have changed by selecting it.
    Select(14, (void *)&varInfo);
}

// ****************************************************************************
// Method: PickAttributes::ClearPickVarInfos
//
// Purpose: 
//   This class contains attributes used for pick.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

void
PickAttributes::ClearPickVarInfos()
{
    AttributeGroupVector::iterator pos;

    for(pos = varInfo.begin(); pos != varInfo.end(); ++pos)
        delete *pos;
    varInfo.clear();

    // Indicate that things have changed by selecting the list.
    Select(14, (void *)&varInfo);
}

// ****************************************************************************
// Method: PickAttributes::RemovePickVarInfo
//
// Purpose: 
//   This class contains attributes used for pick.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

void
PickAttributes::RemovePickVarInfo(int index)
{
    AttributeGroupVector::iterator pos = varInfo.begin();

    // Iterate through the vector "index" times. 
    for(int i = 0; i < index; ++i)
        ++pos;

    // If pos is still a valid iterator, remove that element.
    if(pos != varInfo.end())
    {
        delete *pos;
        varInfo.erase(pos);
    }

    // Indicate that things have changed by selecting the list.
    Select(14, (void *)&varInfo);
}

// ****************************************************************************
// Method: PickAttributes::GetNumPickVarInfos
//
// Purpose: 
//   This class contains attributes used for pick.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

int
PickAttributes::GetNumPickVarInfos() const
{
    return varInfo.size();
}

// ****************************************************************************
// Method: PickAttributes::GetPickVarInfo
//
// Purpose: 
//   This class contains attributes used for pick.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

PickVarInfo &
PickAttributes::GetPickVarInfo(int i)
{
    return *((PickVarInfo *)varInfo[i]);
}

// ****************************************************************************
// Method: PickAttributes::GetPickVarInfo
//
// Purpose: 
//   This class contains attributes used for pick.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

const PickVarInfo &
PickAttributes::GetPickVarInfo(int i) const
{
    return *((PickVarInfo *)varInfo[i]);
}

// ****************************************************************************
// Method: PickAttributes::operator []
//
// Purpose: 
//   This class contains attributes used for pick.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

PickVarInfo &
PickAttributes::operator [] (int i)
{
    return *((PickVarInfo *)varInfo[i]);
}

// ****************************************************************************
// Method: PickAttributes::operator []
//
// Purpose: 
//   This class contains attributes used for pick.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

const PickVarInfo &
PickAttributes::operator [] (int i) const
{
    return *((PickVarInfo *)varInfo[i]);
}

///////////////////////////////////////////////////////////////////////////////
// Keyframing methods
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: PickAttributes::GetFieldName
//
// Purpose: 
//   This method returns the name of a field given its index.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

std::string
PickAttributes::GetFieldName(int index) const
{
    switch (index)
    {
        case 0:  return "clearWindow";
        case 1:  return "fulfilled";
        case 2:  return "validPick";
        case 3:  return "pickLetter";
        case 4:  return "zoneNumber";
        case 5:  return "timeStep";
        case 6:  return "domain";
        case 7:  return "dimension";
        case 8:  return "databaseName";
        case 9:  return "activeVariable";
        case 10:  return "pickPoint";
        case 11:  return "cellPoint";
        case 12:  return "nodes";
        case 13:  return "userSelectedVars";
        case 14:  return "varInfo";
        case 15:  return "useNodeCoords";
        case 16:  return "logicalCoords";
        case 17:  return "nodeCoords";
        case 18:  return "rayPoint1";
        case 19:  return "rayPoint2";
        case 20:  return "needTransformMessage";
        default:  return "invalid index";
    }
}

// ****************************************************************************
// Method: PickAttributes::GetFieldType
//
// Purpose: 
//   This method returns the type of a field given its index.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

AttributeGroup::FieldType
PickAttributes::GetFieldType(int index) const
{
    switch (index)
    {
        case 0:  return FieldType_bool;
        case 1:  return FieldType_bool;
        case 2:  return FieldType_bool;
        case 3:  return FieldType_string;
        case 4:  return FieldType_int;
        case 5:  return FieldType_int;
        case 6:  return FieldType_int;
        case 7:  return FieldType_int;
        case 8:  return FieldType_string;
        case 9:  return FieldType_string;
        case 10:  return FieldType_floatArray;
        case 11:  return FieldType_floatArray;
        case 12:  return FieldType_intVector;
        case 13:  return FieldType_stringVector;
        case 14:  return FieldType_attVector;
        case 15:  return FieldType_bool;
        case 16:  return FieldType_bool;
        case 17:  return FieldType_stringVector;
        case 18:  return FieldType_floatArray;
        case 19:  return FieldType_floatArray;
        case 20:  return FieldType_bool;
        default:  return FieldType_unknown;
    }
}

// ****************************************************************************
// Method: PickAttributes::GetFieldTypeName
//
// Purpose: 
//   This method returns the name of a field type given its index.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

std::string
PickAttributes::GetFieldTypeName(int index) const
{
    switch (index)
    {
        case 0:  return "bool";
        case 1:  return "bool";
        case 2:  return "bool";
        case 3:  return "string";
        case 4:  return "int";
        case 5:  return "int";
        case 6:  return "int";
        case 7:  return "int";
        case 8:  return "string";
        case 9:  return "string";
        case 10:  return "floatArray";
        case 11:  return "floatArray";
        case 12:  return "intVector";
        case 13:  return "stringVector";
        case 14:  return "attVector";
        case 15:  return "bool";
        case 16:  return "bool";
        case 17:  return "stringVector";
        case 18:  return "floatArray";
        case 19:  return "floatArray";
        case 20:  return "bool";
        default:  return "invalid index";
    }
}

// ****************************************************************************
// Method: PickAttributes::FieldsEqual
//
// Purpose: 
//   This method compares two fields and return true if they are equal.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:39:59 PST 2003
//
// Modifications:
//   
// ****************************************************************************

bool
PickAttributes::FieldsEqual(int index_, const AttributeGroup *rhs) const
{
    int i;

    const PickAttributes &obj = *((const PickAttributes*)rhs);
    bool retval = false;
    switch (index_)
    {
    case 0:
        {  // new scope
        retval = (clearWindow == obj.clearWindow);
        }
        break;
    case 1:
        {  // new scope
        retval = (fulfilled == obj.fulfilled);
        }
        break;
    case 2:
        {  // new scope
        retval = (validPick == obj.validPick);
        }
        break;
    case 3:
        {  // new scope
        retval = (pickLetter == obj.pickLetter);
        }
        break;
    case 4:
        {  // new scope
        retval = (zoneNumber == obj.zoneNumber);
        }
        break;
    case 5:
        {  // new scope
        retval = (timeStep == obj.timeStep);
        }
        break;
    case 6:
        {  // new scope
        retval = (domain == obj.domain);
        }
        break;
    case 7:
        {  // new scope
        retval = (dimension == obj.dimension);
        }
        break;
    case 8:
        {  // new scope
        retval = (databaseName == obj.databaseName);
        }
        break;
    case 9:
        {  // new scope
        retval = (activeVariable == obj.activeVariable);
        }
        break;
    case 10:
        {  // new scope
        // Compare the pickPoint arrays.
        bool pickPoint_equal = true;
        for(i = 0; i < 3 && pickPoint_equal; ++i)
            pickPoint_equal = (pickPoint[i] == obj.pickPoint[i]);

        retval = pickPoint_equal;
        }
        break;
    case 11:
        {  // new scope
        // Compare the cellPoint arrays.
        bool cellPoint_equal = true;
        for(i = 0; i < 3 && cellPoint_equal; ++i)
            cellPoint_equal = (cellPoint[i] == obj.cellPoint[i]);

        retval = cellPoint_equal;
        }
        break;
    case 12:
        {  // new scope
        retval = (nodes == obj.nodes);
        }
        break;
    case 13:
        {  // new scope
        retval = (userSelectedVars == obj.userSelectedVars);
        }
        break;
    case 14:
        {  // new scope
        bool varInfo_equal = (obj.varInfo.size() == varInfo.size());
        for(i = 0; (i < varInfo.size()) && varInfo_equal; ++i)
        {
            // Make references to PickVarInfo from AttributeGroup *.
            const PickVarInfo &varInfo1 = *((const PickVarInfo *)(varInfo[i]));
            const PickVarInfo &varInfo2 = *((const PickVarInfo *)(obj.varInfo[i]));
            varInfo_equal = (varInfo1 == varInfo2);
        }

        retval = varInfo_equal;
        }
        break;
    case 15:
        {  // new scope
        retval = (useNodeCoords == obj.useNodeCoords);
        }
        break;
    case 16:
        {  // new scope
        retval = (logicalCoords == obj.logicalCoords);
        }
        break;
    case 17:
        {  // new scope
        retval = (nodeCoords == obj.nodeCoords);
        }
        break;
    case 18:
        {  // new scope
        // Compare the rayPoint1 arrays.
        bool rayPoint1_equal = true;
        for(i = 0; i < 3 && rayPoint1_equal; ++i)
            rayPoint1_equal = (rayPoint1[i] == obj.rayPoint1[i]);

        retval = rayPoint1_equal;
        }
        break;
    case 19:
        {  // new scope
        // Compare the rayPoint2 arrays.
        bool rayPoint2_equal = true;
        for(i = 0; i < 3 && rayPoint2_equal; ++i)
            rayPoint2_equal = (rayPoint2[i] == obj.rayPoint2[i]);

        retval = rayPoint2_equal;
        }
        break;
    case 20:
        {  // new scope
        retval = (needTransformMessage == obj.needTransformMessage);
        }
        break;
    default: retval = false;
    }

    return retval;
}

///////////////////////////////////////////////////////////////////////////////
// User-defined methods.
///////////////////////////////////////////////////////////////////////////////

void
PickAttributes::Reset()
{
    clearWindow  = false;
    fulfilled    = false;
    validPick    = false;
    needTransformMessage = false;
    pickLetter   = " ";
    zoneNumber   = -1;
    timeStep     = -1;
    domain       = -1;
    dimension    = -1;
    pickPoint[0] = 0;
    pickPoint[1] = 0;
    pickPoint[2] = 0;
    cellPoint[0] = 0;
    cellPoint[1] = 0;
    cellPoint[2] = 0;

    rayPoint1[0] = rayPoint1[1] = rayPoint1[2] = 0;
    rayPoint2[0] = rayPoint2[1] = rayPoint2[2] = 0;

    activeVariable = " ";
    databaseName = " ";
    if (!nodes.empty())
        nodes.clear();

    if (!userSelectedVars.empty())
    {
        userSelectedVars.clear();
        userSelectedVars.push_back("default");
    }

    if (!nodeCoords.empty())
        nodeCoords.clear();

    useNodeCoords = false;
    logicalCoords = false;

    ClearPickVarInfos();

    SelectAll();
}

void
PickAttributes::PrintSelf(ostream &os)
{
    int i;
    std::string fileName;
    int pos = databaseName.find_last_of('/');
    if (pos >= databaseName.size())
        fileName = databaseName;
    else
        fileName = databaseName.substr(pos+1) ;
    os << "\n" << pickLetter.c_str() << ":  ";
    os << fileName.c_str() << " ";
    os << "timestep " << timeStep << " ";
    os << "domain " << domain << "\n";
    os << "active variable:   " << activeVariable.c_str() << "\n";
    os << "selected variables: ";
    for (i = 0; i < userSelectedVars.size(); i++)
        os << userSelectedVars[i].c_str() << "  ";
    os << "\n";
    if (!needTransformMessage)
    {
        os << "PickedPoint: <" << cellPoint[0] << ", " 
                               << cellPoint[1] << ", " 
                               << cellPoint[2] << ">\n";
    }
    else 
    {
        os << "PickedPoint:  (in transformed space) <" 
           << cellPoint[0] << ", " 
           << cellPoint[1] << ", " 
           << cellPoint[2] << ">\n";
    }
    os << "Zone " << zoneNumber << " ";
    os << "Nodes " ; 
    for (i = 0; i < nodes.size(); i++)
    {
        os << nodes[i] << "  ";
        if (useNodeCoords && !nodeCoords.empty())
        {
            os << nodeCoords[i].c_str() << "\n";
        } 
    }
    os << "\n";
    for (i = 0; i < varInfo.size(); i++)
        ((PickVarInfo*)varInfo[i])->PrintSelf(os);
    os << "RayPoint 1: <" << rayPoint1[0] << ", " 
                          << rayPoint1[1] << ", " 
                          << rayPoint1[2] << ">\n";
    os << "RayPoint 2: <" << rayPoint2[0] << ", " 
                          << rayPoint2[1] << ", " 
                          << rayPoint2[2] << ">\n";
}

void
PickAttributes::CreateOutputString(std::string &os)
{
    int i;
    char buff[256];
   
    std::string fileName; 
    int pos = databaseName.find_last_of('/');
    if (pos >= databaseName.size())
        fileName = databaseName;
    else
        fileName = databaseName.substr(pos+1) ;

    sprintf(buff, "\n%s:  ", pickLetter.c_str());
    os += buff;
    os += fileName;
    if (domain != -1)
    {
        sprintf(buff, "  timestep %d  domain %d\n", timeStep, domain);
    }
    else 
    {
        sprintf(buff, "  timestep %d  \n", timeStep);
    }
    os += buff;
    if (dimension == 2)
    {
        if (!needTransformMessage)
        {
            sprintf(buff, "Point: <%f, %f>\n",
                    cellPoint[0], cellPoint[1]);
        }
        else 
        {
            sprintf(buff, "Point: (in transformed space)\n        <%f, %f>\n",
                    cellPoint[0], cellPoint[1]);
        }
    }
    else 
    {
        if (!needTransformMessage)
        {
            sprintf(buff, "Point: <%f, %f, %f>\n",
                    cellPoint[0], cellPoint[1], cellPoint[2]);
        }
        else 
        {
            sprintf(buff, "Point: (in transformed space) \n       <%f, %f, %f>\n",
                    cellPoint[0], cellPoint[1], cellPoint[2]);
        }
    }
    os += buff;

    sprintf(buff, "Zone:  %d\n", zoneNumber);
    os += buff;
    os += "Nodes:  " ; 
    bool printCoords = useNodeCoords && !nodeCoords.empty(); 
    if (printCoords)
    {
        os += "\n    "; 
    }
    for (i = 0; i < nodes.size(); i++)
    {
        sprintf(buff, "%d  ", nodes[i]);
        os += buff; 
        if (printCoords)
        {
            sprintf(buff, "%s\n    ", nodeCoords[i].c_str());
            os += buff;
        }
    }
    os += "\n";

    for (i = 0; i < varInfo.size(); i++)
    {
        std::string iv;
        //
        // VarInfo does not append a newline char, but we need one here
        //
        ((PickVarInfo*)varInfo[i])->CreateOutputString(iv);
        os += iv;
        os += "\n";
    }
}


/*****************************************************************************
*
* Copyright (c) 2000 - 2013, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

#include <AnnotationObject.h>
#include <DataNode.h>

//
// Enum conversion methods for AnnotationObject::AnnotationType
//

static const char *AnnotationType_strings[] = {
"Text2D", "Text3D", "TimeSlider", 
"Line2D", "Arrow2D", "Arrow3D", 
"Box", "Image", "LegendAttributes", 
"MaxAnnotationType"};

std::string
AnnotationObject::AnnotationType_ToString(AnnotationObject::AnnotationType t)
{
    int index = int(t);
    if(index < 0 || index >= 10) index = 0;
    return AnnotationType_strings[index];
}

std::string
AnnotationObject::AnnotationType_ToString(int t)
{
    int index = (t < 0 || t >= 10) ? 0 : t;
    return AnnotationType_strings[index];
}

bool
AnnotationObject::AnnotationType_FromString(const std::string &s, AnnotationObject::AnnotationType &val)
{
    val = AnnotationObject::Text2D;
    for(int i = 0; i < 10; ++i)
    {
        if(s == AnnotationType_strings[i])
        {
            val = (AnnotationType)i;
            return true;
        }
    }
    return false;
}

//
// Enum conversion methods for AnnotationObject::FontFamily
//

static const char *FontFamily_strings[] = {
"Arial", "Courier", "Times"
};

std::string
AnnotationObject::FontFamily_ToString(AnnotationObject::FontFamily t)
{
    int index = int(t);
    if(index < 0 || index >= 3) index = 0;
    return FontFamily_strings[index];
}

std::string
AnnotationObject::FontFamily_ToString(int t)
{
    int index = (t < 0 || t >= 3) ? 0 : t;
    return FontFamily_strings[index];
}

bool
AnnotationObject::FontFamily_FromString(const std::string &s, AnnotationObject::FontFamily &val)
{
    val = AnnotationObject::Arial;
    for(int i = 0; i < 3; ++i)
    {
        if(s == FontFamily_strings[i])
        {
            val = (FontFamily)i;
            return true;
        }
    }
    return false;
}

// ****************************************************************************
// Method: AnnotationObject::AnnotationObject
//
// Purpose: 
//   Init utility for the AnnotationObject class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void AnnotationObject::Init()
{
    objectType = Text2D;
    visible = false;
    active = false;
    position[0] = 0;
    position[1] = 0;
    position[2] = 0;
    position2[0] = 0;
    position2[1] = 0;
    position2[2] = 0;
    useForegroundForTextColor = true;
    fontFamily = Arial;
    fontBold = false;
    fontItalic = false;
    fontShadow = false;
    doubleAttribute1 = 0;
    intAttribute1 = 0;
    intAttribute2 = 0;
    intAttribute3 = 0;

    AnnotationObject::SelectAll();
}

// ****************************************************************************
// Method: AnnotationObject::AnnotationObject
//
// Purpose: 
//   Copy utility for the AnnotationObject class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void AnnotationObject::Copy(const AnnotationObject &obj)
{
    objectName = obj.objectName;
    objectType = obj.objectType;
    visible = obj.visible;
    active = obj.active;
    position[0] = obj.position[0];
    position[1] = obj.position[1];
    position[2] = obj.position[2];

    position2[0] = obj.position2[0];
    position2[1] = obj.position2[1];
    position2[2] = obj.position2[2];

    textColor = obj.textColor;
    useForegroundForTextColor = obj.useForegroundForTextColor;
    color1 = obj.color1;
    color2 = obj.color2;
    text = obj.text;
    fontFamily = obj.fontFamily;
    fontBold = obj.fontBold;
    fontItalic = obj.fontItalic;
    fontShadow = obj.fontShadow;
    doubleAttribute1 = obj.doubleAttribute1;
    intAttribute1 = obj.intAttribute1;
    intAttribute2 = obj.intAttribute2;
    intAttribute3 = obj.intAttribute3;
    doubleVector1 = obj.doubleVector1;
    stringVector1 = obj.stringVector1;
    stringVector2 = obj.stringVector2;

    AnnotationObject::SelectAll();
}

// Type map format string
const char *AnnotationObject::TypeMapFormatString = ANNOTATIONOBJECT_TMFS;
const AttributeGroup::private_tmfs_t AnnotationObject::TmfsStruct = {ANNOTATIONOBJECT_TMFS};


// ****************************************************************************
// Method: AnnotationObject::AnnotationObject
//
// Purpose: 
//   Default constructor for the AnnotationObject class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

AnnotationObject::AnnotationObject() : 
    AttributeSubject(AnnotationObject::TypeMapFormatString),
    textColor(), color1(), 
    color2()
{
    AnnotationObject::Init();
}

// ****************************************************************************
// Method: AnnotationObject::AnnotationObject
//
// Purpose: 
//   Constructor for the derived classes of AnnotationObject class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

AnnotationObject::AnnotationObject(private_tmfs_t tmfs) : 
    AttributeSubject(tmfs.tmfs),
    textColor(), color1(), 
    color2()
{
    AnnotationObject::Init();
}

// ****************************************************************************
// Method: AnnotationObject::AnnotationObject
//
// Purpose: 
//   Copy constructor for the AnnotationObject class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

AnnotationObject::AnnotationObject(const AnnotationObject &obj) : 
    AttributeSubject(AnnotationObject::TypeMapFormatString)
{
    AnnotationObject::Copy(obj);
}

// ****************************************************************************
// Method: AnnotationObject::AnnotationObject
//
// Purpose: 
//   Copy constructor for derived classes of the AnnotationObject class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

AnnotationObject::AnnotationObject(const AnnotationObject &obj, private_tmfs_t tmfs) : 
    AttributeSubject(tmfs.tmfs)
{
    AnnotationObject::Copy(obj);
}

// ****************************************************************************
// Method: AnnotationObject::~AnnotationObject
//
// Purpose: 
//   Destructor for the AnnotationObject class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

AnnotationObject::~AnnotationObject()
{
    // nothing here
}

// ****************************************************************************
// Method: AnnotationObject::operator = 
//
// Purpose: 
//   Assignment operator for the AnnotationObject class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

AnnotationObject& 
AnnotationObject::operator = (const AnnotationObject &obj)
{
    if (this == &obj) return *this;

    AnnotationObject::Copy(obj);

    return *this;
}

// ****************************************************************************
// Method: AnnotationObject::operator == 
//
// Purpose: 
//   Comparison operator == for the AnnotationObject class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

bool
AnnotationObject::operator == (const AnnotationObject &obj) const
{
    // Compare the position arrays.
    bool position_equal = true;
    for(int i = 0; i < 3 && position_equal; ++i)
        position_equal = (position[i] == obj.position[i]);

    // Compare the position2 arrays.
    bool position2_equal = true;
    for(int i = 0; i < 3 && position2_equal; ++i)
        position2_equal = (position2[i] == obj.position2[i]);

    // Create the return value
    return ((objectName == obj.objectName) &&
            (objectType == obj.objectType) &&
            (visible == obj.visible) &&
            (active == obj.active) &&
            position_equal &&
            position2_equal &&
            (textColor == obj.textColor) &&
            (useForegroundForTextColor == obj.useForegroundForTextColor) &&
            (color1 == obj.color1) &&
            (color2 == obj.color2) &&
            (text == obj.text) &&
            (fontFamily == obj.fontFamily) &&
            (fontBold == obj.fontBold) &&
            (fontItalic == obj.fontItalic) &&
            (fontShadow == obj.fontShadow) &&
            (doubleAttribute1 == obj.doubleAttribute1) &&
            (intAttribute1 == obj.intAttribute1) &&
            (intAttribute2 == obj.intAttribute2) &&
            (intAttribute3 == obj.intAttribute3) &&
            (doubleVector1 == obj.doubleVector1) &&
            (stringVector1 == obj.stringVector1) &&
            (stringVector2 == obj.stringVector2));
}

// ****************************************************************************
// Method: AnnotationObject::operator != 
//
// Purpose: 
//   Comparison operator != for the AnnotationObject class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

bool
AnnotationObject::operator != (const AnnotationObject &obj) const
{
    return !(this->operator == (obj));
}

// ****************************************************************************
// Method: AnnotationObject::TypeName
//
// Purpose: 
//   Type name method for the AnnotationObject class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

const std::string
AnnotationObject::TypeName() const
{
    return "AnnotationObject";
}

// ****************************************************************************
// Method: AnnotationObject::CopyAttributes
//
// Purpose: 
//   CopyAttributes method for the AnnotationObject class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

bool
AnnotationObject::CopyAttributes(const AttributeGroup *atts)
{
    if(TypeName() != atts->TypeName())
        return false;

    // Call assignment operator.
    const AnnotationObject *tmp = (const AnnotationObject *)atts;
    *this = *tmp;

    return true;
}

// ****************************************************************************
// Method: AnnotationObject::CreateCompatible
//
// Purpose: 
//   CreateCompatible method for the AnnotationObject class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

AttributeSubject *
AnnotationObject::CreateCompatible(const std::string &tname) const
{
    AttributeSubject *retval = 0;
    if(TypeName() == tname)
        retval = new AnnotationObject(*this);
    // Other cases could go here too. 

    return retval;
}

// ****************************************************************************
// Method: AnnotationObject::NewInstance
//
// Purpose: 
//   NewInstance method for the AnnotationObject class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

AttributeSubject *
AnnotationObject::NewInstance(bool copy) const
{
    AttributeSubject *retval = 0;
    if(copy)
        retval = new AnnotationObject(*this);
    else
        retval = new AnnotationObject;

    return retval;
}

// ****************************************************************************
// Method: AnnotationObject::SelectAll
//
// Purpose: 
//   Selects all attributes.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
AnnotationObject::SelectAll()
{
    Select(ID_objectName,                (void *)&objectName);
    Select(ID_objectType,                (void *)&objectType);
    Select(ID_visible,                   (void *)&visible);
    Select(ID_active,                    (void *)&active);
    Select(ID_position,                  (void *)position, 3);
    Select(ID_position2,                 (void *)position2, 3);
    Select(ID_textColor,                 (void *)&textColor);
    Select(ID_useForegroundForTextColor, (void *)&useForegroundForTextColor);
    Select(ID_color1,                    (void *)&color1);
    Select(ID_color2,                    (void *)&color2);
    Select(ID_text,                      (void *)&text);
    Select(ID_fontFamily,                (void *)&fontFamily);
    Select(ID_fontBold,                  (void *)&fontBold);
    Select(ID_fontItalic,                (void *)&fontItalic);
    Select(ID_fontShadow,                (void *)&fontShadow);
    Select(ID_doubleAttribute1,          (void *)&doubleAttribute1);
    Select(ID_intAttribute1,             (void *)&intAttribute1);
    Select(ID_intAttribute2,             (void *)&intAttribute2);
    Select(ID_intAttribute3,             (void *)&intAttribute3);
    Select(ID_doubleVector1,             (void *)&doubleVector1);
    Select(ID_stringVector1,             (void *)&stringVector1);
    Select(ID_stringVector2,             (void *)&stringVector2);
}

///////////////////////////////////////////////////////////////////////////////
// Persistence methods
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: AnnotationObject::CreateNode
//
// Purpose: 
//   This method creates a DataNode representation of the object so it can be saved to a config file.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

bool
AnnotationObject::CreateNode(DataNode *parentNode, bool completeSave, bool forceAdd)
{
    if(parentNode == 0)
        return false;

    AnnotationObject defaultObject;
    bool addToParent = false;
    // Create a node for AnnotationObject.
    DataNode *node = new DataNode("AnnotationObject");

    if(completeSave || !FieldsEqual(ID_objectName, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("objectName", objectName));
    }

    if(completeSave || !FieldsEqual(ID_objectType, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("objectType", AnnotationType_ToString(objectType)));
    }

    if(completeSave || !FieldsEqual(ID_visible, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("visible", visible));
    }

    if(completeSave || !FieldsEqual(ID_active, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("active", active));
    }

    if(completeSave || !FieldsEqual(ID_position, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("position", position, 3));
    }

    if(completeSave || !FieldsEqual(ID_position2, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("position2", position2, 3));
    }

        DataNode *textColorNode = new DataNode("textColor");
        if(textColor.CreateNode(textColorNode, completeSave, true))
        {
            addToParent = true;
            node->AddNode(textColorNode);
        }
        else
            delete textColorNode;
    if(completeSave || !FieldsEqual(ID_useForegroundForTextColor, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("useForegroundForTextColor", useForegroundForTextColor));
    }

        DataNode *color1Node = new DataNode("color1");
        if(color1.CreateNode(color1Node, completeSave, true))
        {
            addToParent = true;
            node->AddNode(color1Node);
        }
        else
            delete color1Node;
        DataNode *color2Node = new DataNode("color2");
        if(color2.CreateNode(color2Node, completeSave, true))
        {
            addToParent = true;
            node->AddNode(color2Node);
        }
        else
            delete color2Node;
    if(completeSave || !FieldsEqual(ID_text, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("text", text));
    }

    if(completeSave || !FieldsEqual(ID_fontFamily, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("fontFamily", FontFamily_ToString(fontFamily)));
    }

    if(completeSave || !FieldsEqual(ID_fontBold, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("fontBold", fontBold));
    }

    if(completeSave || !FieldsEqual(ID_fontItalic, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("fontItalic", fontItalic));
    }

    if(completeSave || !FieldsEqual(ID_fontShadow, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("fontShadow", fontShadow));
    }

    if(completeSave || !FieldsEqual(ID_doubleAttribute1, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("doubleAttribute1", doubleAttribute1));
    }

    if(completeSave || !FieldsEqual(ID_intAttribute1, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("intAttribute1", intAttribute1));
    }

    if(completeSave || !FieldsEqual(ID_intAttribute2, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("intAttribute2", intAttribute2));
    }

    if(completeSave || !FieldsEqual(ID_intAttribute3, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("intAttribute3", intAttribute3));
    }

    if(completeSave || !FieldsEqual(ID_doubleVector1, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("doubleVector1", doubleVector1));
    }

    if(completeSave || !FieldsEqual(ID_stringVector1, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("stringVector1", stringVector1));
    }

    if(completeSave || !FieldsEqual(ID_stringVector2, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("stringVector2", stringVector2));
    }


    // Add the node to the parent node.
    if(addToParent || forceAdd)
        parentNode->AddNode(node);
    else
        delete node;

    return (addToParent || forceAdd);
}

// ****************************************************************************
// Method: AnnotationObject::SetFromNode
//
// Purpose: 
//   This method sets attributes in this object from values in a DataNode 
//    representation of the object.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 17 14:44:33 PST 2006
//
// Modifications:
//   Kathleen Bonnell, Fri Mar 31 14:14:25 PST 2006
//   Handle the case where the parentNode saved postion as float instead
//   of double.
//
//   Brad Whitlock, Fri Mar 23 17:08:29 PST 2007
//   Added objectName.
//
//   Kathleen Bonnell, Thu Oct  1 15:00:50 PDT 2009
//   Added intAttribute2, intAttribute3, doubleVector1, stringVector1, 
//   stringVector2
// ****************************************************************************

void
AnnotationObject::SetFromNode(DataNode *parentNode)
{
    if(parentNode == 0)
        return;

    DataNode *searchNode = parentNode->GetNode("AnnotationObject");
    if(searchNode == 0)
        return;

    DataNode *node;
    if((node = searchNode->GetNode("objectName")) != 0)
        SetObjectName(node->AsString());
    if((node = searchNode->GetNode("objectType")) != 0)
    {
        // Allow enums to be int or string in the config file
        if(node->GetNodeType() == INT_NODE)
        {
            int ival = node->AsInt();
            if(ival >= 0 && ival < 8)
                SetObjectType(AnnotationType(ival));
        }
        else if(node->GetNodeType() == STRING_NODE)
        {
            AnnotationType value;
            if(AnnotationType_FromString(node->AsString(), value))
                SetObjectType(value);
        }
    }
    if((node = searchNode->GetNode("visible")) != 0)
        SetVisible(node->AsBool());
    if((node = searchNode->GetNode("active")) != 0)
        SetActive(node->AsBool());
    if((node = searchNode->GetNode("position")) != 0)
    {
        if(node->GetNodeType() == FLOAT_ARRAY_NODE)
        {
            const float *fn = node->AsFloatArray();
            double dp[3] = {fn[0], fn[1], fn[2]};
            SetPosition(dp);
        }
        else
            SetPosition(node->AsDoubleArray());
    }
    if((node = searchNode->GetNode("position2")) != 0)
    {
        if(node->GetNodeType() == FLOAT_ARRAY_NODE)
        {
            const float *fn = node->AsFloatArray();
            double dp[3] = {fn[0], fn[1], fn[2]};
            SetPosition2(dp);
        }
        else
            SetPosition2(node->AsDoubleArray());
    }
    if((node = searchNode->GetNode("textColor")) != 0)
        textColor.SetFromNode(node);
    if((node = searchNode->GetNode("useForegroundForTextColor")) != 0)
        SetUseForegroundForTextColor(node->AsBool());
    if((node = searchNode->GetNode("color1")) != 0)
        color1.SetFromNode(node);
    if((node = searchNode->GetNode("color2")) != 0)
        color2.SetFromNode(node);
    if((node = searchNode->GetNode("text")) != 0)
        SetText(node->AsStringVector());
    if((node = searchNode->GetNode("fontFamily")) != 0)
    {
        // Allow enums to be int or string in the config file
        if(node->GetNodeType() == INT_NODE)
        {
            int ival = node->AsInt();
            if(ival >= 0 && ival < 3)
                SetFontFamily(FontFamily(ival));
        }
        else if(node->GetNodeType() == STRING_NODE)
        {
            FontFamily value;
            if(FontFamily_FromString(node->AsString(), value))
                SetFontFamily(value);
        }
    }
    if((node = searchNode->GetNode("fontBold")) != 0)
        SetFontBold(node->AsBool());
    if((node = searchNode->GetNode("fontItalic")) != 0)
        SetFontItalic(node->AsBool());
    if((node = searchNode->GetNode("fontShadow")) != 0)
        SetFontShadow(node->AsBool());
    if((node = searchNode->GetNode("floatAttribute1")) != 0)
        SetDoubleAttribute1(node->AsDouble());
    if((node = searchNode->GetNode("doubleAttribute1")) != 0)
        SetDoubleAttribute1(node->AsDouble());
    if((node = searchNode->GetNode("intAttribute1")) != 0)
        SetIntAttribute1(node->AsInt());
    if((node = searchNode->GetNode("intAttribute2")) != 0)
        SetIntAttribute2(node->AsInt());
    if((node = searchNode->GetNode("intAttribute3")) != 0)
        SetIntAttribute3(node->AsInt());
    if((node = searchNode->GetNode("doubleVector1")) != 0)
        SetDoubleVector1(node->AsDoubleVector());
    if((node = searchNode->GetNode("stringVector1")) != 0)
        SetStringVector1(node->AsStringVector());
    if((node = searchNode->GetNode("stringVector2")) != 0)
        SetStringVector2(node->AsStringVector());
}
///////////////////////////////////////////////////////////////////////////////
// Set property methods
///////////////////////////////////////////////////////////////////////////////

void
AnnotationObject::SetObjectName(const std::string &objectName_)
{
    objectName = objectName_;
    Select(ID_objectName, (void *)&objectName);
}

void
AnnotationObject::SetObjectType(AnnotationObject::AnnotationType objectType_)
{
    objectType = objectType_;
    Select(ID_objectType, (void *)&objectType);
}

void
AnnotationObject::SetVisible(bool visible_)
{
    visible = visible_;
    Select(ID_visible, (void *)&visible);
}

void
AnnotationObject::SetActive(bool active_)
{
    active = active_;
    Select(ID_active, (void *)&active);
}

void
AnnotationObject::SetPosition(const double *position_)
{
    position[0] = position_[0];
    position[1] = position_[1];
    position[2] = position_[2];
    Select(ID_position, (void *)position, 3);
}

void
AnnotationObject::SetPosition2(const double *position2_)
{
    position2[0] = position2_[0];
    position2[1] = position2_[1];
    position2[2] = position2_[2];
    Select(ID_position2, (void *)position2, 3);
}

void
AnnotationObject::SetTextColor(const ColorAttribute &textColor_)
{
    textColor = textColor_;
    Select(ID_textColor, (void *)&textColor);
}

void
AnnotationObject::SetUseForegroundForTextColor(bool useForegroundForTextColor_)
{
    useForegroundForTextColor = useForegroundForTextColor_;
    Select(ID_useForegroundForTextColor, (void *)&useForegroundForTextColor);
}

void
AnnotationObject::SetColor1(const ColorAttribute &color1_)
{
    color1 = color1_;
    Select(ID_color1, (void *)&color1);
}

void
AnnotationObject::SetColor2(const ColorAttribute &color2_)
{
    color2 = color2_;
    Select(ID_color2, (void *)&color2);
}

void
AnnotationObject::SetText(const stringVector &text_)
{
    text = text_;
    Select(ID_text, (void *)&text);
}

void
AnnotationObject::SetFontFamily(AnnotationObject::FontFamily fontFamily_)
{
    fontFamily = fontFamily_;
    Select(ID_fontFamily, (void *)&fontFamily);
}

void
AnnotationObject::SetFontBold(bool fontBold_)
{
    fontBold = fontBold_;
    Select(ID_fontBold, (void *)&fontBold);
}

void
AnnotationObject::SetFontItalic(bool fontItalic_)
{
    fontItalic = fontItalic_;
    Select(ID_fontItalic, (void *)&fontItalic);
}

void
AnnotationObject::SetFontShadow(bool fontShadow_)
{
    fontShadow = fontShadow_;
    Select(ID_fontShadow, (void *)&fontShadow);
}

void
AnnotationObject::SetDoubleAttribute1(double doubleAttribute1_)
{
    doubleAttribute1 = doubleAttribute1_;
    Select(ID_doubleAttribute1, (void *)&doubleAttribute1);
}

void
AnnotationObject::SetIntAttribute1(int intAttribute1_)
{
    intAttribute1 = intAttribute1_;
    Select(ID_intAttribute1, (void *)&intAttribute1);
}

void
AnnotationObject::SetIntAttribute2(int intAttribute2_)
{
    intAttribute2 = intAttribute2_;
    Select(ID_intAttribute2, (void *)&intAttribute2);
}

void
AnnotationObject::SetIntAttribute3(int intAttribute3_)
{
    intAttribute3 = intAttribute3_;
    Select(ID_intAttribute3, (void *)&intAttribute3);
}

void
AnnotationObject::SetDoubleVector1(const doubleVector &doubleVector1_)
{
    doubleVector1 = doubleVector1_;
    Select(ID_doubleVector1, (void *)&doubleVector1);
}

void
AnnotationObject::SetStringVector1(const stringVector &stringVector1_)
{
    stringVector1 = stringVector1_;
    Select(ID_stringVector1, (void *)&stringVector1);
}

void
AnnotationObject::SetStringVector2(const stringVector &stringVector2_)
{
    stringVector2 = stringVector2_;
    Select(ID_stringVector2, (void *)&stringVector2);
}

///////////////////////////////////////////////////////////////////////////////
// Get property methods
///////////////////////////////////////////////////////////////////////////////

const std::string &
AnnotationObject::GetObjectName() const
{
    return objectName;
}

std::string &
AnnotationObject::GetObjectName()
{
    return objectName;
}

AnnotationObject::AnnotationType
AnnotationObject::GetObjectType() const
{
    return AnnotationType(objectType);
}

bool
AnnotationObject::GetVisible() const
{
    return visible;
}

bool
AnnotationObject::GetActive() const
{
    return active;
}

const double *
AnnotationObject::GetPosition() const
{
    return position;
}

double *
AnnotationObject::GetPosition()
{
    return position;
}

const double *
AnnotationObject::GetPosition2() const
{
    return position2;
}

double *
AnnotationObject::GetPosition2()
{
    return position2;
}

const ColorAttribute &
AnnotationObject::GetTextColor() const
{
    return textColor;
}

ColorAttribute &
AnnotationObject::GetTextColor()
{
    return textColor;
}

bool
AnnotationObject::GetUseForegroundForTextColor() const
{
    return useForegroundForTextColor;
}

const ColorAttribute &
AnnotationObject::GetColor1() const
{
    return color1;
}

ColorAttribute &
AnnotationObject::GetColor1()
{
    return color1;
}

const ColorAttribute &
AnnotationObject::GetColor2() const
{
    return color2;
}

ColorAttribute &
AnnotationObject::GetColor2()
{
    return color2;
}

const stringVector &
AnnotationObject::GetText() const
{
    return text;
}

stringVector &
AnnotationObject::GetText()
{
    return text;
}

AnnotationObject::FontFamily
AnnotationObject::GetFontFamily() const
{
    return FontFamily(fontFamily);
}

bool
AnnotationObject::GetFontBold() const
{
    return fontBold;
}

bool
AnnotationObject::GetFontItalic() const
{
    return fontItalic;
}

bool
AnnotationObject::GetFontShadow() const
{
    return fontShadow;
}

double
AnnotationObject::GetDoubleAttribute1() const
{
    return doubleAttribute1;
}

int
AnnotationObject::GetIntAttribute1() const
{
    return intAttribute1;
}

int
AnnotationObject::GetIntAttribute2() const
{
    return intAttribute2;
}

int
AnnotationObject::GetIntAttribute3() const
{
    return intAttribute3;
}

const doubleVector &
AnnotationObject::GetDoubleVector1() const
{
    return doubleVector1;
}

doubleVector &
AnnotationObject::GetDoubleVector1()
{
    return doubleVector1;
}

const stringVector &
AnnotationObject::GetStringVector1() const
{
    return stringVector1;
}

stringVector &
AnnotationObject::GetStringVector1()
{
    return stringVector1;
}

const stringVector &
AnnotationObject::GetStringVector2() const
{
    return stringVector2;
}

stringVector &
AnnotationObject::GetStringVector2()
{
    return stringVector2;
}

///////////////////////////////////////////////////////////////////////////////
// Select property methods
///////////////////////////////////////////////////////////////////////////////

void
AnnotationObject::SelectObjectName()
{
    Select(ID_objectName, (void *)&objectName);
}

void
AnnotationObject::SelectPosition()
{
    Select(ID_position, (void *)position, 3);
}

void
AnnotationObject::SelectPosition2()
{
    Select(ID_position2, (void *)position2, 3);
}

void
AnnotationObject::SelectTextColor()
{
    Select(ID_textColor, (void *)&textColor);
}

void
AnnotationObject::SelectColor1()
{
    Select(ID_color1, (void *)&color1);
}

void
AnnotationObject::SelectColor2()
{
    Select(ID_color2, (void *)&color2);
}

void
AnnotationObject::SelectText()
{
    Select(ID_text, (void *)&text);
}

void
AnnotationObject::SelectDoubleVector1()
{
    Select(ID_doubleVector1, (void *)&doubleVector1);
}

void
AnnotationObject::SelectStringVector1()
{
    Select(ID_stringVector1, (void *)&stringVector1);
}

void
AnnotationObject::SelectStringVector2()
{
    Select(ID_stringVector2, (void *)&stringVector2);
}

///////////////////////////////////////////////////////////////////////////////
// Keyframing methods
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: AnnotationObject::GetFieldName
//
// Purpose: 
//   This method returns the name of a field given its index.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

std::string
AnnotationObject::GetFieldName(int index) const
{
    switch (index)
    {
    case ID_objectName:                return "objectName";
    case ID_objectType:                return "objectType";
    case ID_visible:                   return "visible";
    case ID_active:                    return "active";
    case ID_position:                  return "position";
    case ID_position2:                 return "position2";
    case ID_textColor:                 return "textColor";
    case ID_useForegroundForTextColor: return "useForegroundForTextColor";
    case ID_color1:                    return "color1";
    case ID_color2:                    return "color2";
    case ID_text:                      return "text";
    case ID_fontFamily:                return "fontFamily";
    case ID_fontBold:                  return "fontBold";
    case ID_fontItalic:                return "fontItalic";
    case ID_fontShadow:                return "fontShadow";
    case ID_doubleAttribute1:          return "doubleAttribute1";
    case ID_intAttribute1:             return "intAttribute1";
    case ID_intAttribute2:             return "intAttribute2";
    case ID_intAttribute3:             return "intAttribute3";
    case ID_doubleVector1:             return "doubleVector1";
    case ID_stringVector1:             return "stringVector1";
    case ID_stringVector2:             return "stringVector2";
    default:  return "invalid index";
    }
}

// ****************************************************************************
// Method: AnnotationObject::GetFieldType
//
// Purpose: 
//   This method returns the type of a field given its index.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

AttributeGroup::FieldType
AnnotationObject::GetFieldType(int index) const
{
    switch (index)
    {
    case ID_objectName:                return FieldType_string;
    case ID_objectType:                return FieldType_enum;
    case ID_visible:                   return FieldType_bool;
    case ID_active:                    return FieldType_bool;
    case ID_position:                  return FieldType_doubleArray;
    case ID_position2:                 return FieldType_doubleArray;
    case ID_textColor:                 return FieldType_color;
    case ID_useForegroundForTextColor: return FieldType_bool;
    case ID_color1:                    return FieldType_color;
    case ID_color2:                    return FieldType_color;
    case ID_text:                      return FieldType_stringVector;
    case ID_fontFamily:                return FieldType_enum;
    case ID_fontBold:                  return FieldType_bool;
    case ID_fontItalic:                return FieldType_bool;
    case ID_fontShadow:                return FieldType_bool;
    case ID_doubleAttribute1:          return FieldType_double;
    case ID_intAttribute1:             return FieldType_int;
    case ID_intAttribute2:             return FieldType_int;
    case ID_intAttribute3:             return FieldType_int;
    case ID_doubleVector1:             return FieldType_doubleVector;
    case ID_stringVector1:             return FieldType_stringVector;
    case ID_stringVector2:             return FieldType_stringVector;
    default:  return FieldType_unknown;
    }
}

// ****************************************************************************
// Method: AnnotationObject::GetFieldTypeName
//
// Purpose: 
//   This method returns the name of a field type given its index.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

std::string
AnnotationObject::GetFieldTypeName(int index) const
{
    switch (index)
    {
    case ID_objectName:                return "string";
    case ID_objectType:                return "enum";
    case ID_visible:                   return "bool";
    case ID_active:                    return "bool";
    case ID_position:                  return "doubleArray";
    case ID_position2:                 return "doubleArray";
    case ID_textColor:                 return "color";
    case ID_useForegroundForTextColor: return "bool";
    case ID_color1:                    return "color";
    case ID_color2:                    return "color";
    case ID_text:                      return "stringVector";
    case ID_fontFamily:                return "enum";
    case ID_fontBold:                  return "bool";
    case ID_fontItalic:                return "bool";
    case ID_fontShadow:                return "bool";
    case ID_doubleAttribute1:          return "double";
    case ID_intAttribute1:             return "int";
    case ID_intAttribute2:             return "int";
    case ID_intAttribute3:             return "int";
    case ID_doubleVector1:             return "doubleVector";
    case ID_stringVector1:             return "stringVector";
    case ID_stringVector2:             return "stringVector";
    default:  return "invalid index";
    }
}

// ****************************************************************************
// Method: AnnotationObject::FieldsEqual
//
// Purpose: 
//   This method compares two fields and return true if they are equal.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

bool
AnnotationObject::FieldsEqual(int index_, const AttributeGroup *rhs) const
{
    const AnnotationObject &obj = *((const AnnotationObject*)rhs);
    bool retval = false;
    switch (index_)
    {
    case ID_objectName:
        {  // new scope
        retval = (objectName == obj.objectName);
        }
        break;
    case ID_objectType:
        {  // new scope
        retval = (objectType == obj.objectType);
        }
        break;
    case ID_visible:
        {  // new scope
        retval = (visible == obj.visible);
        }
        break;
    case ID_active:
        {  // new scope
        retval = (active == obj.active);
        }
        break;
    case ID_position:
        {  // new scope
        // Compare the position arrays.
        bool position_equal = true;
        for(int i = 0; i < 3 && position_equal; ++i)
            position_equal = (position[i] == obj.position[i]);

        retval = position_equal;
        }
        break;
    case ID_position2:
        {  // new scope
        // Compare the position2 arrays.
        bool position2_equal = true;
        for(int i = 0; i < 3 && position2_equal; ++i)
            position2_equal = (position2[i] == obj.position2[i]);

        retval = position2_equal;
        }
        break;
    case ID_textColor:
        {  // new scope
        retval = (textColor == obj.textColor);
        }
        break;
    case ID_useForegroundForTextColor:
        {  // new scope
        retval = (useForegroundForTextColor == obj.useForegroundForTextColor);
        }
        break;
    case ID_color1:
        {  // new scope
        retval = (color1 == obj.color1);
        }
        break;
    case ID_color2:
        {  // new scope
        retval = (color2 == obj.color2);
        }
        break;
    case ID_text:
        {  // new scope
        retval = (text == obj.text);
        }
        break;
    case ID_fontFamily:
        {  // new scope
        retval = (fontFamily == obj.fontFamily);
        }
        break;
    case ID_fontBold:
        {  // new scope
        retval = (fontBold == obj.fontBold);
        }
        break;
    case ID_fontItalic:
        {  // new scope
        retval = (fontItalic == obj.fontItalic);
        }
        break;
    case ID_fontShadow:
        {  // new scope
        retval = (fontShadow == obj.fontShadow);
        }
        break;
    case ID_doubleAttribute1:
        {  // new scope
        retval = (doubleAttribute1 == obj.doubleAttribute1);
        }
        break;
    case ID_intAttribute1:
        {  // new scope
        retval = (intAttribute1 == obj.intAttribute1);
        }
        break;
    case ID_intAttribute2:
        {  // new scope
        retval = (intAttribute2 == obj.intAttribute2);
        }
        break;
    case ID_intAttribute3:
        {  // new scope
        retval = (intAttribute3 == obj.intAttribute3);
        }
        break;
    case ID_doubleVector1:
        {  // new scope
        retval = (doubleVector1 == obj.doubleVector1);
        }
        break;
    case ID_stringVector1:
        {  // new scope
        retval = (stringVector1 == obj.stringVector1);
        }
        break;
    case ID_stringVector2:
        {  // new scope
        retval = (stringVector2 == obj.stringVector2);
        }
        break;
    default: retval = false;
    }

    return retval;
}

///////////////////////////////////////////////////////////////////////////////
// User-defined methods.
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: AnnotationObject::ProcessOldVersions
//
// Purpose: 
//   This method maps old AnnotationAttributes fields to the 1.9.0 version of
//   the data node tree for AnnotationAttributes.
//
// Programmer: Kathleen Bonnell
// Creation:   Thu Sep 17 10:06:49 PDT 2009
//
// Modifications:
//
// ****************************************************************************

void
AnnotationObject::ProcessOldVersions(DataNode *parentNode,
    const char *configVersion)
{
    if (!VersionLessThan(configVersion, "2.0.0"))
        return;

    if (parentNode == 0)
        return;

    DataNode * searchNode = parentNode->GetNode("AnnotationObject");
    if (searchNode == 0)
        return;

    DataNode *node = searchNode->GetNode("objectType");
    if (node == 0 || node->AsString() != "LegendAttributes")
    {
        return;
    }

    // what follows if for Legends only
    node = searchNode->GetNode("intAttribute1");
    if (node != 0)
    {
        int n = node->AsInt();

        if ((n & (1 << 2)) != 0) // DrawLabels is set, change it to DrawValues
        {
            n -= 4;   // DrawLabels
            n += 512; // DrawValues
        }
        // other new legend enums, default to on, and sum to 384
        n += 384;
        node->SetInt(n);
    }
    // new numTics attribute, default setting is 5
    node = new DataNode("intAttribute2");
    node->SetInt(5);
    searchNode->AddNode(node);
    node = new DataNode("intAttribute3");
    node->SetInt(0);  // default "Variable" type
    searchNode->AddNode(node);
}


#include <PickVarInfo.h>
#include <DataNode.h>
#include <stdio.h>

//
// Enum conversion methods for PickVarInfo::Centering
//

static const char *Centering_strings[] = {
"Nodal", "Zonal", "None"
};

std::string
PickVarInfo::Centering_ToString(PickVarInfo::Centering t)
{
    return Centering_strings[(int)t];
}

std::string
PickVarInfo::Centering_ToString(int t)
{
    return Centering_strings[t];
}

bool
PickVarInfo::Centering_FromString(const std::string &s, PickVarInfo::Centering &val)
{
    for(int i = 0; i < 3; ++i)
    {
        if(s == Centering_strings[i])
        {
            val = (Centering)i;
            return true;
        }
    }
    return false;
}

// ****************************************************************************
// Method: PickVarInfo::PickVarInfo
//
// Purpose: 
//   Constructor for the PickVarInfo class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:40:00 PST 2003
//
// Modifications:
//   
// ****************************************************************************

PickVarInfo::PickVarInfo() : AttributeSubject("ss*d*s*d*bis")
{
    mixVar = false;
    centering = None;
}

// ****************************************************************************
// Method: PickVarInfo::PickVarInfo
//
// Purpose: 
//   Copy constructor for the PickVarInfo class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:40:00 PST 2003
//
// Modifications:
//   
// ****************************************************************************

PickVarInfo::PickVarInfo(const PickVarInfo &obj) : AttributeSubject("ss*d*s*d*bis")
{
    variableName = obj.variableName;
    names = obj.names;
    values = obj.values;
    mixNames = obj.mixNames;
    mixValues = obj.mixValues;
    mixVar = obj.mixVar;
    centering = obj.centering;
    miscMessage = obj.miscMessage;

    SelectAll();
}

// ****************************************************************************
// Method: PickVarInfo::~PickVarInfo
//
// Purpose: 
//   Destructor for the PickVarInfo class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:40:00 PST 2003
//
// Modifications:
//   
// ****************************************************************************

PickVarInfo::~PickVarInfo()
{
    // nothing here
}

// ****************************************************************************
// Method: PickVarInfo::operator = 
//
// Purpose: 
//   Assignment operator for the PickVarInfo class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:40:00 PST 2003
//
// Modifications:
//   
// ****************************************************************************

void
PickVarInfo::operator = (const PickVarInfo &obj)
{
    variableName = obj.variableName;
    names = obj.names;
    values = obj.values;
    mixNames = obj.mixNames;
    mixValues = obj.mixValues;
    mixVar = obj.mixVar;
    centering = obj.centering;
    miscMessage = obj.miscMessage;

    SelectAll();
}

// ****************************************************************************
// Method: PickVarInfo::operator == 
//
// Purpose: 
//   Comparison operator == for the PickVarInfo class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:40:00 PST 2003
//
// Modifications:
//   
// ****************************************************************************

bool
PickVarInfo::operator == (const PickVarInfo &obj) const
{
    // Create the return value
    return ((variableName == obj.variableName) &&
            (names == obj.names) &&
            (values == obj.values) &&
            (mixNames == obj.mixNames) &&
            (mixValues == obj.mixValues) &&
            (mixVar == obj.mixVar) &&
            (centering == obj.centering) &&
            (miscMessage == obj.miscMessage));
}

// ****************************************************************************
// Method: PickVarInfo::operator != 
//
// Purpose: 
//   Comparison operator != for the PickVarInfo class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:40:00 PST 2003
//
// Modifications:
//   
// ****************************************************************************

bool
PickVarInfo::operator != (const PickVarInfo &obj) const
{
    return !(this->operator == (obj));
}

// ****************************************************************************
// Method: PickVarInfo::TypeName
//
// Purpose: 
//   Type name method for the PickVarInfo class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:40:00 PST 2003
//
// Modifications:
//   
// ****************************************************************************

const std::string
PickVarInfo::TypeName() const
{
    return "PickVarInfo";
}

// ****************************************************************************
// Method: PickVarInfo::CopyAttributes
//
// Purpose: 
//   CopyAttributes method for the PickVarInfo class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:40:00 PST 2003
//
// Modifications:
//   
// ****************************************************************************

bool
PickVarInfo::CopyAttributes(const AttributeGroup *atts)
{
    if(TypeName() != atts->TypeName())
        return false;

    // Call assignment operator.
    const PickVarInfo *tmp = (const PickVarInfo *)atts;
    *this = *tmp;

    return true;
}

// ****************************************************************************
// Method: PickVarInfo::CreateCompatible
//
// Purpose: 
//   CreateCompatible method for the PickVarInfo class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:40:00 PST 2003
//
// Modifications:
//   
// ****************************************************************************

AttributeSubject *
PickVarInfo::CreateCompatible(const std::string &tname) const
{
    AttributeSubject *retval = 0;
    if(TypeName() == tname)
        retval = new PickVarInfo(*this);
    // Other cases could go here too. 

    return retval;
}

// ****************************************************************************
// Method: PickVarInfo::SelectAll
//
// Purpose: 
//   Selects all attributes.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:40:00 PST 2003
//
// Modifications:
//   
// ****************************************************************************

void
PickVarInfo::SelectAll()
{
    Select(0, (void *)&variableName);
    Select(1, (void *)&names);
    Select(2, (void *)&values);
    Select(3, (void *)&mixNames);
    Select(4, (void *)&mixValues);
    Select(5, (void *)&mixVar);
    Select(6, (void *)&centering);
    Select(7, (void *)&miscMessage);
}

///////////////////////////////////////////////////////////////////////////////
// Set property methods
///////////////////////////////////////////////////////////////////////////////

void
PickVarInfo::SetVariableName(const std::string &variableName_)
{
    variableName = variableName_;
    Select(0, (void *)&variableName);
}

void
PickVarInfo::SetNames(const stringVector &names_)
{
    names = names_;
    Select(1, (void *)&names);
}

void
PickVarInfo::SetValues(const doubleVector &values_)
{
    values = values_;
    Select(2, (void *)&values);
}

void
PickVarInfo::SetMixNames(const stringVector &mixNames_)
{
    mixNames = mixNames_;
    Select(3, (void *)&mixNames);
}

void
PickVarInfo::SetMixValues(const doubleVector &mixValues_)
{
    mixValues = mixValues_;
    Select(4, (void *)&mixValues);
}

void
PickVarInfo::SetMixVar(bool mixVar_)
{
    mixVar = mixVar_;
    Select(5, (void *)&mixVar);
}

void
PickVarInfo::SetCentering(PickVarInfo::Centering centering_)
{
    centering = centering_;
    Select(6, (void *)&centering);
}

void
PickVarInfo::SetMiscMessage(const std::string &miscMessage_)
{
    miscMessage = miscMessage_;
    Select(7, (void *)&miscMessage);
}

///////////////////////////////////////////////////////////////////////////////
// Get property methods
///////////////////////////////////////////////////////////////////////////////

const std::string &
PickVarInfo::GetVariableName() const
{
    return variableName;
}

std::string &
PickVarInfo::GetVariableName()
{
    return variableName;
}

const stringVector &
PickVarInfo::GetNames() const
{
    return names;
}

stringVector &
PickVarInfo::GetNames()
{
    return names;
}

const doubleVector &
PickVarInfo::GetValues() const
{
    return values;
}

doubleVector &
PickVarInfo::GetValues()
{
    return values;
}

const stringVector &
PickVarInfo::GetMixNames() const
{
    return mixNames;
}

stringVector &
PickVarInfo::GetMixNames()
{
    return mixNames;
}

const doubleVector &
PickVarInfo::GetMixValues() const
{
    return mixValues;
}

doubleVector &
PickVarInfo::GetMixValues()
{
    return mixValues;
}

bool
PickVarInfo::GetMixVar() const
{
    return mixVar;
}

PickVarInfo::Centering
PickVarInfo::GetCentering() const
{
    return Centering(centering);
}

const std::string &
PickVarInfo::GetMiscMessage() const
{
    return miscMessage;
}

std::string &
PickVarInfo::GetMiscMessage()
{
    return miscMessage;
}

///////////////////////////////////////////////////////////////////////////////
// Select property methods
///////////////////////////////////////////////////////////////////////////////

void
PickVarInfo::SelectVariableName()
{
    Select(0, (void *)&variableName);
}

void
PickVarInfo::SelectNames()
{
    Select(1, (void *)&names);
}

void
PickVarInfo::SelectValues()
{
    Select(2, (void *)&values);
}

void
PickVarInfo::SelectMixNames()
{
    Select(3, (void *)&mixNames);
}

void
PickVarInfo::SelectMixValues()
{
    Select(4, (void *)&mixValues);
}

void
PickVarInfo::SelectMiscMessage()
{
    Select(7, (void *)&miscMessage);
}

///////////////////////////////////////////////////////////////////////////////
// Keyframing methods
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: PickVarInfo::GetFieldName
//
// Purpose: 
//   This method returns the name of a field given its index.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:40:00 PST 2003
//
// Modifications:
//   
// ****************************************************************************

std::string
PickVarInfo::GetFieldName(int index) const
{
    switch (index)
    {
        case 0:  return "variableName";
        case 1:  return "names";
        case 2:  return "values";
        case 3:  return "mixNames";
        case 4:  return "mixValues";
        case 5:  return "mixVar";
        case 6:  return "centering";
        case 7:  return "miscMessage";
        default:  return "invalid index";
    }
}

// ****************************************************************************
// Method: PickVarInfo::GetFieldType
//
// Purpose: 
//   This method returns the type of a field given its index.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:40:00 PST 2003
//
// Modifications:
//   
// ****************************************************************************

AttributeGroup::FieldType
PickVarInfo::GetFieldType(int index) const
{
    switch (index)
    {
        case 0:  return FieldType_string;
        case 1:  return FieldType_stringVector;
        case 2:  return FieldType_doubleVector;
        case 3:  return FieldType_stringVector;
        case 4:  return FieldType_doubleVector;
        case 5:  return FieldType_bool;
        case 6:  return FieldType_enum;
        case 7:  return FieldType_string;
        default:  return FieldType_unknown;
    }
}

// ****************************************************************************
// Method: PickVarInfo::GetFieldTypeName
//
// Purpose: 
//   This method returns the name of a field type given its index.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:40:00 PST 2003
//
// Modifications:
//   
// ****************************************************************************

std::string
PickVarInfo::GetFieldTypeName(int index) const
{
    switch (index)
    {
        case 0:  return "string";
        case 1:  return "stringVector";
        case 2:  return "doubleVector";
        case 3:  return "stringVector";
        case 4:  return "doubleVector";
        case 5:  return "bool";
        case 6:  return "enum";
        case 7:  return "string";
        default:  return "invalid index";
    }
}

// ****************************************************************************
// Method: PickVarInfo::FieldsEqual
//
// Purpose: 
//   This method compares two fields and return true if they are equal.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Tue May 20 13:40:00 PST 2003
//
// Modifications:
//   
// ****************************************************************************

bool
PickVarInfo::FieldsEqual(int index_, const AttributeGroup *rhs) const
{
    const PickVarInfo &obj = *((const PickVarInfo*)rhs);
    bool retval = false;
    switch (index_)
    {
    case 0:
        {  // new scope
        retval = (variableName == obj.variableName);
        }
        break;
    case 1:
        {  // new scope
        retval = (names == obj.names);
        }
        break;
    case 2:
        {  // new scope
        retval = (values == obj.values);
        }
        break;
    case 3:
        {  // new scope
        retval = (mixNames == obj.mixNames);
        }
        break;
    case 4:
        {  // new scope
        retval = (mixValues == obj.mixValues);
        }
        break;
    case 5:
        {  // new scope
        retval = (mixVar == obj.mixVar);
        }
        break;
    case 6:
        {  // new scope
        retval = (centering == obj.centering);
        }
        break;
    case 7:
        {  // new scope
        retval = (miscMessage == obj.miscMessage);
        }
        break;
    default: retval = false;
    }

    return retval;
}

///////////////////////////////////////////////////////////////////////////////
// User-defined methods.
///////////////////////////////////////////////////////////////////////////////

void
PickVarInfo::Reset()
{
    variableName = " ";
    centering = None;
    mixVar = false;

    if (!names.empty())
        names.clear();
    if (!values.empty())
        values.clear();
    if (!mixNames.empty())
        mixNames.clear();
    if (!mixValues.empty())
        mixValues.clear();

    SelectAll();
}

void
PickVarInfo::PrintSelf(ostream &os)
{
    int i;
    os << variableName.c_str() << ":  ";
    switch (centering)
    {
        case Nodal:  os << "nodal " ; break;
        case Zonal:  os << "zonal " ; break;
        case None : break;
    }
    if (!names.empty())
    {  
        for (i = 0; i < names.size(); i++)
        {
            os << "    " << names[i].c_str() << " = ";
            if (values.size() > names.size())
            {
                int stride = values.size() / names.size();
                os << "(";
                for (int j = 0; j < stride; j++) 
                {
                    os << values[i*stride + j] << ", " ;
                }
                os << ")\n";
            }
            else if (values.size() == names.size())
            {
                os << values[i] << "\n" ;
            }
        }
    }
    else if (!miscMessage.empty())
    {
        os << "    " << miscMessage.c_str() << "\n";
    }
    else
    {
        os << "    No Information Found\n";
    }
    if (mixVar)
    {
        for (i = 0; i < mixNames.size(); i++)
        {
            os << "        " << mixNames[i].c_str() << " = ";
            os <<  mixValues[i] << "\n";
        }
    }
}

void
PickVarInfo::CreateOutputString(std::string &os)
{
    int i;
    char buff[256];
    os = variableName;
    os +=  ":  ";
    switch (centering)
    {
        case Nodal:  os += "<nodal>\n" ; break;
        case Zonal:  os += "<zonal>\n" ; break;
        case None :  os += "\n";         break;
    }
    if (!names.empty())
    {  
        for (i = 0; i < names.size(); i++)
        {
            SNPRINTF(buff, 256, "    %s ", names[i].c_str());
            os += buff;
            if (values.size() > names.size())
            {
                int stride = values.size() / names.size();
                SNPRINTF(buff, 256, "= (%g", values[i*stride]);
                os += buff;
                for (int j = 1; j < stride-1; j++) 
                {
                    SNPRINTF(buff, 256, ",%g", values[i*stride+j]);
                    os += buff;
                }
                SNPRINTF(buff, 256, ") mag = %g\n", values[i*stride+stride-1]);
                os += buff; 
            }
            else if (values.size() == names.size())
            {
                SNPRINTF(buff, 256, "= %g\n", values[i]);
                os += buff;
            }
            else 
            {
                os += "\n";
            }
        }
    }
    else if (!miscMessage.empty())
    {
        SNPRINTF(buff, 256, "    %s\n", miscMessage.c_str());
        os += buff;
    }
    else
    {
        SNPRINTF(buff, 256, "    No Information Found\n"); 
        os += buff;
    }
    if (mixVar)
    {
        for (i = 0; i < mixNames.size(); i++)
        {
            SNPRINTF(buff, 256, "        material %s = ", mixNames[i].c_str());
            os += buff;
            SNPRINTF(buff, 256, "%g\n", mixValues[i]);
            os += buff;
        }
    }
}

void
PickVarInfo::CreateOutputStrings(std::vector<std::string> &os)
{
    int i;
    char buff[256];
    char buf2[256];
    switch (centering)
    {
        case Nodal:  SNPRINTF(buff, 256, "%s: <nodal>", variableName.c_str()); 
                     os.push_back(buff);
                     break;
        case Zonal:  SNPRINTF(buff, 256, "%s: <zonal>", variableName.c_str()); 
                     os.push_back(buff);
                     break;
        case None :  SNPRINTF(buff, 256, "%s: ", variableName.c_str()); 
                     os.push_back(buff);
                     break;
    }
    if (!names.empty())
    {  
        for (i = 0; i < names.size(); i++)
        {
            SNPRINTF(buff, 256, "    %s ", names[i].c_str());
            // Vectors?
            if (values.size() > names.size())
            {
                int stride = values.size() / names.size();
                SNPRINTF(buf2, 256, "= (%g", values[i*stride]);
                strcat(buff, buf2);
                for (int j = 1; j < stride-1; j++) 
                {
                    SNPRINTF(buf2, 256, ", %g", values[i*stride+j]);
                    strcat(buff, buf2);
                }
                SNPRINTF(buf2, 256, ") mag = %g", values[i*stride+stride-1]);
                strcat(buff,  buf2);
            }
            // Scalars?
            else if (values.size() == names.size())
            {
                SNPRINTF(buf2, 256, "= %g", values[i]);
                strcat(buff, buf2);
            }
            os.push_back(buff);
        }
    }
    else if (!miscMessage.empty())
    {
        SNPRINTF(buff, 256, "    %s", miscMessage.c_str());
        os.push_back(buff);
    }
    else   
    {
        SNPRINTF(buff, 256, "    No Information Found");
        os.push_back(buff);
    }
    if (mixVar)
    {
        for (i = 0; i < mixNames.size(); i++)
        {
            SNPRINTF(buff, 256, "        material %s = %g", mixNames[i].c_str(), mixValues[i]);
            os.push_back(buff);
        }
    }
}


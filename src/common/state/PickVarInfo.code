Function: PrintSelf
Declaration: void PrintSelf(ostream &os);
Definition:
// ****************************************************************************
// Method: PickVarInfo::PrintSelf
//
// Purpose: 
//   Prints the contents of this class to the passed stream. 
//
// Modifications:
//   Kathleen Bonnell, Thu Jun 26 09:31:56 PDT 2003
//   Logic changed in order to support node picking. Info from material var's 
//   now handled differently. 
//   
// ****************************************************************************

void
PickVarInfo::PrintSelf(ostream &os)
{
    int i, j, nMats, mixOffset;
    os << variableName.c_str() << ":  ";
    switch (centering)
    {
        case Nodal:  os << "nodal " ; break;
        case Zonal:  os << "zonal " ; break;
        case None : break;
    }
    if (!(names.empty() && mixNames.empty()))
    {  
        if (!varIsMaterial)
        {
            mixOffset = 0; 
            for (i = 0; i < names.size(); i++)
            {
                os << "    " << names[i].c_str() << " = ";
                if (values.size() > names.size())
                {
                    int stride = values.size() / names.size();
                    os << "(";
                    for (j = 0; j < stride; j++) 
                    {
                        os << values[i*stride + j] << ", " ;
                    }
                    os << ")\n";
                }
                else if (values.size() == names.size())
                {
                    os << values[i] << "\n" ;
                }
                if (mixVar)
                {
                    nMats = numMatsPerZone[i]; 
                    for (j = 0; j < nMats; j++)
                    {
                        os << "        " << mixNames[j+mixOffset].c_str();
                        os << " = " <<  mixValues[j+mixOffset] << "\n";
                    }
                    mixOffset += nMats;
                }
            }
        }
        else
        {
            mixOffset = 0; 
            for (i = 0; i < numMatsPerZone.size(); i++)
            {
                if (names.size() > 0)
                    os << "    " << names[i].c_str() << "\n";
                nMats = numMatsPerZone[i];
                for (j = 0; j < nMats; j++)
                {
                    if (names.size() > 0)
                        os << "    "; 
                    os << "    " << mixNames[j+mixOffset].c_str();
                    if (mixValues[j+mixOffset] < 1.)
                        os << " = " << mixValues[j+mixOffset];
                    os << "\n";
                }
                mixOffset += nMats;
            }
        }
    }
    else if (!miscMessage.empty())
    {
        os << "    " << miscMessage.c_str() << "\n";
    }
    else
    {
        os << "    No Information Found\n";
    }
}

Function: CreateOutputString
Declaration: void CreateOutputString(std::string &os);
Definition:
// ****************************************************************************
// Method: PickVarInfo::CreateOutputString
//
// Purpose: 
//   Creates a single output string containing all the information gathered 
//   from a pick.
//
// Modifications:
//   Kathleen Bonnell, Thu Jun 26 09:31:56 PDT 2003
//   Logic changed in order to support node picking. Info from material vars 
//   now handled differently. 
//   
// ****************************************************************************
void
PickVarInfo::CreateOutputString(std::string &os)
{
    int i, j;
    int mixOffset = 0;
    int nMats;
    char buff[256];
    os = variableName;
    os +=  ":  ";
    switch (centering)
    {
        case Nodal:  os += "<nodal>\n" ; break;
        case Zonal:  os += "<zonal>\n" ; break;
        case None :  os += "\n";         break;
    }
    if (!(names.empty() && mixNames.empty()))
    {  
        if (!varIsMaterial)
        {
            mixOffset  = 0;
            for (i = 0; i < names.size(); i++)
            {
                SNPRINTF(buff, 256, "    %s ", names[i].c_str());
                os += buff;
                if (values.size() > names.size())
                {
                    int stride = values.size() / names.size();
                    SNPRINTF(buff, 256, "= (%g", values[i*stride]);
                    os += buff;
                    for (int j = 1; j < stride-1; j++) 
                    {
                        SNPRINTF(buff, 256, ",%g", values[i*stride+j]);
                        os += buff;
                    }
                    SNPRINTF(buff, 256, ") mag = %g\n", values[i*stride+stride-1]);
                    os += buff; 
                }
                else if (values.size() == names.size())
                {
                    SNPRINTF(buff, 256, "= %g\n", values[i]);
                    os += buff;
                }
                else 
                {
                    os += "\n";
                }
                if (mixVar)
                {
                    nMats = numMatsPerZone[i];
                    for (j = 0; j < nMats; j++)
                    {
                        SNPRINTF(buff, 256, "        material %s = ", 
                                 mixNames[j+mixOffset].c_str());
                        os += buff;
                        SNPRINTF(buff, 256, "%g\n", mixValues[j+mixOffset]);
                        os += buff;
                    }
                    mixOffset += nMats;
                }
            }
        }
        else
        {
            mixOffset  = 0;
            std::string spacing;
            for (i = 0; i < numMatsPerZone.size(); i++)
            {
                if (names.size() > 0)
                {
                    SNPRINTF(buff, 256, "    %s\n", names[i].c_str());
                    os += buff; 
                    spacing = "        ";
                }
                else
                    spacing = "    ";
                nMats = numMatsPerZone[i];
                for (j = 0; j < nMats; j++)
                {
                    SNPRINTF(buff, 256, "%s%s ", spacing.c_str(), 
                             mixNames[j+mixOffset].c_str());
                    os += buff;
                    if (mixValues[j+mixOffset] < 1.)
                    {
                        SNPRINTF(buff, 256, "= %g", mixValues[j+mixOffset]);
                        os += buff;
                    }
                    os += "\n";
                }
                mixOffset += nMats;
            }
        }
    }
    else if (!miscMessage.empty())
    {
        SNPRINTF(buff, 256, "    %s\n", miscMessage.c_str());
        os += buff;
    }
    else
    {
        SNPRINTF(buff, 256, "    No Information Found\n"); 
        os += buff;
    }
}

Function: CreateOutputStrings
Declaration: void CreateOutputStrings(std::vector<std::string> &os);
Definition:
// ****************************************************************************
// Method: PickVarInfo::CreateOutputStrings
//
// Purpose: 
//   Creates output strings containing all the info gathered from a pick.
//   Designed for display in the gui PickWindow -- creates a single string for
//   every line to be displayed.
//
// Modifications:
//   Kathleen Bonnell, Thu Jun 26 09:31:56 PDT 2003
//   Logic changed in order to support node picking. Info from material vars 
//   now handled differently. 
//   
// ****************************************************************************

void
PickVarInfo::CreateOutputStrings(std::vector<std::string> &os)
{
    int i, j;
    int mixOffset, nMats;
    char buff[256];
    char buf2[256];
    switch (centering)
    {
        case Nodal:  SNPRINTF(buff, 256, "%s: <nodal>", variableName.c_str()); 
                     os.push_back(buff);
                     break;
        case Zonal:  SNPRINTF(buff, 256, "%s: <zonal>", variableName.c_str()); 
                     os.push_back(buff);
                     break;
        case None :  SNPRINTF(buff, 256, "%s: ", variableName.c_str()); 
                     os.push_back(buff);
                     break;
    }
    if (!(names.empty() && mixNames.empty()))
    {  
        if (!varIsMaterial)
        {
            mixOffset = 0;
            for (i = 0; i < names.size(); i++)
            {
                SNPRINTF(buff, 256, "    %s ", names[i].c_str());
                // Vectors?
                if (values.size() > names.size())
                {
                    int stride = values.size() / names.size();
                    SNPRINTF(buf2, 256, "= (%g", values[i*stride]);
                    strcat(buff, buf2);
                    for (int j = 1; j < stride-1; j++) 
                    {
                        SNPRINTF(buf2, 256, ", %g", values[i*stride+j]);
                        strcat(buff, buf2);
                    }
                    SNPRINTF(buf2, 256, ") mag = %g", values[i*stride+stride-1]);
                    strcat(buff,  buf2);
                }
                // Scalars?
                else if (values.size() == names.size())
                {
                    SNPRINTF(buf2, 256, "= %g", values[i]);
                    strcat(buff, buf2);
                }
                os.push_back(buff);
                if (mixVar)
                {
                    nMats = numMatsPerZone[i];
                    for (j = 0; j < nMats; j++)
                    {
                        SNPRINTF(buff, 256, "        material %s = %g", 
                                 mixNames[j+mixOffset].c_str(), 
                                 mixValues[j+mixOffset]);
                        os.push_back(buff);
                    }
                    mixOffset += nMats;
                }
            }
        }
        else 
        {
            mixOffset = 0; 
            char spaces[8];
            for (i = 0; i < numMatsPerZone.size(); i++)
            {
                if (names.size() > 0)
                {
                    SNPRINTF(buff, 256, "    %s ", names[i].c_str());
                    os.push_back(buff);
                    SNPRINTF(spaces, 8, "        "); 
                }
                else
                    SNPRINTF(spaces, 8, "    "); 
                nMats = numMatsPerZone[i];
                for (j = 0; j < nMats; j++)
                {
                    if (mixValues[j+mixOffset] < 1.)
                    {
                        SNPRINTF(buff, 256, "%s%s = %g", spaces, 
                                 mixNames[j+mixOffset].c_str(), 
                                 mixValues[j+mixOffset]);
                    }
                    else
                    {
                        SNPRINTF(buff, 256, "%s%s", spaces,
                                 mixNames[j+mixOffset].c_str());
                    }
                    os.push_back(buff);
                } 
                mixOffset += nMats;
            }
        } 
    } 
    else if (!miscMessage.empty())
    {
        SNPRINTF(buff, 256, "    %s", miscMessage.c_str());
        os.push_back(buff);
    }
    else   
    {
        SNPRINTF(buff, 256, "    No Information Found");
        os.push_back(buff);
    }
}


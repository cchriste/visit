Function: PrintSelf
Declaration: void PrintSelf(ostream &os);
Definition:
// ****************************************************************************
// Method: PickVarInfo::PrintSelf
//
// Purpose: 
//   Prints the contents of this class to the passed stream. 
//
// Modifications:
//   Kathleen Bonnell, Thu Jun 26 09:31:56 PDT 2003
//   Logic changed in order to support node picking. Info from material var's 
//   now handled differently. 
//   
// ****************************************************************************

void
PickVarInfo::PrintSelf(ostream &os)
{
    int i, j, nMats, mixOffset;
    os << variableName.c_str() << ":  ";
    switch (centering)
    {
        case Nodal:  os << "nodal " ; break;
        case Zonal:  os << "zonal " ; break;
        case None : break;
    }
    if (!(names.empty() && mixNames.empty()))
    {  
        if (!varIsMaterial)
        {
            mixOffset = 0; 
            for (i = 0; i < names.size(); i++)
            {
                os << "    " << names[i].c_str() << " = ";
                if (values.size() > names.size())
                {
                    int stride = values.size() / names.size();
                    os << "(";
                    for (j = 0; j < stride; j++)
                    {
                        os << values[i*stride + j] << ", " ;
                    }
                    os << ")\n";
                }
                else if (values.size() == names.size())
                {
                    os << values[i] << "\n" ;
                }
                if (mixVar)
                {
                    nMats = numMatsPerZone[i]; 
                    for (j = 0; j < nMats; j++)
                    {
                        os << "        " << mixNames[j+mixOffset].c_str();
                        os << " = " <<  mixValues[j+mixOffset] << "\n";
                    }
                    mixOffset += nMats;
                }
            }
        }
        else
        {
            mixOffset = 0; 
            for (i = 0; i < numMatsPerZone.size(); i++)
            {
                if (names.size() > 0)
                    os << "    " << names[i].c_str() << "\n";
                nMats = numMatsPerZone[i];
                for (j = 0; j < nMats; j++)
                {
                    if (names.size() > 0)
                        os << "    "; 
                    os << "    " << mixNames[j+mixOffset].c_str();
                    if (mixValues[j+mixOffset] < 1.)
                        os << " = " << mixValues[j+mixOffset];
                    os << "\n";
                }
                mixOffset += nMats;
            }
        }
    }
    else if (!miscMessage.empty())
    {
        os << "    " << miscMessage.c_str() << "\n";
    }
    else
    {
        os << "    No Information Found\n";
    }
}

Function: PrintTensor
Declaration: void PrintTensor(std::string &, const std::vector<double> &, int, int, int);
Definition:

// ****************************************************************************
// Method: PickVarInfo::PrintTensor
//
// Purpose: 
//     Prints the information out for a tensor.
//
// Programmer: Hank Childs
// Creation:   September 22, 2003
// ****************************************************************************

void
PickVarInfo::PrintTensor(std::string &os, const std::vector<double> &values,
                         int tuple, int ncomps, int buff_len)
{
    int  j;

    int offset = tuple*ncomps;
    if (ncomps == 2)  // 2D tensor
    {
        char line[256];
        sprintf(line, "(%g, %g)\n", values[offset], values[offset+1]);
        os += line;
        for (j = 0 ; j < buff_len ; j++)
            os += " ";
        sprintf(line, "(%g, %g)\n", values[offset+2], values[offset+3]);
        os += line;
    }
    else if (ncomps == 9) // 3D tensor
    {
        char line[256];
        sprintf(line, "(%g, %g, %g)\n", values[offset], values[offset+1],
                                        values[offset+2]);
        os += line;
        for (j = 0 ; j < buff_len ; j++)
            os += " ";

        sprintf(line, "(%g, %g, %g)\n", values[offset+3], values[offset+4],
                                        values[offset+5]);
        os += line;
        for (j = 0 ; j < buff_len ; j++)
            os += " ";

        sprintf(line, "(%g, %g, %g)\n", values[offset+6], values[offset+7],
                                        values[offset+8]);
        os += line;
    }
}

Function: PrintSymmetricTensor
Declaration: void PrintSymmetricTensor(std::string &, const std::vector<double> &, int, int, int);
Definition:

// ****************************************************************************
// Method: PickVarInfo::PrintSymmetricTensor
//
// Purpose: 
//     Prints the information out for a tensor.
//
// Programmer: Hank Childs
// Creation:   September 22, 2003
// ****************************************************************************

void
PickVarInfo::PrintSymmetricTensor(std::string &os,
         const std::vector<double> &values, int tuple, int ncomps, int buff_len)
{
    int  j;

    int offset = tuple*ncomps;
    if (ncomps == 2)  // 2D tensor
    {
        char line[256];
        sprintf(line, "(%g, %g)\n", values[offset], values[offset+1]);
        os += line;
        for (j = 0 ; j < buff_len ; j++)
            os += " ";
        sprintf(line, "(%g, %g)\n", values[offset+2], values[offset+3]);
        os += line;
    }
    else if (ncomps == 9) // 3D tensor
    {
        char line[256];
        sprintf(line, "(%g, %g, %g)\n", values[offset], values[offset+1],
                                        values[offset+2]);
        os += line;
        for (j = 0 ; j < buff_len ; j++)
            os += " ";

        sprintf(line, "(%g, %g, %g)\n", values[offset+3], values[offset+4],
                                        values[offset+5]);
        os += line;
        for (j = 0 ; j < buff_len ; j++)
            os += " ";

        sprintf(line, "(%g, %g, %g)\n", values[offset+6], values[offset+7],
                                        values[offset+8]);
        os += line;
    }
}


Function: CreateOutputString
Declaration: void CreateOutputString(std::string &os);
Definition:

// ****************************************************************************
// Method: PickVarInfo::CreateOutputString
//
// Purpose: 
//   Creates a single output string containing all the information gathered 
//   from a pick.
//
// Modifications:
//   Kathleen Bonnell, Thu Jun 26 09:31:56 PDT 2003
//   Logic changed in order to support node picking. Info from material vars 
//   now handled differently. 
//   
//   Hank Childs, Mon Sep 22 11:19:22 PDT 2003
//   Extend for tensors.
//
// ****************************************************************************
void
PickVarInfo::CreateOutputString(std::string &os)
{
    int i, j;
    int mixOffset = 0;
    int nMats;
    char buff[256];
    os = variableName;
    os +=  ":  ";
    switch (centering)
    {
        case Nodal:  os += "<nodal>\n" ; break;
        case Zonal:  os += "<zonal>\n" ; break;
        case None :  os += "\n";         break;
    }
    if (!(names.empty() && mixNames.empty()))
    {  
        if (!varIsMaterial)
        {
            mixOffset  = 0;
            for (i = 0; i < names.size(); i++)
            {
                SNPRINTF(buff, 256, "    %s ", names[i].c_str());
                os += buff;
                if (variableType == "vector")
                {
                    int stride = values.size() / names.size();
                    SNPRINTF(buff, 256, "= (%g", values[i*stride]);
                    os += buff;
                    for (int j = 1; j < stride-1; j++) 
                    {
                        SNPRINTF(buff, 256, ",%g", values[i*stride+j]);
                        os += buff;
                    }
                    SNPRINTF(buff, 256, ") mag = %g\n", values[i*stride+stride-1]);
                    os += buff; 
                }
                else if (variableType == "scalar")
                {
                    SNPRINTF(buff, 256, "= %g\n", values[i]);
                    os += buff;
                }
                else if (variableType == "tensor")
                {
                    int buf_len = strlen(buff);
                    int ncomps = values.size() / names.size();
                    PrintTensor(os, values, i, ncomps, buf_len);
                }
                else if (variableType == "symm_tensor")
                {
                    int buf_len = strlen(buff);
                    int ncomps = values.size() / names.size();
                    PrintSymmetricTensor(os, values, i, ncomps, buf_len);
                }
                else 
                {
                    os += "\n";
                }
                if (mixVar)
                {
                    nMats = numMatsPerZone[i];
                    for (j = 0; j < nMats; j++)
                    {
                        SNPRINTF(buff, 256, "        material %s = ", 
                                 mixNames[j+mixOffset].c_str());
                        os += buff;
                        SNPRINTF(buff, 256, "%g\n", mixValues[j+mixOffset]);
                        os += buff;
                    }
                    mixOffset += nMats;
                }
            }
        }
        else
        {
            mixOffset  = 0;
            std::string spacing;
            for (i = 0; i < numMatsPerZone.size(); i++)
            {
                if (names.size() > 0)
                {
                    SNPRINTF(buff, 256, "    %s\n", names[i].c_str());
                    os += buff; 
                    spacing = "        ";
                }
                else
                    spacing = "    ";
                nMats = numMatsPerZone[i];
                for (j = 0; j < nMats; j++)
                {
                    SNPRINTF(buff, 256, "%s%s ", spacing.c_str(), 
                             mixNames[j+mixOffset].c_str());
                    os += buff;
                    if (mixValues[j+mixOffset] < 1.)
                    {
                        SNPRINTF(buff, 256, "= %g", mixValues[j+mixOffset]);
                        os += buff;
                    }
                    os += "\n";
                }
                mixOffset += nMats;
            }
        }
    }
    else if (!miscMessage.empty())
    {
        SNPRINTF(buff, 256, "    %s\n", miscMessage.c_str());
        os += buff;
    }
    else
    {
        SNPRINTF(buff, 256, "    No Information Found\n"); 
        os += buff;
    }
}

Function: CreateOutputStrings
Declaration: void CreateOutputStrings(std::vector<std::string> &os);
Definition:
// ****************************************************************************
// Method: PickVarInfo::CreateOutputStrings
//
// Purpose: 
//   Creates output strings containing all the info gathered from a pick.
//   Designed for display in the gui PickWindow -- creates a single string for
//   every line to be displayed.
//
// Modifications:
//   Kathleen Bonnell, Thu Jun 26 09:31:56 PDT 2003
//   Logic changed in order to support node picking. Info from material vars 
//   now handled differently. 
//   
//   Hank Childs, Mon Sep 22 11:19:22 PDT 2003
//   Extend for tensors.
//
// ****************************************************************************

void
PickVarInfo::CreateOutputStrings(std::vector<std::string> &os)
{
    int i, j;
    int mixOffset, nMats;
    char buff[256];
    char buf2[256];
    switch (centering)
    {
        case Nodal:  SNPRINTF(buff, 256, "%s: <nodal>", variableName.c_str()); 
                     os.push_back(buff);
                     break;
        case Zonal:  SNPRINTF(buff, 256, "%s: <zonal>", variableName.c_str()); 
                     os.push_back(buff);
                     break;
        case None :  SNPRINTF(buff, 256, "%s: ", variableName.c_str()); 
                     os.push_back(buff);
                     break;
    }
    if (!(names.empty() && mixNames.empty()))
    {  
        if (!varIsMaterial)
        {
            mixOffset = 0;
            for (i = 0; i < names.size(); i++)
            {
                SNPRINTF(buff, 256, "    %s ", names[i].c_str());
                if (variableType == "vector")
                {
                    int stride = values.size() / names.size();
                    SNPRINTF(buf2, 256, "= (%g", values[i*stride]);
                    strcat(buff, buf2);
                    for (int j = 1; j < stride-1; j++) 
                    {
                        SNPRINTF(buf2, 256, ", %g", values[i*stride+j]);
                        strcat(buff, buf2);
                    }
                    SNPRINTF(buf2, 256, ") mag = %g", 
                                                    values[i*stride+stride-1]);
                    strcat(buff,  buf2);
                }
                else if (variableType == "scalar")
                {
                    SNPRINTF(buf2, 256, "= %g", values[i]);
                    strcat(buff, buf2);
                }
                else if (variableType == "tensor")
                {
                    std::string tmp;
                    int buf_len = strlen(buff);
                    int ncomps = values.size() / names.size();
                    PrintTensor(tmp, values, i, ncomps, buf_len);
                    strcat(buff, tmp.c_str());
                }
                else if (variableType == "symm_tensor")
                {
                    std::string tmp;
                    int buf_len = strlen(buff);
                    int ncomps = values.size() / names.size();
                    PrintSymmetricTensor(tmp, values, i, ncomps, buf_len);
                    strcat(buff, tmp.c_str());
                }
                os.push_back(buff);
                if (mixVar)
                {
                    nMats = numMatsPerZone[i];
                    for (j = 0; j < nMats; j++)
                    {
                        SNPRINTF(buff, 256, "        material %s = %g", 
                                 mixNames[j+mixOffset].c_str(), 
                                 mixValues[j+mixOffset]);
                        os.push_back(buff);
                    }
                    mixOffset += nMats;
                }
            }
        }
        else 
        {
            mixOffset = 0; 
            char spaces[8];
            for (i = 0; i < numMatsPerZone.size(); i++)
            {
                if (names.size() > 0)
                {
                    SNPRINTF(buff, 256, "    %s ", names[i].c_str());
                    os.push_back(buff);
                    SNPRINTF(spaces, 8, "        "); 
                }
                else
                    SNPRINTF(spaces, 8, "    "); 
                nMats = numMatsPerZone[i];
                for (j = 0; j < nMats; j++)
                {
                    if (mixValues[j+mixOffset] < 1.)
                    {
                        SNPRINTF(buff, 256, "%s%s = %g", spaces, 
                                 mixNames[j+mixOffset].c_str(), 
                                 mixValues[j+mixOffset]);
                    }
                    else
                    {
                        SNPRINTF(buff, 256, "%s%s", spaces,
                                 mixNames[j+mixOffset].c_str());
                    }
                    os.push_back(buff);
                } 
                mixOffset += nMats;
            }
        } 
    } 
    else if (!miscMessage.empty())
    {
        SNPRINTF(buff, 256, "    %s", miscMessage.c_str());
        os.push_back(buff);
    }
    else   
    {
        SNPRINTF(buff, 256, "    No Information Found");
        os.push_back(buff);
    }
}


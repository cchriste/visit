/*****************************************************************************
*
* Copyright (c) 2000 - 2014, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

#include <SocketConnection.h>
#include <visit-config.h>
#if defined(_WIN32)
#include <winsock2.h>
#include <win32commhelpers.h>
#else
#include <strings.h>             // bzero by way of FD_ZERO
#include <sys/socket.h>
#include <sys/time.h>
#include <unistd.h>
#include <signal.h>
#endif
#ifdef HAVE_SELECT
#include <SysCall.h>
#endif
#include <LostConnectionException.h>
#include <AttributeSubject.h>
#include <MapNode.h>
#include <JSONNode.h>

#include <cstdlib>

// ****************************************************************************
// Method: SocketConnection::SocketConnection
//
// Purpose: 
//   Constructor for the SocketConnection class.
//
// Arguments:
//   _descriptor : The file descriptor of the socket we want to use.
//
// Programmer: Brad Whitlock
// Creation:   Tue Aug 29 12:16:31 PDT 2000
//
// Modifications:
//   Brad Whitlock, Mon Mar 25 12:33:03 PDT 2002
//   Initialized the zeroesRead member.
//
// ****************************************************************************

SocketConnection::SocketConnection(DESCRIPTOR descriptor_) : buffer()
{
    descriptor = descriptor_;
    zeroesRead = 0;
}

// ****************************************************************************
// Method: SocketConnection::~SocketConnection
//
// Purpose: 
//   Destructor for the SocketConnection class.
//
// Programmer: Brad Whitlock
// Creation:   Tue Aug 29 12:17:12 PDT 2000
//
// Modifications:
//   Brad Whitlock, Fri Mar 22 17:07:16 PST 2002
//   Made it close the socket.
//
// ****************************************************************************

SocketConnection::~SocketConnection()
{
#if defined(_WIN32)
     closesocket(descriptor);
#else
     close(descriptor);
#endif
}

// ****************************************************************************
// Method: SocketConnection::GetDescriptor
//
// Purpose: 
//   Returns the socket descriptor.
//
// Programmer: Brad Whitlock
// Creation:   Thu Oct 5 18:30:32 PST 2000
//
// Modifications:
//   
// ****************************************************************************

int
SocketConnection::GetDescriptor() const
{
    return int(descriptor);
}

long
SocketConnection::ReadHeader(unsigned char *buf, long len)
{
    return DirectRead(buf,len);
}

long
SocketConnection::WriteHeader(const unsigned char *buf, long len)
{
    return DirectWrite(buf,len);
}

// ****************************************************************************
// Method: SocketConnection::Fill
//
// Purpose: 
//   Tries to fill up the connection with new data.
//
// Returns:    The number of bytes read.
//
// Programmer: Brad Whitlock
// Creation:   Wed Mar 20 17:28:27 PST 2002
//
// Modifications:
//   
// ****************************************************************************


int
SocketConnection::Fill()
{
    if(destFormat.Format == TypeRepresentation::ASCIIFORMAT)
    {
        std::string xmlString = "";

        char tmp[1001]; //leave 1 for null termination//

        int amountRead = 0;
        do
        {

#if defined(_WIN32)
            int amountRead = recv(descriptor, (char FAR *)tmp, 1000, 0);
            if(amountRead == SOCKET_ERROR)
            {
                LogWindowsSocketError("SocketConnection", "Fill");
                if(WSAGetLastError() == WSAEWOULDBLOCK)
                    return -1;
            }
#else
            amountRead = recv(descriptor, (void *)tmp, 1000, 0);
#endif

            if(amountRead > 0)
            {
                zeroesRead = 0;
                tmp[amountRead] = 0;
                xmlString += tmp;
            }

            ++zeroesRead;

            // If we have had a certain number of zero length reads in a row,
            // assume the connection died.
            if(zeroesRead > 100)
            {
                 EXCEPTION0(LostConnectionException);
            }
        }while(amountRead == 1000); //if it gets entire list..
        if(xmlString.size() > 0)
        {
            JSONNode node;
            node.Parse(xmlString);

            //std::cout << node.ToString() << std::endl;

            int guido = node["id"].GetInt();

            JSONNode contents = node["contents"];
            JSONNode metadata = node["metadata"];

            /// With the information I have I could probably
            /// just use JSONNode to convert completely..
            /// but that would leave MapNode incomplete..

            //MapNode mapnode(contents, metadata, false);

            //std::cout << mapnode.ToXML(false) << std::endl;
            //std::cout << metadata["data"] << std::endl;

            buffer.clear();
            return Write(guido, contents, metadata); //Write(guido,&mapnode); //,&metadata["data"]
        }

        return 0;
    }

    unsigned char tmp[1000];
#if defined(_WIN32)
    int amountRead = recv(descriptor, (char FAR *)tmp, 1000, 0);
    if(amountRead == SOCKET_ERROR)
    {
        LogWindowsSocketError("SocketConnection", "Fill");
        if(WSAGetLastError() == WSAEWOULDBLOCK)
            return -1;
    }
#else
    int amountRead = recv(descriptor, (void *)tmp, 1000, 0);
#endif

    if(amountRead > 0)
    {
        zeroesRead = 0;

        // Add the new bytes to the buffer.
        for(int i = 0; i < amountRead; ++i)
            buffer.push_back(tmp[i]);
    }
    else
        ++zeroesRead;

    // If we have had a certain number of zero length reads in a row,
    // assume the connection died.
    if(zeroesRead > 100)
    {
         EXCEPTION0(LostConnectionException);
    }

    return amountRead;
}


int
SocketConnection::Write(int id,MapNode *mapnode)
{
    size_t fillSize = 0;

    //std::cout << key << " " << id << std::endl;
    int totalSize = 0;
    int totalLen = 0;

    WriteToBuffer(mapnode,false,id,totalLen,totalSize);

    int attrSize = (totalLen < 256) ?   srcFormat.CharSize():
                                        srcFormat.IntSize();

    totalSize += attrSize;
    totalSize += (totalLen*attrSize);

    //std::cout << "TotalSize: " << id << " " << totalLen << " " << totalSize << std::endl;

    /// actual write
    WriteInt(id);
    WriteInt(totalSize);
    totalLen < 256 ? WriteUnsignedChar((unsigned char)totalLen) : WriteInt(totalLen);

    WriteToBuffer(mapnode,true,id,totalLen,totalSize);

    /// fileSize is Size of message + 2 ints
    fillSize += totalSize + (srcFormat.IntSize()*2);

    return fillSize;
}

void
SocketConnection::WriteToBuffer(MapNode *mapnode,
                                bool write,
                                int id,
                                int& totalLen,
                                int &totalSize)
{
    /// loop through mapnode
    /// don't do anything for pure mapnode structures..
    if(mapnode->Type() != 0)
    {
        if(write)
            (totalLen < 256)? WriteUnsignedChar((unsigned char)id) : WriteInt(id);
        else
             ++totalLen;

        if(mapnode->Type() == MapNode::BOOL_TYPE)
        {
            if(write)
                WriteChar( mapnode->AsBool()? 1 : 0);
            else
                totalSize += srcFormat.CharSize();
        }
        else if(mapnode->Type() == MapNode::CHAR_TYPE)
        {
            if(write)
                WriteChar( mapnode->AsChar() );
            else
                totalSize += srcFormat.CharSize();
        }
        else if(mapnode->Type() == MapNode::UNSIGNED_CHAR_TYPE)
        {
            if(write)
                WriteUnsignedChar( mapnode->AsUnsignedChar() );
            else
                totalSize += srcFormat.CharSize();
        }
        else if(mapnode->Type() == MapNode::INT_TYPE)
        {
            if(write)
                WriteInt( mapnode->AsInt() );
            else
                totalSize += srcFormat.IntSize();
        }
        else if(mapnode->Type() == MapNode::FLOAT_TYPE)
        {
            if(write)
                WriteFloat( mapnode->AsFloat() );
            else
                totalSize += srcFormat.FloatSize();
        }
        else if(mapnode->Type() == MapNode::DOUBLE_TYPE)
        {
            if(write)
                WriteDouble( mapnode->AsDouble() );
            else
                totalSize += srcFormat.DoubleSize();
        }
        else if(mapnode->Type() == MapNode::LONG_TYPE)
        {
            if(write)
                WriteLong( mapnode->AsLong() );
            else
                totalSize += srcFormat.LongSize();
        }
        else if(mapnode->Type() == MapNode::STRING_TYPE)
        {
            if(write)
                WriteString( mapnode->AsString() );
            else
                totalSize += srcFormat.CharSize()*(mapnode->AsString().size() + 1);
        }
        else if(mapnode->Type() == MapNode::BOOL_VECTOR_TYPE)
        {
            const boolVector& vec = mapnode->AsBoolVector();

//            if(vec.size() > 0)
            {
                if(write)
                {
                    WriteInt((int)vec.size());
                    for(size_t i = 0; i < vec.size(); ++i)
                        WriteChar( vec[i]? 1 : 0);
                }
                else
                {
                    //std::cout << mapnode->TypeName() << " " << str << std::endl;
                    totalSize += srcFormat.IntSize();
                    totalSize += (vec.size()*srcFormat.CharSize());
                }
            }
        }
        else if(mapnode->Type() == MapNode::CHAR_VECTOR_TYPE)
        {
            const charVector& vec = mapnode->AsCharVector();

//            if(vec.size() > 0)
            {
                if(write)
                {
                    WriteInt((int)vec.size());
                    for(size_t i = 0; i < vec.size(); ++i)
                        WriteChar( vec[i] );
                }
                else
                {
                    //std::cout << mapnode->TypeName() << " " << str << std::endl;
                    totalSize += srcFormat.IntSize();
                    totalSize += (vec.size()*srcFormat.CharSize());
                }
            }
        }
        else if(mapnode->Type() == MapNode::UNSIGNED_CHAR_VECTOR_TYPE)
        {
            const unsignedCharVector& vec = mapnode->AsUnsignedCharVector();

//            if(vec.size() > 0)
            {
                if(write)
                {
                    WriteInt((int)vec.size());
                    for(size_t i = 0; i < vec.size(); ++i)
                        WriteUnsignedChar( vec[i] );
                }
                else
                {
                    //std::cout << mapnode->TypeName() << " " << str << std::endl;
                    totalSize += srcFormat.IntSize();
                    totalSize += (vec.size()*srcFormat.CharSize());
                }
            }
        }
        else if(mapnode->Type() == MapNode::INT_VECTOR_TYPE)
        {
            const intVector& vec = mapnode->AsIntVector();

//            if(vec.size() > 0)
            {
                if(write)
                {
                    WriteInt((int)vec.size());
                    for(size_t i = 0; i < vec.size(); ++i)
                        WriteInt( vec[i] );
                }
                else
                {
                    //std::cout << mapnode->TypeName() << " " << str << std::endl;
                    totalSize += srcFormat.IntSize();
                    totalSize += (vec.size()*srcFormat.IntSize());
                }
            }
        }
        else if(mapnode->Type() == MapNode::FLOAT_VECTOR_TYPE)
        {
            const floatVector& vec = mapnode->AsFloatVector();

//            if(vec.size() > 0)
            {
                if(write)
                {
                    WriteInt((int)vec.size());
                    for(size_t i = 0; i < vec.size(); ++i)
                        WriteFloat( vec[i] );
                }
                else
                {
                    //std::cout << mapnode->TypeName() << " " << str << std::endl;
                    totalSize += srcFormat.IntSize();
                    totalSize += (vec.size()*srcFormat.FloatSize());
                }
            }
        }
        else if(mapnode->Type() == MapNode::DOUBLE_VECTOR_TYPE)
        {
            const doubleVector& vec = mapnode->AsDoubleVector();

//            if(vec.size() > 0)
            {
                if(write)
                {
                    WriteInt((int)vec.size());
                    for(size_t i = 0; i < vec.size(); ++i)
                        WriteDouble( vec[i] );
                }
                else
                {
                    //std::cout << mapnode->TypeName() << " " << str << std::endl;
                    totalSize += srcFormat.IntSize();
                    totalSize += (vec.size()*srcFormat.DoubleSize());
                }
            }
        }
        else if(mapnode->Type() == MapNode::LONG_VECTOR_TYPE)
        {
            const longVector& vec = mapnode->AsLongVector();

//            if(vec.size() > 0)
            {
                if(write)
                {
                    WriteInt((int)vec.size());
                    for(size_t i = 0; i < vec.size(); ++i)
                        WriteLong( vec[i] );
                }
                else
                {
                    //std::cout << mapnode->TypeName() << " " << str << std::endl;
                    totalSize += srcFormat.IntSize();
                    totalSize += (vec.size()*srcFormat.LongSize());
                }
            }
        }
        else if(mapnode->Type() == MapNode::STRING_VECTOR_TYPE)
        {
            const stringVector& vec = mapnode->AsStringVector();
            //std::cout << "String vector type : " << vec.size() << std::endl;
            //if(vec.size() > 0)
            {
                if(write)
                {
                    WriteInt((int)vec.size());
                    for(size_t i = 0; i < vec.size(); ++i)
                        WriteString( vec[i] );
                }
                else
                {
                    //std::cout << mapnode->TypeName() << " " << str << std::endl;
                    totalSize += srcFormat.IntSize();
                    for(size_t i = 0; i < vec.size(); ++i)
                        totalSize += (vec[i].size() + 1)*srcFormat.CharSize();
                }
            }
        }
        else
        {
            std::cout << "not handled: "
                      << mapnode->TypeName()
                      << std::endl;
        }
    }

    stringVector names;
    mapnode->GetEntryNames(names);
    for(size_t i = 0; i < names.size(); ++i)
    {
        //std::cout << "** " << names[i] << std::endl;
        std::string& name = names[i];
        MapNode* mc = mapnode->GetEntry(names[i]);

        if(mc->Type() == 0)
        {
            WriteToBuffer(mc,write,0,totalLen,totalSize);
        }
        else
        {
            int id = atoi(name.c_str());//data->operator [](name).GetInt();
            WriteToBuffer(mc,write,id,totalLen,totalSize);
        }
    }
}

int
SocketConnection::Write(int id, JSONNode& node, JSONNode& metadata)
{
    size_t fillSize = 0;

    //std::cout << key << " " << id << std::endl;
    int totalSize = 0;
    int totalLen = 0;

    WriteToBuffer(node,metadata,false,id,totalLen,totalSize);

    int attrSize = (totalLen < 256) ?   srcFormat.CharSize():
                                        srcFormat.IntSize();

    totalSize += attrSize;
    totalSize += (totalLen*attrSize);

    //std::cout << "TotalSize: " << id << " " << totalLen << " " << totalSize << std::endl;

    /// actual write
    WriteInt(id);
    WriteInt(totalSize);
    totalLen < 256 ? WriteUnsignedChar((unsigned char)totalLen) : WriteInt(totalLen);

    WriteToBuffer(node,metadata,true,id,totalLen,totalSize);

    /// fileSize is Size of message + 2 ints
    fillSize += totalSize + (srcFormat.IntSize()*2);

    return fillSize;
}

void
SocketConnection::WriteToBuffer(const JSONNode &node,
                                const JSONNode &metadata,
                                bool write,
                                int id,
                                int& totalLen,
                                int &totalSize)
{
    int data_type = 0;

    if(metadata.GetType() == JSONNode::JSONINTEGER){
        data_type = metadata.GetInt();
    }
//    else
//    {
////        const std::string name = metadata.GetString();

////        data_type = isdigit(name[0]) ? atoi(name.c_str()) :
////                                       Variant::NameToTypeID(name);
//        //std::cerr << "entry not handled" << std::endl;
//        //return;
//    }

    /// loop through mapnode
    /// don't do anything for pure mapnode structures..
    if(data_type != 0)
    {
        if(data_type == MapNode::MapNodeType)
            return; /// Does not handle mapnode yet..

        if(write)
            (totalLen < 256)? WriteUnsignedChar((unsigned char)id) : WriteInt(id);
        else
             ++totalLen;

        if(data_type == MapNode::BOOL_TYPE)
        {
            if(write)
                WriteChar( node.GetBool()? 1 : 0);
            else
                totalSize += srcFormat.CharSize();
        }
        else if(data_type == MapNode::CHAR_TYPE)
        {
            if(write)
                WriteChar( node.AsChar() );
            else
                totalSize += srcFormat.CharSize();
        }
        else if(data_type == MapNode::UNSIGNED_CHAR_TYPE)
        {
            if(write)
                WriteUnsignedChar( node.AsUnsignedChar() );
            else
                totalSize += srcFormat.CharSize();
        }
        else if(data_type == MapNode::INT_TYPE)
        {
            if(write)
                WriteInt( node.GetInt() );
            else
                totalSize += srcFormat.IntSize();
        }
        else if(data_type == MapNode::FLOAT_TYPE)
        {
            if(write)
                WriteFloat( node.GetFloat() );
            else
                totalSize += srcFormat.FloatSize();
        }
        else if(data_type == MapNode::DOUBLE_TYPE)
        {
            if(write)
                WriteDouble( node.GetDouble() );
            else
                totalSize += srcFormat.DoubleSize();
        }
        else if(data_type == MapNode::LONG_TYPE)
        {
            if(write)
                WriteLong( node.GetLong() );
            else
                totalSize += srcFormat.LongSize();
        }
        else if(data_type == MapNode::STRING_TYPE)
        {
            if(write)
                WriteString( node.GetString() );
            else
                totalSize += srcFormat.CharSize()*(node.GetString().size() + 1);
        }
        else if(data_type == MapNode::BOOL_VECTOR_TYPE)
        {
            const boolVector& vec = node.AsBoolVector();

//            if(vec.size() > 0)
            {
                if(write)
                {
                    WriteInt((int)vec.size());
                    for(size_t i = 0; i < vec.size(); ++i)
                        WriteChar( vec[i]? 1 : 0);
                }
                else
                {
                    //std::cout << mapnode->TypeName() << " " << str << std::endl;
                    totalSize += srcFormat.IntSize();
                    totalSize += (vec.size()*srcFormat.CharSize());
                }
            }
        }
        else if(data_type == MapNode::CHAR_VECTOR_TYPE)
        {
            const charVector& vec = node.AsCharVector();

//            if(vec.size() > 0)
            {
                if(write)
                {
                    WriteInt((int)vec.size());
                    for(size_t i = 0; i < vec.size(); ++i)
                        WriteChar( vec[i] );
                }
                else
                {
                    //std::cout << mapnode->TypeName() << " " << str << std::endl;
                    totalSize += srcFormat.IntSize();
                    totalSize += (vec.size()*srcFormat.CharSize());
                }
            }
        }
        else if(data_type == MapNode::UNSIGNED_CHAR_VECTOR_TYPE)
        {
            const unsignedCharVector& vec = node.AsUnsignedCharVector();

//            if(vec.size() > 0)
            {
                if(write)
                {
                    WriteInt((int)vec.size());
                    for(size_t i = 0; i < vec.size(); ++i)
                        WriteUnsignedChar( vec[i] );
                }
                else
                {
                    //std::cout << mapnode->TypeName() << " " << str << std::endl;
                    totalSize += srcFormat.IntSize();
                    totalSize += (vec.size()*srcFormat.CharSize());
                }
            }
        }
        else if(data_type == MapNode::INT_VECTOR_TYPE)
        {
            const intVector& vec = node.AsIntVector();

//            if(vec.size() > 0)
            {
                if(write)
                {
                    WriteInt((int)vec.size());
                    for(size_t i = 0; i < vec.size(); ++i)
                        WriteInt( vec[i] );
                }
                else
                {
                    //std::cout << mapnode->TypeName() << " " << str << std::endl;
                    totalSize += srcFormat.IntSize();
                    totalSize += (vec.size()*srcFormat.IntSize());
                }
            }
        }
        else if(data_type == MapNode::FLOAT_VECTOR_TYPE)
        {
            const floatVector& vec = node.AsFloatVector();

//            if(vec.size() > 0)
            {
                if(write)
                {
                    WriteInt((int)vec.size());
                    for(size_t i = 0; i < vec.size(); ++i)
                        WriteFloat( vec[i] );
                }
                else
                {
                    //std::cout << mapnode->TypeName() << " " << str << std::endl;
                    totalSize += srcFormat.IntSize();
                    totalSize += (vec.size()*srcFormat.FloatSize());
                }
            }
        }
        else if(data_type == MapNode::DOUBLE_VECTOR_TYPE)
        {
            const doubleVector& vec = node.AsDoubleVector();

//            if(vec.size() > 0)
            {
                if(write)
                {
                    WriteInt((int)vec.size());
                    for(size_t i = 0; i < vec.size(); ++i)
                        WriteDouble( vec[i] );
                }
                else
                {
                    //std::cout << mapnode->TypeName() << " " << str << std::endl;
                    totalSize += srcFormat.IntSize();
                    totalSize += (vec.size()*srcFormat.DoubleSize());
                }
            }
        }
        else if(data_type == MapNode::LONG_VECTOR_TYPE)
        {
            const longVector& vec = node.AsLongVector();

//            if(vec.size() > 0)
            {
                if(write)
                {
                    WriteInt((int)vec.size());
                    for(size_t i = 0; i < vec.size(); ++i)
                        WriteLong( vec[i] );
                }
                else
                {
                    //std::cout << mapnode->TypeName() << " " << str << std::endl;
                    totalSize += srcFormat.IntSize();
                    totalSize += (vec.size()*srcFormat.LongSize());
                }
            }
        }
        else if(data_type == MapNode::STRING_VECTOR_TYPE)
        {
            const stringVector& vec = node.AsStringVector();
            //std::cout << "String vector type : " << vec.size() << std::endl;
            //if(vec.size() > 0)
            {
                if(write)
                {
                    WriteInt((int)vec.size());
                    for(size_t i = 0; i < vec.size(); ++i)
                        WriteString( vec[i] );
                }
                else
                {
                    //std::cout << mapnode->TypeName() << " " << str << std::endl;
                    totalSize += srcFormat.IntSize();
                    for(size_t i = 0; i < vec.size(); ++i)
                        totalSize += (vec[i].size() + 1)*srcFormat.CharSize();
                }
            }
        }
        else if(data_type == MapNode::MapNodeType)
        {
            MapNode mapnode(node);

            if(write) {
                totalSize += mapnode.CalculateMessageSize(this);
            }
            else {
                mapnode.Write(this);
            }

            //WriteToBuffer(&mapnode, write, 0, totalLen, totalSize);
        }
        else
        {
            std::cout << "not handled: "
                      << node.ToString()
                      << std::endl;
        }
    }

    /// this
    if(data_type == 0 && node.GetType() == JSONNode::JSONOBJECT)
    {
        const JSONNode::JSONObject& object = node.GetJsonObject();
        const JSONNode::JSONObject& mobject = metadata.GetJsonObject();
        JSONNode::JSONObject::const_iterator itr  = object.begin();
        JSONNode::JSONObject::const_iterator mitr = mobject.begin();

        for(;itr != object.end(); ++itr,++mitr) {
            int cid = atoi(itr->first.c_str());
            WriteToBuffer(itr->second,mitr->second,
                          write,cid,totalLen,totalSize);
        }
    }
    else if(data_type == 0 && node.GetType() == JSONNode::JSONARRAY)
    {
        const JSONNode::JSONArray& array = node.GetArray();
        const JSONNode::JSONArray& marray = metadata.GetArray();

        for(size_t i = 0; i < array.size(); ++i)
            WriteToBuffer(array[i],marray[i],
                          write,i,totalLen,totalSize);
    }
}

// ****************************************************************************
// Method: SocketConnection::Flush
//
// Purpose: 
//   Writes the entire contents of the connection's buffer onto the
//   socket file descriptor in chunks. It then clears the buffer.
//
//
// Programmer: Brad Whitlock
// Creation:   Tue Aug 29 12:17:37 PDT 2000
//
// Modifications:
//   Brad Whitlock, Tue Mar 26 13:29:20 PST 2002
//   Made it use socket functions so it is more portable.
//
//   Brad Whitlock, Thu Jan 25 18:42:50 PST 2007
//   I made it use MSG_NOSIGNAL so we don't get a signal in the event that
//   we can't write to the socket.
//
//   Eric Brugger, Tue Mar 13 09:18:48 PDT 2007
//   I made the use of MSG_NOSIGNAL conditional on its definition.
//
// ****************************************************************************
void
SocketConnection::Flush(AttributeSubject *subject)
{
    if(destFormat.Format == TypeRepresentation::BINARYFORMAT)
        Connection::Flush(subject);
    else
    {
//        std::cout << subject->TypeName() << " "
//                  << subject->CalculateMessageSize(*this)
//                  << std::endl;

        if(subject->GetSendMetaInformation())
        {
            JSONNode meta;
            JSONNode node;

            subject->WriteAPI(meta);

            node["id"] = subject->GetGuido();
            node["typename"] = subject->TypeName();
            node["api"] = meta;

            const std::string& output = node.ToString().c_str();

#if defined(_WIN32)
            send(descriptor, (const char FAR *)output.c_str(), output.size(), 0);
#else
#ifdef MSG_NOSIGNAL
            send(descriptor, (const void *)output.c_str(), output.size(), MSG_NOSIGNAL);
#else
            send(descriptor, (const void *)output.c_str(), output.size(), 0);
#endif
#endif
        }

        JSONNode child, metadata;
        JSONNode node;

        subject->Write(child);
        subject->WriteMetaData(metadata);

        node["id"] = subject->GetGuido();
        node["typename"] = subject->TypeName();
        node["contents"] = child; //.ToJSONNode(false);
        node["metadata"] = metadata; //.ToJSONNode(false);

        const std::string& output = node.ToString();

#if defined(_WIN32)
            send(descriptor, (const char FAR *)output.c_str(), output.size(), 0);
#else
#ifdef MSG_NOSIGNAL
            send(descriptor, (const void *)output.c_str(), output.size(), MSG_NOSIGNAL);
#else
            send(descriptor, (const void *)output.c_str(), output.size(), 0);
#endif
#endif
        buffer.clear();
    }
}

void
SocketConnection::Flush()
{
    const int bufSize = 500;
    unsigned char buf[bufSize];
    int count = 0;

    // Write out the entire buffer, in pieces, to the socket descriptor.
    for(size_t bufindex = 0; bufindex < buffer.size(); ++bufindex)
    {
        buf[count++] = buffer[bufindex];

        // Write the chunk to the socket descriptor            
        if((count == bufSize) || (bufindex == buffer.size() - 1))
        {
#if defined(_WIN32)
            send(descriptor, (const char FAR *)buf, count, 0);
#else
#ifdef MSG_NOSIGNAL
            send(descriptor, (const void *)buf, count, MSG_NOSIGNAL);
#else
            send(descriptor, (const void *)buf, count, 0);
#endif
#endif

            count = 0;
        }
    }

    // Clear the buffer
    buffer.clear();
}

// ****************************************************************************
// Method: SocketConnection::Size
//
// Purpose: 
//   Returns the size of the connection's buffer. This is how many
//   bytes can still be consumed.
//
// Programmer: Brad Whitlock
// Creation:   Tue Aug 29 12:18:32 PDT 2000
//
// Modifications:
//   
// ****************************************************************************

long
SocketConnection::Size()
{
    return (long)buffer.size();
}

// ****************************************************************************
// Method: SocketConnection::Write
//
// Purpose: 
//   Appends a character to the connection's buffer.
//
// Arguments:
//   value : The character to append.
//
// Programmer: Brad Whitlock
// Creation:   Tue Aug 29 12:19:23 PDT 2000
//
// Modifications:
//   
// ****************************************************************************

void
SocketConnection::Write(unsigned char value)
{
    buffer.push_back(value);
}

// ****************************************************************************
// Method: SocketConnection::Read
//
// Purpose: 
//   Reads a character from the start of the connection's buffer.
//
// Arguments:
//   address : The memory location in which to store the character.
//
// Programmer: Brad Whitlock
// Creation:   Tue Aug 29 12:20:03 PDT 2000
//
// Modifications:
//   
// ****************************************************************************

void
SocketConnection::Read(unsigned char *address)
{
   *address = buffer.front();
    buffer.pop_front();
}

// ****************************************************************************
// Method: SocketConnection::Append
//
// Purpose: 
//   Adds characters to the end of the connection's buffer.
//
// Arguments:
//   buf   : An array of characters to append.
//   count : The length of the array.
//
// Programmer: Brad Whitlock
// Creation:   Tue Aug 29 12:20:50 PDT 2000
//
// Modifications:
//   
// ****************************************************************************

void
SocketConnection::Append(const unsigned char *buf, int count)
{
    const unsigned char *temp = buf;
    for(int i = 0; i < count; ++i)
        buffer.push_back(*temp++);
}

// ****************************************************************************
// Method: SocketConnection::DirectRead
//
// Purpose: 
//   Reads the specified number of bytes from the connection.
//
// Arguments:
//   buf    : The destination buffer.
//   ntotal : The number of bytes to read.
//
// Returns:    The number of bytes read.
//
// Note:       This method does not return until the specified number of
//             bytes have been read. This method was adapted from Jeremy's
//             read_n function.
//
// Programmer: Brad Whitlock
// Creation:   Mon Mar 25 14:28:39 PST 2002
//
// Modifications:
//   Brad Whitlock, Mon Jul 19 11:41:13 PDT 2004
//   I fixed a problem reading large messages on Windows.
//
// ****************************************************************************

long
SocketConnection::DirectRead(unsigned char *buf, long ntotal)
{
    char *b = (char*)buf;
    long nread = 0;

    while (nread < ntotal)
    {
        int n = recv(descriptor, b, ntotal-nread, 0);

        if (n < 0)
        {
#if defined(_WIN32)
            //
            // If the last socket error was any of the errors that are
            // typically set by recv then return. For some large messages
            // that VisIt reads, recv returns -1 indicating some kind of
            // failure but the error code does match anything fatal so
            // don't bother returning. In the situations I've observed,
            // it's been okay to continue calling recv until it succeeds.
            //
            int err = WSAGetLastError();
            if(err == WSANOTINITIALISED ||
               err == WSAENETDOWN ||
               err == WSAEFAULT ||
               err == WSAENOTCONN ||
               err == WSAEINTR ||
               err == WSAEINPROGRESS ||
               err == WSAENETRESET ||
               err == WSAENOTSOCK ||
               err == WSAEOPNOTSUPP ||
               err == WSAESHUTDOWN ||
               err == WSAEWOULDBLOCK ||
               err == WSAEMSGSIZE ||
               err == WSAEINVAL ||
               err == WSAECONNABORTED ||
               err == WSAETIMEDOUT ||
               err == WSAECONNRESET ||
               err == WSAEDISCON)
            {
                return long(n);
            }
#else
            return long(n);
#endif
        }
        else if(n == 0)
        {
            ++zeroesRead;

            if(zeroesRead > 100)
            {
                EXCEPTION0(LostConnectionException);
            }
        }
        else
        {
            nread += n;
            b += n;

            // Reset the flag.
            zeroesRead = 0;
        }
    }

    return ntotal;
}

// ****************************************************************************
// Method: SocketConnection::DirectWrite
//
// Purpose: 
//   Writes a buffer to the connection without doing any buffering.
//
// Arguments:
//   buf    : The buffer that we want to write.
//   ntotal : The length of the buffer.
//
// Returns:    The number of bytes written.
//
// Note:       This method was adapted from Jeremy's write_n function.
//
// Programmer: Brad Whitlock
// Creation:   Mon Mar 25 14:33:40 PST 2002
//
// Modifications:
//    Jeremy Meredith, Fri Jan 30 17:39:47 PST 2004
//    Fixed a bug where failed sends would restart from the beginning.
//
// ****************************************************************************

long
SocketConnection::DirectWrite(const unsigned char *buf, long ntotal)
{
    size_t          nleft, nwritten;
    const char      *ptr;

    ptr = (const char*)buf;
    nleft = ntotal;
    while (nleft > 0)
    {
        if((nwritten = send(descriptor, (const char *)ptr, nleft, 0)) <= 0)
            return nwritten;

        nleft -= nwritten;
        ptr   += nwritten;
    }
    return ntotal;
}

// ****************************************************************************
// Method: SocketConnection::NeedsRead
//
// Purpose: 
//   Returns whether or not the connection has data that could be read.
//
// Arguments:
//   blocking : Specifies whether we should block until input needs to be
//              read or whether we should poll.
//
// Returns:  True if there is data, false otherwise.  
//
// Programmer: Brad Whitlock
// Creation:   Mon Mar 25 16:01:17 PST 2002
//
// Modifications:
//    Tom Fogal, Sat Feb 16 15:47:15 EST 2008
//    Restart the system call if it gets interrupted.
//
//    Brad Whitlock, Thu Jun 11 15:14:50 PST 2009
//    Don't call select if we don't have it.
//
// ****************************************************************************

bool
SocketConnection::NeedsRead(bool blocking) const
{
#ifdef HAVE_SELECT
    // Set up a file descriptor set that only consists of the descriptor
    // used by this connection.
    fd_set readSet;
    FD_ZERO(&readSet);
    FD_SET(descriptor, &readSet);

    int ret = 0;
    if(blocking)
    {
        ret = RESTART_SELECT(descriptor+1, &readSet,
                             static_cast<fd_set*>(NULL),
                             static_cast<fd_set*>(NULL),
                             static_cast<struct timeval *>(NULL));
    }
    else
    {
        // Create a null timeout that will cause select to poll.
        struct timeval timeout = {0,0};
        ret = RESTART_SELECT(descriptor+1, &readSet,
                             static_cast<fd_set*>(NULL),
                             static_cast<fd_set*>(NULL),
                             &timeout);
    }

    return (ret > 0);
#else
    // Assume that read will block for input.
    return true;
#endif
}

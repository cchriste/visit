                         Building VisIt on MacOS X
                         =========================

This document describes how to build VisIt on MacOS X under at least 10.4.x 
on Intel and 10.3.9 on PPC. 

build_visit
  The recomended method for building VisIt on MacOS X is to use the 
  build_visit script available at:
    http://www.llnl.gov/VisIt/1.11.0/build_visit 
  Note: you may need to restore the execute permissions after downloading
  with, chmod +x build_visit
  Using build_visit a basic build for the Mac can be initiated with:
     ./build_visit -z
  The above command will download the required VisIt and 3rd party source code,
  configuring, and building it all using your C++ compiler. The full-blown
  version of VisIt (same as the binary distribution minus Mili) use:
    ./build_visit -45bcefgnrwz 
  Some users are more comfortable with a GUI interface. The build_visit script
  optionally uses dialog, a script-interpreter which providing a set of curses
  widgets, similar to the what is used in Linux kernel configuration. Dialog
  is not include in the distribution of MacOS X. A source distribution of
  dialog is available at: http://invisible-island.net/dialog/dialog.tar.gz,
  and a Universal binary is available at:
    http://www.llnl.gov/VisIt/1.9.1/dialog
  Note: you may need to restore the execute permissions after downloading
  with, chmod +x dialog

Universal binary
  The single step building of a universal binary for MacOS X is impossible
  at this point. The resulting binary using diables exceptions on the PowerPC
  Mac, and most of the third pary libraries can't perform the required
  cross-compile. A good reference for some of the issues involved
  is: http://developer.apple.com/technotes/tn2005/tn2137.html. 
  The Mac binaries adds a significant degree of difficulty to the VisIt build.
  Some of the reasons for this complexity include:
  1) MacOS X dynamic shared libraries use the .dylib extension. The later GNU
  autotools, and libtool know about this, but the library must be built using 
  these later versions. If the package is a few years old there's a good chance
  it doesn't know how to build dynamic libraries for the Mac.
  2) Intel Mac binaries require gcc/g++-4.x. Quite a few of the third-party 
  libraries are a few years old, and even though they use configure, they were
  released before MacOS X and gcc-4.x.
  3) The Intel Mac is not the same architecture as the PPC Mac. Some packages 
  even if they do support the MacOS X, assume that MacOS X = PowerPC (32-bit
  only). This gets even more complex, when 4-way universal binaries (ppc, i386,
  ppc_64, and x86_64) are desired.
  4) The configure file are created with older autoconf scripts which don't 
  support either: Mac OS X, gcc-4.x, or cross-compiling. In the worse case
  configure can't determine that a cross compile is required, and configure
  can't determine the target machines characteristics by running code the build
  machine.
  5) The third-pary configure  doesn't support the building universal 
  binaries. Problems develop when configure determines the endianness or word
  size for compiling. Universal binaries must make this determination during
  the compile. Each architecture in a universal binary requires it's own
  separate compile.
  Building of a universal install target requires 2 independent builds of VisIt
  and its supporting libraries. The PowerPC Mac be running at least MacOS
  X10.3.9, and the Intel Mac running MacOS X10.4.x (Tiger). Each build is put
  into a binary distribution tarball (e.g., visit1_11_0.darwin-ppc.tar.gz or
  visit1_11_0.darwin-i386.tar.gz) by the clearcase_bin/visit-bin-dist step.
  Each of these tarballs can be installed in a executable distributions,
  see: http://www/visit/1.11.0/INSTALL_NOTES.

Build Notes (if you still want to do it by hand)
  VisIt relies on several external libraries which must be built and installed
  prior to building VisIt.  This document provides detailed step by step
  instructions for building VisIt and each of the dependent libraries.  The
  instructions have been designed so that you can cut and paste most of the
  commands needed to build the libraries and VisIt from this file into your
  shell prompt.

    Library  Version  Description           For More Information
    =======  =======  ===========           ====================
    Mesa     6.4.2    3-D Graphics Library  http://www.mesa3d.org/
                   http://www.llnl.gov/visit/3rd_party/Mesalib-6.4.2.tar.gz
    Python   2.5      Scripting Language    http://www.python.org
                   http://www.llnl.gov/visit/3rd_party/Python-2.5.tar.gz
    Qt       3.3.8    GUI Toolkit           http://www.trolltech.com
                   http://www.llnl.gov/visit/3rd_partyqt-/mac-free-3.3.8.tar.gz
    VTK      5.0.0c   Visualization Toolkit http://www.vtk.org
                   http://www.llnl.gov/visit/3rd_party/vtk-5.0.0c.tar.gz
    cmake    2.4.5    Make file generation  http://www.cmake.org
                   http://www.llnl.gov/visit/3rd_party/cmake-2.4.5.tar.gz
    Silo     4.5.1    File I/O library       
                   http://www.llnl.gov/visit/3rd_party/silo060605.sh
    
    Optional Version  Description           For More Information
    ======== =======  ===========           ====================
    Boxlib   2.5      An AMR I/O library    
                   http://www.llnl.gov/visit/3rd_party/boxlib.tar.rz
    CFITSIO  3006     File I/O library       
                             http://heasarc.gsfc.nasa.gov/docs/heasarc/fits.html
                   http://www.llnl.gov/visit/3rd_party/cfitsio3006.tar.gz
    CGNS     2.4.3    File I/O library      http://www.cgns.org    
                   http://www.llnl.gov/visit/3rd_party/cgnslib_2.4-3.tar.gz
    ExodusII 4.46     File I/O library      http://www.sourceforge.net/projects/
                   http://www.llnl.gov/visit/3rd_party/exodusii-4.46.tar.gz
    GDAL     1.3.2    GIS reader library    http://www.gdal.org
                   http://www.llnl.gov/visit/3rd_party/gdal-1.3.2.tar.gz
    H5Part   1.3.3    I/O library           
                             https://codeforge.lbl.gov/projects/h5part
                   http://www.llnl.gov/visit/3rd_party/H5Part-20070711.tar.gz
    HDF4     2.4.1    I/O library           
                             http://hdfgroup.org/products/hdf4/index.html
                   http://www.llnl.gov/visit/3rd_party/HDF4.2r1.tar.gz
    HDF5     1.6.5    I/O library           
                             http://hdfgroup.org/products/hdf5/index.html
                   http://www.llnl.gov/visit/3rd_party/hdf5-1.6.5.tar.gz
    Mili     1.09     I/O library           (none)    
                   NOT RELEASED
    netCDF   3.6.0    File I/O library       
                             http://www.unidata.ucar.edu/packages/netcdf/
                   http://www.llnl.gov/visit/3rd_party/netcdf.tar.gz
    szip     2.1      szip-2.1.tar.gz         
                             http://hdfgroup.org/doc_resource/SZIP/
                   http://www.llnl.gov/visit/3rd_party/szip-2.1.tar.gz
    
  The public version of VisIt has been built with the above listed versions
  of the libraries, so it is known to work properly with those versions.  For
  all the packages except VTK and Qt, you can probably use newer versions of
  the packages and VisIt should work properly. For VTK, you must use the 5.0.0c
  distribution provided on the VisIt Web site, because extensions/fixes have
  been added to the VTK-5.x library. The version of Qt used to build VisIt on
  MacOS X must be greater than or equal to 3.3.6 to support gcc-4.x and Intel
  Mac. For Mesa, you must build a mangled version of Mesa.  

  All of the third party libraries necessary to build VisIt (except Mili,
  whose sources hasn't been released) are available for download from:
  http://www.llnl.gov/visit/3rd_party/.  It is suggested that you start there
  and then go to the "For More Information" web sites for any remaining
  libraries.

  It is essential that you build all the dependent packages and VisIt using
  the same c++ compiler or you will encounter linking problems because
  different compilers or different versions of the same compiler may use
  different name mangling schemes. For MacOS X, we recommend using at least
  Xcode 2.4.1.


==============================================================================
Crucial linker flags for dynamic library
==============================================================================

-install_name        The -install_name flag inserts the name of the library
                     into the actual dylib file. Normally if you do not
                     provide this flag, the path where you built the library is
                     inserted into the dylib file and applications that link
                     with the dylib look for it in the path stored in the dylib,
                     which easily leads to the library not being found. In order
                     to make sure that the system can find the dylib file used
                     by your application, make sure you build dylib files so
                     their installed name is relative to the executable.
                   
                     For VisIt, which has a bin directory and a separate lib
                     directory for libraries, we set the installation name like
                     this:
                     
                     -install_name,@executable_path/../lib/libfoo.dylib.
                     
                     The above example makes sure that applications in bin that
                     linked with libfoo.dylib look for it in ../lib instead of
                     a hardcoded path.
                 

==============================================================================
install_name_tool
==============================================================================

This tool allows us to change information about where an application looks for 
libraries or what these libraries are called. By changing the internal file
information we can use relative paths to the 3rd party libraries, and not
relaying on DYLD_LIBRARY_PATH (or LD_LIBRARY_PATH) environment variables.
For example the multithreaded version of Qt, replace libqt.3.dylib with 
libqt-mt.3.dylib, the build scripts all assume libqt.dylib (or simply -lqt).
Assume we must update both the library and an executable so that they know 
where the qt library can be found. This is where the install_name_tool 
command-line tool comes in handy. For the Qt library:
    cp libqt-mt.3.dylib libqt.dylib
    install_name_tool -id @executable_path/../lib/libqt.dylib \
        libqt.dylib
    
And for included libraries, and the executable:
    install_name_tool \
        -change libqt-mt.3.dylib \
        @executable_path/../lib/libqt.dylib \
        demo
    
The "@executable_path" symbol should to be typed as is; it must not be replaced 
by the real path to the executable on your machine.

==============================================================================
otool
==============================================================================

MacOS X has a utility called otool that allows you to examine the contents of
a dynamic library or an executable. This tool performs function similar to the
ldd tool (used in Linux). Otool is very handy for determining the names and
locations of the dynamic library's needed for this binary. Here are the most 
useful options for otool:

# Print all of the dependent libraries
otool -L libfoo.dylib

==============================================================================
Creating dynamic libraries
==============================================================================

Use gxx/g++ in place of the link editor on the specified input object files to
creates the dynamic library.  The library's name  is specified  by  output  
(the argument to the -o flag).  The input object files may be in any correct
format that contains universal object files, or plain object files. The 
options: -install_name, -compatibility_version, -current_version, 
-undefined dynamic_lookup, and -header-pad_max_install_names must be embedded
in the -Wl, option for passage to the linker.

Example:
gcc -dynamiclib -o libfoo.dylib src/*.o \
-Wl,-headerpad_max_install_names,-undefined,dynamic_lookup,\
-compatibility_version,2.0,-current_version,2.2.1,\
-install_name,@executable_path/../lib/libfoo.dylib

Example for universal binary:
gcc -dynamiclib -o libfoo.dylib src/*.o \
-Wl,-syslibroot,/Developer/SDKs/MacOSX10.4u.sdk,\
-headerpad_max_install_names,-undefined,dynamic_lookup,\
-compatibility_version,2.0,-current_version,2.2.1,\
-install_name,@executable_path/../lib/libfoo.dylib \
 -arch ppc -arch i386

==============================================================================
Creating dynamic libraries from static libraries
==============================================================================

Using Apple's custom libtool command takes the specified input object files and
creates dynamic a library for use with the link editor, ld(1).  The library's 
name  is specified  by  output  (the argument to the -o flag).  The input
object files may be in any correct format that contains universal object files,
archives, object files. The options: -install_name, -compatibility_version, 
current_version, -multiply_defined, and -header-pad_max_install_names are
commonly used.

Example:
libtool -o libfoo.dylib-i386 -dynamic libfoo.a -lSystem \
-twolevel_namespace -undefined dynamic_lookup -arch_only i386 \
-headerpad_max_install_names \
-install_name @executable_path/../lib/libfoo.dylib \
-compatibility_version 1.0 -current_version 1.1.5

However it's been found that some third party libraries fail to produce working
dynamic libraries using the above method. So a relinking of the object files is
required to create a dynamic library.

Example:
mkdir tmpdir
cd tmpdir
ar x ../libfoo.a
gcc -dynamiclib -o ../libfoo.dylib *.o \
-Wl,-headerpad_max_install_names,\
-compatibility_version,2.0,-current_version,2.2.1,\
-install_name,@executable_path/../lib/libfoo.dylib
cd ..
rm -rf tmpdir

==============================================================================
Building an application that can run on multiple versions of MacOS X
==============================================================================

By default, the linker on MacOS X will resolve all system library dependencies
such that the final linked binary file will depend on a particular version of
the system libraries. For example, this prevents you from building on 
MacOS X 10.4 and running your application on MacOS X 10.3. As of MacOS X 10.3,
there is a special linker flag, called -undefined, that allows system library
dependencies to be left undefined during the link step. There is 
also an environment variable called MACOSX_DEPLOYMENT_TARGET that can be 
set to tell the linker which versions of the system libraries to expect. 
Setting the  MACOSX_DEPLOYMENT_TARGET environment variable and using the
-undefined linker flag will help your compiled application run on more than
one version of MacOS X.

To make sure that when you build an application on MacOS X 10.3, it can also 
run on MacOS X 10.4 and beyond, you should set the MACOSX_DEPLOYMENT_TARGET
environment variable before you build your application.

Example:
export MACOSX_DEPLOYMENT_TARGET=10.3

You should also add the -headerpad_max_install_names to your LDFLAGS in your
Makefile, this option allows renaming of the install name stored in the
dynamic library file.

These are the default linker flags for the Mac used by VisIt.
Example:
LDFLAGS="$LDFLAGS -Wl,-undefined,dynamic_lookup,-headerpad_max_install_names"

==============================================================================
Configuring universal binaries on MacOS X
==============================================================================

The first approach is to simply have configure build a universal binary, by
passing in the appropriate CFLAGS, CXXFLAGS and LDFLAGS environment variables. 
This isdone simply by running:
./configure --prefix=${VISITPATH}/foo CXXFLAGS=\
 "-O -g -isysroot /Developer/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc" \
 CFLAGS="-O -g -isysroot /Developer/SDKs/MacOSX10.4u.sdk -arch i386 -arch ppc" \
 LDFLAGS="-arch i386 -arch ppc"  --disable-dependency-tracking
 
The --disable-dependency-tracking option to configure causes it to not use gcc's
built-in dependency generation code, which does not work with multiple -arch
targets.

This is the easiest means of generating universal binaries, but unfortunatly
most older configure scripts will not support this feature.

With MacOS X 10.5 a 4-way universial binary can be created by adding:
-arch ppc_64 -arch x86_64 to the flags.

==============================================================================
Universal binaries on MacOS X by merging multiple builds
==============================================================================

If the third-party library does care about byte order, word size, or pointer
size, and configure supports cross-compiling. Multiple invocations of 
configure/make will generate architecture based objects, that can in turn can 
be merged into universal binaries. Not all open source projects follow these
convensions. The lipo command is used to merge the multiple builds.

In the worse case (configu doen't support cross-compiling) multiple machines
will be needed to generate the architecture based objects.

On both an Intel- and PowerPC-based Macintosh, configure and build the program
as follows:
./configure --prefix=${VISITPATH}/foo
make

Copy the resultant libfoo.dylib programs to a single machine; for example, into
/tmp on a PowerPC-based Macintosh, with the names libfoo.dylib-intel and
libfoo.dylib-ppc, respectively. Then, use the lipo command to combine the two:

lipo -create libfoo.dylib-intel libfoo.dylib-ppc -output libfoo.dylib

As before, the file command can verify the file contents:
$ file libfoo.dylib
libfoo.dylib: Mach-O universal binary with 2 architectures
libfoo.dylib (for architecture ppc):        Mach-O dynamically linked shared
library ppc
libfoo.dylib (for architecture i386):       Mach-O dynamically linked shared
library i386

The same procedure as above applies to executables.

==============================================================================
Support libraries
==============================================================================

Most of the instructions in this document are for building the various support
libraries that VisIt depends on as prebound dynamic libraries. Few of the
libraries that VisIt uses actually have support in their make system for
producing universal binary libraries so it is imperative that you follow the
directions. The following procedure used an Intel-Mac as the primary build
machine, also a PowerPC-Mac was required to build a few of the 3-party
libraries that didn't support cross compiling.

Before building VisIt or any of its support libraries, you need to create a
"visit" directory in which the support libraries will be installed. We also 
create a file that contains the path so we can use that in some of the
instructions later on.

mkdir visit
echo `pwd`/visit > visitpath
export VISITPATH="`pwd`/visit"

Also, note when these instructions indicate that a library's source code must
be replaced or modified. VTK requires some source code modifications before
compilation. Since the source exists within VisIt's source code directory, 
take this opportunity to unzip VisIt's source code distribution and set an
environment variable that will be used to identify VisIt's source code 
directory.

# Make sure that you build a version of VisIt that can run on MacOS X 10.3
# and later.
export MACOSX_DEPLOYMENT_TARGET=10.3

==============================================================================
Building Qt library
==============================================================================

Qt actually builds as a prebound dynamic library but we need to make sure
that it sets an install_name that is relative to our VisIt executables. The
Qt-4.x version promises to support universal builds, until then you'll
need to build twice then lipo to combine the two build.

# Unzip the Qt source
tar zxf qt-mac-free-3.3.8.tar.gz
cd qt-mac-free-3.3.8

#
export QTDIR=$(pwd)
export DYLD_LIBRARY_PATH=$QTDIR/lib:$DYLD_LIBRARY_PATH
./configure -thread -platform macx-g++ --prefix=$VISITPATH/qt
make

# Install headers Qt
make install

# Change the dynamic install names
cd lib
rm libqt.dylib
cp libqt-mt.3.3.8.dylib libqt.dylib
install_name_tool -id @executable_path/../lib/libqt.dylib libqt.dylib
rm libqui.dylib
cp libqui.1.0.0.dylib libqui.dylib
install_name_tool -change libqt-mt.3.dylib @executable_path/../lib/libqt.dylib \
libqui.dylib
install_name_tool -id @executable_path/../lib/libqui.dylib libqui.dylib
cp libqt.dylib libqui.dylib $VISITPATH/qt/lib
cd ../..

==============================================================================
Building Mesa 
==============================================================================              

Mesa is a 3-D graphics library with an API which is very similar to that of
OpenGL.  It is used for performing off-screen rendering.

#
# Build Mesa
#
tar zxf MesaLib-6.4.2.tar.gz
cd Mesa-6.4.2

#
# Special instructions for building Mesa on MacOS X
#
# The darwin target for building Mesa assumes that you want to build Mesa
# with support for X11. This is not what we want to do for the version of
# Mesa that we'll use for VisIt since we only want offscreen rendering.

# Remove the X11 libraries, and change GL_LIB so it will build a 
# library called libMesaGL.dylib instead of libGL.dylib. Finally, 
# edit GLU_LIB_DEPS so it uses -lMesaGL instead of -lGL.
vi configs/default
#    Change:
#      GL_LIB = GL
#      GL_LIB_DEPS = $(EXTRA_LIB_PATH) -lX11 -lXext -lm -lpthread
#      GLUT_LIB_DEPS = -L$(TOP)/$(LIB_DIR) -l$(GLU_LIB) -l$(GL_LIB) \
#           $(EXTRA_LIB_PATH) -lX11 -lXmu -lXt -lXi -lm
#      GLW_LIB_DEPS = -L$(TOP)/$(LIB_DIR) -l$(GL_LIB) $(EXTRA_LIB_PATH) \
#           -lXt -lX11
#      to
#      GL_LIB = MesaGL
#      GL_LIB_DEPS = -lm -lpthread
#      GLUT_LIB_DEPS = -L$(TOP)/$(LIB_DIR) -l$(GLU_LIB) -l$(GL_LIB) -lm
#      GLW_LIB_DEPS = -L$(TOP)/$(LIB_DIR) -l$(GL_LIB)
#
# Remove all X include files and libraries from the darwin target. Also add 
# -DUSE_MGL_NAMESPACE to the CFLAGS so a mangled version of Mesa will be built.
# edit configs/darwin-x86 for intel, configs/darwin for PPC, and
# configs/darwin-x86ppc for a universal build.
vi configs/darwin-x86ppc
#    Remove -I/usr/X11R6/include from CFLAGS, and CXXFLAGS.
#    Add -DUSE_MGL_NAMESPACE to the end of CFLAGS, and CXXFLAGS.
#
#    Change:
#      GL_LIB_NAME = libGL.dylib
#      GL_LIB_DEPS = -L/usr/X11R6/lib -lX11 -lXext -lm -lpthread
#      OSMESA_LIB_DEPS = -L$(TOP)/$(LIB_DIR) -lGL
#      GLU_LIB_DEPS = -L$(TOP)/$(LIB_DIR) -lGL
#      GLUT_LIB_DEPS = -L$(TOP)/$(LIB_DIR) -lGL -lGLU -L/usr/X11R6/lib -lX11 \
#      -lXmu -lXi -lXext
#      GLW_LIB_DEPS = -L/usr/X11R6/lib -lX11 -lXt $(TOP)/lib/GL.dylib
#      APP_LIB_DEPS = -L$(TOP)/lib -l$(GLUT_LIB) -l$(GLU_LIB) -l$(GL_LIB) \
#      -L/usr/X11R6/lib -lX11 -lXmu -lXt -lXi -lm
#      to
#      GL_LIB_NAME = libMesaGL.dylib
#      GL_LIB_DEPS = -lm -lpthread
#      OSMESA_LIB_DEPS = -L$(TOP)/$(LIB_DIR) -lMesaGL
#      GLU_LIB_DEPS = -L$(TOP)/$(LIB_DIR) -lMesaGL
#      GLUT_LIB_DEPS = -L$(TOP)/$(LIB_DIR) -lMesaGL -lGLU
#      GLW_LIB_DEPS = $(TOP)/lib/MesaGL.dylib
#      APP_LIB_DEPS = -L$(TOP)/lib -l$(GLUT_LIB) -l$(GLU_LIB) -l$(GL_LIB) -lm
#
# Remove all of the source code files from the X11_DRIVER_SOURCES variable.
vi src/mesa/sources
#    Change:
#      X11_DRIVER_SOURCES =            \
#              drivers/x11/glxapi.c    \
#         . . .
#              drivers/x11/xm_tri.c
#    to:
#       X11_DRIVER_SOURCES =

#
# Build Mesa by typing in the Mesa-6.4.2 directory.
#
make darwin

#
# Install Mesa
#
make INSTALL_DIR=$VISITPATH/mesa install
cp lib/libMesa*.dylib $VISITPATH/mesa/lib
cd $VISITPATH/mesa/lib
rm libMesaGL.dylib
cp libMesaGL.1.dylib libMesaGL.dylib
install_name_tool -id @executable_path/../lib/libMesaGL.dylib \
libMesaGL.dylib
rm libOSMesa.dylib
cp libOSMesa.6.dylib libOSMesa.dylib
install_name_tool -id @executable_path/../lib/libOSMesa.dylib \
libOSMesa.dylib
install_name_tool -change libMesaGL.1.dylib \
@executable_path/../lib/libMesaGL.dylib libOSMesa.dylib
cd ../../..

==============================================================================
Building CMake in order to build VTK
==============================================================================

CMake is a cross-platform make system used to build VTK. Before building VTK,
we must build CMake. The VisIt third-party contains the older cmake-2.2.3 
It didn't build for me so I'm using the more recent cmake-2.4.5.

tar zxf cmake-2.4.5.tar.gz
cd cmake-2.4.5
env CXXFLAGS="" CFLAGS="" ./bootstrap
make
cd ..

==============================================================================
Building VTK as a set of prebound dynamic libraries
==============================================================================

VTK is an object oriented library for visualizing 3D data.  VisIt uses it
for all its visualization functionality. Follow the directions listed below
to build VTK.  If you have any problems building or installing VTK, read the
VTK/README.html file included in the VTK distribution for more information.
This distribution however would not build as 2-way universal binary without
building on separate machines.

tar zxf vtk-5.0.0c.tar.gz
cd VTK

Source code and build modifications:
====================================

The above VTK distribution must be modified a little to support features that
VisIt needs in order to run properly. For example, VisIt requires VTK to be
built with support for mangled mesa in order to support offscreen rendering.
VisIt uses offscreen rendering to save images, do scalable rendering in 
parallel, and to render images when the CLI is run in -nowin mode. VTK cannot
be built with mangled mesa support on MacOS X without some modifications to 
its source code and build system. Follow each of the next instructions before
building VTK to ensure that you produce VTK libraries that meet VisIt's needs.

vi CMakeLists.txt
# Look for the 2 lines containing: 
   -flat_namespace,-U,_environ
# and replace with: 
   -twolevel_namespace,-headerpad_max_install_names
# On the 2 lines containing:
   -no-cpp-precomp 
# add: 
   -fno-common

# Add a "#" to references to Widget library, search and change the 4 following
# lines:
   # SET(VTK_KITS ${VTK_KITS} WIDGETS)
   # SUBDIRS(Widgets)
   #   SUBDIRS(Widgets/Testing)
   #   INSTALL_FILES(${VTK_INSTALL_INCLUDE_DIR} .h vtkWidgetsInstantiator)

vi Utilities/ftgl/CMakeLists.txt
# look for:
   SET (VTKFTGL_LIBS "${VTKFTGL_LIBS};${OPENGL_gl_LIBRARY}")
# Add the following code after the above string:

IF (FTGL_SUPPORT_MANGLE_MESA)
 SET (VTKFTGL_LIBS "${VTKFTGL_LIBS};${MANGLED_MESA_LIBRARY}")
ENDIF (FTGL_SUPPORT_MANGLE_MESA)

vi Rendering/CMakeLists.txt
# remove the line that contains:
   vtkXMesaRenderWindow.cxx.

vi Rendering/vtkGraphicsFactory.cxx
# wrap the
   #include "vtkXMesaRenderWindow.h"
# with:
   #if !defined(__APPLE__)
   #include "vtkXMesaRenderWindow.h"
   #endif
# to prevent that header from being included.

vi Rendering/vtkXMesaRenderWindow.cxx
# change:
   #include "vtkXMesaRenderWindow.h"
# to:
   #if !defined(__APPLE__)
   #include "vtkXMesaRenderWindow.h"
   #else
   #include "vtkMesaRenderWindow.h"
   #endif

vi Rendering/vtkImagingFactory.cxx
# The vtkImagingFactory class does not support creation of Mesa objects under
# Carbon. Find the code that looks like this:

#ifdef VTK_USE_CARBON
  if (!strcmp("CarbonOpenGL",rl))
    {
    if(strcmp(vtkclassname, "vtkTextMapper") == 0)
      {
      return vtkOpenGLFreeTypeTextMapper::New();
      }
    if(strcmp(vtkclassname, "vtkImageMapper") == 0)
      {
      return vtkOpenGLImageMapper::New();
      }
    if(strcmp(vtkclassname, "vtkPolyDataMapper2D") == 0)
      {
      return vtkOpenGLPolyDataMapper2D::New();
      }
    }
#endif

# Modify that code so it includes the code to create Mesa objects when VTK has
# been instructed to use Mesa. The modified code will look like this:   

#ifdef VTK_USE_CARBON
  if (!strcmp("CarbonOpenGL",rl))
    {
    if(strcmp(vtkclassname, "vtkTextMapper") == 0)
      {
#if defined(VTK_USE_MANGLED_MESA)
      if ( vtkImagingFactory::UseMesaClasses )
        {
        return vtkMesaFreeTypeTextMapper::New();
        }
#endif
      return vtkOpenGLFreeTypeTextMapper::New();
      }
    if(strcmp(vtkclassname, "vtkImageMapper") == 0)
      {
#if defined(VTK_USE_MANGLED_MESA)
      if ( vtkImagingFactory::UseMesaClasses )
        {
        return vtkMesaImageMapper::New();
        }
#endif
      return vtkOpenGLImageMapper::New();
      }
    if(strcmp(vtkclassname, "vtkPolyDataMapper2D") == 0)
      {
#if defined(VTK_USE_MANGLED_MESA)
      if ( vtkImagingFactory::UseMesaClasses )
        {
        return vtkMesaPolyDataMapper2D::New();
        }
#endif
      return vtkOpenGLPolyDataMapper2D::New();
      }
    }
#endif

You may have noticed that we don't do anything in VTK to preclude the use of
vtkCarbonRenderWindow, even though it cannot support Mesa. We register an
override of vtkCarbonRenderWindow later in VisIt's visit_vtk library that
forces VTK to create one of VisIt's vtkOSMesaRenderWindow objects instead
of creating vtkCarbonRenderWindow objects. This allows us to do offscreen
rendering in MacOS X without having to rewrite vtkCarbonRenderWindow.


Configuring VTK:
================

../cmake-2.4.5/bin/ccmake .

The above ccmake program is a menu for configuring VTK. Follow these steps to 
configure VTK and generate its makefiles. You must perform these steps before
you can build VTK.

1. First, press "c" for configure.
2. When it is finished, press "t" for advanced options, and change the 
   options listed below:

    Option                             Value
    =================================================
    SHARED_LIBS                        ON
    BUILD_TESTING                      OFF
    CMAKE_BUILD_TYPE                   Release
    CMAKE_CXX_FLAGS_RELEASE            -O3 -fno-common
    CMAKE_C_FLAGS_RELEASE              -O3 -fno-common
    CMAKE_EXE_LINKER_FLAGS_RELEASE     -Wl,-headerpad_max_install_names
    CMAKE_MODULE_LINKER_FLAGS_RELEASE  -Wl,-headerpad_max_install_names
    CMAKE_SHARED_LINKER_FLAGS_RELEASE  -Wl,-headerpad_max_install_names,\
-compatibility_version,5.0,-current_version,5.0.0
    CMAKE_VERBOSE_MAKEFILE             ON
    VTK_USE_MANGLED_MESA               ON

3. Type "c" to make ccmake configure. When it is done there are more options 
   to fill in. The use of $VISITPATH in this case is for illustration purposes
   only. Since you are inside of ccmake, substitute the actual value for
   $VISITPATH instead of using the $VISITPATH environment variable.

   Option                              Value
   =================================================
   MANGLED_MESA_INCLUDE_DIR            $VISITPATH/mesa/include
   MANGLED_MESA_LIBRARY                $VISITPATH/mesa/lib/libMesaGL.dylib
   MANGLED_OSMESA_INCLUDE_DIR          $VISITPATH/mesa/include
   MANGLED_OSMESA_LIBRARY              $VISITPATH/mesa/lib/libOSMesa.dylib

4. Type "c" to configure
5. Type "g" to generate and quit


Building VTK:
=============

# Now that VTK's source and build have been modified and you've configured and
# generated VTK's Makefiles, you can start building VTK.

make

#
# fix the internal name with in the libraries
#
# first change the libraries name and identification by executing the following
# bourne shell script
cd bin
for i in libvtkCommon libvtkDICOMParser libvtkFiltering libvtkGenericFiltering \
libvtkGraphics libvtkHybrid libvtkIO libvtkImaging libvtkMPEG2Encode \
libvtkRendering libvtkVolumeRendering \
libvtkexpat libvtkfreetype libvtkftgl libvtkjpeg libvtkpng libvtksys \
libvtktiff libvtkzlib
do 
  rm $i.dylib
  mv $i.5.0.0.dylib $i.dylib
  install_name_tool -id @executable_path/../lib/$i.dylib $i.dylib
  rm $i.5.0.dylib
done

#
# Next change the dependent libraries names and paths
for i in libvtkCommon libvtkDICOMParser libvtkFiltering libvtkGenericFiltering \
libvtkGraphics libvtkHybrid libvtkIO libvtkImaging libvtkMPEG2Encode \
libvtkRendering libvtkVolumeRendering \
libvtkexpat libvtkfreetype libvtkftgl libvtkjpeg libvtkpng libvtksys \
libvtktiff libvtkzlib 
do
  for j in libvtkCommon libvtkDICOMParser libvtkFiltering \
  libvtkGenericFiltering libvtkGraphics libvtkHybrid libvtkIO libvtkImaging \
  libvtkMPEG2Encode libvtkRendering libvtkVolumeRendering \
  libvtkexpat libvtkfreetype libvtkftgl libvtkjpeg \
  libvtkpng libvtksys libvtktiff libvtkzlib
  do
    install_name_tool -change $j.5.0.dylib @executable_path/../lib/$j.dylib \
    $i.dylib 
  done
done
cd ..
#
# Install VTK in the visit directory under the vtk directory.
#
mkdir $VISITPATH/vtk
mkdir $VISITPATH/vtk/{Common,Filtering,GenericFiltering}
mkdir $VISITPATH/vtk/{Graphics,Hybrid,IO,Imaging}
mkdir $VISITPATH/vtk/{Rendering,MangleMesaInclude,Utilities}
mkdir $VISITPATH/vtk/{VolumeRendering,lib}
mkdir $VISITPATH/vtk/{vtkstd,Utilities/vtktiff,Utilities/vtkexpat}
mkdir $VISITPATH/vtk/{Utilities/vtkzlib,Utilities/vtkjpeg}
cp vtkConfigure.h                 $VISITPATH/vtk
cp vtkToolkits.h                  $VISITPATH/vtk
cp vtk*Instantiator.h             $VISITPATH/vtk
cp Common/*.h                     $VISITPATH/vtk/Common
cp Common/*.txx                   $VISITPATH/vtk/Common
cp Filtering/*.h                  $VISITPATH/vtk/Filtering
cp Filtering/*.txx                $VISITPATH/vtk/Filtering
cp GenericFiltering/*.h           $VISITPATH/vtk/GenericFiltering
cp Graphics/*.h                   $VISITPATH/vtk/Graphics
cp Hybrid/*.h                     $VISITPATH/vtk/Hybrid
cp IO/*.h                         $VISITPATH/vtk/IO
cp Imaging/*.h                    $VISITPATH/vtk/Imaging
cp Rendering/*.h                  $VISITPATH/vtk/Rendering
cp Utilities/*.h                  $VISITPATH/vtk/Utilities
cp Utilities/vtktiff/*.h          $VISITPATH/vtk/Utilities/vtktiff
cp Utilities/vtkexpat/*.h         $VISITPATH/vtk/Utilities/vtkexpat
cp Utilities/vtkzlib/*.h          $VISITPATH/vtk/Utilities/vtkzlib
cp Utilities/vtkjpeg/*.h          $VISITPATH/vtk/Utilities/vtkjpeg
cp VolumeRendering/*.h            $VISITPATH/vtk/VolumeRendering
cp MangleMesaInclude/*.h          $VISITPATH/vtk/MangleMesaInclude
cp vtkstd/*                       $VISITPATH/vtk/vtkstd
cp bin/*.dylib                    $VISITPATH/vtk/lib

#
# Create a JPEG library from the VTK JPEG library in case the
# computer does not have a JPEG library.
ln -s $VISITPATH/vtk/lib/libvtkjpeg.dylib $VISITPATH/vtk/lib/libjpeg.dylib
cd ..

===============================================================================
Building Python as a dynamic library
===============================================================================

Python is a powerful, free scripting language that is used to drive VisIt's
viewer when running VisIt without a GUI. Python is cross platform and runs on
many UNIXes as well as MS Windows. VisIt can be configured to run without
Python if scripting features are not desired.  Follow the directions listed
below to build Python.  If you have any problems building or installing Python,
read the README file in the Python distribution for more information.  Python
currently can't be built as a 4-way universal binary, because it depends on
the Carbon framework, which is currently 32-bit, a 2-way build appears to
supported now.

tar zxf Python-2.5.tgz
cd Python-2.5
./configure --prefix=$VISITPATH/python \
OPT="-O3 -Wall -Wstrict-prototypes -fno-common" \
LDFLAGS="-Wl,-headerpad_max_install_names" 
make

# Install Python
make install
# Now that Python is built, we need to modify the install_name.
echo "char **environ=0;" > environhack.c
gcc -c environhack.c -fno-common
mkdir tmp
cd tmp
ar x ../libpython2.5.a
gcc -o ../libpython2.5.dylib -dynamiclib \
../environhack.o *.o -lSystem -lSystemStubs \
-framework Carbon -Wl,-twolevel_namespace \
-Wl,-undefined,dynamic_lookup,-headerpad_max_install_names \
-Wl,-install_name,@executable_path/../lib/libpython2.5.dylib \
-Wl,-compatibility_version,2.5 \
-Wl,-current_version,2.5
cd ..
cp libpython2.5.dylib $VISITPATH/python/lib/python2.5/config/libpython2.5.dylib
cd ..

===============================================================================
Building SZIP as a dynamic library (optional, required with HDF5 or HDF4)
===============================================================================

Szip compression software, providing lossless compression of scientific data,
support is provided with HDF software products as of HDF5 Release 1.6.0
and HDF4 Release 2.0.

tar zxf szip-2.1.tar.gz
cd szip-2.1

# Configure
./configure --prefix=$VISITPATH/szip CFLAGS="-O2 -fno-common"

# make will bomb, but gets far enough
make
# Install SZIP headers
make install

# Create and install dynamic library
gcc -dynamiclib -o libsz.dylib src/*.o \
-Wl,-headerpad_max_install_names,-twolevel_namespace \
-Wl,-install_name @executable_path/../lib/libsz.dylib \
-Wl,-compatibility_version,2.0 \
-Wl,-current_version,2.1 -lSystem

cp libsz.dylib $VISITPATH/szip/lib

cd ..

===============================================================================
Building HDF5 as a dynamic library (optional)
===============================================================================

HDF5 is a data storage library that allows you to efficiently write large
volumes of structured storage to a disk file. VisIt can technically be built
without support for HDF5 so it is an optional, but recommended, package. Though
it is optional, we build it before the Silo library because the Silo library
should be built with support for HDF5 when possible. If you don't want to build
HDF5, you can skip this section but you will have to take care that you do not
attempt to build Silo with support for HDF5. HDF5 uses configure to
determine endianness and configure doesn't support cross-compiling. Therefore
HDF5 meeded to be built on both an Intel machine and a PPC machine. These 
resulting libraries are then merged together to get a universal binary.
HDF5 is now dependent on SZIP (above).

tar zxf hdf5-1.6.5.tar.gz
cd hdf5-1.6.5

HDF5 need more recent configure, and libtool configuration. I used the latest
releases from GNU for m4, autoconf, automake, and libtool. Run autoreconf
to rebuild the GUN build system.

autoreconf -vif

# Build a library for each architecure, on the PPC machine:
./configure --prefix=$VISITPATH/hdf5 CFLAGS="-O2 -fno-common" \
LDFLAGS="-Wl,-headerpad_max_install_names" \
--with-szlib=$VISITPATH/szip

# make will bomb, but gets far enough
make
# Install HDF5 headers
make install

# Create and install dynamic library
##libtool -o libhdf5.dylib -dynamic src/.libs/libhdf5.a -lSystem -lz \
##-twolevel_namespace -undefined dynamic_lookup \
##-headerpad_max_install_names \
##-install_name @executable_path/../lib/libhdf5.dylib \
##-compatibility_version 1.6 -current_version 1.6.5
gcc -dynamiclib -o libhdf5.dylib src/*.o \
-Wl,-headerpad_max_install_names,-twolevel_namespace \
-Wl,-install_name @executable_path/../lib/libhdf5.dylib \
-Wl,-compatibility_version,1.6 -Wl,-current_version,1.6.5 \
-L"$VISITDIR/szip/lib" -lSystem -lsz -lz

cp libhdf5.dylib $VISITPATH/hdf5/lib

cd ..

===============================================================================
Building Mili as a dynamic library  (optional)
===============================================================================

Mili is a database file format library for finite element codes like ls-dyna.
VisIt has a database reader for this popular LLNL engineering database file
format. Mili file format support is optional and is not required for
VisIt to run. Mili doesn't require building on 2 different machines. 

tar zxf mili.tar
cd mili

vi src/mili_internal.h
# After line 56 insert #include <sys/types.h>

# Build
./configure --prefix=$VISITPATH/mili CFLAGS="-O2 -fno-common" \
LDFLAGS="-Wl,-headerpad_max_install_names"

cd MILI-Darwin-*/src

gcc -O2 -fno-common -D_LARGEFILE64_SOURCE -c mili.c direc.c param.c io.c \
util.c dep.c svar.c srec.c mesh_u.c wrap_c.c io_mem.c eprtf.c sarray.c \
gahl.c util.c partition.c ti.c tidirc.c

gcc -dynamiclib -o libmili.dylib mili.o direc.o param.o io.o dep.o \
svar.o srec.o mesh_u.o wrap_c.o io_mem.o eprtf.o sarray.o gahl.o util.o \
partition.o ti.o tidirc.o -Wl,-headerpad_max_install_names,\
-install_name,@executable_path/../lib/libmili.dylib,\
-compatibility_version,1.0,-current_version,1.10.0

mkdir $VISITPATH/mili
cp mili.h $VISITPATH/mili
cp mili_enum.h $VISITPATH/mili
cp libmili.dylib $VISITPATH/mili
cd ../../..

==============================================================================
Building HDF4 as a dynamic library  (optional)
==============================================================================

HDF4 is a data storage library that lets you write large volumes of data to 
disk files and it is the predecessor of HDF5. Like most of the other libraries
mentioned so far, HDF4 does not have a make target to produce a dynamic
library. In fact, its make target for MacOS X produces a static library. Follow
the instructions below for creating universal dynamic libraries. 
This distribution however would not build as 2-way universal binary without
building on separate machines.

HDF4 requires some external software libries, SZIP, ZLIB. and JPEG. ZLIB is
built in to MacOS, JPEG was created during the VTK step above, and SZIP
will be ignored.

# Unpack HDF4
tar zxf HDF4.2r1.tar.gz
cd HDF4.2r1

vi configure
# Note that as of VTK 5.0, the names in the VTK
# jpeg library are mangled so they have a "vtk_" prefix. HDF4 can be built
# against the VTK jpeg library just fine once you get past configure, which
# does not like VTK's mangled jpeg library.
# 
# Comment out lines 5659-5708
#
# insert after line 5708:
# ac_cv_lib_jpeg_jpeg_start_decompress=yes

# 
# Comment out lines 6878-7181 because the script exits with a failure to
# calculate the size of int*.
#
# Insert, after line 7181, ac_cv_sizeof_intp=4
#

vi hdf/src/hdfi.h
# Replace line 739:

#define DF_MT   DFMT_APPLE

# with the following:

#ifdef __i386
#ifndef INTEL86
#define INTEL86   /* we need this Intel define or bad things happen later */
#endif /* INTEL86 */
#define DF_MT   DFMT_APPLE_INTEL
#else
#define DF_MT   DFMT_APPLE
#endif /* __i386 */

# Replace line 889:

#if !(defined(macintosh) || defined(MAC))

# With:

#if !(defined(macintosh) || defined(MAC) || defined (__APPLE__))

# Build
./configure --prefix=$VISITPATH/hdf4 \
CPPFLAGS="-I$VISITPATH/vtk/Utilities -I$VISITPATH/vtk/Utilities/vtkjpeg" \
CFLAGS="-O2 -fno-common" \
LDFLAGS="-Wl,-headerpad_max_install_names" --with-jpeg=$VISITPATH/vtk/lib \
--with-szlib=$VISITPATH/szip --disable-fortran --disable-dependency-tracking

# The build, and install will bomb during test, just ignore
make

# Install headers
make install

# Relink libdf.
gcc -dynamiclib -o libdf.dylib hdf/src/*.o \
-Wl,-headerpad_max_install_names,\
-install_name,@executable_path/../lib/libdf.dylib,\
-compatibility_version,4.0,-current_version,4.2.1 \
-L$VISITPATH/vtk/lib -L$VISITPATH/szip/lib -ljpeg -lsz -lz

cp libdf.dylib $VISITPATH/hdf4/lib

# Relink libmfhdf.
gcc -dynamiclib -o libmfhdf.dylib mfhdf/libsrc/*.o \
-Wl,-headerpad_max_install_names,-undefined,dynamic_lookup,\
-install_name,@executable_path/../lib/libmfhdf.dylib,\
-compatibility_version,4.0,-current_version,4.2.1 \
-L$VISITPATH/vtk/lib -L$VISITPATH/szip/lib -L$VISITPATH/hdf4/lib \
-ljpeg -ldf -lsz -lz

cp libmfhdf.dylib $VISITPATH/hdf4/lib

cd ..

==============================================================================
Building NetCDF as a dynamic library  (optional)
==============================================================================

NetCDF is a scientific data storage library that lets you write platform-
independent binary files. The build system doesn't allow for a universal 
binary build, the endianness and word size is determined in configure, and
cross-compiling doesn't work, so a merge from 2 different machine builds is
needed.

# Unpack NetCDF
tar zxf netcdf.tar.gz
cd netcdf-3.6.0-p1
cd src

# The exodusII library uses the netcdf library for low-level data storage.
# The netcdf library must be modified slightly in order to handle the
# exodusII datamodel. 

vi libsrc/netcdf.h
# Modify the following defines:

#define NC_MAX_DIMS     65536    /* max dimensions per file */
#define NC_MAX_VARS     524288   /* max variables per file */
#define NC_MAX_VAR_DIMS 8        /* max per variable dimensions */

# Have to run configure to create head files on both PPC and Intel machines
./configure --enable-largefile --prefix=$VISITPATH/netcdf/3.6.0 \
"CFLAGS="-O2 -fno-common" CXXFLAGS="-O2 -fno-common" FC=""

# Build the C library 
cd libsrc

gcc -c -O2 -fno-common -DVERSION=`cat ../VERSION` libvers.c
gcc -c -O2 -fno-common attr.c dim.c error.c nc.c ncio.c \
ncx.c putget.c string.c v1hpg.c v2i.c var.c
# Create dynamic library.
gcc -dynamiclib -o ../libnetcdf.dylib attr.o dim.o error.o libvers.o nc.o \
ncio.o ncx.o putget.o string.o v1hpg.o v2i.o var.o \
-Wl,-headerpad_max_install_names,\
-install_name,@executable_path/../lib/libnetcdf.dylib,\
-compatibility_version,3.6,-current_version,3.6.0

# Build the C library 
cd ../cxx
g++ -c -O2 -fno-common -I../libsrc -I.   netcdf.cpp
g++ -c -O2 -fno-common -I../libsrc -I.   ncvalues.cpp
g++ -dynamiclib -o ../libnetcdf_c++.dylib netcdf.o ncvalues.o \
-L.. -lnetcdf -Wl,-headerpad_max_install_names,\
-install_name,@executable_path/../lib/libnetcdf_c++.dylib,\
-compatibility_version,3.6,-current_version,3.6.0
cd ..
# Install header files.
mkdir $VISITPATH/netcdf
mkdir $VISITPATH/netcdf/3.6.0
mkdir $VISITPATH/netcdf/3.6.0/{include,lib}
cp cxx/ncvalues.h $VISITPATH/netcdf/3.6.0/include
cp cxx/netcdf.hh $VISITPATH/netcdf/3.6.0/include
cp cxx/netcdfcpp.h $VISITPATH/netcdf/3.6.0/include
cp libsrc/netcdf.h $VISITPATH/netcdf/3.6.0/include

cp libnetcdf.dylib $VISITPATH/netcdf/3.6.0/lib
cp libnetcdf_c++.dylib $VISITPATH/netcdf/3.6.0/lib
cd ../..


===============================================================================
Building CGNS as a dynamic library  (optional)
===============================================================================
The CFD General Notation System (CGNS) consists of a collection of 
conventions, and software implementing those conventions, for the storage
and retrieval of CFD (computational fluid dynamics) data. The principal 
target of CGNS is data normally associated with compressible viscous flow
(i.e., the Navier-Stokes equations), but the standard is also applicable
to subclasses such as Euler and potential flows.

# Unpack CGNS
tar zxf cgnslib_2.4-3.tar.gz
cd cgnslib_2.4

# CGNS's configure was built with a real old autoconf, so need to use the
# env syntax.
# Configure CGNS
env CFLAGS="-O2 -fno-common" ./configure --prefix=$VISITPATH/cgns/2.4
make

# Install headers, etc.
mkdir $VISITPATH/cgns
mkdir $VISITPATH/cgns/2.4
mkdir $VISITPATH/cgns/include
mkdir $VISITPATH/cgns/lib

make install

# Create dynamic library
libtool -o libcgns.dylib -dynamic DARWIN/libcgns.a -lSystem -lSystemStubs \
-headerpad_max_install_names \
-install_name @executable_path/../lib/libcgns.dylib \
-compatibility_version 2.4 -current_version 2.4

cp libcgns.dylib $VISITPATH/cgns/2.4/lib
cd ..

===============================================================================
Building GDAL as a dynamic library  (optional)
===============================================================================
GDAL is a translator library for raster geospatial data formats that presents
a single abstract data model to the calling application for all supported
formats. The VisIt provided gdal-1.3.0 had problems building, so I'm
using the current gdal-1.3.2 release. The endianness and word size is determined
in configure, and cross-compiling doesn't work so a machine merge is needed.

# Unpack GDAL
tar zxf gdal-1.3.2.tar.gz
cd gdal-1.3.2

# Configure GDAL
./configure --prefix=$VISITPATH/gdal/1.3.2 --with-tiff=internal \ 
--with-gif=internal --with-png=internal --with-jpeg=internal \
--with-libz=internal --with-netcdf=no --without-jasper --without-python \
CFLAGS="-O2 -fno-common" CXXFLAGS="-O2 -fno-common" F77=""

make

# Install GDAL headers, etc.
make install

# Prepare dynamic library
cp .libs/libgdal.1.10.0.dylib libgdal.dylib
install_name_tool -id @executable_path/../lib/libgdal.dylib libgdal.dylib

# 
rm $VISITPATH/gdal/1.3.2/lib/libgdal.dylib
cp libgdal.dylib $VISITPATH/gdal/1.3.2/lib/libgdal.dylib
cd ..

===============================================================================
Building Exodus II as a dynamic library  (optional)
===============================================================================
EXODUS II is a model developed to store and retrieve data for finite element 
analyses. It is used for preprocessing (problem definition), postprocessing 
(results visualization), as well as code to code data transfer. An EXODUS II
data file is a random access, machine independent, binary file that is written
and read via C, C++, or Fortran library routines which comprise the Application 
Programming Interface. (exodusII is based on netcdf). I needed to do a machine
merge in order to get a universal binary.

The EXODUS II library depends on the customized NetCDF library, from above.

#
# Build and install the exodus libraries.
#
tar zxf exodusii-4.46.tar.gz
cd exodusii-4.46/cbind/src

# Build the Exodus II source (note that it requires NetCDF)
export NETCDFLIB=$VISITPATH/netcdf/3.6.0/lib
export NETCDFINC=$VISITPATH/netcdf/3.6.0/include
gcc -O2 -fno-common -I../include -I$NETCDFINC -c *.c

# Build a universal dynamic library
gcc -dynamiclib -o libexoIIv2c.dylib *.o -Wl,-headerpad_max_install_names,\
-install_name,@executable_path/../lib/libexoIIv2c.dylib,\
-compatibility_version,4.0,-current_version,4.46 \
-L$NETCDFLIB -lnetcdf

# Install Exodus
mkdir $VISITPATH/exodus
mkdir $VISITPATH/exodus/4.46
mkdir $VISITPATH/exodus/4.46/{inc,lib}
cp libexoIIv2c.dylib $VISITPATH/exodus/4.46/lib
cp ../include/*.h $VISITPATH/exodus/4.46/inc
ln -s $VISITPATH/netcdf/3.6.0/include/netcdf.h \
$VISITPATH/exodus/4.46/inc/netcdf.h
cd ../../..

===============================================================================
Building Silo as a dynamic library  (optional)
===============================================================================

Silo is a self-describing, machine-independent scientific file format.
Silo is one of the file formats supported by VisIt.  Follow the directions
listed below to build Silo.  If you have any problems building or installing
Silo, read the INSTALL_NOTES file in the SILO distribution for more
information.

Note that these instructions assume that Silo will be built with HDF5 support.
If you build Silo with HDF5 support then you must have first built HDF5 using
the instructions provided earlier in this document. If you don't want to build
Silo with HDF5 support, replace the --with-hdf5=... with --without-hdf5.
The library segment offsets used assume that Silo will be built with support
for HDF5. I needed to do a machine merge in order to get a universal binary,
because the endianness and word size is determined in configure.

# Build silo source into an archive library
sh silo060605.sh
cd silo060605
#

# Need to fake-out dependency tracking.
mv include/make-depend-gnu.in include/make-depend-gnu.in.orig
cp include/make-depend-std.in include/make-depend-gnu.in
#
# Set the values of some helper variables
export HDF5INCLUDE=$VISITPATH/hdf5/include
export HDF5LIB=$VISITPATH/hdf5/lib
ln -s $VISITPATH/szip/lib/libsz.dylib $VISITPATH/hdf5/lib/libsz.dylib

# Edit configure, replacing all occurences of "-lhdf5" with "-lhdf5 -lsz".
cat configure | sed 's/-lhdf5/-lhdf5 -lsz/' > tmp.conf
mv configure configure.orig
mv tmp.conf configure
chmod +x configure

./configure --prefix=$VISITPATH/silo CFLAGS="-O2 -fno-common" \
CXXFLAGS="-O2 -fno-common" \
LDFLAGS="-Wl,-headerpad_max_install_names,-undefined,dynamic_lookup" \
--disable-sdx --disable-browser --without-readline \
--without-exodus --without-python --with-hdf5=$HDF5INCLUDE,$HDF5LIB

# Compile the needed subroutines. Force make to ignore errors from
# archive creation, it should get us to where we want to be.
make -i

gcc -dynamiclib -o libsilo.dylib silo/*/*.o \
-Wl,-headerpad_max_install_names,\
-install_name,@executable_path/../lib/libsilo.dylib,\
-compatibility_version,4.5,-current_version,4.5.1 \
-L$HDF5LIB -lhdf5 -lsz -lz

# Install headers. Ignore archive creation errors.
make -i install

# Install Silo
cp libsilo.dylib  $VISITPATH/silo/lib
cd ..

===============================================================================
Building Boxlib as a dynamic library (optional)
===============================================================================

Boxlib is an I/O library for reading and writing structured AMR mesh data.
I needed to do a machine merge in order to get a universal binary.

#
# Build Boxlib.
#
# Boxlib requires a Fortran compiler, skip the Boxlib building if you
# don't have access to a Fortran compiler

tar -zxf boxlib.tar.gz
cd CCSEApps/BoxLib

vi GNUmakefile
# You will need to add -fno-common
# to the compile flags.
# This can be done by adding the lines:
CXXFLAGS += -fno-common
CCFLAGS += -fno-common
# near the top of the file GNUmakefile.
#
# Change: 
DEBUG = FALSE
USE_MPI = FALSE
COMP =

vi BaseFab.cpp
# Comment out the references to Fortran routines FORT_FASTCOPY, and 
# FORT_SETVAL, in BaseFab.cpp,
# Comment out lines 101 and 102:
    if (destbox == domain && srcbox == src.box())
    {
# to:
//    if (destbox == domain && srcbox == src.box())
//    {
# Do the same thing to lines: 110 through 135, 148, 149, 156 through 173

vi FPC.cpp
# Add the Apple macro defination to FPC.cpp.
# At lines 67, 94, and 140 change:
# defined(__sun) || \
#to: 
# defined(__sun) || defined(__ppc__) || defined(__ppc64__) || \

vi Make.package
# Comment out the Fortran interfaces starting a line 94:
#f$(BOXLIB_BASE)_sources += BLutil_F.f
#f$(BOXLIB_BASE)_sources += BLParmParse_F.f
#f$(BOXLIB_BASE)_sources += BLBoxLib_F.f

#F$(BOXLIB_BASE)_sources += SPECIALIZE_$(DIM)D.F
#F$(BOXLIB_BASE)_headers += SPECIALIZE_F.H

# Create a Darwin Makefile templet:
cp ../mk/Make.FreeBSD ../mk/Make.Darwin

#
# Start off by building the 3d version.
# 
# Don't want the fortran bindings, so we'll try and bull I way through to that
# part.
make -f GNUmakefile

# Build a dynamic library
libtool -o libbox3D.dylib -dynamic libbox3d.Darwin.CC.f77.a -lSystem \
-twolevel_namespace -undefined dynamic_lookup -headerpad_max_install_names \
-install_name @executable_path/../lib/libbox3D.dylib \
-compatibility_version 2.0 -current_version 2.5

tar cf Boxlib3D.h.tar *.H
#
# Now build the 2d version.
#
make clean

vi GNUmakefile
# You will need to modify the GNUmakefile to set the dimension to 2.  This
# will involve replacing "3" with "2" in the line "DIM       = 3".
#
make -f GNUmakefile

# Build a universal dynamic library
libtool -o libbox2D.dylib -dynamic libbox2d.Darwin.CC.f77.a -lSystem \
-twolevel_namespace -undefined dynamic_lookup -headerpad_max_install_names \
-install_name @executable_path/../lib/libbox2D.dylib \
-compatibility_version 2.0 -current_version 2.5

tar cf Boxlib2D.h.tar *.H
#
# Install#
mkdir $VISITPATH/boxlib
mkdir $VISITPATH/boxlib/include
mkdir $VISITPATH/boxlib/lib
mkdir $VISITPATH/boxlib/include/2D
mkdir $VISITPATH/boxlib/include/3D
cp libbox3D.dylib $VISITPATH/boxlib/lib/
cp libbox2D.dylib $VISITPATH/boxlib/lib/

#
# Install the header files.
#
cp Boxlib2D.h.tar $VISITPATH/boxlib/include/2D
cp Boxlib3D.h.tar $VISITPATH/boxlib/include/3D
cd $VISITPATH/boxlib/include/2D
tar xf Boxlib2D.h.tar
cd $VISITPATH/boxlib/include/3D
tar xf Boxlib3D.h.tar
cd $VISITPATH
cd ..

===============================================================================
Building CFITSIO as a dynamic library (Optional)
===============================================================================

CFITSIO is a library for reading FITS files. FITS stands for `Flexible Image 
Transport System' and is the standard astronomical data format endorsed by 
both NASA and the IAU. FITS is much more than an image format (such as JPG 
or GIF) and is primarily designed to store scientific data sets consisting 
of multi-dimensional arrays (1-D spectra, 2-D images or 3-D data cubes) and
2-dimensional tables containing rows and columns of data.
Cfitsio uses an old autoconf, only makeing a static library.
I could build a 2-way universal binary.

#
# Build CFITSIO
#
tar zxf cfitsio3006.tar.gz
cd cfitsio

#
env CFLAGS="-O2 -fno-common" LDFLAGS="-Wl,-headerpad_max_install_names" \
./configure --prefix=$VISITPATH/cfitsio/3006

make
# Build a dynamic library
libtool -o libcfitsio.dylib -dynamic libcfitsio.a -lSystem \
-twolevel_namespace -headerpad_max_install_names \
-install_name @executable_path/../lib/libcfits.dylib \
-compatibility_version 3.0 -current_version 3.006

# Install.
mkdir $VISITPATH/cfitsio
make install
cd ..
#

===============================================================================
Building H5Part as a dynamic library (optional)
===============================================================================

H5Part is a very simple data storage schema and provides an API that simplifies the reading/writing of the data to the HDF5 file format.

tar zxf H5Part-1.4.0.tar.gz
cd H5Part-1.4.0

# Configure
./configure --prefix=$VISITPATH/H5Part CFLAGS="-O2 -fno-common"

# build
make
# Install headers
make install

# Create and install dynamic library
libtool -o libH5Part.dylib -dynamic libH5Part.a -lSystem \
-twolevel_namespace -headerpad_max_install_names \
-install_name @executable_path/../lib/libH5Part.dylib \
-compatibility_version 1.4 -current_version 1.4.0

cp libH5Part.dylib $VISITPATH/H5Part/lib

cd ..

===============================================================================
Building VisIt
===============================================================================

VisIt uses GNU's autoconf system to provide platform independence when
building VisIt in a UNIX environment. Autoconf creates a script called
configure that tests your system for various libraries and programs required
to build VisIt.  Follow the directions listed below to build VisIt.
More information about building VisIt follows after that.

#
# Unzipping VisIt's source code distribution
#
tar zxf visit070702.tar.gz
cd visit070702/src

#
# HDF5 and Silo
#
If you built the Silo library with support for HDF5 using the instructions in
this document then create a symbolic link to it from the Silo directory so 
VisIt's configure script will find it..

ln -s $VISITPATH/hdf5/lib/libhdf5.dylib $VISITPATH/silo/lib/libhdf5.dylib

#
# Configure VisIt
# The example Mac configurations are config-site/tread.llnl.gov.conf and
# config-site/tread.local.conf
#
cd config-site
echo VISITHOME=`cat ../../../visitpath` > `hostname`.conf
cat Template.conf >> `hostname`.conf
# Edit `hostname`.conf so that:
QT_BIN=$VISITHOME/qt/bin
QT_INCLUDE=$VISITHOME/qt/include
QT_LIB=$VISITHOME/qt/lib
MESA=$VISITHOME/mesa
VTK=$VISITHOME/vtk
PYDIR=$VISITHOME/python     
PYVERSION=python2.5
DEFAULT_BOXLIB2D_INCLUDE=$VISITHOME/boxlib/include/2D
DEFAULT_BOXLIB2D_LIBS=$VISITHOME/boxlib/lib
DEFAULT_BOXLIB3D_INCLUDE=$VISITHOME/boxlib/include/3D
DEFAULT_BOXLIB3D_LIBS=$VISITHOME/boxlib/lib
DEFAULT_CFITSIO_INCLUDE=$VISITHOME/cfitsio/3006/include
DEFAULT_CFITSIO_LIB=$VISITHOME/cfitsio/3006/lib
DEFAULT_CGNS_INCLUDE=$VISITHOME/cgns/2.4/include                            
DEFAULT_CGNS_LIB=$VISITHOME/cgns/2.4/lib
DEFAULT_EXODUS_INCLUDES=$VISITHOME/exodusII/include
DEFAULT_EXODUS_LIBRARY=$VISITHOME/exodusII/lib
DEFAULT_GDAL_INCLUDE=$VISITHOME/gdal/1.3.2/include                            
DEFAULT_GDAL_LIB=$VISITHOME/gdal/1.3.2/lib                            
DEFAULT_H5PART_INCLUDE=$VISITHOME/h5part/include
DEFAULT_H5PART_LIB=$VISITHOME/h5part/lib
DEFAULT_HDF4_FLAGS=$VISITHOME/hdf4/include                                
DEFAULT_HDF4_LIBS=$VISITHOME/hdf4/lib
DEFAULT_HDF5_INCLUDE=$VISITHOME/hdf5/include             
DEFAULT_HDF5_LIB=$VISITHOME/hdf5/lib
MILI_DIR=$VISITHOME/mili
DEFAULT_NETCDF_INCLUDE=$VISITHOME/netcdf/3.6.0/include
DEFAULT_NETCDF_LIB=$VISITHOME/netcdf/3.6.0/lib
DEFAULT_SILO_INCLUDES=$VISITHOME/silo/include
DEFAULT_SILO_LIBRARY=$VISITHOME/silo/lib
DEFAULT_SZIP_INCLUDE=$VISITHOME/szip/include
DEFAULT_SZIP_LIB=$VISITHOME/szip/lib

cd ..

./configure --enable-visitmodule
#
# If VisIt failed to configure properly, check the contents of the
# `hostname`.conf file to make sure that it points to the libraries that
# you build. You can look at tread.local.conf, which is a configuration file
# for another MacOS X computer, if you want an example file that works.
#

# Patch some problems with some make files
cat databases/Fluent/Makefile | sed '/CXXFLAGS/s/$/ -O0/g' > Make.tmp
mv -f databases/Fluent/Makefile databases/Fluent/Makefile.orig
mv -f Make.tmp databases/Fluent/Makefile
cat databases/SimV1/Makefile | \
  sed '/LDFLAGS/s/$/ -Wl,-undefined,dynamic_lookup/g' > Make.tmp
mv -f databases/SimV1/Makefile databases/SimV1/Makefile.orig
mv -f Make.tmp databases/SimV1/Makefile
cat databases/SimV1Writer/Makefile | \
  sed '/LDFLAGS/s/$/ -Wl,-undefined,dynamic_lookup/g' > Make.tmp
mv -f databases/SimV1Writer/Makefile databases/SimV1Writer/Makefile.orig
mv -f Make.tmp databases/SimV1Writer/Makefile
# Build VisIt
make

# Create a binary distribution tarball, which for an Intel Mac will create
# a visit1_6.darwin-i386.tar.gz file of about 60Mbytes.
clearcase_bin/visit-bin-dist

# To install the binaries in a directory called "INSTALL_DIR_PATH"
clearcase_bin/visit-install 1.6 darwin-i386 INSTALL_DIR_PATH

# To install the PPC binaries in a directory called "INSTALL_DIR_PATH", and
# create a disk image file called Visit-1.6.dmg containing both images, use:
clearcase_bin/visit-install -dmg 1.6 darwin-ppc INSTALL_DIR_PATH

If you have any problems send e-mail to visit-developers@ornl.gov.

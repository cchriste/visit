Initialization: collections
    // create pre-defined collection classes (currently just "whole")
    int wholeCollectionClassId = collections.size();
    avtSILCollectionMetaData wholeCollectionClass("whole", meshName, 1, -1, -1, -1, NULL);
    AddCollections(wholeCollectionClass);

Initialization: theStorageChunkClassId
    // initially, we don't know the storage chunk class id
    theStorageChunkClassId = -1;

Initialization: classIds
    classIds.push_back(wholeCollectionClassId);

Initialization: classDisjointFlags
    classDisjointFlags.push_back(1);

Function: avtSILMetaData2
Declaration: avtSILMetaData(const std::string &_meshName);
Definition:
// ****************************************************************************
//  Method: avtSILMetaData default constructor 
//
//  Programmer:  Mark C. Miller
//  Creation:    02Sep03 
//
// ****************************************************************************
avtSILMetaData::avtSILMetaData(const std::string &_meshName)
    : AttributeSubject(avtSILMetaData::TypeMapFormatString)
{
    meshName = _meshName;

    // initially, we don't know the storage chunk class id
    theStorageChunkClassId = -1;

    // create pre-defined collection classes (currently just "whole")
    int wholeCollectionClassId = collections.size();
    avtSILCollectionMetaData wholeCollectionClass("whole", _meshName, 1, -1, -1, -1, NULL);
    AddCollections(wholeCollectionClass);

    classDisjointFlags.push_back(1);
    classIds.push_back(wholeCollectionClassId);
}

Function: Print
Declaration: void Print(ostream &, int = 0) const;
Definition:
// ****************************************************************************
//  Method: avtSILMetaData::Print
//
//  Programmer:  Mark C. Miller
//  Creation:    02Sep03 
//
// ****************************************************************************
inline void
Indent(ostream &out, int indent)
{
    for (int i = 0 ; i < indent ; i++)
    {
        out << "\t";
    }
}
void
avtSILMetaData::Print(ostream& out, int indent) const
{
    int i;

    Indent(out, indent);
    out << "Mesh Name = " << meshName.c_str() << endl;

    Indent(out, indent);
    out << "Number of collection classes = " << classIds.size() << endl;

    Indent(out, indent);
    out << "Collection class names are..." << endl;
    for (i = 0; i < classIds.size(); i++)
    {
       Indent(out, indent+8);
       out << GetCollections(classIds[i]).GetClassName().c_str() << endl;
    }

    Indent(out, indent);
    out << "The storage chunk class = " <<
       GetCollections(theStorageChunkClassId).GetClassName().c_str() << endl;

    Indent(out, indent);
    out << "Collection details are..." << endl;
    for (i = 0; i < collections.size(); i++)
       GetCollections(i).Print(out,indent+8);

}

Function: GetCollectionClassId
Declaration: int GetCollectionClassId(const std::string& className) const;
Definition:
// ****************************************************************************
//  Method: avtSILMetaData::GetCollectionClassId
//
//  Programmer:  Mark C. Miller
//  Creation:    02Sep03 
//
// ****************************************************************************
int
avtSILMetaData::GetCollectionClassId(const std::string& className) const
{
    for (int i = 0; i < classIds.size(); i++)
    {
        const avtSILCollectionMetaData &obj = GetCollections(classIds[i]);
        if (className == obj.GetClassName())
            return classIds[i];
    }
    return -1;
}

Function: AddCollectionClass
Declaration: int AddCollectionClass(const std::string &className, const std::string &defaultMemberBasename, int numSetsInClass, int pairwiseDisjoint = 0, bool hideFromWhole = false, bool isStorageChunkClass = false);
Definition:
// ****************************************************************************
//  Method: avtSILMetaData::AddCollectionClass
//
//  Purpose: Add a collection class to SIL metadata. A collection class is an
//  awful lot like a collection. In fact, it can be thought of as being
//  implemented as a collection on the whole though if hideFromWhole is true,
//  it won't be 'visible' on the whole from inside VisIt.
//
//  Collection class names must be unique. Only one collection class can be
//  created that has isStorageChunkClass true. Finally, the count of the number
//  of members in the collection class is a global count over the SIL of
//  sets of the associated class. For example, if you are creating a collection
//  class for patches in a block-structured AMR mesh, the numMembers you
//  would pass here is the total number of patches over all levels. Each
//  'entry' in the collection class uniquely identifies one of the patches.
//
//  Programmer:  Mark C. Miller
//  Creation:    02Sep03 
//
//  Modifications:
//    Brad Whitlock, Tue Mar 6 11:56:49 PDT 2007
//    Made it use methods for autogeneration.
//
// ****************************************************************************
int
avtSILMetaData::AddCollectionClass(const std::string &className,
   const std::string &defaultMemberBasename, int numMembers,
   int pairwiseDisjoint, bool hideFromWhole, bool isStorageChunkClass)
{
    int newCollectionClassId = collections.size();

    // make sure the number of members is sane
    if (numMembers <= 0)
    {
        EXCEPTION1(ImproperUseException, className);
    }

    // make sure the class name is unique
    for (int i = 0; i < classIds.size(); i++)
    {
        const avtSILCollectionMetaData &obj = GetCollections(classIds[i]);
        if (className == obj.GetClassName())
        {
            EXCEPTION1(ImproperUseException, className);
        }
    }

    // create the collection class entry
    avtSILCollectionMetaData newCollectionClass(className, defaultMemberBasename,
        numMembers, -1, -1, -1, NULL);
    AddCollections(newCollectionClass);

    classDisjointFlags.push_back(pairwiseDisjoint);
    classIds.push_back(newCollectionClassId);

    if (isStorageChunkClass)
    {
        if (theStorageChunkClassId != -1)
        {
            EXCEPTION1(ImproperUseException, className);
        }
 
        theStorageChunkClassId = newCollectionClassId;
    }

    return newCollectionClassId;
}

Function: AddCollection
Declaration: int AddCollection(const std::string &classOfCollection, const std::string &defaultMemberBasename, int collectionSize, int collectionIdOfParent, int indexOfParent, int collectionIdOfChildren = 0, int *indicesOfChildren = NULL);
Definition:
// ****************************************************************************
//  Method: avtSILMetaData::AddCollection 
//
//  Purpose: Add a collection to SIL meta data. A collection can be created
//  'from scratch' or in terms of another collection. In the former mode,
//  the caller does NOT specify either the collectionIdOfChildren of
//  indicesOfChildren arguments. In the later mode, the caller specifies
//  both of these arguments. The indicesOfChildren argument enumerates which
//  sets in the collection identified by collectionIdOfChildren, are in the
//  collection being here defined and, consequently, subsets of the set
//  identified by the pair <collectionIdOfParent,indexOfParent>.
//
//  Programmer:  Mark C. Miller
//  Creation:    02Sep03 
//
// ****************************************************************************
int
avtSILMetaData::AddCollection(
   const std::string &classOfCollection, const std::string &defaultMemberBasename,
   int collectionSize, int collectionIdOfParent, int indexOfParent,
   int collectionIdOfChildren, int *indicesOfChildren)
{
    int newCollectionId = GetNumCollections();

    if(collectionIdOfParent < 0 || collectionIdOfParent >= GetNumCollections())
    {
        EXCEPTION2(BadIndexException, collectionIdOfParent, GetNumCollections());
    }

    avtSILCollectionMetaData &parentCollection = GetCollections(collectionIdOfParent);
    if (indexOfParent < 0 || indexOfParent >= parentCollection.GetSize())
    {
        EXCEPTION2(BadIndexException, indexOfParent, parentCollection.GetSize());
    }

    if (collectionIdOfChildren < 0 && indicesOfChildren != NULL)
    {
        EXCEPTION1(ImproperUseException, classOfCollection);
    }

    if (collectionIdOfChildren >= 0)
    {
        avtSILCollectionMetaData &childrenCollection = GetCollections(collectionIdOfChildren);
        if (classOfCollection != childrenCollection.GetClassName())
        {
            EXCEPTION1(ImproperUseException, classOfCollection);
        }

        if (indicesOfChildren)
        {
            for (int i = 0; i < collectionSize; i++)
            {
                if (indicesOfChildren[i] >= childrenCollection.GetSize())
                {
                    EXCEPTION2(BadIndexException, indicesOfChildren[i], childrenCollection.GetSize());
                }
            }
        }  
    }

    avtSILCollectionMetaData newCollection(classOfCollection, defaultMemberBasename,
        collectionSize, collectionIdOfParent, indexOfParent,
        collectionIdOfChildren, indicesOfChildren);
    AddCollections(newCollection);

    return newCollectionId;
}

Function: Validate
Declaration: void Validate(void);
Definition:
// ****************************************************************************
//  Method: avtSILMetaData::Validate
//
//  Purpose: check a SIL meta data object for errors.
//
//  Programmer:  Mark C. Miller
//  Creation:    02Sep03 
//
// ****************************************************************************
void
avtSILMetaData::Validate()
{
    if (theStorageChunkClassId == -1)
    {
        EXCEPTION0(ImproperUseException);
    }

    for (int i = 0; i < GetNumCollections(); i++)
    {
        const avtSILCollectionMetaData &coll = GetCollections(i);
  
        if ((coll.collectionIdOfChildren > 0) &&
            (GetCollections(coll.collectionIdOfChildren).GetType() != avtSILCollectionMetaData::Class))
        {
            if (coll.indicesOfChildren.size() == 0)
            {
                EXCEPTION0(ImproperUseException);
            }
   
            const avtSILCollectionMetaData &childColl = GetCollections(coll.collectionIdOfChildren);
  
            if (coll.collectionSize > childColl.collectionSize)
            {
                EXCEPTION0(ImproperUseException);
            }
   
            for (int j = 0; j < coll.collectionSize; j++)
            {
                if ((coll.indicesOfChildren[i] < 0) ||
                    (coll.indicesOfChildren[i] >= childColl.collectionSize))
                {
                    EXCEPTION2(BadIndexException, coll.indicesOfChildren[i],
                               childColl.collectionSize);
                }
            }
        }
    }
}


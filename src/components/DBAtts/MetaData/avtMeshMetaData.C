/*****************************************************************************
*
* Copyright (c) 2000 - 2007, The Regents of the University of California
* Produced at the Lawrence Livermore National Laboratory
* All rights reserved.
*
* This file is part of VisIt. For details, see http://www.llnl.gov/visit/. The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or materials provided with the distribution.
*  - Neither the name of the UC/LLNL nor  the names of its contributors may be
*    used to  endorse or  promote products derived from  this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED.  IN  NO  EVENT  SHALL  THE  REGENTS  OF  THE  UNIVERSITY OF
* CALIFORNIA, THE U.S.  DEPARTMENT  OF  ENERGY OR CONTRIBUTORS BE  LIABLE  FOR
* ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

#include <avtMeshMetaData.h>
#include <DataNode.h>

// Type map format string
const char *avtMeshMetaData::TypeMapFormatString = "ssbiiiiissssssbDDiisss*iissi*bibbbbibFbD";

// ****************************************************************************
// Method: avtMeshMetaData::avtMeshMetaData
//
// Purpose: 
//   Constructor for the avtMeshMetaData class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:17 PST 2007
//
// Modifications:
//   
// ****************************************************************************

avtMeshMetaData::avtMeshMetaData() : 
    AttributeSubject(avtMeshMetaData::TypeMapFormatString)
{
    name = "mesh";
    validVariable = true;
    meshType = AVT_UNKNOWN_MESH;
    meshCoordType = AVT_XY;
    cellOrigin = 0;
    spatialDimension = 3;
    topologicalDimension = 3;
    xLabel = "X-Axis";
    yLabel = "Y-Axis";
    zLabel = "Z-Axis";
    hasSpatialExtents = false;
    minSpatialExtents[0] = 0;
    minSpatialExtents[1] = 0;
    minSpatialExtents[2] = 0;
    maxSpatialExtents[0] = 0;
    maxSpatialExtents[1] = 0;
    maxSpatialExtents[2] = 0;
    numBlocks = 1;
    blockOrigin = 0;
    blockPieceName = "domain";
    blockTitle = "domains";
    numGroups = 0;
    groupOrigin = 0;
    groupPieceName = "group";
    groupTitle = "groups";
    disjointElements = false;
    containsGhostZones = AVT_MAYBE_GHOSTS;
    containsOriginalCells = false;
    containsOriginalNodes = false;
    containsGlobalNodeIds = false;
    containsGlobalZoneIds = false;
    loadBalanceScheme = LOAD_BALANCE_UNKNOWN;
    nodesAreCritical = false;
    unitCellVectors[0] = 1;
    unitCellVectors[1] = 0;
    unitCellVectors[2] = 0;
    unitCellVectors[3] = 0;
    unitCellVectors[4] = 1;
    unitCellVectors[5] = 0;
    unitCellVectors[6] = 0;
    unitCellVectors[7] = 0;
    unitCellVectors[8] = 1;
    rectilinearGridHasTransform = false;
    rectilinearGridTransform[0] = 1;
    rectilinearGridTransform[1] = 0;
    rectilinearGridTransform[2] = 0;
    rectilinearGridTransform[3] = 0;
    rectilinearGridTransform[4] = 0;
    rectilinearGridTransform[5] = 1;
    rectilinearGridTransform[6] = 0;
    rectilinearGridTransform[7] = 0;
    rectilinearGridTransform[8] = 0;
    rectilinearGridTransform[9] = 0;
    rectilinearGridTransform[10] = 1;
    rectilinearGridTransform[11] = 0;
    rectilinearGridTransform[12] = 0;
    rectilinearGridTransform[13] = 0;
    rectilinearGridTransform[14] = 0;
    rectilinearGridTransform[15] = 1;
}

// ****************************************************************************
// Method: avtMeshMetaData::avtMeshMetaData
//
// Purpose: 
//   Copy constructor for the avtMeshMetaData class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:17 PST 2007
//
// Modifications:
//   
// ****************************************************************************

avtMeshMetaData::avtMeshMetaData(const avtMeshMetaData &obj) : 
    AttributeSubject(avtMeshMetaData::TypeMapFormatString)
{
    int i;

    name = obj.name;
    originalName = obj.originalName;
    validVariable = obj.validVariable;
    meshType = obj.meshType;
    meshCoordType = obj.meshCoordType;
    cellOrigin = obj.cellOrigin;
    spatialDimension = obj.spatialDimension;
    topologicalDimension = obj.topologicalDimension;
    xUnits = obj.xUnits;
    yUnits = obj.yUnits;
    zUnits = obj.zUnits;
    xLabel = obj.xLabel;
    yLabel = obj.yLabel;
    zLabel = obj.zLabel;
    hasSpatialExtents = obj.hasSpatialExtents;
    minSpatialExtents[0] = obj.minSpatialExtents[0];
    minSpatialExtents[1] = obj.minSpatialExtents[1];
    minSpatialExtents[2] = obj.minSpatialExtents[2];

    maxSpatialExtents[0] = obj.maxSpatialExtents[0];
    maxSpatialExtents[1] = obj.maxSpatialExtents[1];
    maxSpatialExtents[2] = obj.maxSpatialExtents[2];

    numBlocks = obj.numBlocks;
    blockOrigin = obj.blockOrigin;
    blockPieceName = obj.blockPieceName;
    blockTitle = obj.blockTitle;
    blockNames = obj.blockNames;
    numGroups = obj.numGroups;
    groupOrigin = obj.groupOrigin;
    groupPieceName = obj.groupPieceName;
    groupTitle = obj.groupTitle;
    groupIds = obj.groupIds;
    disjointElements = obj.disjointElements;
    containsGhostZones = obj.containsGhostZones;
    containsOriginalCells = obj.containsOriginalCells;
    containsOriginalNodes = obj.containsOriginalNodes;
    containsGlobalNodeIds = obj.containsGlobalNodeIds;
    containsGlobalZoneIds = obj.containsGlobalZoneIds;
    loadBalanceScheme = obj.loadBalanceScheme;
    nodesAreCritical = obj.nodesAreCritical;
    for(i = 0; i < 9; ++i)
        unitCellVectors[i] = obj.unitCellVectors[i];

    rectilinearGridHasTransform = obj.rectilinearGridHasTransform;
    for(i = 0; i < 16; ++i)
        rectilinearGridTransform[i] = obj.rectilinearGridTransform[i];


    SelectAll();
}

// ****************************************************************************
// Method: avtMeshMetaData::~avtMeshMetaData
//
// Purpose: 
//   Destructor for the avtMeshMetaData class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:17 PST 2007
//
// Modifications:
//   
// ****************************************************************************

avtMeshMetaData::~avtMeshMetaData()
{
    // nothing here
}

// ****************************************************************************
// Method: avtMeshMetaData::operator = 
//
// Purpose: 
//   Assignment operator for the avtMeshMetaData class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:17 PST 2007
//
// Modifications:
//   
// ****************************************************************************

avtMeshMetaData& 
avtMeshMetaData::operator = (const avtMeshMetaData &obj)
{
    if (this == &obj) return *this;
    int i;

    name = obj.name;
    originalName = obj.originalName;
    validVariable = obj.validVariable;
    meshType = obj.meshType;
    meshCoordType = obj.meshCoordType;
    cellOrigin = obj.cellOrigin;
    spatialDimension = obj.spatialDimension;
    topologicalDimension = obj.topologicalDimension;
    xUnits = obj.xUnits;
    yUnits = obj.yUnits;
    zUnits = obj.zUnits;
    xLabel = obj.xLabel;
    yLabel = obj.yLabel;
    zLabel = obj.zLabel;
    hasSpatialExtents = obj.hasSpatialExtents;
    minSpatialExtents[0] = obj.minSpatialExtents[0];
    minSpatialExtents[1] = obj.minSpatialExtents[1];
    minSpatialExtents[2] = obj.minSpatialExtents[2];

    maxSpatialExtents[0] = obj.maxSpatialExtents[0];
    maxSpatialExtents[1] = obj.maxSpatialExtents[1];
    maxSpatialExtents[2] = obj.maxSpatialExtents[2];

    numBlocks = obj.numBlocks;
    blockOrigin = obj.blockOrigin;
    blockPieceName = obj.blockPieceName;
    blockTitle = obj.blockTitle;
    blockNames = obj.blockNames;
    numGroups = obj.numGroups;
    groupOrigin = obj.groupOrigin;
    groupPieceName = obj.groupPieceName;
    groupTitle = obj.groupTitle;
    groupIds = obj.groupIds;
    disjointElements = obj.disjointElements;
    containsGhostZones = obj.containsGhostZones;
    containsOriginalCells = obj.containsOriginalCells;
    containsOriginalNodes = obj.containsOriginalNodes;
    containsGlobalNodeIds = obj.containsGlobalNodeIds;
    containsGlobalZoneIds = obj.containsGlobalZoneIds;
    loadBalanceScheme = obj.loadBalanceScheme;
    nodesAreCritical = obj.nodesAreCritical;
    for(i = 0; i < 9; ++i)
        unitCellVectors[i] = obj.unitCellVectors[i];

    rectilinearGridHasTransform = obj.rectilinearGridHasTransform;
    for(i = 0; i < 16; ++i)
        rectilinearGridTransform[i] = obj.rectilinearGridTransform[i];


    SelectAll();
    return *this;
}

// ****************************************************************************
// Method: avtMeshMetaData::operator == 
//
// Purpose: 
//   Comparison operator == for the avtMeshMetaData class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:17 PST 2007
//
// Modifications:
//   
// ****************************************************************************

bool
avtMeshMetaData::operator == (const avtMeshMetaData &obj) const
{
    int i;

    // Compare the minSpatialExtents arrays.
    bool minSpatialExtents_equal = true;
    for(i = 0; i < 3 && minSpatialExtents_equal; ++i)
        minSpatialExtents_equal = (minSpatialExtents[i] == obj.minSpatialExtents[i]);

    // Compare the maxSpatialExtents arrays.
    bool maxSpatialExtents_equal = true;
    for(i = 0; i < 3 && maxSpatialExtents_equal; ++i)
        maxSpatialExtents_equal = (maxSpatialExtents[i] == obj.maxSpatialExtents[i]);

    // Compare the unitCellVectors arrays.
    bool unitCellVectors_equal = true;
    for(i = 0; i < 9 && unitCellVectors_equal; ++i)
        unitCellVectors_equal = (unitCellVectors[i] == obj.unitCellVectors[i]);

    // Compare the rectilinearGridTransform arrays.
    bool rectilinearGridTransform_equal = true;
    for(i = 0; i < 16 && rectilinearGridTransform_equal; ++i)
        rectilinearGridTransform_equal = (rectilinearGridTransform[i] == obj.rectilinearGridTransform[i]);

    // Create the return value
    return ((name == obj.name) &&
            (originalName == obj.originalName) &&
            (validVariable == obj.validVariable) &&
            (meshType == obj.meshType) &&
            (meshCoordType == obj.meshCoordType) &&
            (cellOrigin == obj.cellOrigin) &&
            (spatialDimension == obj.spatialDimension) &&
            (topologicalDimension == obj.topologicalDimension) &&
            (xUnits == obj.xUnits) &&
            (yUnits == obj.yUnits) &&
            (zUnits == obj.zUnits) &&
            (xLabel == obj.xLabel) &&
            (yLabel == obj.yLabel) &&
            (zLabel == obj.zLabel) &&
            (hasSpatialExtents == obj.hasSpatialExtents) &&
            minSpatialExtents_equal &&
            maxSpatialExtents_equal &&
            (numBlocks == obj.numBlocks) &&
            (blockOrigin == obj.blockOrigin) &&
            (blockPieceName == obj.blockPieceName) &&
            (blockTitle == obj.blockTitle) &&
            (blockNames == obj.blockNames) &&
            (numGroups == obj.numGroups) &&
            (groupOrigin == obj.groupOrigin) &&
            (groupPieceName == obj.groupPieceName) &&
            (groupTitle == obj.groupTitle) &&
            (groupIds == obj.groupIds) &&
            (disjointElements == obj.disjointElements) &&
            (containsGhostZones == obj.containsGhostZones) &&
            (containsOriginalCells == obj.containsOriginalCells) &&
            (containsOriginalNodes == obj.containsOriginalNodes) &&
            (containsGlobalNodeIds == obj.containsGlobalNodeIds) &&
            (containsGlobalZoneIds == obj.containsGlobalZoneIds) &&
            (loadBalanceScheme == obj.loadBalanceScheme) &&
            (nodesAreCritical == obj.nodesAreCritical) &&
            unitCellVectors_equal &&
            (rectilinearGridHasTransform == obj.rectilinearGridHasTransform) &&
            rectilinearGridTransform_equal);
}

// ****************************************************************************
// Method: avtMeshMetaData::operator != 
//
// Purpose: 
//   Comparison operator != for the avtMeshMetaData class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:17 PST 2007
//
// Modifications:
//   
// ****************************************************************************

bool
avtMeshMetaData::operator != (const avtMeshMetaData &obj) const
{
    return !(this->operator == (obj));
}

// ****************************************************************************
// Method: avtMeshMetaData::TypeName
//
// Purpose: 
//   Type name method for the avtMeshMetaData class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:17 PST 2007
//
// Modifications:
//   
// ****************************************************************************

const std::string
avtMeshMetaData::TypeName() const
{
    return "avtMeshMetaData";
}

// ****************************************************************************
// Method: avtMeshMetaData::CopyAttributes
//
// Purpose: 
//   CopyAttributes method for the avtMeshMetaData class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:17 PST 2007
//
// Modifications:
//   
// ****************************************************************************

bool
avtMeshMetaData::CopyAttributes(const AttributeGroup *atts)
{
    if(TypeName() != atts->TypeName())
        return false;

    // Call assignment operator.
    const avtMeshMetaData *tmp = (const avtMeshMetaData *)atts;
    *this = *tmp;

    return true;
}

// ****************************************************************************
// Method: avtMeshMetaData::CreateCompatible
//
// Purpose: 
//   CreateCompatible method for the avtMeshMetaData class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:17 PST 2007
//
// Modifications:
//   
// ****************************************************************************

AttributeSubject *
avtMeshMetaData::CreateCompatible(const std::string &tname) const
{
    AttributeSubject *retval = 0;
    if(TypeName() == tname)
        retval = new avtMeshMetaData(*this);
    // Other cases could go here too. 

    return retval;
}

// ****************************************************************************
// Method: avtMeshMetaData::NewInstance
//
// Purpose: 
//   NewInstance method for the avtMeshMetaData class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:17 PST 2007
//
// Modifications:
//   
// ****************************************************************************

AttributeSubject *
avtMeshMetaData::NewInstance(bool copy) const
{
    AttributeSubject *retval = 0;
    if(copy)
        retval = new avtMeshMetaData(*this);
    else
        retval = new avtMeshMetaData;

    return retval;
}

// ****************************************************************************
// Method: avtMeshMetaData::SelectAll
//
// Purpose: 
//   Selects all attributes.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:17 PST 2007
//
// Modifications:
//   
// ****************************************************************************

void
avtMeshMetaData::SelectAll()
{
    Select(0, (void *)&name);
    Select(1, (void *)&originalName);
    Select(2, (void *)&validVariable);
    Select(3, (void *)&meshType);
    Select(4, (void *)&meshCoordType);
    Select(5, (void *)&cellOrigin);
    Select(6, (void *)&spatialDimension);
    Select(7, (void *)&topologicalDimension);
    Select(8, (void *)&xUnits);
    Select(9, (void *)&yUnits);
    Select(10, (void *)&zUnits);
    Select(11, (void *)&xLabel);
    Select(12, (void *)&yLabel);
    Select(13, (void *)&zLabel);
    Select(14, (void *)&hasSpatialExtents);
    Select(15, (void *)minSpatialExtents, 3);
    Select(16, (void *)maxSpatialExtents, 3);
    Select(17, (void *)&numBlocks);
    Select(18, (void *)&blockOrigin);
    Select(19, (void *)&blockPieceName);
    Select(20, (void *)&blockTitle);
    Select(21, (void *)&blockNames);
    Select(22, (void *)&numGroups);
    Select(23, (void *)&groupOrigin);
    Select(24, (void *)&groupPieceName);
    Select(25, (void *)&groupTitle);
    Select(26, (void *)&groupIds);
    Select(27, (void *)&disjointElements);
    Select(28, (void *)&containsGhostZones);
    Select(29, (void *)&containsOriginalCells);
    Select(30, (void *)&containsOriginalNodes);
    Select(31, (void *)&containsGlobalNodeIds);
    Select(32, (void *)&containsGlobalZoneIds);
    Select(33, (void *)&loadBalanceScheme);
    Select(34, (void *)&nodesAreCritical);
    Select(35, (void *)unitCellVectors, 9);
    Select(36, (void *)&rectilinearGridHasTransform);
    Select(37, (void *)rectilinearGridTransform, 16);
}

///////////////////////////////////////////////////////////////////////////////
// Set property methods
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Get property methods
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// User-defined methods.
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
//  Method: avtMeshMetaData constructor
//
//  Arguments:
//      extents     Mesh extents as <min_x, max_x, min_y, max_y, min_z, max_z>.
//      s           The name of the mesh.
//      nb          The number of blocks.
//      bo          The block origin.
//      sd          The spacial dimensionality.
//      td          The topological dimensionality.
//      mt          The type of mesh.
//
//  Programmer: Hank Childs
//  Creation:   August 25, 2000
//
//  Modifications:
//
//    Hank Childs, Tue May 28 13:57:49 PDT 2002
//    Initialized blockPieceName and blockTitle.
//
//    Hank Childs, Sun Jun 16 19:31:03 PDT 2002 
//    Added argument for cell origin.
//
//    Hank Childs, Mon Jun 24 12:21:15 PDT 2002
//    Initialize numGroups.
//
//    Hank Childs, Sun Aug 18 10:54:26 PDT 2002
//    Initialized disjointElements.
//
//    Hank Childs, Mon Sep 30 08:57:30 PDT 2002 
//    Initialized containsGhostZones.
//
//    Hank Childs, Mon Dec  9 17:04:39 PST 2002
//    Initialized validVariable.
//
//    Kathleen Bonnell, Wed Mar 26 13:03:54 PST 2003 
//    Initialized containsOriginalCells. 
//
//    Kathleen Bonnell, Fri May 28 18:16:48 PDT 2004 
//    Initialized containsOriginalNodes. 
//
//    Hank Childs, Sun Jun 27 11:50:34 PDT 2004
//    Initialized containsGlobalNodeIds.
//
//    Brad Whitlock, Fri Jul 23 12:25:03 PDT 2004
//    Added xLabel, yLabel, zLabel.
//
//    Mark C. Miller, August 9, 2004
//    Added containsGlobalZoneIds data member
//
//    Hank Childs, Mon Feb 14 14:16:49 PST 2005
//    Added original name.
//
//    Jeremy Meredith, Thu Aug 25 09:42:33 PDT 2005
//    Added group origin.
//
//    Mark C. Miller, Wed Nov 16 10:46:36 PST 2005
//    Added loadBalanceScheme
//
//    Kathleen Bonnell, Fri Feb  3 10:23:36 PST 2006 
//    Added meshCoordType.
//
//    Jeremy Meredith, Fri Aug 25 17:14:58 EDT 2006
//    Added nodesAreCritical and unitCellVectors.
//
//    Jeremy Meredith, Thu Feb 15 11:42:44 EST 2007
//    Added support for rectilinear grids with an inherent transform.
//
//    Brad Whitlock, Thu Mar 1 16:36:37 PST 2007
//    Rewrote.
//
// ****************************************************************************

avtMeshMetaData::avtMeshMetaData(const double *extents, std::string s, int nb,
                                 int bo, int co, int go, int sd, int td,
                                 avtMeshType mt)
    : AttributeSubject(avtMeshMetaData::TypeMapFormatString)
{
    // Initialize all values.
    *this = avtMeshMetaData();

    // Override some initialization with the passed arguments.
    name                 = s;
    originalName         = name;
    numBlocks            = nb;
    blockOrigin          = bo;
    cellOrigin           = co;
    groupOrigin          = go;
    topologicalDimension = td;
    spatialDimension     = sd;
    meshType             = mt;
    numGroups            = 0;
    SetExtents(extents);
}

// ****************************************************************************
//  Method: avtMeshMetaData constructor
//
//  Arguments:
//      s           The name of the mesh.
//      nb          The number of blocks.
//      bo          The block origin.
//      sd          The spacial dimensionality.
//      td          The topological dimensionality.
//      mt          The type of mesh.
//
//  Programmer: Hank Childs
//  Creation:   August 25, 2000
//
//  Modifications:
//
//    Hank Childs, Tue May 28 13:57:49 PDT 2002
//    Initialized blockPieceName and blockTitle.
//
//    Hank Childs, Sun Jun 16 19:31:03 PDT 2002 
//    Added argument for cell origin.
//
//    Hank Childs, Mon Jun 24 12:21:15 PDT 2002
//    Initialize numGroups.
//
//    Hank Childs, Sun Aug 18 10:54:26 PDT 2002
//    Initialized disjointElements.
//
//    Hank Childs, Mon Sep 30 08:57:30 PDT 2002 
//    Initialized containsGhostZones.
//
//    Hank Childs, Mon Dec  9 17:04:39 PST 2002
//    Initialized validVariable.
//
//    Kathleen Bonnell, Wed Mar 26 13:03:54 PST 2003 
//    Initialized containsOriginalCells. 
//
//    Kathleen Bonnell, Fri May 28 18:16:48 PDT 2004 
//    Initialized containsOriginalNodes. 
//
//    Hank Childs, Sun Jun 27 11:50:34 PDT 2004
//    Initialized containsGlobalNodeIds.
//
//    Brad Whitlock, Fri Jul 23 12:25:22 PDT 2004
//    Added xLabel, yLabel, zLabel.
//
//    Mark C. Miller, August 9, 2004
//    Added containsGlobalZoneIds data member
//
//    Hank Childs, Mon Feb 14 14:16:49 PST 2005
//    Added original name.
//
//    Jeremy Meredith, Thu Aug 25 09:42:37 PDT 2005
//    Added group origin.
//
//    Mark C. Miller, Wed Nov 16 10:46:36 PST 2005
//    Added loadBalanceScheme
//
//    Kathleen Bonnell, Fri Feb  3 10:23:36 PST 2006 
//    Added meshCoordType.
//
//    Mark C. Miller, Tue Aug 15 21:48:46 PDT 2006
//    Called SetExtents to initialize extents. Keeps purify happy.
//
//    Jeremy Meredith, Fri Aug 25 17:14:58 EDT 2006
//    Added nodesAreCritical and unitCellVectors.
//
//    Jeremy Meredith, Thu Feb 15 11:42:44 EST 2007
//    Added support for rectilinear grids with an inherent transform.
//
//    Brad Whitlock, Thu Mar 1 16:37:16 PST 2007
//    Rewrote.
//
// ****************************************************************************

avtMeshMetaData::avtMeshMetaData(std::string s, int nb, int bo, int co, int go,
                                 int sd, int td, avtMeshType mt)
    : AttributeSubject(avtMeshMetaData::TypeMapFormatString)
{
    // Initialize all values.
    *this = avtMeshMetaData();

    // Override some initialization with the passed arguments.
    name                 = s;
    originalName         = name;
    numBlocks            = nb;
    blockOrigin          = bo;
    cellOrigin           = co;
    groupOrigin          = go;
    topologicalDimension = td;
    spatialDimension     = sd;
    meshType             = mt;
    SetExtents(0);
}

// ****************************************************************************
//  Method: avtMeshMetaData::SetExtents
//
//  Purpose:
//      Sets the extents of the mesh.
//
//  Arguments:
//      extents     Mesh extents as <min_x, max_x, min_y, max_y, min_z, max_z>.
//
//  Programmer: Hank Childs
//  Creation:   August 30, 2000
//
//  Modifications:
//
//    Hank Childs, Tue May  1 12:53:10 PDT 2001
//    Check for NULL extents.
//
//    Mark C. Miller, Tue Aug 15 21:45:50 PDT 2006
//    Added code to initialize extents to [0,1] if null was passed in. Keeps
//    purify happy.
// ****************************************************************************

void
avtMeshMetaData::SetExtents(const double *extents)
{
    if (extents == NULL)
    {
        hasSpatialExtents = false;
        for (int i = 0 ; i < spatialDimension ; i++)
        {
            minSpatialExtents[i] = 0.0;  
            maxSpatialExtents[i] = 1.0; 
        }
    }
    else
    {
        hasSpatialExtents = true;
        for (int i = 0 ; i < spatialDimension ; i++)
        {
            minSpatialExtents[i] = extents[2*i];
            maxSpatialExtents[i] = extents[2*i + 1];
        }
    }
}

void
avtMeshMetaData::UnsetExtents()
{
    hasSpatialExtents = false;
}

// ****************************************************************************
//  Method: avtMeshMetaData::Print
//
//  Purpose:
//      Print statement for debugging.
//
//  Arguments:
//      out      The stream to output to.
//      indent   The number of tabs to indent each line with.
//
//  Programmer:  Hank Childs
//  Creation:    August 28, 2000
//
//  Modifications:
//
//    Hank Childs, Tue Aug 28 10:16:24 PDT 2001
//    Added block names.
//
//    Hank Childs, Tue May 28 13:57:49 PDT 2002
//    Added blockPieceName and blockTitle.
//
//    Hank Childs, Sun Jun 16 19:31:03 PDT 2002 
//    Added cell origin.
//
//    Hank Childs, Mon Jun 24 12:21:15 PDT 2002
//    Added numGroups.
//
//    Hank Childs, Sun Aug 18 10:54:26 PDT 2002
//    Added disjointElements.
//
//    Brad Whitlock, Tue Aug 20 15:11:14 PST 2002
//    Changed printing a little.
//
//    Hank Childs, Thu Sep 26 22:01:55 PDT 2002
//    Added units.
//
//    Hank Childs, Mon Sep 30 08:57:30 PDT 2002 
//    Added containsGhostZones.
//
//    Hank Childs, Mon Dec  9 17:04:39 PST 2002
//    Added validVariable.
//
//    Kathleen Bonnell, Wed Mar 26 13:03:54 PST 2003 
//    Added containsOriginalCells. 
//
//    Kathleen Bonnell, Fri May 28 18:16:48 PDT 2004 
//    Added containsOriginalNodes. 
//
//    Brad Whitlock, Fri Jul 23 12:28:21 PDT 2004
//    Added xLabel, yLabel, and zLabel.
//
//    Hank Childs, Mon Feb 14 14:16:49 PST 2005
//    Added original name.
//
//    Jeremy Meredith, Thu Aug 25 09:42:47 PDT 2005
//    Added group origin.
//
//    Mark C. Miller, Wed Nov 16 10:46:36 PST 2005
//    Added loadBalanceScheme
// 
//    Hank Childs, Wed Jan 11 09:36:13 PST 2006
//    Added new mesh types.
//
//    Kathleen Bonnell, Fri Feb  3 10:23:36 PST 2006 
//    Added meshCoordType.
//
//    Jeremy Meredith, Fri Aug 25 17:14:58 EDT 2006
//    Added nodesAreCritical and unitCellVectors.
//
//    Jeremy Meredith, Thu Feb 15 11:42:44 EST 2007
//    Added support for rectilinear grids with an inherent transform.
//
// ****************************************************************************
inline void
Indent(ostream &out, int indent)
{
    for (int i = 0 ; i < indent ; i++)
    {
        out << "\t";
    }
}

void
avtMeshMetaData::Print(ostream &out, int indent) const
{
    Indent(out, indent);
    out << "Name = " << name.c_str() << endl;
    if (name != originalName)
    {
        Indent(out, indent);
        out << "Original Name = " << originalName.c_str() << endl;
    }
    Indent(out, indent);
    out << "Number of blocks = " << numBlocks << endl;
    Indent(out, indent);
    out << "Block origin = " << blockOrigin << endl;
    Indent(out, indent);
    out << "Cell origin = " << cellOrigin 
        << " (origin within one block of the cells)." << endl;
    Indent(out, indent);
    out << "Group origin = " << groupOrigin << endl;
    Indent(out, indent);
    out << "Title for domain hierarchy is " << blockTitle.c_str() << endl;
    Indent(out, indent);
    out << "Title for individual piece in domain hierarchy is "
        << blockPieceName.c_str() << endl;

    Indent(out, indent);
    out << "Number of groups = " << numGroups << endl;
    if(numGroups > 0)
    {
        Indent(out, indent);
        out << "Group ids are:";
        for (int i = 0 ; i < groupIds.size() ; i++)
        {
            out << groupIds[i];
            if(i  < groupIds.size() - 1)
                out << ", ";
        }
        out << endl;
    }
    Indent(out, indent);
    out << "Title for group hierarchy is " << groupTitle.c_str() << endl;
    Indent(out, indent);
    out << "Title for individual piece in group hierarchy is "
        << groupPieceName.c_str() << endl;

    Indent(out, indent);
    out << "Mesh type is ";
    switch (meshType)
    {
      case AVT_RECTILINEAR_MESH:
        out << "Rectilinear Mesh";
        break;

      case AVT_CURVILINEAR_MESH:
        out << "Curvilinear Mesh";
        break;

      case AVT_UNSTRUCTURED_MESH:
        out << "Unstructured Mesh";
        break;

      case AVT_POINT_MESH:
        out << "Point Mesh";
        break;

      case AVT_SURFACE_MESH:
        out << "Surface Mesh";
        break;

      case AVT_CSG_MESH:
        out << "CSG Mesh";
        break;

      case AVT_AMR_MESH:
        out << "AMR Mesh";
        break;

      case AVT_UNKNOWN_MESH:
      default:
        out << "Unknown";
        break;
    }
    out << "." << endl;

    Indent(out, indent);
    out << "Spatial Dimension = " << spatialDimension << endl;
    Indent(out, indent);
    out << "Topological Dimension = " << topologicalDimension << endl;
    if (hasSpatialExtents)
    {
        Indent(out, indent);
        out << "Extents are: (";
        for (int j = 0 ; j < spatialDimension ; j++)
        {
            out << "(" << minSpatialExtents[j] << ", " << maxSpatialExtents[j]
                << ")";
            if(j < spatialDimension-1)
                out << ", ";
        }
        out << ")" << endl;
    }
    else
    {
        Indent(out, indent);
        out << "The spatial extents are not set." << endl;
    }

    if (blockNames.size() == numBlocks)
    {
        Indent(out, indent);
        out << "Block names: " << endl;
        for (int i = 0 ; i < numBlocks ; i++)
        {
            Indent(out, indent);
            out << "\t" << blockNames[i].c_str() << endl;
        }
    }
    else
    {
        Indent(out, indent);
        out << "There are no names set with the blocks." << endl;
    }

    Indent(out, indent);
    out << "Disjoint elements " << (disjointElements ? "true" : "false") 
        << endl;

    Indent(out, indent);
    out << "Contains ghost zones " << containsGhostZones << endl;

    Indent(out, indent);
    out << "Contains original cells " << containsOriginalCells << endl;

    Indent(out, indent);
    out << "Contains original nodes " << containsOriginalNodes << endl;

    Indent(out, indent);
    out << "Units =  x: \"" << xUnits.c_str()
        << "\", y: \"" << yUnits.c_str()
        << "\", z: \"" << zUnits.c_str() << "\"." << endl;

    Indent(out, indent);
    out << "Labels =  x: \"" << xLabel.c_str()
        << "\", y: \"" << yLabel.c_str()
        << "\", z: \"" << zLabel.c_str() << "\"." << endl;

    if (!validVariable)
    {
        Indent(out, indent);
        out << "THIS IS NOT A VALID VARIABLE." << endl;
    }

    if (loadBalanceScheme != LOAD_BALANCE_UNKNOWN)
    {
        Indent(out, indent);
        out << "HAS A SPECIFIC LOAD BALANCE SCHEME = "
            << loadBalanceScheme << endl;
    }
    if (meshCoordType == AVT_XY)
    {
        Indent(out, indent);
        out << "Mesh coord type is XY" << endl;
    }
    else if (meshCoordType == AVT_RZ)
    {
        Indent(out, indent);
        out << "Mesh coord type is RZ" << endl;
    }
    else if (meshCoordType == AVT_ZR)
    {
        Indent(out, indent);
        out << "Mesh coord type is ZR" << endl;
    }

    Indent(out, indent);
    out << "Mesh is primarily "
        << (nodesAreCritical ? "point" : "cell") << "-based" << endl;

    for (int i=0; i<3; i++)
    {
        Indent(out, indent);
        out << "Unit cell vector #"<<i<<" is "
            << unitCellVectors[i*3+0] << " "
            << unitCellVectors[i*3+1] << " "
            << unitCellVectors[i*3+2] << endl;
    }

    Indent(out, indent);
    out << "Rectilinear grids "
        << (rectilinearGridHasTransform ? "do " : "do not ")
        << "have an implicit transform." << endl;
    if (rectilinearGridHasTransform)
    {
        for (int i=0; i<4; i++)
        {
            Indent(out, indent);
            out << "   [ "
                << rectilinearGridTransform[i*4+0] << " "
                << rectilinearGridTransform[i*4+1] << " "
                << rectilinearGridTransform[i*4+2] << " "
                << rectilinearGridTransform[i*4+3] << " "
                << "]" << endl;
        }
    }
}


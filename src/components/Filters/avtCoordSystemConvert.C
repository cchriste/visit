/*****************************************************************************
*
* Copyright (c) 2000 - 2006, The Regents of the University of California
* Produced at the Lawrence Livermore National Laboratory
* All rights reserved.
*
* This file is part of VisIt. For details, see http://www.llnl.gov/visit/. The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or materials provided with the distribution.
*  - Neither the name of the UC/LLNL nor  the names of its contributors may be
*    used to  endorse or  promote products derived from  this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED.  IN  NO  EVENT  SHALL  THE  REGENTS  OF  THE  UNIVERSITY OF
* CALIFORNIA, THE U.S.  DEPARTMENT  OF  ENERGY OR CONTRIBUTORS BE  LIABLE  FOR
* ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//  File: avtCoordSystemConvert.C
// ************************************************************************* //

#include <avtCoordSystemConvert.h>

#include <vtkCellData.h>
#include <vtkDataSet.h>
#include <vtkFloatArray.h>
#include <vtkMath.h>
#include <vtkPointData.h>
#include <vtkPoints.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>

#include <vtkVisItUtility.h>

#include <avtDatasetExaminer.h>
#include <avtExtents.h>


static vtkDataSet *CreateNewDataset(vtkDataSet *in_ds, vtkPoints *newPts);
static vtkDataSet *SphericalToCartesian(vtkDataSet *in_ds, bool);
static vtkDataSet *CylindricalToSpherical(vtkDataSet *in_ds, bool);
static vtkDataSet *CartesianToCylindrical(vtkDataSet *in_ds, bool);
static vtkDataSet *FixWraparounds(vtkDataSet *in_ds, int comp_idx);

// ****************************************************************************
//  Method: avtCoordSystemConvert constructor
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Fri Jun 27 16:41:32 PST 2003
//
// ****************************************************************************

avtCoordSystemConvert::avtCoordSystemConvert()
{
    inputSys  = CARTESIAN;
    outputSys = CARTESIAN;
}


// ****************************************************************************
//  Method: avtCoordSystemConvert destructor
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Fri Jun 27 16:41:32 PST 2003
//
//  Modifications:
//
// ****************************************************************************

avtCoordSystemConvert::~avtCoordSystemConvert()
{
}


// ****************************************************************************
//  Method: avtCoordSystemConvert::ExecuteData
//
//  Purpose:
//      Sends the specified input and output through the CoordConvert filter.
//
//  Arguments:
//      in_ds      The input dataset.
//      <unused>   The domain number.
//      <unused>   The label.
//
//  Returns:       The output dataset.
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Fri Jun 27 16:41:32 PST 2003
//
//  Modifications:
//
//    Hank Childs, Tue Nov 15 15:40:04 PST 2005
//    Add support for 2D.
//
// ****************************************************************************

vtkDataSet *
avtCoordSystemConvert::ExecuteData(vtkDataSet *in_ds, int, std::string)
{
    vector<vtkDataSet *> deleteList;

    CoordSystem ct_current = inputSys;

    bool in2D = 
             (GetInput()->GetInfo().GetAttributes().GetSpatialDimension() < 3);
    vtkDataSet *cur_ds = in_ds;
    while (ct_current != outputSys)
    {
        switch (ct_current)
        {
          case CARTESIAN:
          {
            vtkDataSet *new_ds = CartesianToCylindrical(cur_ds, in2D);
            deleteList.push_back(new_ds);
            cur_ds = new_ds;
            ct_current = CYLINDRICAL;
            break;
          }
          case CYLINDRICAL:
          {
            vtkDataSet *new_ds = CylindricalToSpherical(cur_ds, in2D);
            deleteList.push_back(new_ds);
            cur_ds = new_ds;
            ct_current = SPHERICAL;
            break;
          }
          case SPHERICAL:
          {
            vtkDataSet *new_ds = SphericalToCartesian(cur_ds, in2D);
            deleteList.push_back(new_ds);
            cur_ds = new_ds;
            ct_current = CARTESIAN;
            break;
          }
        }
    }

    if (outputSys == SPHERICAL)
    {
        cur_ds = FixWraparounds(cur_ds, 1);
        deleteList.push_back(cur_ds);
        cur_ds = FixWraparounds(cur_ds, 2);
        deleteList.push_back(cur_ds);
    }
    else if (outputSys == CYLINDRICAL)
    {
        cur_ds = FixWraparounds(cur_ds, 1);
        deleteList.push_back(cur_ds);
    }

    ManageMemory(cur_ds);

    for (int i = 0 ; i < deleteList.size() ; i++)
    {
         deleteList[i]->Delete();
    }

    return cur_ds;
}


// ****************************************************************************
//  Method: avtCoordSystemConvert::PostExecute
//
//  Purpose:
//      This is called to set up the output extents.
//
//  Programmer: Hank Childs
//  Creation:   June 30, 2003
//
//  Modifications:
//
//    Hank Childs, Tue Jul  5 09:23:13 PDT 2005
//    Properly create extents.
//
// ****************************************************************************
 
void
avtCoordSystemConvert::PostExecute()
{
    avtDataAttributes &outAtts = GetOutput()->GetInfo().GetAttributes();
    outAtts.GetTrueSpatialExtents()->Clear();
    outAtts.GetEffectiveSpatialExtents()->Clear();
    outAtts.GetCurrentSpatialExtents()->Clear();

    double bounds[6];
    avtDataset_p ds = GetTypedOutput();
    avtDatasetExaminer::GetSpatialExtents(ds, bounds);
    outAtts.GetCumulativeTrueSpatialExtents()->Set(bounds);
}


// ****************************************************************************
//  Method: avtCoordSystemConvert::TransformExtents
//
//  Purpose:
//      Transforms a bounding box to get the new extents.
//
//  Programmer: Hank Childs
//  Creation:   June 30, 2003
//
// ****************************************************************************

void
avtCoordSystemConvert::TransformExtents(double *extents)
{
    //
    // Set up a one cell-ed rectilinear grid based on the bounding box.
    //
    vtkFloatArray *x = vtkFloatArray::New();
    x->SetNumberOfTuples(10);
    int i;
    for (i = 0 ; i < 10 ; i++)
        x->SetTuple1(i, (extents[1]-extents[0]) * ((float)i)/10. + extents[0]);
 
    vtkFloatArray *y = vtkFloatArray::New();
    y->SetNumberOfTuples(10);
    for (i = 0 ; i < 10 ; i++)
        y->SetTuple1(i, (extents[3]-extents[2]) * ((float)i)/10. + extents[2]);
 
    vtkFloatArray *z = vtkFloatArray::New();
    z->SetNumberOfTuples(10);
    for (i = 0 ; i < 10 ; i++)
        z->SetTuple1(i, (extents[5]-extents[4]) * ((float)i)/10. + extents[4]);
 
    vtkRectilinearGrid *rgrid = vtkRectilinearGrid::New();
    rgrid->SetDimensions(10, 10, 10);
    rgrid->SetXCoordinates(x);
    rgrid->SetYCoordinates(y);
    rgrid->SetZCoordinates(z);

    vtkDataSet *rv = ExecuteData(rgrid, -1, "");
    rv->GetBounds(extents);

    x->Delete();
    y->Delete();
    z->Delete();
    rgrid->Delete();
    //rv does not need to be deleted.
    //rv->Delete();
}


// ****************************************************************************
//  Function: CreateNewDataset
//
//  Purpose:
//      Creates a dataset just like the input, except with the new set of
//      points.
//
//  Programmer: Hank Childs
//  Creation:   June 30, 2003
//
// ****************************************************************************

static vtkDataSet *
CreateNewDataset(vtkDataSet *in_ds, vtkPoints *newPts)
{
    vtkDataSet *rv = NULL;

    int dstype = in_ds->GetDataObjectType();
    if (dstype == VTK_STRUCTURED_GRID || dstype == VTK_POLY_DATA ||
        dstype == VTK_UNSTRUCTURED_GRID)
    {
        vtkPointSet *rv2 = (vtkPointSet *) in_ds->NewInstance();
        rv2->ShallowCopy(in_ds);
        rv2->SetPoints(newPts);

        rv = rv2;
    }
    else if (dstype == VTK_RECTILINEAR_GRID)
    {
        int dims[3];
        vtkRectilinearGrid *rg = (vtkRectilinearGrid *) in_ds;
        rg->GetDimensions(dims);

        vtkStructuredGrid *rv2 = vtkStructuredGrid::New();
        rv2->SetDimensions(dims);
        rv2->GetPointData()->ShallowCopy(in_ds->GetPointData());
        rv2->GetCellData()->ShallowCopy(in_ds->GetCellData());
        rv2->SetPoints(newPts);

        rv = rv2;
    }

    return rv;
}


// ****************************************************************************
//  Function: SphericalToCartesian
//
//  Purpose:
//      Converts spherical coordinates to cartesian coordinates.
//
//      More info at: 
//      http://www.geom.uiuc.edu/docs/reference/CRC-formulas/node42.html
//      (For the record, I did this myself and only *confirmed* the formulas at
//      this site.)
//
//  Programmer: Hank Childs
//  Creation:   June 28, 2003
//
//  Modifications:
//
//    Hank Childs, Tue Nov 15 15:40:04 PST 2005
//    Add support for 2D.  Also re-order coordinates.
//
// ****************************************************************************

static vtkDataSet *
SphericalToCartesian(vtkDataSet *in_ds, bool in2D)
{
    vtkPoints *pts = vtkVisItUtility::GetPoints(in_ds);
    int npts = pts->GetNumberOfPoints();

    vtkPoints *newPts = vtkPoints::New();
    newPts->SetNumberOfPoints(npts);
    for (int i = 0 ; i < npts ; i++)
    {
        double pt[3];
        pts->GetPoint(i, pt);
        double newpt[3];
        if (in2D)
        {
            newpt[0] = pt[0]*cos(pt[1]);
            newpt[1] = pt[0]*sin(pt[1]);
            newpt[2] = 0.;
        }
        else
        {
            newpt[0] = pt[0]*cos(pt[1])*sin(pt[2]);
            newpt[1] = pt[0]*sin(pt[1])*sin(pt[2]);
            newpt[2] = pt[0]*cos(pt[2]);
        }
        newPts->SetPoint(i, newpt);
    }

    vtkDataSet *rv = CreateNewDataset(in_ds, newPts);
    pts->Delete();
    newPts->Delete();

    return rv;
}


// ****************************************************************************
//  Function: CylindricalToSpherical
//
//  Purpose:
//      Converts spherical coordinates to cartesian coordinates.
//
//      More info at: 
//      http://www.geom.uiuc.edu/docs/reference/CRC-formulas/node42.html
//      (For the record, I did this myself and only *confirmed* the formulas at
//      this site.)
//
//  Programmer: Hank Childs
//  Creation:   June 28, 2003
//
//  Modifications:
//
//    Hank Childs, Tue Nov 15 15:40:04 PST 2005
//    Add support for 2D.  Also re-order coordinates.
//
// ****************************************************************************

static vtkDataSet *
CylindricalToSpherical(vtkDataSet *in_ds, bool in2D)
{
    vtkPoints *pts = vtkVisItUtility::GetPoints(in_ds);
    int npts = pts->GetNumberOfPoints();

    vtkPoints *newPts = vtkPoints::New();
    newPts->SetNumberOfPoints(npts);
    for (int i = 0 ; i < npts ; i++)
    {
        double pt[3];
        pts->GetPoint(i, pt);
        double newpt[3];
        newpt[1] = pt[1];
        newpt[2] = atan2(pt[0], pt[2]);
        if (newpt[2] < 0.)
            newpt[2] = 2*vtkMath::Pi() + newpt[2];
        if (in2D)
            newpt[2] = 0.;
        newpt[0] = sqrt(pt[0]*pt[0] + pt[2]*pt[2]);
        newPts->SetPoint(i, newpt);
    }

    vtkDataSet *rv = CreateNewDataset(in_ds, newPts);
    pts->Delete();
    newPts->Delete();

    return rv;
}


// ****************************************************************************
//  Function: CartesianToCylindrical
//
//  Purpose:
//      Converts spherical coordinates to cartesian coordinates.
//
//      More info at: 
//      http://www.geom.uiuc.edu/docs/reference/CRC-formulas/node42.html
//      (For the record, I did this myself and only *confirmed* the formulas at
//      this site.)
//
//  Programmer: Hank Childs
//  Creation:   June 28, 2003
//
//  Modifications:
//
//    Hank Childs, Tue Nov 15 15:40:04 PST 2005
//    Add support for 2D.  Also re-order coordinates.
//
// ****************************************************************************

static vtkDataSet *
CartesianToCylindrical(vtkDataSet *in_ds, bool in2D)
{
    vtkPoints *pts = vtkVisItUtility::GetPoints(in_ds);
    int npts = pts->GetNumberOfPoints();

    vtkPoints *newPts = vtkPoints::New();
    newPts->SetNumberOfPoints(npts);
    for (int i = 0 ; i < npts ; i++)
    {
        double pt[3];
        pts->GetPoint(i, pt);
        double newpt[3];
        newpt[1] = atan2(pt[1], pt[0]);
        if (newpt[1] < 0.)
            newpt[1] = 2*vtkMath::Pi() + newpt[0];
        newpt[0] = sqrt(pt[0]*pt[0] + pt[1]*pt[1]);
        newpt[2] = pt[2];
        if (in2D)
            newpt[2] = 0.;
        newPts->SetPoint(i, newpt);
    }

    vtkDataSet *rv = CreateNewDataset(in_ds, newPts);
    pts->Delete();
    newPts->Delete();

    return rv;
}


// ****************************************************************************
//  Function: FixWraparounds
//
//  Purpose:
//      Locates cells where the dataset has been wrapped-around from 0 radians
//      to 2*pi radians.
//
//  Programmer: Hank Childs
//  Creation:   July 7, 2003
//
// ****************************************************************************

static vtkDataSet *
FixWraparounds(vtkDataSet *in_ds, int comp_idx)
{
    int   i, j;

    if (in_ds->GetDataObjectType() != VTK_UNSTRUCTURED_GRID)
    {
        in_ds->Register(NULL);
        return in_ds;
    }

    vtkUnstructuredGrid *ugrid = (vtkUnstructuredGrid *) in_ds;
    vtkPoints *pts = ugrid->GetPoints();
    int npts = pts->GetNumberOfPoints();

    vtkPoints *new_pts = vtkPoints::New();
    new_pts->SetNumberOfPoints(2*npts);
    vtkUnstructuredGrid *new_grid = vtkUnstructuredGrid::New();
    new_grid->SetPoints(new_pts);
    vtkPointData *out_pd = new_grid->GetPointData();
    vtkPointData *in_pd  = in_ds->GetPointData();
    out_pd->CopyAllocate(in_pd, 2*npts);
   
    for (i = 0 ; i < npts ; i++)
    {
        double pt[3];
        pts->GetPoint(i, pt);
        new_pts->SetPoint(2*i, pt);
        if (pt[comp_idx] > vtkMath::Pi())
            pt[comp_idx] -= 2*vtkMath::Pi();
        else
            pt[comp_idx] += 2*vtkMath::Pi();
        new_pts->SetPoint(2*i+1, pt);
        out_pd->CopyData(in_pd, i, 2*i);
        out_pd->CopyData(in_pd, i, 2*i+1);
    }

    int ncells = ugrid->GetNumberOfCells();
    new_grid->Allocate(2*ncells*8);
    vtkCellData *out_cd = new_grid->GetCellData();
    vtkCellData *in_cd  = in_ds->GetCellData();
    out_cd->CopyAllocate(in_cd, 2*ncells);
   
    float pi = vtkMath::Pi();
    float twoPiCutoff = 2*vtkMath::Pi()*0.95;
    float zeroPiCutoff = vtkMath::Pi()*0.1;
    int cellCnt = 0;
    for (i = 0 ; i < ncells ; i++)
    {
        vtkIdType *ids;
        int cellNPts;
        ugrid->GetCellPoints(i, cellNPts, ids);
        bool closeToZero = false;
        bool closeToTwoPi = false;
        bool closeToLow[8];
        for (j = 0 ; j < cellNPts ; j++)
        {
            double pt[3];
            pts->GetPoint(ids[j], pt);
            if (pt[comp_idx] > twoPiCutoff)
                closeToTwoPi = true;
            if (pt[comp_idx] < zeroPiCutoff)
                closeToZero  = true;
            closeToLow[j] = (pt[comp_idx] < pi ? false : true);
        }
        if (closeToTwoPi && closeToZero)
        {
            // Make two cells -- start with the one close to 0 radians.
            vtkIdType low_ids[8];
            for (j = 0 ; j < cellNPts ; j++)
                low_ids[j] = (closeToLow[j] ? 2*ids[j] : 2*ids[j]+1);
            new_grid->InsertNextCell(ugrid->GetCellType(i), cellNPts, low_ids);
            out_cd->CopyData(in_cd, i, cellCnt++);
            
            vtkIdType hi_ids[8];
            for (j = 0 ; j < cellNPts ; j++)
                hi_ids[j] = (!closeToLow[j] ? 2*ids[j] : 2*ids[j]+1);
            new_grid->InsertNextCell(ugrid->GetCellType(i), cellNPts, hi_ids);
            out_cd->CopyData(in_cd, i, cellCnt++);
        }
        else
        {
            vtkIdType new_ids[8];
            for (j = 0 ; j < cellNPts ; j++)
                new_ids[j] = 2*ids[j];
            new_grid->InsertNextCell(ugrid->GetCellType(i), cellNPts, new_ids);
            out_cd->CopyData(in_cd, i, cellCnt++);
        }
    }
    new_grid->Squeeze();
    new_pts->Delete();

    return new_grid;
}


// ****************************************************************************
//  Method: avtCoordSystemConvert::RefashionDataObjectInfo
//
//  Purpose:
//      Changes the labels of the axes
//
//  Programmer: Hank Childs
//  Creation:   June 8, 2005
//
//  Modifications:
//
//    Hank Childs, Tue Nov 15 15:40:04 PST 2005
//    Re-order coordinates.
//
// ****************************************************************************

void
avtCoordSystemConvert::RefashionDataObjectInfo(void)
{
    avtDataAttributes &inAtts  = GetInput()->GetInfo().GetAttributes();
    avtDataAttributes &outAtts = GetOutput()->GetInfo().GetAttributes();
    if (inputSys == CARTESIAN)
    {
        if (outputSys == SPHERICAL)
        {
            if (inAtts.GetXLabel() == "X-Axis" ||
                inAtts.GetXLabel() == "X Axis")
                outAtts.SetXLabel("Radius");
            else
                outAtts.SetXLabel(std::string("Radius / ") + 
                                  inAtts.GetXLabel());

            if (inAtts.GetYLabel() == "Y-Axis" ||
                inAtts.GetYLabel() == "Y Axis")
                outAtts.SetYLabel("Theta");
            else
                outAtts.SetYLabel(std::string("Theta / ") + 
                                  inAtts.GetYLabel());

            if (inAtts.GetZLabel() == "Z-Axis" ||
                inAtts.GetZLabel() == "Z Axis")
                outAtts.SetZLabel("Phi");
            else
                outAtts.SetZLabel(std::string("Phi / ") + 
                                  inAtts.GetZLabel());
        }
        else if (outputSys == CYLINDRICAL)
        {
            if (inAtts.GetXLabel() == "X-Axis" ||
                inAtts.GetXLabel() == "X Axis")
                outAtts.SetXLabel("Radius");
            else
                outAtts.SetXLabel(std::string("Radius / ") + 
                                   inAtts.GetXLabel());

            if (inAtts.GetYLabel() == "Y-Axis" ||
                inAtts.GetYLabel() == "Y Axis")
                outAtts.SetYLabel("Theta");
            else
                outAtts.SetYLabel(std::string("Theta / ") + 
                                   inAtts.GetYLabel());

            if (inAtts.GetZLabel() == "Z-Axis" ||
                inAtts.GetZLabel() == "Z Axis")
                outAtts.SetZLabel("Height");
            else
                outAtts.SetZLabel(std::string("Height / ") + 
                                   inAtts.GetZLabel());
        }
    }
    if (outputSys == SPHERICAL)
    {
        outAtts.SetYUnits("radians");
        outAtts.SetZUnits("radians");
    }
    else if (outputSys == CYLINDRICAL)
    {
        outAtts.SetYUnits("radians");
    }
    GetOutput()->GetInfo().GetValidity().SetPointsWereTransformed(true);
}



// ************************************************************************* //
//                        avtCurveConstructorFilter.C                        //
// ************************************************************************* //

#include <avtCurveConstructorFilter.h>
#include <avtDataTree.h>

#include <vtkDataSet.h>
#include <vtkPolyData.h>
#include <InvalidDimensionsException.h>
#include <NoInputException.h>

#include <DebugStream.h>

#ifdef PARALLEL
#include <mpi.h>
#include <vtkPolyDataReader.h>
#include <vtkDataSetWriter.h>
#include <vtkCharArray.h>
#endif


#include <map>
using std::map;

// ****************************************************************************
//  Method: avtCurveConstructorFilter constructor
//
//  Programmer: kbonnell -- generated by xml2info
//  Creation:   Sat Apr 20 13:01:58 PST 2002
//
// ****************************************************************************

avtCurveConstructorFilter::avtCurveConstructorFilter()
{
}


// ****************************************************************************
//  Method: avtCurveConstructorFilter destructor
//
//  Programmer: kbonnell -- generated by xml2info
//  Creation:   Sat Apr 20 13:01:58 PST 2002
//
// ****************************************************************************

avtCurveConstructorFilter::~avtCurveConstructorFilter()
{
}


// ****************************************************************************
//  Method: avtCurveConstructorFilter::ExecuteData
//
//  Purpose:
//      Does the actual VTK code to modify the dataset.
//
//  Arguments:
//      inDS      The input dataset.
//      <unused>  The domain number.
//
//  Returns:      The output dataset.
//
//  Programmer: kbonnell -- generated by xml2info
//  Creation:   Sat Apr 20 13:01:58 PST 2002
//
//  Modifications:
//
//    Hank Childs, Tue May 28 11:41:21 PDT 2002
//    Use the variable name as the label for our output data tree.
//
//    Kathleen Bonnell, Fri Jul 12 16:53:11 PDT 2002
//    Removed vtk filters associated with label-creation.  Now handled by
//    the plot.
//
// ****************************************************************************

void avtCurveConstructorFilter::Execute()
{
    avtDataTree_p inTree = GetInputDataTree();

#ifdef PARALLEL
    //
    //  Gather all data onto one processor, so that 
    //  there will be no discontinuities in the curve.
    //
    int myRank, numProcs;

    MPI_Comm_size(MPI_COMM_WORLD, &numProcs);
    MPI_Comm_rank(MPI_COMM_WORLD, &myRank);

    if (myRank == 0)
    {
        int i , j;
        for (i = 1; i < numProcs; i++)
        {
           MPI_Status stat;
           MPI_Status stat2;
           int nds = 0, size = 0;
           MPI_Recv(&nds, 1, MPI_INT, MPI_ANY_SOURCE, MPI_ANY_TAG,
                    MPI_COMM_WORLD, &stat);
           for (j = 0; j < nds; j++)
           {
               vtkPolyDataReader *reader = vtkPolyDataReader::New(); 
               reader->ReadFromInputStringOn();
               MPI_Recv(&size, 1, MPI_INT, stat.MPI_SOURCE, MPI_ANY_TAG,
                         MPI_COMM_WORLD, &stat2);
               char *str = new char[size];
               MPI_Recv(str, size, MPI_CHAR, stat.MPI_SOURCE, MPI_ANY_TAG,
                        MPI_COMM_WORLD, &stat2);
               vtkCharArray *charArray = vtkCharArray::New();
               charArray->SetArray((char*)str, size, 1);
               reader->SetInputArray(charArray);
               reader->Update();
      
               inTree->Merge(new avtDataTree(reader->GetOutput(), -1));
               delete [] str;
               reader->Delete(); 
               charArray->Delete(); 
           }
        }
    }
    else
    {
        SetOutputDataTree(new avtDataTree());
        char *str = NULL;;
        int i = 0, size = 0, nleaves = 0;
        if (inTree->IsEmpty())
        {
            MPI_Send(&nleaves, 1, MPI_INT, 0, myRank, MPI_COMM_WORLD);
            return;
        }

        vtkDataSet **ds = inTree->GetAllLeaves(nleaves);
        MPI_Send(&nleaves, 1, MPI_INT, 0, myRank, MPI_COMM_WORLD);
 
        vtkDataSetWriter *writer = vtkDataSetWriter::New();
        writer->WriteToOutputStringOn();
        writer->SetFileTypeToBinary();

        for (i = 0; i < nleaves; i++)
        {
            writer->SetInput(ds[i]);
            writer->Write();
            size =  writer->GetOutputStringLength();
            str  =  writer->RegisterAndGetOutputString();

            MPI_Send(&size, 1, MPI_INT, 0, myRank, MPI_COMM_WORLD);
            MPI_Send(str, size, MPI_CHAR, 0, myRank, MPI_COMM_WORLD);
            delete [] str; //allocated by writer
        }
        writer->Delete(); 
        delete [] ds;
        return;
    }
#endif

    if (inTree->IsEmpty())
    {
        SetOutputDataTree(inTree);
        return; 
    }

    //
    //  This filter doesn't do much right now.  Basically just a 
    //  "connect-the-dots" between the vertices.  
    //
    int nleaves, j;
    float x;
    avtDataTree_p outTree;
    vtkDataSet **ds;
    ds = inTree->GetAllLeaves(nleaves);

    map <float, int> minX;

    //
    //  Assuming points are sorted w/i each dataset (which is true
    //  when lineout operator applied, our only use just now).  
    //  Now must order the datasets so that the points will
    //  be accessed in proper order, to avoid discontinuities
    //  between domains.
    //  Store in map with x value as the key.  
    //  (from first point in each ds).
    //
    for (j = 0; j < nleaves; j++)
    {
        x = ((vtkPolyData*)ds[j])->GetPoint(0)[0]; 
        minX.insert(std::map <float, int> ::value_type(x, j));
    }

    vtkPolyData *outPolys = vtkPolyData::New();
    
    vtkPoints *inPts; 
    vtkPoints *outPts  = vtkPoints::New();
    outPolys->SetPoints(outPts);
    outPts->Delete();

    vtkCellArray *lines   = vtkCellArray::New();
    outPolys->SetLines(lines);
    lines->Delete();

    int nPoints; 
    float pt[3];
    vtkIdType i, ptIds[2];

    //
    //  Ensure that the output is 2d by setting z-component to zero.
    //
    std::map <float, int>::iterator it;
    for (it = minX.begin(); it != minX.end(); it++)
    {
        inPts = ((vtkPolyData*)ds[(*it).second])->GetPoints();
        nPoints = inPts->GetNumberOfPoints();
        for (i = 0; i < nPoints; i++)
        {
            inPts->GetPoint(i, pt);
            pt[2] = 0; 
            outPts->InsertNextPoint(pt);
        }
    }

    nPoints = outPts->GetNumberOfPoints();
    for (i = 0; i < nPoints-1; i++)
    {
        ptIds[0] = i;
        ptIds[1] = i+1;
        lines->InsertNextCell(2, ptIds);        
    } 

    const char *varname = (pipelineVariable != NULL ? pipelineVariable : "");

    avtDataRepresentation dr(outPolys, -1, varname);
    outTree = new avtDataTree(dr);
    outPolys->Delete();

    SetOutputDataTree(outTree);

    //
    //  Clean up.
    // 
    delete [] ds;
}

// ****************************************************************************
//  Method: avtCurveConstructorFilter::VerifyInput
//
//  Purpose:
//      Verifies that the input is 2D data, throws an exception if not.
//
//  Programmer: Kathleen Bonnell
//  Creation:   April 26, 2002 
//
// ****************************************************************************
 
void
avtCurveConstructorFilter::VerifyInput(void)
{
    if  (GetInput()->GetInfo().GetAttributes().GetTopologicalDimension() != 1)
    {
        EXCEPTION2(InvalidDimensionsException, "Curve", " Lines ");
    }
}

// ****************************************************************************
//  Method: avtCurveConstructorFilter::PerformRestriction
//
//  Purpose:
//    Indicates that we cannot do dynamic load balancing with this filter.  
//
//  Programmer: Kathleen Bonnell
//  Creation:   April 26, 2002 
//
// ****************************************************************************

avtPipelineSpecification_p
avtCurveConstructorFilter::PerformRestriction(avtPipelineSpecification_p spec)
{
    spec->NoDynamicLoadBalancing();
    return spec;
}

// ****************************************************************************
//  Method: avtCurveConstructorFilter::PerformRestriction
//
//  Purpose:
//      Allows the filter to change its output's data object information, which
//      is a description of the data object.
//
//  Programmer: Kathleen Bonnell
//  Creation:   December 23, 2002 
//
// ****************************************************************************

void
avtCurveConstructorFilter::RefashionDataObjectInfo(void)
{
    GetOutput()->GetInfo().GetAttributes().SetSpatialDimension(2);
}


#include <ViewActions.h>
#include <ViewAttributes.h>
#include <ViewerAnimation.h>
#include <ViewerMessaging.h>
#include <ViewerPlotList.h>
#include <ViewerPopupMenu.h>
#include <ViewerToolbar.h>
#include <ViewerWindow.h>
#include <ViewerWindowManager.h>
#include <snprintf.h>

#include <avtViewCurve.h>
#include <avtView2D.h>
#include <avtView3D.h>

#include <DataNode.h>
#include <DebugStream.h>

#include <qaction.h>
#include <qapplication.h>
#include <qiconset.h>
#include <qpainter.h>
#include <qpopupmenu.h>
#include <qpixmap.h>

// Include icons
#include <perspectiveon.xpm>
#include <perspectiveoff.xpm>
#include <resetview.xpm>
#include <recenterview.xpm>
#include <undoview.xpm>
#include <viewlockon.xpm>
#include <viewlockoff.xpm>
#include <saveview.xpm>
#include <blankcamera.xpm>

///////////////////////////////////////////////////////////////////////////////

TogglePerspectiveViewAction::TogglePerspectiveViewAction(ViewerWindow *win) : ViewerToggleAction(win, "Perspective")
{
    SetAllText("Perspective");
    SetToolTip("Toggle perspective view");
    if (!win->GetNoWinMode())
        SetIcons(QPixmap(perspectiveon_xpm), QPixmap(perspectiveoff_xpm));
}

void
TogglePerspectiveViewAction::Execute()
{
    windowMgr->TogglePerspective(window->GetWindowId());
}

bool
TogglePerspectiveViewAction::Enabled() const
{
    // This action should only be enabled if the window to which the action belongs
    // has plots in it.
    return (window->GetAnimation()->GetPlotList()->GetNumPlots() > 0);
}

bool
TogglePerspectiveViewAction::Toggled() const
{
    return window->GetPerspectiveProjection();
}

///////////////////////////////////////////////////////////////////////////////

ResetViewAction::ResetViewAction(ViewerWindow *win) : ViewerAction(win, "ResetViewAction")
{
    SetAllText("Reset view");
    if (!win->GetNoWinMode())
        SetIconSet(QIconSet(QPixmap(resetview_xpm)));
}

void
ResetViewAction::Execute()
{
    windowMgr->ResetView(windowId);
}

bool
ResetViewAction::Enabled() const
{
    // This action should only be enabled if the window to which the action belongs
    // has plots in it.
    return (window->GetAnimation()->GetPlotList()->GetNumPlots() > 0);
}

///////////////////////////////////////////////////////////////////////////////

RecenterViewAction::RecenterViewAction(ViewerWindow *win) :
    ViewerAction(win, "RecenterViewAction")
{
    SetAllText("Recenter view");
    if (!win->GetNoWinMode())
        SetIconSet(QIconSet(QPixmap(recenterview_xpm)));
}

void
RecenterViewAction::Execute()
{
    windowMgr->RecenterView(windowId);
}

bool
RecenterViewAction::Enabled() const
{
    // This action should only be enabled if the window to which the action belongs
    // has plots in it.
    return (window->GetAnimation()->GetPlotList()->GetNumPlots() > 0);
}

///////////////////////////////////////////////////////////////////////////////

UndoViewAction::UndoViewAction(ViewerWindow *win) :
    ViewerAction(win, "UndoViewAction")
{
    SetAllText("Undo view");
    if (!win->GetNoWinMode())
        SetIconSet(QIconSet(QPixmap(undoview_xpm)));
}

void
UndoViewAction::Execute()
{
    windowMgr->UndoView(windowId);
    windowMgr->UndoView(windowId);
}

bool
UndoViewAction::Enabled() const
{
    // This action should only be enabled if the window to which the action belongs
    // has plots in it.
    return (window->GetAnimation()->GetPlotList()->GetNumPlots() > 0);
}


///////////////////////////////////////////////////////////////////////////////

ToggleLockViewAction::ToggleLockViewAction(ViewerWindow *win) :
    ViewerToggleAction(win, "ToggleLockViewAction")
{
    SetAllText("Lock view");
    if (!win->GetNoWinMode())
        SetIcons(QPixmap(viewlockon_xpm), QPixmap(viewlockoff_xpm));
}

void
ToggleLockViewAction::Execute()
{
    windowMgr->ToggleLockViewMode(windowId);
}

bool
ToggleLockViewAction::Enabled() const
{
    // This action should only be enabled if the window to which the action belongs
    // has plots in it.
    return (window->GetAnimation()->GetPlotList()->GetNumPlots() > 0);
}

bool
ToggleLockViewAction::Toggled() const
{
    return window->GetViewIsLocked();
}

///////////////////////////////////////////////////////////////////////////////

ToggleFullFrameAction::ToggleFullFrameAction(ViewerWindow *win) : 
    ViewerToggleAction(win, "Full frame")
{
    SetAllText("Full frame");
    SetToolTip("Toggle full frame");
}

void
ToggleFullFrameAction::Execute()
{
    windowMgr->ToggleFullFrameMode(window->GetWindowId());
}

bool
ToggleFullFrameAction::Enabled() const
{
    // This action should only be enabled if the window to which the action 
    // belongs has plots in it, and is 2D.
    return (window->GetAnimation()->GetPlotList()->GetNumPlots() > 0) &&
           (window->GetWindowMode() == WINMODE_2D);
}

bool
ToggleFullFrameAction::Toggled() const
{
    return window->GetFullFrameMode();
}

///////////////////////////////////////////////////////////////////////////////

const int SaveViewAction::MAX_SAVED_VIEWS = 15;
const int SaveViewAction::VIEWCurve = 1;
const int SaveViewAction::VIEW2D = 2;
const int SaveViewAction::VIEW3D = 3;

// ****************************************************************************
// Method: SaveViewAction::SaveViewAction
//
// Purpose: 
//   Constructor for the SaveViewAction class.
//
// Arguments:
//   win : The viewer window that owns this action.
//
// Programmer: Brad Whitlock
// Creation:   Wed Feb 26 08:53:26 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

SaveViewAction::SaveViewAction(ViewerWindow *win) : ViewerMultipleAction(win,
    "SaveView"), views()
{
    const char *s1 = "Clear saved views";
    const char *s2 = "Save view";
    const char *s3 = "Save current view";

    SetAllText(s2);
    SetToolTip(s3);
    SetExclusive(false);

    if (!win->GetNoWinMode())
    {
        // Add the clear saved views choice.
        QPixmap clearIcon(saveview_xpm);
        QPainter paint(&clearIcon);
        QPen pen(QColor(255,0,0));
        pen.setWidth(2);
        paint.setPen(pen);
        paint.drawLine(clearIcon.width()-1, 0, 0, clearIcon.height()-1);
        AddChoice(s1, s1, clearIcon);
        
        // Add the save view choice
        QPixmap icon(saveview_xpm);
        SetIconSet(QIconSet(icon));
        AddChoice(s2, s3, icon);
    }
    else
    {
        AddChoice(s1);
        AddChoice(s2);
    }
}

// ****************************************************************************
// Method: SaveViewAction::~SaveViewAction
//
// Purpose: 
//   Destructor for the SaveViewAction class.
//
// Programmer: Brad Whitlock
// Creation:   Wed Feb 26 08:53:31 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

SaveViewAction::~SaveViewAction()
{
    DeleteViews();
}

// ****************************************************************************
// Method: SaveViewAction::DeleteViews
//
// Purpose: 
//   Deletes the views in the view vector.
//
// Programmer: Brad Whitlock
// Creation:   Wed Feb 26 08:53:37 PDT 2003
//
// Modifications:
//   Brad Whitlock, Thu Feb 27 14:37:03 PST 2003
//   Added VIEWCurve.
//
// ****************************************************************************

void
SaveViewAction::DeleteViews()
{
    // Delete the views
    for(int i = 0; i < views.size(); ++i)
    {
        if(views[i].viewType == VIEWCurve)
        {
            avtViewCurve *v = (avtViewCurve *)views[i].view;
            delete v;
        }
        else if(views[i].viewType == VIEW2D)
        {
            avtView2D *v = (avtView2D *)views[i].view;
            delete v;
        }
        else
        {
            avtView3D *v = (avtView3D *)views[i].view;
            delete v;
        }
    }

    views.clear();
}

// ****************************************************************************
// Method: SaveViewAction::DeleteViewsFromInterface(
//
// Purpose: 
//   Deletes the saved views from the interface (toolbar, menu).
//
// Programmer: Brad Whitlock
// Creation:   Thu Aug 14 16:13:47 PST 2003
//
// Modifications:
//   
// ****************************************************************************

void
SaveViewAction::DeleteViewsFromInterface()
{
    // Delete the views.
    DeleteViews();

    // Remove the action from the popup menu and the toolbar.
    window->GetPopupMenu()->RemoveAction(this);
    window->GetToolbar()->RemoveAction(this);

    // Remove all of the choices after the second choice.
    int s = children.size();
    for(int i = 2; i < s; ++i)
    {
        delete children[s - i + 1];
        children.pop_back();
    }
}

// ****************************************************************************
// Method: SaveViewAction::Execute
//
// Purpose: 
//   Executes the save view action.
//
// Arguments:
//   val : The choice to execute.
//
// Programmer: Brad Whitlock
// Creation:   Wed Feb 26 08:53:39 PDT 2003
//
// Modifications:
//   Brad Whitlock, Thu Feb 27 14:41:35 PST 2003
//   I added support for curve views.
//
//   Brad Whitlock, Thu Aug 14 16:13:03 PST 2003
//   I moved code into DeleteViewsFromInterface.
//
// ****************************************************************************

void
SaveViewAction::Execute(int val)
{
    if(val == 0)
    {
        // Delete the views from the interface.
        DeleteViewsFromInterface();

        // Update the construction.
        UpdateConstruction();
    }
    else if(val == 1)
    {
        // Save the current view.
        SaveCurrentView();
    }
    else
    {
        // Use a saved view.
        UseSavedView(val - 2);
    }
}

// ****************************************************************************
// Method: SaveViewAction::SaveCurrentView
//
// Purpose: 
//   Saves the current view so we can use it later.
//
// Programmer: Brad Whitlock
// Creation:   Thu Feb 27 15:13:47 PST 2003
//
// Modifications:
//   Brad Whitlock, Tue Jul 1 14:50:11 PST 2003
//   I moved some code into AddNewView.
//
//   Eric Brugger, Wed Aug 20 10:56:24 PDT 2003
//   I Modified the routine to use the window mode to determine the type of
//   view to save.
//
// ****************************************************************************

void
SaveViewAction::SaveCurrentView()
{
    if(views.size() < MAX_SAVED_VIEWS)
    {
        void *saveView;
        int vt;

        // Create storage for the view based on the window type and dimension.
        if(window->GetWindowMode() == WINMODE_CURVE)
        {
            avtViewCurve *v = new avtViewCurve;
            *v = window->GetViewCurve();
            vt = VIEWCurve;
            saveView = (void *)v;
        }
        else if(window->GetWindowMode() == WINMODE_2D)
        {
            avtView2D *v = new avtView2D;
            *v = window->GetView2D();
            vt = VIEW2D;
            saveView = (void *)v;
        }
        else
        {
            avtView3D *v = new avtView3D;
            *v = window->GetView3D();
            vt = VIEW3D;
            saveView = (void *)v;
        }

        // Add the new view to the list of saved views and make a new
        // icon as necessary.
        AddNewView(saveView, vt);

        // Update the menus and the toolbar.
        UpdateConstruction();
    }
    else
    {
        // We only have this limit because I made ViewerMultipleActions
        // capable of containing a finite number of actions.
        Warning("You cannot save more than 15 views.");
    }
}

// ****************************************************************************
// Method: SaveViewAction::AddNewView
//
// Purpose: 
//   Saves the view in the views vector and creates a new choice for the user
//   in the menus.
//
// Arguments:
//   v  : A void pointer to the view.
//   vt : The type of view.
//
// Programmer: Brad Whitlock
// Creation:   Tue Jul 1 14:51:22 PST 2003
//
// Modifications:
//   
// ****************************************************************************

void
SaveViewAction::AddNewView(void *v, int vt)
{
    //
    // Save the view.
    //
    ViewInfo info;
    info.view = (void *)v;
    info.viewType = vt;
    views.push_back(info);

    //
    // Add the view to the action so that it is available in the toolbar.
    //
    char tmp[20];
    SNPRINTF(tmp, 20, "Use saved view %d", views.size());

    if (!window->GetNoWinMode())
    {
        //
        // Create a pixmap from the blank camera pixmap that we can
        // draw on.
        //
        QPixmap icon(blankcamera_xpm);
        QPainter paint(&icon);
        QString str;
        str.sprintf("%d", views.size());
        paint.setPen(QColor(0,255,0));
        QFont f(QApplication::font());
        f.setBold(true);
        f.setPixelSize(28);
        paint.setFont(f);
        int x = icon.width();
        int y = icon.height();
        paint.drawText(icon.width() - x, 0, x, y, Qt::AlignCenter, str);

        AddChoice(tmp, tmp, icon);
    }
    else
    {
        AddChoice(tmp);
    }
}

// ****************************************************************************
// Method: SaveViewAction::UseSavedView
//
// Purpose: 
//   Uses the numbered saved view.
//
// Arguments:
//   index : The index of the saved view that we want to use.
//
// Programmer: Brad Whitlock
// Creation:   Thu Feb 27 15:10:00 PST 2003
//
// Modifications:
//   Eric Brugger, Wed Aug 20 10:56:24 PDT 2003
//   I modified the routine to use the window mode to determine if the saved
//   view is appropriate.  I changed the call to UpdateViewAtts.
//   
// ****************************************************************************

void
SaveViewAction::UseSavedView(int index)
{
    if(index >= 0 && index < views.size())
    {
        if(views[index].viewType == VIEWCurve)
        {
            if(window->GetWindowMode() == WINMODE_CURVE)
            {
                window->SetViewCurve(*((avtViewCurve *)views[index].view));
            }
            else
            {
                char msg[200];
                SNPRINTF(msg, 200, "VisIt cannot use saved view %d because "
                         "it is a curve view and the window does not "
                         "contain curves.", index + 1);
                Error(msg);
            }
        }
        else if(views[index].viewType == VIEW2D)
        {
            if(window->GetWindowMode() == WINMODE_2D)
            {
                window->SetView2D(*((avtView2D *)views[index].view));
                windowMgr->UpdateViewAtts(window->GetWindowId(),
                                          false, true, false);
            }
            else
            {
                char msg[200];
                SNPRINTF(msg, 200, "VisIt cannot use saved view %d because "
                         "it is a 2D view and the window does not "
                         "contain 2D plots.", index + 1);
                Error(msg);
            }
        }
        else
        {
            if(window->GetWindowMode() == WINMODE_3D)
            {
                window->SetView3D(*((avtView3D *)views[index].view));
                windowMgr->UpdateViewAtts(window->GetWindowId(),
                                          false, false, true);
            }
            else
            {
                char msg[200];
                SNPRINTF(msg, 200, "VisIt cannot use saved view %d because "
                         "it is a 3D view and the window does not "
                         "contain 3D plots.", index + 1);
                Error(msg);
            }
        }
    }
}

// ****************************************************************************
// Method: SaveViewAction::Enabled
//
// Purpose: 
//   Tells when this action is enabled.
//
// Programmer: Brad Whitlock
// Creation:   Wed Feb 26 08:53:46 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

bool
SaveViewAction::Enabled() const
{
    return ViewerMultipleAction::Enabled() &&
           window->GetAnimation()->GetPlotList()->GetNumPlots() > 0;
}

// ****************************************************************************
// Method: SaveViewAction::ChoiceEnabled
//
// Purpose: 
//   Tells when the individual choices in this action are enabled.
//
// Arguments:
//   i : The action that to consider when returning the enabled flag.
//
// Programmer: Brad Whitlock
// Creation:   Wed Feb 26 08:53:14 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

bool
SaveViewAction::ChoiceEnabled(int i) const
{
    bool retval = true;

    if(i == 0)
        retval = (views.size() > 0);
    else if(i == 1)
        retval = (views.size() < 15);

    return retval;
}

// ****************************************************************************
// Method: SaveViewAction::CreateNode
//
// Purpose: 
//   Lets the action save its views for use in a future session.
//
// Arguments:
//   parentNode : The node to which we're adding.
//
// Returns:    
//
// Note:       
//
// Programmer: Brad Whitlock
// Creation:   Tue Jul 1 14:26:23 PST 2003
//
// Modifications:
//   Eric Brugger, Wed Aug 20 10:56:24 PDT 2003
//   I modified the routine to write a ViewCurveAttribute when writing a curve
//   view.  I split the view attributes into 2d and 3d parts.  I added code
//   to delete any existing views before adding the new ones.
//   
// ****************************************************************************

bool
SaveViewAction::CreateNode(DataNode *parentNode)
{
    if(parentNode == 0)
        return false;

    // Delete any existing views.
    DeleteViews();

    DataNode *saveviewNode = new DataNode("SaveViewAction");
    bool haveViews = false;

    // Add a node for each view that is not the default view.
    intVector viewTypes;
    for(int i = 0; i < views.size(); ++i)
    {
        if(views[i].viewType == VIEWCurve)
        {
            ViewCurveAttributes viewAtts;

            avtViewCurve *v = (avtViewCurve *)views[i].view;
            v->SetToViewCurveAttributes(&viewAtts);

            if(viewAtts.CreateNode(saveviewNode, false))
            {
                haveViews = true;
                viewTypes.push_back(views[i].viewType);
            }
        }
        else if(views[i].viewType == VIEW2D)
        {
            View2DAttributes viewAtts;

            avtView2D *v = (avtView2D *)views[i].view;
            v->SetToView2DAttributes(&viewAtts);

            if(viewAtts.CreateNode(saveviewNode, false))
            {
                haveViews = true;
                viewTypes.push_back(views[i].viewType);
            }
        }
        else if(views[i].viewType == VIEW3D)
        {
            View3DAttributes viewAtts;

            avtView3D *v = (avtView3D *)views[i].view;
            v->SetToView3DAttributes(&viewAtts);

            if(viewAtts.CreateNode(saveviewNode, false))
            {
                haveViews = true;
                viewTypes.push_back(views[i].viewType);
            }
        }
    }

    if(haveViews)
    {
        saveviewNode->AddNode(new DataNode("viewTypes", viewTypes));
        parentNode->AddNode(saveviewNode);
    }
    else
        delete saveviewNode;

    return haveViews;
}

// ****************************************************************************
// Method: SaveViewAction::SetFromNode
//
// Purpose: 
//   Reads in the saved views from the config.
//
// Arguments:
//   parentNode : The node that we're looking at for the config.
//
// Programmer: Brad Whitlock
// Creation:   Tue Jul 1 14:58:58 PST 2003
//
// Modifications:
//   Eric Brugger, Wed Aug 20 10:56:24 PDT 2003
//   I modified the routine to read a ViewCurveAttribute when reading a curve
//   view.  I split the view attributes into 2d and 3d parts.
//
//   Brad Whitlock, Tue Aug 12 11:31:04 PDT 2003
//   I made it clear out views before reading them back in so we don't get
//   an ever-increasing number of views.
//
// ****************************************************************************

void
SaveViewAction::SetFromNode(DataNode *parentNode)
{
    if(parentNode == 0)
        return;

    DataNode *saveviewNode = parentNode->GetNode("SaveViewAction");
    if(saveviewNode == 0)
        return;

    DataNode *viewTypesNode = saveviewNode->GetNode("viewTypes");
    if(viewTypesNode == 0)
        return;

    bool addedOrRemovedViews = false;
    if(views.size() > 0)
    {
        DeleteViewsFromInterface();
        addedOrRemovedViews = true;
    }

    const intVector &viewTypes = viewTypesNode->AsIntVector();
    DataNode **views = saveviewNode->GetChildren();
    int index = 0;
    for(int i = 0; i < saveviewNode->GetNumChildren(); ++i)
    {
        if(views[i]->GetKey() == "ViewCurveAttributes")
        {
            // Read the view from the config node.
            ViewCurveAttributes viewAtts;
            viewAtts.SetFromNode(views[i]);

            // Create the curve view.
            avtViewCurve *v = new avtViewCurve;
            v->SetFromViewCurveAttributes(&viewAtts);

            // Add it to the saved views.
            AddNewView((void *)v, VIEWCurve);
            addedOrRemovedViews = true;

            ++index;
        }
        else if(views[i]->GetKey() == "View2DAttributes")
        {
            // Read the view from the config node.
            View2DAttributes viewAtts;
            viewAtts.SetFromNode(views[i]);

            // Create the curve view.
            avtView2D *v = new avtView2D;
            v->SetFromView2DAttributes(&viewAtts);

            // Add it to the saved views.
            AddNewView((void *)v, VIEW2D);
            addedOrRemovedViews = true;

            ++index;
        }
        else if(views[i]->GetKey() == "View3DAttributes")
        {
            // Read the view from the config node.
            View3DAttributes viewAtts;
            viewAtts.SetFromNode(views[i]);

            // Create the curve view.
            avtView3D *v = new avtView3D;
            v->SetFromView3DAttributes(&viewAtts);

            // Add it to the saved views.
            AddNewView((void *)v, VIEW3D);
            addedOrRemovedViews = true;

            ++index;
        }
        else if(views[i]->GetKey() == "ViewAttributes")
        {
            //
            // This coding is for reading saved views from release 1.2 and
            // earlier.  It should be removed in release 1.3.
            //
            // Read the view from the config node.
            ViewAttributes viewAtts;
            viewAtts.SetFromNode(views[i]);

            // Use the information to create the appropriate view type.
            void *viewPtr = 0;
            if(viewTypes[index] == VIEW2D)
            {
                avtView2D *v = new avtView2D;
                for(int i = 0; i < 4; ++i)
                {
                    v->viewport[i] = viewAtts.GetViewportCoords()[i];
                    v->window[i] = viewAtts.GetWindowCoords()[i];
                }
                viewPtr = (void *)v;
            }
            else if(viewTypes[index] == VIEW3D)
            {
                avtView3D *v = new avtView3D;
                for(int i = 0; i < 3; ++i)
                {
                    v->normal[i] = viewAtts.GetViewNormal()[i];
                    v->focus[i]  = viewAtts.GetFocus()[i];
                    v->viewUp[i] = viewAtts.GetViewUp()[i];
                }

                v->viewAngle = viewAtts.GetViewAngle();
                v->parallelScale = viewAtts.GetParallelScale();
                v->nearPlane = viewAtts.GetNearPlane();
                v->farPlane = viewAtts.GetFarPlane();
                v->imagePan[0] = viewAtts.GetImagePan()[0];
                v->imagePan[1] = viewAtts.GetImagePan()[1];
                v->imageZoom = viewAtts.GetImageZoom();
                v->perspective = viewAtts.GetPerspective();
                viewPtr = (void *)v;
            }

            // If we created a new view, add it to the saved views.
            if(viewPtr)
            {
                AddNewView(viewPtr, viewTypes[index]);
                addedOrRemovedViews = true;
            }

            ++index;
        }
    }

    // If we added some views, update the menus.
    if(addedOrRemovedViews)
        UpdateConstruction();
}

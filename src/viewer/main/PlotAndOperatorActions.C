/*****************************************************************************
*
* Copyright (c) 2000 - 2014, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

#include <PlotAndOperatorActions.h>
#include <ParsingExprList.h>
#include <ViewerFileServer.h>
#include <ViewerPlot.h>
#include <ViewerPlotList.h>
#include <ViewerProperties.h>
#include <ViewerQueryManager.h>
#include <ViewerWindow.h>
#include <ViewerWindowManager.h>

#include <OperatorPluginManager.h>
#include <OperatorPluginInfo.h>
#include <PlotPluginManager.h>
#include <PlotPluginInfo.h>
#include <GlobalAttributes.h>

#include <snprintf.h>

#include <QAction>
#include <QIcon>
#include <QMainWindow>
#include <QMenuBar>
#include <QPixmapCache>
#include <QMenu>
#include <QToolBar>
#include <QToolButton>
#include <QToolTip>

#include <QvisVariablePopupMenu.h>

#include <DebugStream.h>
#include <InvalidExpressionException.h>

#define VMAX(A,B) (((A) > (B)) ? (A) : (B))

//
// Include icons
//
#include <removelastoperator.xpm>
#include <removealloperators.xpm>

// ****************************************************************************
// Method: AddOperatorAction::AddOperatorAction
//
// Purpose: 
//   Constructor for the AddOperator action.
//
// Arguments:
//   win : The window that owns the action.
//
// Programmer: Brad Whitlock
// Creation:   Mon Mar 17 09:12:08 PDT 2003
//
// Modifications:
//   Brad Whitlock, Tue Jul 27 18:11:58 PST 2004
//   Added code to prevent pixmaps from being created when in -nowin mode.
//
//   Brad Whitlock, Tue Apr 29 11:22:40 PDT 2008
//   Use the menu name from the plugin info since it's translatable. Use
//   GetUserSelectable from the plugin interface instead of checking for
//   a plugin name.
//
// ****************************************************************************

AddOperatorAction::AddOperatorAction(ViewerWindow *win) :
    ViewerMultipleAction(win), graphicalPlugins()
{
    SetAllText(tr("Add operator"));
    SetExclusive(false);

    //
    // Iterate through all of the loaded operator plugins and add a
    // choice for all of the ones that have icons.
    //
    ViewerOperatorPluginInfo *info = 0;
    OperatorPluginManager *pluginMgr = GetOperatorPluginManager();
    int nTypes = pluginMgr->GetNEnabledPlugins();
    for (int i = 0; i < nTypes; ++i)
    {
        info = pluginMgr->GetViewerPluginInfo(pluginMgr->GetEnabledID(i));
        if(info)
        {
            if(!GetViewerProperties()->GetNowin() && 
               info->XPMIconData() != 0 &&
               info->GetUserSelectable())
            {
                QString *menuName = info->GetMenuName();

                if(!GetViewerProperties()->GetNowin())
                {
                    // Create a pixmap for the operator or get its pixmap from
                    // the pixmap cache.
                    QString key;
                    key.sprintf("operator_icon_%s", info->GetName());
                    QPixmap pix;
                    if(!QPixmapCache::find(key, pix))
                    {
                        pix = QPixmap(info->XPMIconData());
                        QPixmapCache::insert(key, pix);
                    }

                    // Add a choice for operator so that it has an icon.
                    QString tip(tr("Add %1 operator").arg(*menuName));
                    AddChoice(*menuName, tip, pix);
                }
                else
                    AddChoice(*menuName);

                delete menuName;

                // Record that this plugin has an icon.
                graphicalPlugins.push_back(i);
            }
        }
    }
}

// ****************************************************************************
// Method: AddOperatorAction::~AddOperatorAction
//
// Purpose: 
//   Destructor for the AddOperatorAction class.
//
// Programmer: Brad Whitlock
// Creation:   Mon Mar 17 09:20:04 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

AddOperatorAction::~AddOperatorAction()
{
}

// ****************************************************************************
// Method: AddOperatorAction::Setup
//
// Purpose: 
//   This method is called when the toolbar button is clicked. It stores the
//   information about the button into the args so that the Execute method
//   can work for both toolbar clicks and commands from the client.
//
// Programmer: Brad Whitlock
// Creation:   Mon Mar 17 09:20:22 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

void
AddOperatorAction::Setup()
{
    args.SetOperatorType(graphicalPlugins[activeAction]);
}

// ****************************************************************************
// Method: AddOperatorAction::Execute
//
// Purpose: 
//   Adds an operator to the plots in the window's plot list.
//
// Programmer: Brad Whitlock
// Creation:   Mon Mar 17 09:21:25 PDT 2003
//
// Modifications:
//    Jeremy Meredith, Tue Jun 17 18:17:55 PDT 2003
//    Fixed a bug where disabling an operator would cause crashes when
//    using unrelated operators; it was using AllID instead of EnabledID.
//   
//    Kathleen Bonnell, Thu Sep 11 11:35:08 PDT 2003
//    Added 'from Default' to 'AddOperator'. 
//    
//    Kathleen Bonnell, Fri Jul  9 13:40:42 PDT 2004
//    Make ViewerWindow handle Lineouts (instead of ViewerQueryManager).
//    This is to ensure that new lineout windows that get created are 
//    properly initialized in SR mode. 
//    
// ****************************************************************************

void
AddOperatorAction::Execute(int)
{
    //
    // Get the rpc arguments.
    //
    int type = args.GetOperatorType();
    bool fromDefault = args.GetBoolFlag();

    OperatorPluginManager *opMgr = GetOperatorPluginManager();
    std::string name(opMgr->GetPluginName(opMgr->GetEnabledID(type)));
    if (name == "Lineout") // PLUGIN SIN!!!
    {
        window->Lineout(fromDefault);
    }
    else
    {
        //
        // Add the operator to the window's plot list.
        //
        bool applyToAllWindows = windowMgr->GetClientAtts()->GetApplyWindow();
        bool applyOperatorToAllPlots = windowMgr->GetClientAtts()->GetApplyOperator();

        if( applyToAllWindows )
        {
          for( int i=0; i< windowMgr->GetNumWindows(); ++i )
          {
            windowMgr->GetWindow(i)->GetPlotList()->
              AddOperator(type, applyOperatorToAllPlots, fromDefault);
          }
        }
        else // Just the active window
        {
          window->GetPlotList()->
            AddOperator(type, applyOperatorToAllPlots, fromDefault);
        }
    }
}

// ****************************************************************************
// Method: AddOperatorAction::Enabled()
//
// Purpose: 
//   This method indicates when the action is enabled.
//
// Returns:    A bool indicating when the action is enabled.
//
// Programmer: Brad Whitlock
// Creation:   Mon Mar 17 09:22:22 PDT 2003
//
// Modifications:
//   Brad Whitlock, Fri Apr 4 14:10:07 PST 2003
//   I disabled the action in curve windows.
//
//   Eric Brugger, Wed Aug 20 10:53:00 PDT 2003
//   I removed the disabling of the action in curve windows.
//
// ****************************************************************************

bool
AddOperatorAction::Enabled() const
{
    return ViewerMultipleAction::Enabled() &&
           (window->GetPlotList()->GetNumPlots() > 0);
}

// ****************************************************************************
// Method: AddOperatorAction::ChoiceEnabled
//
// Purpose: 
//   This method indicates when individual choices in the action are enabled.
//
// Returns:    true
//
// Programmer: Brad Whitlock
// Creation:   Mon Mar 17 09:22:55 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

bool
AddOperatorAction::ChoiceEnabled(int) const
{
    return true;
}

// ****************************************************************************
// Method: AddOperatorAction::ConstructToolbar
//
// Purpose: 
//   Adds the action's operators to the toolbar.
//
// Arguments:
//   toolbar : The toolbar to which the operators will be added.
//
// Programmer: Brad Whitlock
// Creation:   Thu Mar 20 12:48:44 PDT 2003
//
// Modifications:
//   Brad Whitlock, Thu May 22 13:49:04 PDT 2008
//   Qt 4.
//
// ****************************************************************************

void
AddOperatorAction::ConstructToolbar(QToolBar *toolbar)
{
    ViewerMultipleAction::ConstructToolbar(toolbar);
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: PromoteOperatorAction::PromoteOperatorAction
//
// Purpose: 
//   Constructor for the PromoteOperatorAction class.
//
// Arguments:
//   win : The window to which the action belongs.
//
// Programmer: Brad Whitlock
// Creation:   Thu Apr 10 09:47:19 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

PromoteOperatorAction::PromoteOperatorAction(ViewerWindow *win) : ViewerAction(win)
{
    DisableVisual();
}

// ****************************************************************************
// Method: PromoteOperatorAction::~PromoteOperatorAction
//
// Purpose: 
//   Destructor for the PromoteOperatorAction class.
//
// Programmer: Brad Whitlock
// Creation:   Thu Apr 10 09:48:36 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

PromoteOperatorAction::~PromoteOperatorAction()
{
}

// ****************************************************************************
// Method: PromoteOperatorAction::Execute
//
// Purpose: 
//   This method executes the action.
//
// Programmer: Brad Whitlock
// Creation:   Thu Apr 10 09:48:59 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

void
PromoteOperatorAction::Execute()
{
    bool applyToAllWindows = windowMgr->GetClientAtts()->GetApplyWindow();
    bool applyOperatorToAllPlots = windowMgr->GetClientAtts()->GetApplyOperator();

    if( applyToAllWindows )
    {
      for( int i=0; i< windowMgr->GetNumWindows(); ++i )
      {
        windowMgr->GetWindow(i)->GetPlotList()->
          PromoteOperator(args.GetOperatorType(), applyOperatorToAllPlots);
      }
    }
    else // Just the active window
    {
      window->GetPlotList()->
        PromoteOperator(args.GetOperatorType(), applyOperatorToAllPlots);
    }
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: DemoteOperatorAction::DemoteOperatorAction
//
// Purpose: 
//   Constructor for the DemoteOperatorAction class.
//
// Arguments:
//   win : The window to which the action belongs.
//
// Programmer: Brad Whitlock
// Creation:   Thu Apr 10 09:47:19 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

DemoteOperatorAction::DemoteOperatorAction(ViewerWindow *win) : ViewerAction(win)
{
    DisableVisual();
}

// ****************************************************************************
// Method: DemoteOperatorAction::~DemoteOperatorAction
//
// Purpose: 
//   Destructor for the DemoteOperatorAction class.
//
// Programmer: Brad Whitlock
// Creation:   Thu Apr 10 09:48:36 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

DemoteOperatorAction::~DemoteOperatorAction()
{
}

// ****************************************************************************
// Method: DemoteOperatorAction::Execute
//
// Purpose: 
//   This method executes the action.
//
// Programmer: Brad Whitlock
// Creation:   Thu Apr 10 09:48:59 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

void
DemoteOperatorAction::Execute()
{
    bool applyToAllWindows = windowMgr->GetClientAtts()->GetApplyWindow();
    bool applyOperatorToAllPlots = windowMgr->GetClientAtts()->GetApplyOperator();

    if( applyToAllWindows )
    {
      for( int i=0; i< windowMgr->GetNumWindows(); ++i )
      {
        windowMgr->GetWindow(i)->GetPlotList()->
          DemoteOperator(args.GetOperatorType(), applyOperatorToAllPlots);
      }
    }
    else // Just the active window
    {
      window->GetPlotList()->
        DemoteOperator(args.GetOperatorType(), applyOperatorToAllPlots);
    }
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: RemoveOperatorAction::RemoveOperatorAction
//
// Purpose: 
//   Constructor for the RemoveOperatorAction class.
//
// Arguments:
//   win : The window to which the action belongs.
//
// Programmer: Brad Whitlock
// Creation:   Thu Apr 10 09:47:19 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

RemoveOperatorAction::RemoveOperatorAction(ViewerWindow *win) : ViewerAction(win)
{
    DisableVisual();
}

// ****************************************************************************
// Method: RemoveOperatorAction::~RemoveOperatorAction
//
// Purpose: 
//   Destructor for the RemoveOperatorAction class.
//
// Programmer: Brad Whitlock
// Creation:   Thu Apr 10 09:48:36 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

RemoveOperatorAction::~RemoveOperatorAction()
{
}

// ****************************************************************************
// Method: RemoveOperatorAction::Execute
//
// Purpose: 
//   This method executes the action.
//
// Programmer: Brad Whitlock
// Creation:   Thu Apr 10 09:48:59 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

void
RemoveOperatorAction::Execute()
{
    bool applyToAllWindows = windowMgr->GetClientAtts()->GetApplyWindow();
    bool applyOperatorToAllPlots = windowMgr->GetClientAtts()->GetApplyOperator();

    if( applyToAllWindows )
    {
      for( int i=0; i< windowMgr->GetNumWindows(); ++i )
      {
        windowMgr->GetWindow(i)->GetPlotList()->
          RemoveOperator(args.GetOperatorType(), applyOperatorToAllPlots);
      }
    }
    else // Just the active window
    {
      window->GetPlotList()->
        RemoveOperator(args.GetOperatorType(), applyOperatorToAllPlots);
    }
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: RemoveLastOperatorAction::RemoveLastOperatorAction
//
// Purpose: 
//   Constructor for the RemoveLastOperatorAction class.
//
// Arguments:
//   win : The window to which the action belongs.
//
// Programmer: Brad Whitlock
// Creation:   Thu Mar 20 12:41:50 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

RemoveLastOperatorAction::RemoveLastOperatorAction(ViewerWindow *win) : ViewerAction(win)
{
    SetAllText(tr("Remove last operator"));
    if(!GetViewerProperties()->GetNowin())
        SetIcon(QIcon(QPixmap(removelastoperator_xpm)));
}

// ****************************************************************************
// Method: RemoveLastOperatorAction::~RemoveLastOperatorAction
//
// Purpose: 
//   Destructor for the RemoveLastOperatorAction class.
//
// Programmer: Brad Whitlock
// Creation:   Thu Mar 20 12:41:50 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

RemoveLastOperatorAction::~RemoveLastOperatorAction()
{
}

// ****************************************************************************
// Method: RemoveLastOperatorAction::Execute
//
// Purpose: 
//   Executes the work for RemoveLastOperatorAction.
//
// Programmer: Brad Whitlock
// Creation:   Thu Mar 20 12:41:50 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

void
RemoveLastOperatorAction::Execute()
{
    bool applyToAllWindows = windowMgr->GetClientAtts()->GetApplyWindow();
    bool applyOperatorToAllPlots = windowMgr->GetClientAtts()->GetApplyOperator();

    if( applyToAllWindows )
    {
      for( int i=0; i<windowMgr->GetNumWindows(); ++i )
      {
        windowMgr->GetWindow(i)->GetPlotList()->
          RemoveLastOperator(applyOperatorToAllPlots);
      }
    }
    else // Just the active window
    {
      window->GetPlotList()->
        RemoveLastOperator(applyOperatorToAllPlots);
    }
}

// ****************************************************************************
// Method: RemoveLastOperatorAction::Enabled
//
// Purpose: 
//   Returns when this action is enabled.
//
// Returns:    Returns true when the action is enabled; false otherwise.
//
// Programmer: Brad Whitlock
// Creation:   Thu Mar 20 12:41:50 PDT 2003
//
// Modifications:
//   Eric Brugger, Wed Aug 20 10:53:00 PDT 2003
//   I removed the disabling of the action in curve windows.
//   
// ****************************************************************************

bool
RemoveLastOperatorAction::Enabled() const
{
    return window->GetPlotList()->GetNumPlots() > 0;
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: RemoveAllOperatorsAction::RemoveAllOperatorsAction
//
// Purpose: 
//   Constructor for the RemoveAllOperatorsAction class.
//
// Arguments:
//   win : The window to which the action belongs.
//
// Programmer: Brad Whitlock
// Creation:   Thu Mar 20 12:41:50 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

RemoveAllOperatorsAction::RemoveAllOperatorsAction(ViewerWindow *win) : 
    ViewerAction(win)
{
    SetAllText(tr("Remove all operators"));
    if(!GetViewerProperties()->GetNowin())
        SetIcon(QIcon(QPixmap(removealloperators_xpm)));
}

// ****************************************************************************
// Method: RemoveAllOperatorsAction::~RemoveAllOperatorsAction
//
// Purpose: 
//   Denstructor for the RemoveAllOperatorsAction class.
//
// Programmer: Brad Whitlock
// Creation:   Thu Mar 20 12:41:50 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

RemoveAllOperatorsAction::~RemoveAllOperatorsAction()
{
}

// ****************************************************************************
// Method: RemoveAllOperatorsAction::Execute
//
// Purpose: 
//   Executes the RemoveAllOperatorsAction.
//
// Programmer: Brad Whitlock
// Creation:   Thu Mar 20 12:41:50 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

void
RemoveAllOperatorsAction::Execute()
{
    bool applyToAllWindows = windowMgr->GetClientAtts()->GetApplyWindow();
    bool applyOperatorToAllPlots = windowMgr->GetClientAtts()->GetApplyOperator();

    if( applyToAllWindows )
    {
      for( int i=0; i<windowMgr->GetNumWindows(); ++i )
      {
        windowMgr->GetWindow(i)->GetPlotList()->
          RemoveAllOperators(applyOperatorToAllPlots);
      }
    }
    else // Just the active window
    {
      window->GetPlotList()->
        RemoveAllOperators(applyOperatorToAllPlots);
    }
}

// ****************************************************************************
// Method: RemoveAllOperatorsAction::Enabled
//
// Purpose: 
//   Returns when this action is enabled.
//
// Returns:    True if the action is enabled; false otherwise.
//
// Programmer: Brad Whitlock
// Creation:   Thu Mar 20 12:41:50 PDT 2003
//
// Modifications:
//   Brad Whitlock, Fri Apr 4 14:21:24 PST 2003
//   I made the action inactive in curve windows.
//
//   Eric Brugger, Wed Aug 20 10:53:00 PDT 2003
//   I removed the disabling of the action in curve windows.
//   
// ****************************************************************************

bool
RemoveAllOperatorsAction::Enabled() const
{
    return window->GetPlotList()->GetNumPlots() > 0;
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: SetOperatorOptionsAction::SetOperatorOptionsAction
//
// Purpose: 
//   Constructor for the SetOperatorOptionsAction class.
//
// Arguments:
//   win : The window to which the action belongs.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 07:58:39 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

SetOperatorOptionsAction::SetOperatorOptionsAction(ViewerWindow *win) : 
   ViewerAction(win)
{
    DisableVisual();
}

// ****************************************************************************
// Method: SetOperatorOptionsAction::~SetOperatorOptionsAction
//
// Purpose: 
//   Destructor for the SetOperatorOptionsAction class.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:02:35 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

SetOperatorOptionsAction::~SetOperatorOptionsAction()
{
}

// ****************************************************************************
// Method: SetOperatorOptionsAction::Execute
//
// Purpose: 
//   Sets the operator attributes.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:02:54 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

void
SetOperatorOptionsAction::Execute()
{
    //
    // Set the operator attributes.
    //
    int  oper = args.GetOperatorType();
    bool applyToAllWindows = windowMgr->GetClientAtts()->GetApplyWindow();
    bool applyOperatorToAllPlots = windowMgr->GetClientAtts()->GetApplyOperator();
    
    if( applyToAllWindows )
    {
      for( int i=0; i<windowMgr->GetNumWindows(); ++i )
      {
        windowMgr->GetWindow(i)->GetPlotList()->
          SetPlotOperatorAtts(oper, windowMgr->GetWindow(i)==window,
                              applyToAllWindows, applyOperatorToAllPlots);
      }
    }
    else // Just the active window
    {
      window->GetPlotList()->
        SetPlotOperatorAtts(oper, true,
                            applyToAllWindows, applyOperatorToAllPlots);
    }
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: AddEmbeddedPlotAction::AddEmbeddedPlotAction
//
// Purpose: 
//   Constructor for the AddEmbeddedPlotAction class.
//
// Arguments:
//   win : The window that owns the action.
//
// Programmer: Marc Durant
// Creation:   June 19, 2011
//
// Modifications:
//   Brad Whitlock, Mon Aug 18 11:20:32 PDT 2014
//   Do not make a menu for this action.
//
// ****************************************************************************

AddEmbeddedPlotAction::AddEmbeddedPlotAction(ViewerWindow *win) : ViewerAction(win)
{
    SetAllText(tr("Add Plot With Id"));
    DisableVisual();
}

// ****************************************************************************
// Method: AddEmbeddedPlotAction::~AddEmbeddedPlotAction
//
// Purpose: 
//   Destructor for the AddEmbeddedPlotAction class.
//
// Programmer: Marc Durant
// Creation:   June 19, 2011
//
// Modifications:
//
// ****************************************************************************

AddEmbeddedPlotAction::~AddEmbeddedPlotAction()
{
}

// ****************************************************************************
// Method: AddEmbeddedPlotAction::Enabled
//
// Purpose: 
//   This method lets callers know if the action's menu should be enabled.
//
// Programmer: Marc Durant
// Creation:   June 19, 2011
//
// Modifications:
//   
// ****************************************************************************

bool
AddEmbeddedPlotAction::Enabled() const
{
  return false;
}

// ****************************************************************************
// Method: AddEmbeddedPlotAction::Execute
//
// Purpose: 
//   This method is called when the AddEmbeddedPlotAction must be executed.
//
// Programmer: Marc Durant
// Creation:   June 19, 2011
//
// Modifications:
//
// ****************************************************************************

void
AddEmbeddedPlotAction::Execute()
{
  bool replacePlots = windowMgr->GetClientAtts()->GetReplacePlots();
  bool applyOperator = windowMgr->GetClientAtts()->GetApplyOperator();
  bool applySelection = windowMgr->GetClientAtts()->GetApplySelection();
  bool inheritSILRestriction = windowMgr->GetClientAtts()->
  GetNewPlotsInheritSILRestriction();
  
  //
  // Try and create the plot.
  //
  window->GetPlotList()->AddPlot(args.GetPlotType(),
                                 args.GetVariable().c_str(), replacePlots, applyOperator,
                                 inheritSILRestriction, applySelection, NULL, args.GetEmbeddedPlotId());
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: AddPlotAction::AddPlotAction
//
// Purpose: 
//   Constructor for the AddPlotAction class.
//
// Arguments:
//   win : The window that owns the action.
//
// Programmer: Brad Whitlock
// Creation:   Thu Mar 20 12:41:50 PDT 2003
//
// Modifications:
//   Brad Whitlock, Mon Sep 29 17:39:17 PST 2003
//   Initialized host.
//
//   Brad Whitlock, Tue Jul 27 18:09:16 PST 2004
//   Changed so pixmaps are not created when we're in -nowin mode.
//
//   Brad Whitlock, Tue Apr 29 11:41:42 PDT 2008
//   Added tr(), remove code to disable Curve plot. Made the code use the
//   plot's menu name.
//
//   Brad Whitlock, Thu May 22 13:53:02 PDT 2008
//   Qt 4.
//
// ****************************************************************************

AddPlotAction::AddPlotAction(ViewerWindow *win) : ViewerMultipleAction(win),
    pluginEntries(), menuPopulator()
{
    SetAllText(tr("Add plot"));
    SetExclusive(false);

    maxPixmapWidth = maxPixmapHeight = 0;

    //
    // Iterate through all of the loaded plot plugins and add a
    // choice for all of the ones that have icons.
    //
    ViewerPlotPluginInfo *info = 0;
    PlotPluginManager *pluginMgr = GetPlotPluginManager();
    for(int i = 0; i < pluginMgr->GetNEnabledPlugins(); ++i)
    {
        info = pluginMgr->GetViewerPluginInfo(pluginMgr->GetEnabledID(i));
        if(info)
        {
            if(!GetViewerProperties()->GetNowin() && info->XPMIconData() != 0)
            {
                QString *menuName = info->GetMenuName();

                // Create a pixmap for the plot or get its pixmap from
                // the pixmap cache.
                if(!GetViewerProperties()->GetNowin())
                {
                    QString key;
                    key.sprintf("plot_icon_%s", info->GetName());
                    QPixmap pix;
                    if(!QPixmapCache::find(key, pix))
                    {
                        pix = QPixmap(info->XPMIconData());
                        QPixmapCache::insert(key, pix);
                    }

                    // Find the maximum pixmap width and height
                    maxPixmapWidth = VMAX(maxPixmapWidth, pix.width());
                    maxPixmapHeight = VMAX(maxPixmapHeight, pix.height());

                    // Add a choice for plot so that it has an icon.
                    QString tip(tr("Add %1 plot").arg(*menuName));
                    AddChoice(*menuName, tip, pix);
                }
                else
                    AddChoice(*menuName);

                delete menuName;

                // Record the plugin entry.
                PluginEntry p;
                p.index = i;
                p.varMenu = 0;
                p.varTypes = info->GetVariableTypes();
                pluginEntries.push_back(p);
            }
        }
    }
}

// ****************************************************************************
// Method: AddPlotAction::~AddPlotAction
//
// Purpose: 
//   Destructor for the AddPlotAction class.
//
// Note:       We manually delete the menus because they have no parent widget.
//
// Programmer: Brad Whitlock
// Creation:   Thu Mar 20 12:42:34 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

AddPlotAction::~AddPlotAction()
{
    for(size_t i = 0; i < pluginEntries.size(); ++i)
        delete pluginEntries[i].varMenu;
}

// ****************************************************************************
// Method: AddPlotAction::Update
//
// Purpose: 
//   This method is called when the action needs to be updated.
//
// Programmer: Brad Whitlock
// Creation:   Thu Mar 20 12:43:45 PDT 2003
//
// Modifications:
//   Brad Whitlock, Mon Sep 29 17:03:33 PST 2003
//   I changed the code so it no longer will attempt to get the metadata and
//   the SIL for an invalid database name.
//
//   Brad Whitlock, Mon Sep 29 17:39:31 PST 2003
//   I separated the database into host and database and queried it from the
//   plot list in such a way that it is more likely to be valid.
//
//   Brad Whitlock, Tue Feb 24 16:37:30 PST 2004
//   I changed the code so the menu is only updated then the variable menu
//   populator indicates that it needed an update due to a different
//   database name or a different expression list.
//
//   Brad Whitlock, Wed Dec 8 15:28:59 PST 2004
//   I updated the code to use a new interface to
//   VariableMenuPopulator::UpdateSingleVariableMenu.
//
//   Brad Whitlock, Fri Apr 15 13:39:32 PST 2005
//   Added code to clear the menu since the menu populator no longer does
//   menu clearing. I also made the variable menu populator responsible for
//   deciding when the menu must be cleared since it does a better overall
//   job.
//
//   Mark C. Miller, Thu Jun 14 10:26:37 PDT 2007
//   Added bool to treat all databases as time varying to call to
//   PopulateVariableLists
//
//   Mark C. Miller, Wed Aug 22 20:16:59 PDT 2007
//   Changed how treatAllDBsAsTimeVarying to be obtained from
//   ViewerWindowManager which manages the GlobalAttributes object
//
//   Brad Whitlock, Thu May 29 15:50:33 PDT 2008
//   Qt 4.
//
//   Rob Sisneros, Sun Aug 29 20:13:10 CDT 2010
//   Put expressions from operators into the pipeline.
//
//   Brad Whitlock, Fri Nov 19 15:05:34 PST 2010
//   I changed the code so it deletes and recreates the menu since clearing
//   it did not free memory.
//
// ****************************************************************************

void
AddPlotAction::Update()
{
    if(pluginEntries.size() > 0)
    {
        ViewerPlotList *plotList = window->GetPlotList();
        const std::string &host = plotList->GetHostName();
        const std::string &database = plotList->GetDatabaseName();

        if(host.size() > 0 && database.size() > 0)
        {
            // Get the metadata and SIL for the file.
            ViewerFileServer *fileServer = ViewerFileServer::Instance();
            const avtDatabaseMetaData *md = fileServer->GetMetaData(host, database);
            const avtSIL *sil = fileServer->GetSIL(host, database);
            const ExpressionList *exprList = ParsingExprList::Instance()->GetList();

            //
            // Repopulate the menu variable list using information from the
            // new file.
            //

            OperatorPluginManager *oPM = GetOperatorPluginManager();
            bool treatAllDBsAsTimeVarying =
                ViewerWindowManager::Instance()->GetClientAtts()->GetTreatAllDBsAsTimeVarying();
            if(menuPopulator.PopulateVariableLists(plotList->GetHostDatabaseName(),
                                                   md, sil, exprList,
                                                   oPM,
                                                   treatAllDBsAsTimeVarying))
            {
                // Print to the debug logs.
                debug4 << "AddPlotAction::Update: Either the host or the database " << endl
                       << "changed so we need to update the variable menu!" << endl
                       << "\thost=" << host.c_str() << endl
                       << "\tdb=" << database.c_str() << endl;

                //
                // Update the variable menus for the actions.
                //
                bool menuEnabled = false;
                for(int i = 0; i < (int)pluginEntries.size(); ++i)
                {
                    DeletePlotMenu(i);
                    CreatePlotMenu(i);

                    int varCount = menuPopulator.UpdateSingleVariableMenu(
                        pluginEntries[i].varMenu,
                        pluginEntries[i].varTypes, this, 
                        SLOT(addPlot(int, const QString &)));
                    bool hasEntries = (varCount > 0);

                    // Set the new menu's enabled state based on the variable type.
                    if(hasEntries != pluginEntries[i].varMenu->isEnabled())
                        pluginEntries[i].varMenu->setEnabled(hasEntries);
                    menuEnabled |= hasEntries;
                }
            }
        }
    }

    ViewerMultipleAction::Update();
}

// ****************************************************************************
// Method: AddPlotAction::Execute
//
// Purpose: 
//   This method is called when the AddPlotAction must be executed.
//
// Programmer: Brad Whitlock
// Creation:   Thu Mar 20 12:44:42 PDT 2003
//
// Modifications:
//   Brad Whitlock, Thu Jan 24 11:39:15 PDT 2008
//   Made inheriting the SIL restriction optional.
//
//   Brad Whitlock, Thu Aug 12 14:36:18 PDT 2010
//   Pass applySelection so it affects whether a plot is created with a 
//   named selection.
//
// ****************************************************************************

void
AddPlotAction::Execute(int)
{
    bool replacePlots = windowMgr->GetClientAtts()->GetReplacePlots();
    bool applyOperator = windowMgr->GetClientAtts()->GetApplyOperator();
    bool applySelection = windowMgr->GetClientAtts()->GetApplySelection();
    bool inheritSILRestriction = windowMgr->GetClientAtts()->
        GetNewPlotsInheritSILRestriction();

    //
    // Try and create the plot.
    //
    window->GetPlotList()->AddPlot(args.GetPlotType(),
        args.GetVariable().c_str(), replacePlots, applyOperator,
        inheritSILRestriction, applySelection);
}

// ****************************************************************************
// Method: AddPlotAction::Enabled
//
// Purpose: 
//   This method lets callers know if the action's menu should be enabled.
//
// Programmer: Brad Whitlock
// Creation:   Thu Mar 20 12:45:14 PDT 2003
//
// Modifications:
//   Brad Whitlock, Fri Apr 4 14:11:58 PST 2003
//   I prevented the action from being enabled in curve windows.
//
//   Eric Brugger, Wed Aug 20 10:53:00 PDT 2003
//   I removed the disabling of the action in curve windows.
//   
// ****************************************************************************

bool
AddPlotAction::Enabled() const
{
    bool dbIsOpen = (window->GetPlotList()->GetHostDatabaseName().length() > 0);
    return ViewerMultipleAction::Enabled() && dbIsOpen;
}

// ****************************************************************************
// Method: AddPlotAction::ChoiceEnabled
//
// Purpose: 
//   This method lets callers know a choice in the action's menu should
//   be enabled.
//
// Arguments:
//   i : The index of the menu item that we're checking.
//
// Programmer: Brad Whitlock
// Creation:   Thu Mar 20 12:46:09 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

bool
AddPlotAction::ChoiceEnabled(int i) const
{
    return menuPopulator.ItemEnabled(pluginEntries[i].varTypes);
}

// ****************************************************************************
// Method: AddPlotAction::CreatePlotMenu
//
// Purpose: 
//   This method creates the i'th plot menu.
//
// Arguments:
//   i : The index of the plot menu we're creating.
//
// Programmer: Brad Whitlock
// Creation:   Fri Nov 19 15:09:34 PST 2010
//
// Modifications:
//   
// ****************************************************************************

void
AddPlotAction::CreatePlotMenu(int i)
{
    // Create the menu for the plot.
    pluginEntries[i].varMenu = new QvisVariablePopupMenu(i, 0);
    pluginEntries[i].varMenu->setIcon(children[i]->icon());
    pluginEntries[i].varMenu->setTitle(children[i]->text());
    connect(pluginEntries[i].varMenu, SIGNAL(activated(int, const QString &)),
            this, SLOT(addPlot(int, const QString &)));

    // Set the variable menu into the action
    children[i]->setMenu(pluginEntries[i].varMenu);
}

// ****************************************************************************
// Method: AddPlotAction::DeletePlotMenu
//
// Purpose: 
//   This method deletes the i'th plot menu.
//
// Arguments:
//   i : The index of the plot menu we're deleting.
//
// Programmer: Brad Whitlock
// Creation:   Fri Nov 19 15:09:34 PST 2010
//
// Modifications:
//   
// ****************************************************************************

void
AddPlotAction::DeletePlotMenu(int i)
{
    if(pluginEntries[i].varMenu != 0)
    {
        delete pluginEntries[i].varMenu;
        pluginEntries[i].varMenu = 0;
    }
}

// ****************************************************************************
// Method: AddPlotAction::ConstructMenu
//
// Purpose: 
//   This method constructs a menu that contains the plots that are available.
//
// Arguments:
//   menu : The parent menu.
//
// Programmer: Brad Whitlock
// Creation:   Thu Mar 20 12:47:03 PDT 2003
//
// Modifications:
//   Brad Whitlock, Wed May 28 16:50:13 PDT 2008
//   Qt 4.
//
// ****************************************************************************

void
AddPlotAction::ConstructMenu(QMenu *menu)
{
    // Create a new menu and add all of the actions to it.
    actionMenu = new QMenu("Add plot", menu);

    for(int i = 0; i < (int)pluginEntries.size(); ++i)
    {
        // Create the menu for the plot.
        CreatePlotMenu(i);

        // Add the action into the actionMenu
        actionMenu->addAction(children[i]);
    }

    // Insert the new menu into the old menu.
    if(iconSpecified)
        actionMenu->setIcon(icon);
    actionMenu->setTitle(menuText);
    menu->addMenu(actionMenu);
}

// ****************************************************************************
// Method: AddPlotAction::RemoveFromMenu
//
// Purpose: 
//   Removes the action from the menu.
//
// Arguments:
//   menu : The menu from which the action should be removed.
//
// Programmer: Brad Whitlock
// Creation:   Thu Mar 20 12:47:43 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

void
AddPlotAction::RemoveFromMenu(QMenu *menu)
{
    // NOT IMPLEMENTED. Remove the action from the menu.
}

// ****************************************************************************
// Method: AddPlotAction::ConstructToolbar
//
// Purpose: 
//   Adds the action's plots to the toolbar.
//
// Arguments:
//   toolbar : The toolbar to which the plots will be added.
//
// Note:       We add the plots as a QMenuBar so we can have nice popup menu
//             selection. This presented some problems in menu orientation,
//             and toolbars but those problems are pretty much solved.
//
// Programmer: Brad Whitlock
// Creation:   Thu Mar 20 12:48:44 PDT 2003
//
// Modifications:
//   Brad Whitlock, Tue Mar 16 15:34:28 PST 2004
//   I added code to create the toolbar using the right icon size. The new
//   code also connects a signal from the vis window that tells this object
//   to update its icons when the icon size in the vis window changes.
//
//   Brad Whitlock, Tue Apr 29 11:45:08 PDT 2008
//   Added tr()
//
//   Brad Whitlock, Thu May 29 16:37:07 PDT 2008
//   Qt 4. Ditched menu-based implementation.
//
// ****************************************************************************

void
AddPlotAction::ConstructToolbar(QToolBar *toolbar)
{
    for(size_t i = 0; i < children.size(); ++i)
        toolbar->addAction(children[i]);
}

// ****************************************************************************
// Method: AddPlotAction::addPlot
//
// Purpose: 
//   This is a Qt slot function, which is private to this class, that is called
//   when the user makes a selection from one of the variable menus.
//
// Arguments:
//   index : The index of the selected plot type in the toolbar/menu.
//   var   : The name of the variable that was selected.
//
// Programmer: Brad Whitlock
// Creation:   Thu Mar 20 12:50:41 PDT 2003
//
// Modifications:
//   Brad Whitlock, Fri Apr 15 13:37:32 PST 2005
//   Changed to the no argument Activate call.
//
// ****************************************************************************

void
AddPlotAction::addPlot(int index, const QString &var)
{
    // Hide the menu if it is active.
    int plotType = pluginEntries[index].index;
    pluginEntries[index].varMenu->hide();

    // Set the plot type and variable name into the args.
    args.SetPlotType(plotType);
    args.SetVariable(var.toStdString());

    // Execute the action.
    Activate();
}

// ****************************************************************************
// Method: AddPlotAction::changeMenuIconSize
//
// Purpose: 
//   This method is called when the vis window changes its icon size.
//
// Arguments:
//   large : Whether the vis window is using large icons.
//
// Notes:      This code should also update the tool tips on the menu widget
//             but that can be done later.
//
// Programmer: Brad Whitlock
// Creation:   Tue Mar 16 15:26:21 PST 2004
//
// Modifications:
//   Brad Whitlock, Mon Aug 2 09:57:20 PDT 2004
//   Prevented any action in -nowin mode.
//
//   Brad Whitlock, Thu May 22 14:16:17 PDT 2008
//   Qt 4.
//
// ****************************************************************************

void
AddPlotAction::changeMenuIconSize(bool large)
{
    if(!GetViewerProperties()->GetNowin())
    {
#if 1
//#//warning Finish porting AddPlotAction::changeMenuIconSize
#else
        if(large)
        {
            for(int i = 0; i < pluginEntries.size(); ++i)
            {
                QPixmap pix(children[i]->icon().pixmap(Qt::Large,
                            QIcon::Normal));
                menu->changeItem(i, pix);
            }
        }
        else
        {
            for(int i = 0; i < pluginEntries.size(); ++i)
            {
                QPixmap pix(children[i]->icon().pixmap(Qt::Small,
                            QIcon::Normal));
                menu->changeItem(i, pix);
            }
        }
#endif
    }
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: DrawPlotsAction::DrawPlotsAction
//
// Purpose: 
//   Constructor for the DrawPlotsAction class.
//
// Arguments:
//   win : The window that owns the action.
//
// Programmer: Brad Whitlock
// Creation:   Fri Mar 21 15:55:52 PST 2003
//
// Modifications:
//   
// ****************************************************************************

DrawPlotsAction::DrawPlotsAction(ViewerWindow *win) : ViewerAction(win)
{
    SetAllText(tr("Draw plots"));
}

// ****************************************************************************
// Method: DrawPlotsAction::~DrawPlotsAction
//
// Purpose: 
//   Destructor for the DrawPlotsAction class.
//
// Programmer: Brad Whitlock
// Creation:   Fri Mar 21 15:55:34 PST 2003
//
// Modifications:
//   
// ****************************************************************************

DrawPlotsAction::~DrawPlotsAction()
{
}

// ****************************************************************************
// Method: DrawPlotsAction::Execute
//
// Purpose: 
//   Draws the plots
//
// Programmer: Brad Whitlock
// Creation:   Fri Mar 21 15:51:48 PST 2003
//
// Modifications:
//  Ellen Tarwater October 12, 2007
//  added flag for active vs all plots
//   
// ****************************************************************************

void
DrawPlotsAction::Execute()
{
    bool applyToAllWindows = windowMgr->GetClientAtts()->GetApplyWindow();
    
    if( applyToAllWindows )
    {
      for( int i=0; i<windowMgr->GetNumWindows(); ++i )
      {
        windowMgr->GetWindow(i)->GetPlotList()->
          RealizePlots(args.GetBoolFlag());
      }
    }
    else // Just the active window
    {
      window->GetPlotList()->RealizePlots(args.GetBoolFlag());
    }
}

// ****************************************************************************
// Method: DrawPlotsAction::Enabled
//
// Purpose: 
//   Returns whether the action is enabled.
//
// Programmer: Brad Whitlock
// Creation:   Fri Mar 21 15:51:48 PST 2003
//
// Modifications:
//   
// ****************************************************************************

bool
DrawPlotsAction::Enabled() const
{
    return (window->GetPlotList()->GetNumPlots() > 0);
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: HideActivePlotsAction::HideActivePlotsAction
//
// Purpose: 
//   Constructor for the HideActivePlotsAction class.
//
// Arguments:
//   win : The window that owns the action.
//
// Programmer: Brad Whitlock
// Creation:   Fri Mar 21 15:54:54 PST 2003
//
// Modifications:
//   
// ****************************************************************************

HideActivePlotsAction::HideActivePlotsAction(ViewerWindow *win) : ViewerAction(win)
{
    SetAllText(tr("Hide active plots"));
    // Think of an icon...
}

// ****************************************************************************
// Method: HideActivePlotsAction::~HideActivePlotsAction
//
// Purpose: 
//   Destructor for the HideActivePlotsAction class.
//
// Programmer: Brad Whitlock
// Creation:   Fri Mar 21 15:54:27 PST 2003
//
// Modifications:
//   
// ****************************************************************************

HideActivePlotsAction::~HideActivePlotsAction()
{
}

// ****************************************************************************
// Method: HideActivePlotsAction::Execute
//
// Purpose: 
//   Hides the active plots.
//
// Programmer: Brad Whitlock
// Creation:   Fri Mar 21 15:51:48 PST 2003
//
// Modifications:
//   
// ****************************************************************************

void
HideActivePlotsAction::Execute()
{
    window->GetPlotList()->HideActivePlots();
}

// ****************************************************************************
// Method: HideActivePlotsAction::Enabled
//
// Purpose: 
//   Returns whether the action is enabled.
//
// Programmer: Brad Whitlock
// Creation:   Fri Mar 21 15:51:48 PST 2003
//
// Modifications:
//   
// ****************************************************************************

bool
HideActivePlotsAction::Enabled() const
{
    return (window->GetPlotList()->GetNumPlots() > 0);
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: DeleteActivePlotsAction::DeleteActivePlotsAction
//
// Purpose: 
//   Constructor for the DeleteActivePlotsAction class.
//
// Arguments:
//   win : The window to which the action belongs.
//
// Programmer: Brad Whitlock
// Creation:   Fri Mar 21 15:50:38 PST 2003
//
// Modifications:
//   
// ****************************************************************************

DeleteActivePlotsAction::DeleteActivePlotsAction(ViewerWindow *win) :
    ViewerAction(win)
{
    SetAllText(tr("Delete active plots"));
    // Think of an icon...
}

// ****************************************************************************
// Method: DeleteActivePlotsAction::~DeleteActivePlotsAction
//
// Purpose: 
//   Destructor for the DeleteActivePlotsAction class.
//
// Programmer: Brad Whitlock
// Creation:   Fri Mar 21 15:51:14 PST 2003
//
// Modifications:
//   
// ****************************************************************************

DeleteActivePlotsAction::~DeleteActivePlotsAction()
{
}

// ****************************************************************************
// Method: DeleteActivePlotsAction::Execute
//
// Purpose: 
//   Executes the DeleteActivePlots action.
//
// Programmer: Brad Whitlock
// Creation:   Fri Mar 21 15:51:48 PST 2003
//
// Modifications:
//   Brad Whitlock, Mon Jun 23 16:30:51 PST 2003
//   I made the ClearPickPoints and ClearRefLines methods use the window
//   instead of the window manager.
//
//   Kathlen Bonnell, Thu Apr  1 19:13:59 PST 2004 
//   Added call to ResetTimeQueryDesignation. 
//
// ****************************************************************************

void
DeleteActivePlotsAction::Execute()
{
    window->GetPlotList()->DeleteActivePlots();
    if(window->GetPlotList()->GetNumPlots() == 0)
    {
        window->ClearPickPoints();
        window->ClearRefLines();
        windowMgr->ResetLineoutDesignation();
        windowMgr->ResetTimeQueryDesignation();
        windowMgr->DisableAllTools();
    }
}

// ****************************************************************************
// Method: DeleteActivePlotsAction::Enabled
//
// Purpose: 
//   Returns whether the action is enabled.
//
// Programmer: Brad Whitlock
// Creation:   Fri Mar 21 15:51:48 PST 2003
//
// Modifications:
//   
// ****************************************************************************

bool
DeleteActivePlotsAction::Enabled() const
{
    return (window->GetPlotList()->GetNumPlots() > 0);
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: SetActivePlotsAction::SetActivePlotsAction
//
// Purpose: 
//   Constructor for the SetActivePlotsAction class.
//
// Arguments:
//   win : The window to which the action belongs.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 07:50:03 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

SetActivePlotsAction::SetActivePlotsAction(ViewerWindow *win) : ViewerAction(win)
{
    DisableVisual();
}

// ****************************************************************************
// Method: SetActivePlotsAction::~SetActivePlotsAction
//
// Purpose: 
//   Destructor for the SetActivePlotsAction class.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 07:50:31 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

SetActivePlotsAction::~SetActivePlotsAction()
{
}

// ****************************************************************************
// Method: SetActivePlotsAction::Execute
//
// Purpose: 
//   Sets the active plots for the window's plot list.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 07:50:49 PDT 2003
//
// Modifications:
//   Eric Brugger, Mon Jul 28 16:48:01 PDT 2003
//   Added code to make the database for the first active plot the database
//   for the plotlist when the plotlist has at least one active plot.
//
//   Brad Whitlock, Mon Dec 8 15:25:54 PST 2003
//   I removed Eric's code.
//
//   Kathleen Bonnell, Wed Aug 10 16:46:17 PDT 2005 
//   Notify ViewerQueryManger that active plot has changed if in Pick mode.
//   (So that plot can be reexecuted if necesssary).
//
//   Jonathan Byrd (Allinea Software) Sun Dec 18, 2011
//   Added DDT_PICK mode.
//
// ****************************************************************************

void
SetActivePlotsAction::Execute()
{
    //
    // Set the active plots through the window manager.
    //
    const intVector &activePlots     = args.GetActivePlotIds();
    const intVector &activeOperators = args.GetActiveOperatorIds();
    const intVector &expandedPlots   = args.GetExpandedPlotIds();
    bool moreThanPlotsValid          = args.GetBoolFlag();

    bool applyToAllWindows = windowMgr->GetClientAtts()->GetApplyWindow();
    
    if( applyToAllWindows )
    {
      for( int i=0; i<windowMgr->GetNumWindows(); ++i )
      {
        windowMgr->GetWindow(i)->GetPlotList()->
          SetActivePlots(activePlots,
                         activeOperators, expandedPlots, moreThanPlotsValid);
      }
    }
    else // Just the active window
    {
      window->GetPlotList()->
        SetActivePlots(activePlots,
                       activeOperators, expandedPlots, moreThanPlotsValid);
    }

    if (window->GetInteractionMode() == ZONE_PICK || 
        window->GetInteractionMode() == NODE_PICK ||
        window->GetInteractionMode() == DDT_PICK)
       ViewerQueryManager::Instance()->ActivePlotsChanged(); 
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: ChangeActivePlotsVarAction::ChangeActivePlotsVarAction
//
// Purpose: 
//   Constructor for the ChangeActivePlotsVarAction class.
//
// Arguments:
//   win : The window to which the action belongs.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 07:51:26 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

ChangeActivePlotsVarAction::ChangeActivePlotsVarAction(ViewerWindow *win) : 
   ViewerAction(win)
{
    DisableVisual();
}

// ****************************************************************************
// Method: ChangeActivePlotsVarAction::~ChangeActivePlotsVarAction
//
// Purpose: 
//   Destructor for the ChangeActivePlotsVarAction class.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 07:51:53 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

ChangeActivePlotsVarAction::~ChangeActivePlotsVarAction()
{
}

// ****************************************************************************
// Method: ChangeActivePlotsVarAction::Execute
//
// Purpose: 
//   Changes the active plots' variables.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 07:52:13 PDT 2003
//
// Modifications:
//   
//   Hank Childs, Tue Jul 22 11:50:12 PDT 2008
//   Added explicit error handling.
//
// ****************************************************************************

void
ChangeActivePlotsVarAction::Execute()
{
    //
    // Set the plot variable for the selected plots.
    //
    TRY
    {
        const char *var = args.GetVariable().c_str();
        window->GetPlotList()->SetPlotVar(var);
    }
    CATCH2(InvalidExpressionException, ve)
    {
        QString msg = tr("VisIt was unable to change the active variable "
                       "because: %1\n").arg(ve.Message().c_str());
        Error(msg);
    }
    ENDTRY
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: SetPlotSILRestrictionAction::SetPlotSILRestrictionAction
//
// Purpose: 
//   Constructor for the SetPlotSILRestrictionAction class.
//
// Arguments:
//   win : The window to which the action belongs.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 07:54:24 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

SetPlotSILRestrictionAction::SetPlotSILRestrictionAction(ViewerWindow *win) : 
   ViewerAction(win)
{
    DisableVisual();
}

// ****************************************************************************
// Method: SetPlotSILRestrictionAction::~SetPlotSILRestrictionAction
//
// Purpose: 
//   Destructor for the SetPlotSILRestrictionAction class.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 07:55:00 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

SetPlotSILRestrictionAction::~SetPlotSILRestrictionAction()
{
}

// ****************************************************************************
// Method: SetPlotSILRestrictionAction::Execute
//
// Purpose: 
//   Sets the SIL restriction for the selected plots.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 07:55:20 PDT 2003
//
// Modifications:
//  Gunther H. Weber, Fri Jan 18 17:28:52 PST 2008
//  Toggle setting SIL restriction to all plots independently from applying
//  operators to all plots. 
// ****************************************************************************

void
SetPlotSILRestrictionAction::Execute()
{
    //
    // Tell the plot list set the current SIL restriction for the
    // selected plots.
    //
    bool applyToAllWindows = windowMgr->GetClientAtts()->GetApplyWindow();
    bool applySelectionToAllPlots = windowMgr->GetClientAtts()->GetApplySelection();
    
    if( applyToAllWindows )
    {
      for( int i=0; i<windowMgr->GetNumWindows(); ++i )
      {
        windowMgr->GetWindow(i)->GetPlotList()->
          SetPlotSILRestriction(applySelectionToAllPlots);
      }
    }
    else // Just the active window
    {
      window->GetPlotList()->SetPlotSILRestriction(applySelectionToAllPlots);
    }
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: SetPlotOptionsAction::SetPlotOptionsAction
//
// Purpose: 
//   Constructor for the SetPlotOptionsAction class.
//
// Arguments:
//   win : The window to which the action belongs.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:23:28 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

SetPlotOptionsAction::SetPlotOptionsAction(ViewerWindow *win) : ViewerAction(win)
{
    DisableVisual();
}

// ****************************************************************************
// Method: SetPlotOptionsAction::~ChangeActivePlotsVarAction
//
// Purpose: 
//   Destructor for the SetPlotOptionsAction class.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:24:01 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

SetPlotOptionsAction::~SetPlotOptionsAction()
{
}

// ****************************************************************************
// Method: SetPlotOptionsAction::Execute
//
// Purpose: 
//   Sets the plot options for the selected plots.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:24:25 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

void
SetPlotOptionsAction::Execute()
{
    window->GetPlotList()->SetPlotAtts(args.GetPlotType());

    // ARS loop here 
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: SetPlotFrameRangeAction::SetPlotFrameRangeAction
//
// Purpose: 
//   Constructor for the SetPlotFrameRangeAction class.
//
// Arguments:
//   win : The window to which the action belongs.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:27:01 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

SetPlotFrameRangeAction::SetPlotFrameRangeAction(ViewerWindow *win) : 
   ViewerAction(win)
{
    DisableVisual();
}

// ****************************************************************************
// Method: SetPlotFrameRangeAction::~SetPlotFrameRangeAction
//
// Purpose: 
//   Destructor for the SetPlotFrameRangeAction class.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:27:26 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

SetPlotFrameRangeAction::~SetPlotFrameRangeAction()
{
}

// ****************************************************************************
// Method: SetPlotFrameRangeAction::Execute
//
// Purpose: 
//   Sets the frame range for the selected plots.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:27:45 PDT 2003
//
// Modifications:
//   Brad Whitlock, Mon Apr 5 14:43:45 PST 2004
//   Renamed some method calls.
//
// ****************************************************************************

void
SetPlotFrameRangeAction::Execute()
{
    //
    // Set the plot frame range.
    //
    int plotId = args.GetIntArg1();
    int index0 = args.GetIntArg2();
    int index1 = args.GetIntArg3();
    ViewerPlotList *plotList = window->GetPlotList();
    plotList->SetPlotRange(plotId, index0, index1);
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: DeletePlotKeyframeAction::DeletePlotKeyframeAction
//
// Purpose: 
//   Constructor
//
// Arguments:
//   win : The window to which the action belongs.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:33:28 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

DeletePlotKeyframeAction::DeletePlotKeyframeAction(ViewerWindow *win) : 
   ViewerAction(win)
{
    DisableVisual();
}

// ****************************************************************************
// Method: DeletePlotKeyframeAction::~DeletePlotKeyframeAction
//
// Purpose: 
//   Destructor
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:33:52 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

DeletePlotKeyframeAction::~DeletePlotKeyframeAction()
{
}

// ****************************************************************************
// Method: DeletePlotKeyframeAction::Execute
//
// Purpose: 
//   Deletes a plot keyframe.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:34:10 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

void
DeletePlotKeyframeAction::Execute()
{
    //
    // Delete the plot keyframe.
    //
    int plotId = args.GetIntArg1();
    int index = args.GetIntArg2();
    window->GetPlotList()->DeletePlotKeyframe(plotId, index);
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: MovePlotKeyframeAction::MovePlotKeyframeAction
//
// Purpose: 
//   Constructor.
//
// Arguments:
//   win : the window to which the action belongs.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:35:39 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

MovePlotKeyframeAction::MovePlotKeyframeAction(ViewerWindow *win) : 
   ViewerAction(win)
{
    DisableVisual();
}

// ****************************************************************************
// Method: MovePlotKeyframeAction::~MovePlotKeyframeAction
//
// Purpose: 
//   Destructor
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:36:03 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

MovePlotKeyframeAction::~MovePlotKeyframeAction()
{
}

// ****************************************************************************
// Method: MovePlotKeyframeAction::Execute
//
// Purpose: 
//   Moves a plot keyframe.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:36:14 PDT 2003
//
// Modifications:
//   Brad Whitlock, Mon Apr 5 14:45:00 PST 2004
//   Renamed some variables.
//
// ****************************************************************************

void
MovePlotKeyframeAction::Execute()
{
    //
    // Move the plot keyframe.
    //
    int plotId = args.GetIntArg1();
    int oldIndex = args.GetIntArg2();
    int newIndex = args.GetIntArg3();
    ViewerPlotList *plotList = window->GetPlotList();
    plotList->MovePlotKeyframe(plotId, oldIndex, newIndex);
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: SetPlotDatabaseStateAction::SetPlotDatabaseStateAction
//
// Purpose: 
//   Constructor
//
// Arguments:
//   win : The window to which the action belongs.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:38:06 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

SetPlotDatabaseStateAction::SetPlotDatabaseStateAction(ViewerWindow *win) : 
   ViewerAction(win)
{
    DisableVisual();
}

// ****************************************************************************
// Method: SetPlotDatabaseStateAction::~SetPlotDatabaseStateAction
//
// Purpose: 
//   Destructor
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:38:55 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

SetPlotDatabaseStateAction::~SetPlotDatabaseStateAction()
{
}

// ****************************************************************************
// Method: SetPlotDatabaseStateAction::Execute
//
// Purpose: 
//   Sets a database keyframe for the plot.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:39:14 PDT 2003
//
// Modifications:
//   Brad Whitlock, Mon Apr 5 14:45:22 PST 2004
//   Renamed some variables.
//
// ****************************************************************************

void
SetPlotDatabaseStateAction::Execute()
{
    //
    // Perform the rpc.
    //
    int plotId = args.GetIntArg1();
    int index = args.GetIntArg2();
    int state = args.GetIntArg3();
    ViewerPlotList *plotList = window->GetPlotList();
    plotList->SetPlotDatabaseState(plotId, index, state);
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: DeletePlotDatabaseKeyframeAction::DeletePlotDatabaseKeyframeAction
//
// Purpose: 
//   Constructor
//
// Arguments:
//   win : The window to which the action belongs.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:41:24 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

DeletePlotDatabaseKeyframeAction::DeletePlotDatabaseKeyframeAction(
   ViewerWindow *win) : ViewerAction(win)
{
    DisableVisual();
}

// ****************************************************************************
// Method: DeletePlotDatabaseKeyframeAction::~DeletePlotDatabaseKeyframeAction
//
// Purpose: 
//   Destructor
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:41:50 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

DeletePlotDatabaseKeyframeAction::~DeletePlotDatabaseKeyframeAction()
{
}

// ****************************************************************************
// Method: DeletePlotDatabaseKeyframeAction::Execute
//
// Purpose: 
//   Deletes a database keyframe.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:42:04 PDT 2003
//
// Modifications:
//   Brad Whitlock, Mon Apr 5 14:45:40 PST 2004
//   I renamed some variables.
//
// ****************************************************************************

void
DeletePlotDatabaseKeyframeAction::Execute()
{
    //
    // Delete the database keyframe
    //
    int plotId = args.GetIntArg1();
    int index = args.GetIntArg2();
    ViewerPlotList *plotList = window->GetPlotList();
    plotList->DeletePlotDatabaseKeyframe(plotId, index);
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: MovePlotDatabaseKeyframeAction::MovePlotDatabaseKeyframeAction
//
// Purpose: 
//   Constructor
//
// Arguments:
//   win : The window to which the action belongs.
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:44:42 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

MovePlotDatabaseKeyframeAction::MovePlotDatabaseKeyframeAction(
   ViewerWindow *win) : ViewerAction(win)
{
    DisableVisual();
}

// ****************************************************************************
// Method: MovePlotDatabaseKeyframeAction::~MovePlotDatabaseKeyframeAction
//
// Purpose: 
//   Destructor
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:45:06 PDT 2003
//
// Modifications:
//   
// ****************************************************************************

MovePlotDatabaseKeyframeAction::~MovePlotDatabaseKeyframeAction()
{
}

// ****************************************************************************
// Method: MovePlotDatabaseKeyframeAction::Execute
//
// Purpose: 
//   Moves a database keyframe.
//
// Arguments:
//
// Returns:    
//
// Note:       
//
// Programmer: Brad Whitlock
// Creation:   Fri Apr 11 08:45:24 PDT 2003
//
// Modifications:
//   Brad Whitlock, Mon Apr 5 14:46:15 PST 2004
//   I renamed some variables.
//
// ****************************************************************************

void
MovePlotDatabaseKeyframeAction::Execute()
{
    //
    // Move the database keyframe.
    //
    int plotId = args.GetIntArg1();
    int oldIndex = args.GetIntArg2();
    int newIndex = args.GetIntArg3();
    ViewerPlotList *plotList = window->GetPlotList();
    plotList->MovePlotDatabaseKeyframe(plotId, oldIndex, newIndex);
}
///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: CopyPlotAction::CopyPlotAction
//
// Purpose: 
//   Constructor for the CopyPlotAction class.
//
// Arguments:
//   win : The window that owns the action.
//
// Programmer: Ellen Tarwater
// Creation:   Fri Sept 28 15:38:54 PST 2007
//
// Modifications:
//   
// ****************************************************************************

CopyPlotAction::CopyPlotAction(ViewerWindow *win) : ViewerAction(win)
{
    SetAllText(tr("Copy active plots"));
    // Think of an icon...
}

// ****************************************************************************
// Method: CopyPlotAction::~CopyPlotAction
//
// Purpose: 
//   Destructor for the CopyPlotAction class.
//
// Programmer: Ellen Tarwater
// Creation:   Fri Sept 28 15:54:27 PST 2007
//
// Modifications:
//   
// ****************************************************************************

CopyPlotAction::~CopyPlotAction()
{
}

// ****************************************************************************
// Method: CopyPlotAction::Execute
//
// Purpose: 
//   Copies the active plots.
//
// Programmer: Ellen Tarwater
// Creation:   Fri Sept 28 15:54:27 PST 2007
//
// Modifications:
//   
// ****************************************************************************

void
CopyPlotAction::Execute()
{
    window->GetPlotList()->CopyActivePlots();
}

// ****************************************************************************
// Method: CopyPlotAction::Enabled
//
// Purpose: 
//   Returns whether the action is enabled.
//
// Programmer: Ellen Tarwater
// Creation:   Fri Sept 28 15:54:27 PST 2007
//
// Modifications:
//   
// ****************************************************************************

bool
CopyPlotAction::Enabled() const
{
    return (window->GetPlotList()->GetNumPlots() > 0);
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: SetPlotFollowsTimeAction::SetPlotFollowsTimeAction
//
// Purpose: 
//   Constructor for the SetPlotFollowsTimeAction class.
//
// Arguments:
//   win : The window that owns the action.
//
// Programmer: Ellen Tarwater
// Creation:   Thurs, Dec 6, 2007
//
// Modifications:
//   Brad Whitlock, Tue Mar 29 11:16:58 PDT 2011
//   Change the description.
//
// ****************************************************************************

SetPlotFollowsTimeAction::SetPlotFollowsTimeAction(ViewerWindow *win) : ViewerAction(win)
{
    SetAllText(tr("Plot follows time slider"));
    // Think of an icon...
}

// ****************************************************************************
// Method: SetPlotFollowsTimeAction::~SetPlotFollowsTimeAction
//
// Purpose: 
//   Destructor for the SetPlotFollowsTimeAction class.
//
// Programmer: Ellen Tarwater
// Creation:   Thurs, Dec 6, 2007
//
// Modifications:
//   
// ****************************************************************************

SetPlotFollowsTimeAction::~SetPlotFollowsTimeAction()
{
}

// ****************************************************************************
// Method: SetPlotFollowsTimeAction::Execute
//
// Purpose: 
//   Disconnects the active plot from the time slider.
//
// Programmer: Ellen Tarwater
// Creation:   Thurs, Dec 6, 2007
//
// Modifications:
//   Brad Whitlock, Tue Mar 29 11:16:42 PDT 2011
//   Pass flag to SetPlotFollowsTime.
//
// ****************************************************************************

void
SetPlotFollowsTimeAction::Execute()
{
     window->GetPlotList()->SetPlotFollowsTime(args.GetBoolFlag());
}

// ****************************************************************************
// Method: SetPlotFollowsTimeAction::Enabled
//
// Purpose: 
//   Returns whether the action is enabled.
//
// Programmer: Ellen Tarwater
// Creation:   Thurs, Dec 6, 2007
//
// Modifications:
//   
// ****************************************************************************

bool
SetPlotFollowsTimeAction::Enabled() const
{
    return (window->GetPlotList()->GetNumPlots() > 0);
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

SetPlotDescriptionAction::SetPlotDescriptionAction(ViewerWindow *win) : ViewerAction(win)
{
    DisableVisual();
}

SetPlotDescriptionAction::~SetPlotDescriptionAction()
{
}

void
SetPlotDescriptionAction::Execute()
{
    window->GetPlotList()->SetPlotDescription(args.GetIntArg1(), 
        args.GetStringArg1());
}

bool
SetPlotDescriptionAction::Enabled() const
{
    return true;
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

MovePlotOrderTowardFirstAction::MovePlotOrderTowardFirstAction(ViewerWindow *win) : ViewerAction(win)
{
    DisableVisual();
}

MovePlotOrderTowardFirstAction::~MovePlotOrderTowardFirstAction()
{
}

void
MovePlotOrderTowardFirstAction::Execute()
{
    window->GetPlotList()->MovePlotOrderTowardFirst(args.GetIntArg1());
}

bool
MovePlotOrderTowardFirstAction::Enabled() const
{
    return true;
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

MovePlotOrderTowardLastAction::MovePlotOrderTowardLastAction(ViewerWindow *win) : ViewerAction(win)
{
    DisableVisual();
}

MovePlotOrderTowardLastAction::~MovePlotOrderTowardLastAction()
{
}

void
MovePlotOrderTowardLastAction::Execute()
{
    window->GetPlotList()->MovePlotOrderTowardLast(args.GetIntArg1());
}

bool
MovePlotOrderTowardLastAction::Enabled() const
{
    return true;
}

///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

SetPlotOrderToFirstAction::SetPlotOrderToFirstAction(ViewerWindow *win) : ViewerAction(win)
{
    DisableVisual();
}

SetPlotOrderToFirstAction::~SetPlotOrderToFirstAction()
{
}

void
SetPlotOrderToFirstAction::Execute()
{
    window->GetPlotList()->SetPlotOrderToFirst(args.GetIntArg1());
}

bool
SetPlotOrderToFirstAction::Enabled() const
{
    return true;
}


///////////////////////////////////////////////////////////////////////////////
///
///////////////////////////////////////////////////////////////////////////////

SetPlotOrderToLastAction::SetPlotOrderToLastAction(ViewerWindow *win) : ViewerAction(win)
{
    DisableVisual();
}

SetPlotOrderToLastAction::~SetPlotOrderToLastAction()
{
}

void
SetPlotOrderToLastAction::Execute()
{
    window->GetPlotList()->SetPlotOrderToLast(args.GetIntArg1());
}

bool
SetPlotOrderToLastAction::Enabled() const
{
    return true;
}

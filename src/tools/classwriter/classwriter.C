#include <string>
#include <vector>
#include <algorithm>
#ifdef WIN32
#include <iostream>
#include <fstream>
#include <stdlib.h>
#include <time.h>
#else
#include <stdio.h>
#include <iostream.h>
#include <fstream.h>
#include <stdlib.h>
#include <sys/types.h>
#include <time.h>
#endif

using namespace std;

string
MakeName(const string &str)
{
    string temp(str);
    temp[0] = toupper(temp[0]);

    return temp;
}

string
MakeSingle(const string &str)
{
    string temp(str);
    temp[0] = toupper(temp[0]);
    if(temp[temp.size()] == 's')
        temp = temp.substr(0, temp.size() - 1);

    return temp;
}

string
AllCaps(const string &str)
{
    string temp(str);

    for(int i = 0; i < str.length(); ++i)
        temp[i] = toupper(temp[i]);

    return temp;
}

string
CurrentTime()
{
    char *tstr[] = {"PDT", "PST"};
    char s1[10], s2[10], s3[10], tmpbuf[200];
    time_t t;
    char *c = NULL;
    int h,m,s,y;
    t = time(NULL);
    c = asctime(localtime(&t));
    // Read the hour.
    sscanf(c, "%s %s %s %d:%d:%d %d", s1, s2, s3, &h, &m, &s, &y);
    // Reformat the string a little.
    sprintf(tmpbuf, "%s %s %s %02d:%02d:%02d %s %d",
            s1, s2, s3, h, m, s, tstr[h > 12], y);

    return string(tmpbuf);
}

string
DataNodeConversion(const string &inType)
{
    if(inType == "c")
        return "AsChar";
    else if(inType == "u")
        return "AsUnsignedChar";
    else if(inType == "i")
        return "AsInt";
    else if(inType == "l")
        return "AsLong";
    else if(inType == "f")
        return "AsFloat";
    else if(inType == "d")
        return "AsDouble";
    else if(inType == "s")
        return "AsString";
    else if(inType == "b")
        return "AsBool";
    else if(inType == "C")
        return "AsCharArray";
    else if(inType == "U")
        return "AsUnsignedCharArray";
    else if(inType == "I")
        return "AsIntArray";
    else if(inType == "L")
        return "AsLongArray";
    else if(inType == "F")
        return "AsFloatArray";
    else if(inType == "D")
        return "AsDoubleArray";
    else if(inType == "S")
        return "AsStringArray";
    else if(inType == "B")
        return "AsBoolArray";
    else if(inType == "c*")
        return "AsCharVector";
    else if(inType == "u*")
        return "AsUnsignedCharVector";
    else if(inType == "i*")
        return "AsIntVector";
    else if(inType == "l*")
        return "AsLongVector";
    else if(inType == "f*")
        return "AsFloatVector";
    else if(inType == "d*")
        return "AsDoubleVector";
    else if(inType == "s*")
        return "AsStringVector";
    else
        return "BadType";
}

void
WriteMethodComment(ostream &out, const string &ClassName,
    const string &methodName, const string &purposeString)
{
    out << "// ****************************************************************************" << endl;
    out << "// Method: " << ClassName << "::" << methodName << endl;
    out << "//" << endl;
    out << "// Purpose: " << endl;
    out << "//   " << purposeString << endl;
    out << "//" << endl;
    out << "// Note:       Autogenerated by classwriter." << endl;
    out << "//" << endl;
    out << "// Programmer: classwriter" << endl;
    out << "// Creation:   ";

    // Create the generation time, date.
    out << CurrentTime() << endl;
       
    out << "//" << endl;
    out << "// Modifications:" << endl;
    out << "//   " << endl;
    out << "// ****************************************************************************" << endl;
    out << endl;
}

struct AttributeInfo
{
    AttributeInfo() : attrType()
    {
        length = 1; defaultData = 0;
        publicMode = false;
    }

    ~AttributeInfo()
    {
        if(defaultData != 0)
        {
            // We have to delete the appropriate kind of pointer or
            // the compiler will really complain.
            char          *cptr = (char*)defaultData;
            unsigned char *uptr = (unsigned char*)defaultData;
            int           *iptr = (int*)defaultData;
            long          *lptr = (long*)defaultData;
            float         *fptr = (float*)defaultData;
            double        *dptr = (double*)defaultData;
            string        *sptr = (string*)defaultData;
            bool          *bptr = (bool*)defaultData;

            if(attrType == "C" || attrType == "c")
            {
                delete [] cptr;
            }
            else if(attrType == "U" || attrType == "u")
            {
                delete [] uptr;
            }
            else if(attrType == "I" || attrType == "i")
            {
                delete [] iptr;
            }
            else if(attrType == "L" || attrType == "l")
            {
                delete [] lptr;
            }
            else if(attrType == "F" || attrType == "f")
            {
                delete [] fptr;
            }
            else if(attrType == "D" || attrType == "d")
            {
                delete [] dptr;
            }
            else if((attrType == "S" || attrType == "s") ||
                   (attrType == "A" || attrType == "a" || attrType == "a*"))
            {
                delete [] sptr;
            }
            else if(attrType == "B" || attrType == "b")
            {
                delete [] bptr;
            }
        }
    }

    bool isList()
    {
        return (attrType == "C") ||
               (attrType == "U") ||
               (attrType == "I") ||
               (attrType == "L") ||
               (attrType == "F") ||
               (attrType == "D") ||
               (attrType == "S") ||
               (attrType == "B") ||
               (attrType == "A");
    }

    bool isVector()
    {
        return (attrType == "c*") ||
               (attrType == "u*") ||
               (attrType == "i*") ||
               (attrType == "l*") ||
               (attrType == "f*") ||
               (attrType == "d*") ||
               (attrType == "s*") ||
               (attrType == "a*");
    }

    istream &ReadList(istream &is)
    {
        // Read the length
        is >> length;

        return Read(is);
    }

    istream &Read(istream &is)
    {
        int templength = length;

        if(attrType == "C" || attrType == "c")
        {
            defaultData = (void *)(new char[length]);
        }
        else if(attrType == "U" || attrType == "u")
        {
            defaultData = (void *)(new unsigned char[length]);
        }
        else if(attrType == "I" || attrType == "i")
        {
            defaultData = (void *)(new int[length]);
        }
        else if(attrType == "L" || attrType == "l")
        {
            defaultData = (void *)(new long[length]);
        }
        else if(attrType == "F" || attrType == "f")
        {
            defaultData = (void *)(new float[length]);
        }
        else if(attrType == "D" || attrType == "d")
        {
            defaultData = (void *)(new double[length]);
        }
        else if(attrType == "S" || attrType == "s")
        {
            defaultData = (void *)(new string[length]);
        }
        else if(attrType == "B" || attrType == "b")
        {
            defaultData = (void *)(new bool[length]);
        }
        else if(attrType == "A" || attrType == "a" || attrType == "a*")
        {
            templength = 1;
            defaultData = (void *)(new string);
        }
        else
            length = 0;

        char          *cptr = (char*)defaultData;
        unsigned char *uptr = (unsigned char*)defaultData;
        int           *iptr = (int*)defaultData;
        long          *lptr = (long*)defaultData;
        float         *fptr = (float*)defaultData;
        double        *dptr = (double*)defaultData;
        string        *sptr = (string*)defaultData;
        bool          *bptr = (bool*)defaultData;

        // Read all elements
        for(int i = 0; i < templength; ++i)
        {
            if(attrType == "C" || attrType == "c")
            {
                is >> *cptr++;
            }
            else if(attrType == "U" || attrType == "u")
            {
                int tmp;
                is >> tmp;
                *uptr++ = (unsigned char)tmp;
            }
            else if(attrType == "I" || attrType == "i")
            {
                is >> *iptr++;
            }
            else if(attrType == "L" || attrType == "l")
            {
                is >> *lptr++;
            }
            else if(attrType == "F" || attrType == "f")
            {
                is >> *fptr++;
            }
            else if(attrType == "D" || attrType == "d")
            {
                is >> *dptr++;
            }
            else if((attrType == "S" || attrType == "s") ||
                   (attrType == "A" || attrType == "a" || attrType == "a*"))
            {
                is >> *sptr++;
            }
            else if(attrType == "B" || attrType == "b")
            {
                string boolStr;
                is >> boolStr;
                if(boolStr == "true")
                    *bptr++ = true;
                else
                    *bptr++ = false;
            }
        }

        return is;
    }

    string SpaceString(int nspaces)
    {
        string retval;
        for(int i = 0; i < nspaces; ++i)
           retval += string(" ");

        return retval;
    }

    string GetCPPName(int totalWidth = 0)
    {
        string name;

        if(attrType == "C" || attrType == "c")
        {
            name = string("char");
        }
        else if(attrType == "U" || attrType == "u")
        {
            name = string("unsigned char");
        }
        else if(attrType == "I" || attrType == "i")
        {
            name = string("int");
        }
        else if(attrType == "L" || attrType == "l")
        {
            name = string("long");
        }
        else if(attrType == "F" || attrType == "f")
        {
            name = string("float");
        }
        else if(attrType == "D" || attrType == "d")
        {
            name = string("double");
        }
        else if(attrType == "S" || attrType == "s")
        {
            name = string("std::string");
        }
        else if(attrType == "B" || attrType == "b")
        {
            name = string("bool");
        }
        else if(attrType == "A")
        {
            name = string("AttributeGroup *");
        }
        else if(attrType == "a")
        {
            name = (*((string *)defaultData));
        }
        else if(attrType == "c*")
        {
            name = string("charVector");
        }
        else if(attrType == "u*")
        {
            name = string("unsignedCharVector");
        }
        else if(attrType == "i*")
        {
            name = string("intVector");
        }
        else if(attrType == "l*")
        {
            name = string("longVector");
        }
        else if(attrType == "f*")
        {
            name = string("floatVector");
        }
        else if(attrType == "d*")
        {
            name = string("doubleVector");
        }
        else if(attrType == "s*")
        {
            name = string("stringVector");
        }
        else if(attrType == "a*")
        {
            name = string("AttributeGroupVector");
        }
        else
        {
            cerr << "Unable to recognize type " << attrType << "... " << endl;
            cerr << "Cannot generate classes." << endl;
            exit(EXIT_FAILURE);
        }

        if(totalWidth > 0) 
            name = string(name + SpaceString(totalWidth - name.length()));

        return name;
    }

    bool CanHaveConst()
    {
        return (isVector() || isList() || attrType == "s" || attrType == "a");
    }

    void WriteDataValue(ostream &os, void **data)
    {
        char          **cptr = (char**)data;
        unsigned char **uptr = (unsigned char**)data;
        int           **iptr = (int**)data;
        long          **lptr = (long**)data;
        float         **fptr = (float**)data;
        double        **dptr = (double**)data;
        string        **sptr = (string**)data;
        bool          **bptr = (bool**)data;

        if(attrType == "C" || attrType == "c")
        {
            os << "'" << *(*cptr)++ << "'";
        }
        else if(attrType == "U" || attrType == "u")
        {
            os << int(*(*uptr)++);
        }
        else if(attrType == "I" || attrType == "i")
        {
            os << *(*iptr)++;
        }
        else if(attrType == "L" || attrType == "l")
        {
            os << *(*lptr)++;
        }
        else if(attrType == "F" || attrType == "f")
        {
            os << *(*fptr)++;
        }
        else if(attrType == "D" || attrType == "d")
        {
            os << *(*dptr)++;
        }
        else if(attrType == "S" || attrType == "s")
        {
            os << *(*sptr)++;
        }
        else if(attrType == "B" || attrType == "b")
        {
            if(*(*bptr)++)
                os << "true";
            else
                os << "false";
        }
    }

    void WriteAttribute(ostream &os, int totalWidth)
    {
        os << "    " << GetCPPName(totalWidth) << " " << attrName;
        if(isList())
           os << "[" << length << "]";
        os << ";" << endl;
    }

    void WriteDefault(ostream &os)
    {
        void *vptr;

        if(attrType == "a")
            return;

        if(isList())
        {
            if(attrType == "A")
            {
                os << "    for(int i = 0; i < " << length << "; ++i)" << endl;
                os << "        " << attrName << "[i] = 0;" << endl;
            }
            else
            {
                vptr = defaultData;
                for(int i = 0; i < length; ++i)
                {
                    os << "    " << attrName << "[" << i << "] = ";
                    WriteDataValue(os, &vptr);
                    os << ";" << endl;
                }
                os << endl;
            }
        }
        else if(!isVector())
        {
            vptr = defaultData;
            os << "    " << attrName << " = ";
            WriteDataValue(os, &vptr);
            os << ";" << endl;
        }
    }

    void WriteSetFunctionProto(ostream &os)
    {
        // There is no set method for this attribute if it is public.
        if(publicMode || (attrType == "a*"))
            return;

        os << "    void Set" << MakeName(attrName) << "(";
        if(isList() || isVector() || (attrType == "s") || (attrType == "a"))
            os << "const ";
        if(attrType == "A")
        {
            string &s = (*((string *)defaultData));
            os << s << " ";
        }
        else
            os << GetCPPName() << " ";
        if(isList())
            os << "*";
        else if(isVector() || (attrType == "s") || (attrType == "a"))
            os << "&";
        os << attrName << "_);" << endl;
    }

    void WriteSetFunction(ostream &os, const string &ClassName, int attr_id)
    {
        // There is no set method for this attribute if it is public.
        if(publicMode || (attrType == "a*"))
            return;

        // Write prototype.
        os << "void" << endl;
        os << ClassName << "::Set" << MakeName(attrName) << "(";
        if(isList() || isVector() || attrType == "s" || (attrType == "a"))
            os << "const ";
        if(attrType == "A")
        {
            string &s = (*((string *)defaultData));
            os << s << " ";
        }
        else
            os << GetCPPName() << " ";
        if(isList())
            os << "*";
        else if(isVector() || (attrType == "s") || (attrType == "a"))
            os << "&";
        os << attrName << "_)" << endl;

        // Write function body
        os << "{" << endl;
        if(!isList())
        {
            os << "    " << attrName << " = " << attrName << "_;" << endl;
            os << "    Select(" << attr_id << ", (void *)&" << attrName << ");" << endl;
        }
        else
        {
            if(attrType == "A")
            {
                // Write code to copy the AttributeGroupVector.
                string &s = (*((string *)defaultData));
                os << "    int i;" << endl << endl;
                os << "    // *** Copy the " << attrName << " field ***" << endl;
                os << "    // Delete the AttributeGroup objects.." << endl;
                os << "    for(i = 0; i < " << length << "; ++i)" << endl;
                os << "    {" << endl;
                os << "        if(" << attrName << "[i] != 0) delete " << attrName << "[i];" << endl;
                os << "        " << attrName << "[i] = 0;" << endl;
                os << "    }" << endl;
                os << "    // Duplicate the " << attrName << " from the array." << endl;
                os << "    for(i = 0; i < " << length << "; ++i)" << endl;
                os << "    {" << endl;
                os << "        " << attrName << "[i] = new " << s << "(" << attrName << "_[i]);" << endl;
                os << "    }" << endl << endl;
            }
            else if(length < 5)
            {
                for(int i = 0; i < length; ++i)
                    os << "    " << attrName << "[" << i << "] = " << attrName << "_[" << i << "];"<< endl;
            }
            else
            {
                os << "    for(int i = 0; i < " << length << "; ++i)" << endl;
                os << "        " << attrName << "[i] = " << attrName << "_[i];"<< endl;
            }
            os << "    Select(" << attr_id << ", (void *)" << attrName << ", " << length << ");" << endl;
        }
        os << "}" << endl;
        os << endl;
    }

    void WriteGetFunctionProto(ostream &os, int totalWidth)
    {
        // There is no get method for this attribute if it is public.
        if(publicMode || (attrType == "a*"))
            return;

        // Write function name
        if(isList())
        {
            os << "    const " << GetCPPName(totalWidth) << " *Get" << MakeName(attrName) << "() const;" << endl;
            os << "          " << GetCPPName(totalWidth) << " *Get" << MakeName(attrName) << "();" << endl;
        }
        else if(isVector() || (attrType == "s") || (attrType == "a"))
        {
            os << "    const " << GetCPPName(totalWidth) << " &Get" << MakeName(attrName) << "() const;" << endl;
            os << "          " << GetCPPName(totalWidth) << " &Get" << MakeName(attrName) << "();" << endl;
        }
        else
            os << "    " << GetCPPName(totalWidth) << " Get" << MakeName(attrName) << "() const;" << endl;
    }

    void WriteGetFunction(ostream &os, const string &ClassName, bool doConst)
    {
        // There is no get method for this attribute if it is public.
        if(publicMode || (attrType == "a*"))
            return;

        // Write function name
        if(isList())
        {
            if(doConst)
            {
                os << "const " << GetCPPName() << " *" << endl << ClassName << "::Get"
                   << MakeName(attrName) << "() const" << endl;
            }
            else
            {
                os << GetCPPName() << " *" << endl << ClassName << "::Get"
                   << MakeName(attrName) << "()" << endl;
            }
        }
        else if(isVector() || (attrType == "s") || (attrType == "a"))
        {
            if(doConst)
            {
                os << "const " << GetCPPName() << " &" << endl << ClassName
                   << "::Get" << MakeName(attrName) << "() const" << endl;
            }
            else
            {
                os << GetCPPName() << " &" << endl << ClassName << "::Get"
                   << MakeName(attrName) << "()" << endl;
            }
        }
        else
        {
            os << GetCPPName() << endl << ClassName << "::Get"
               << MakeName(attrName) << "() const" << endl;
        }

        // Function body
        os << "{" << endl;
        if(attrType == "A")
        {
            os << "    const AttributeGroup **temp = (const AttributeGroup **)" << attrName << ";" << endl;
            os << "    return temp;" << endl;
        }
        else 
            os << "    return " << attrName << ";" << endl;
        os << "}" << endl;
        os << endl;
    }

    void WriteSelectFunctionProto(ostream &os)
    {
        if(isVector() || isList() || (attrType == "s") || (attrType == "a"))
        {
            os << "    void Select" << MakeName(attrName) << "();" << endl;
        }
    }

    void WriteSelectFunction(ostream &os, const string &className, int attr_id)
    {
        if(isVector() || isList() || (attrType == "s") || (attrType == "a"))
        {
            os << "void" << endl << className << "::Select" << MakeName(attrName) << "()" << endl;
            os << "{" << endl;
            if(isList())
            {
                os << "    Select(" << attr_id << ", (void *)"
                    << attrName << ", " << length  << ");";
            }
            else
            {
                os << "    Select(" << attr_id << ", (void *)&"
                    << attrName << ");";
            }
            os << endl << "}" << endl << endl;
        }
    }

    void WriteAttributeGroupVectorProto(ostream &os)
    {
        if(!(attrType == "a*"))
            return;

        string &s = (*((string *)defaultData));
        os << "    void Add" << MakeName(s) << "(const " << s << " &);" << endl;
        os << "    void Clear" << MakeName(s) << "s();" << endl;
        os << "    void Remove" << MakeSingle(s) << "(int i);" << endl;
        os << "    int  GetNum" << MakeName(s) << "s() const;" << endl;
        os << "    " << s << " &Get" << MakeSingle(s) << "(int i);" << endl;
        os << "    " << s << " &operator [] (int i);" << endl;
        os << "    const " << s << " &operator [] (int i) const;" << endl;
        os << endl;
    }

    void WriteAttributeGroupVectorFunctions(ostream &os,
        const string &ClassName, const string &purposeString, int attr_id)
    {
        if(!(attrType == "a*"))
            return;

        string methodName;
        string &s = (*((string *)defaultData));

        // Write the Add method.
        methodName = "Add";
        methodName += s;
        WriteMethodComment(os, ClassName, methodName, purposeString);
        os << "void" << endl;
        os << ClassName << "::" << methodName << "(const " << s << " &obj)" << endl;
        os << "{" << endl;
        os << "    " << s << " *new" << s << " = new " << s << "(obj);" << endl;
        os << "    " << attrName << ".push_back(new" << s << ");" << endl;
        os << endl;
        os << "    // Indicate that things have changed by selecting it." << endl;
        os << "    Select(" << attr_id << ", (void *)&" << attrName << ");" << endl;
        os << "}" << endl << endl;

        // Write the Clear method
        methodName = "Clear";
        methodName += s;
        WriteMethodComment(os, ClassName, methodName, purposeString);
        os << "void" << endl;
        os << ClassName << "::" << methodName << "s()" << endl;
        os << "{" << endl;
        os << "    AttributeGroupVector::iterator pos;" << endl;
        os << endl;
        os << "    for(pos = " << attrName << ".begin(); pos != " << attrName << ".end(); ++pos)" << endl;
        os << "        delete *pos;" << endl;
        os << "    " << attrName << ".clear();" << endl;
        os << endl;
        os << "    // Indicate that things have changed by selecting the list." << endl;
        os << "    Select(0, (void *)&" << attrName << ");" << endl;
        os << "}" << endl << endl;

        // Write the Remove method
        methodName = "Remove";
        methodName += s;
        WriteMethodComment(os, ClassName, methodName, purposeString);
        os << "void" << endl;
        os << ClassName << "::" << methodName << "(int index)" << endl;
        os << "{" << endl;
        os << "    AttributeGroupVector::iterator pos = " << attrName << ".begin();" << endl;
        os << endl;
        os << "    // Iterate through the vector \"index\" times. " << endl;
        os << "    for(int i = 0; i < index; ++i)" << endl;
        os << "        ++pos;" << endl;
        os << endl;
        os << "    // If pos is still a valid iterator, remove that element." << endl;
        os << "    if(pos != " << attrName << ".end())" << endl;
        os << "    {" << endl;
        os << "        delete *pos;" << endl;
        os << "        " << attrName << ".erase(pos);" << endl;
        os << "    }" << endl;
        os << endl;
        os << "    // Indicate that things have changed by selecting the list." << endl;
        os << "    Select(0, (void *)&" << attrName << ");" << endl;
        os << "}" << endl << endl;

        // Write the GetNum method
        methodName = "GetNum";
        methodName += s;
        WriteMethodComment(os, ClassName, methodName, purposeString);
        os << "int" << endl;
        os << ClassName << "::" << methodName << "s() const" << endl;
        os << "{" << endl;
        os << "    return " << attrName << ".size();" << endl;
        os << "}" << endl << endl;

        // Write the Get method
        methodName = "Get";
        methodName += s;
        WriteMethodComment(os, ClassName, methodName, purposeString);
        os << s << " &" << endl;
        os << ClassName << "::" << methodName << "(int i)" << endl;
        os << "{" << endl;
        os << "    return *((" << s << " *)" << attrName << "[i]);" << endl;
        os << "}" << endl << endl;

        // Write the non-const [] operator
        methodName = "operator []";
        WriteMethodComment(os, ClassName, methodName, purposeString);
        os << s << " &" << endl;
        os << ClassName << "::" << methodName << " (int i)" << endl;
        os << "{" << endl;
        os << "    return *((" << s << " *)" << attrName << "[i]);" << endl;
        os << "}" << endl << endl;

        // Write the const [] operator
        WriteMethodComment(os, ClassName, methodName, purposeString);
        os << "const " << s << " &" << endl;
        os << ClassName << "::" << methodName << " (int i) const" << endl;
        os << "{" << endl;
        os << "    return *((" << s << " *)" << attrName << "[i]);" << endl;
        os << "}" << endl << endl;
    }

// attributes
    string attrName;
    string attrType;
    int    length;
    void   *defaultData;
    bool   publicMode;
};

istream &operator >> (istream &is, AttributeInfo &attr)
{
    // Read the attrType;
    is >> attr.attrType;

    if(attr.isList())
        return attr.ReadList(is);
    else
        return attr.Read(is);
}

typedef vector<AttributeInfo *> AttributeInfoVector;

class ClassAttributes
{
public:
    ClassAttributes() : ClassName(), attributes(), purposeString("")
    {
    }

    ~ClassAttributes()
    {
    }

    void Clear()
    {
        attributes.clear();
    }

    void AddAttribute(const string &_attrName, AttributeInfo *attr,
                      bool publicMode)
    {
        attr->attrName = _attrName;
        attr->publicMode = publicMode;
        attributes.push_back(attr);
    }

    void WriteClassComment(ostream &out)
    {
        out << "// ****************************************************************************" << endl;
        out << "// Class: " << ClassName << endl;
        out << "//" << endl;
        out << "// Purpose:" << endl;
        out << "//   " << purposeString << endl;
        out << "//" << endl;
        out << "// Notes:      Autogenerated by classwriter." << endl;
        out << "//" << endl;
        out << "// Programmer: classwriter" << endl;
        out << "// Creation:   " << CurrentTime() << endl;
        out << "//" << endl;
        out << "// Modifications:" << endl;
        out << "//   " << endl;
        out << "// ****************************************************************************" << endl;
        out << endl;
    }

    void WriteForewardDeclares(ostream &out)
    {
        AttributeInfoVector::iterator pos;
        for(pos = attributes.begin(); pos != attributes.end(); ++pos)
        {
            if((*pos)->attrType == string("a"))
            {
                string &s = (*((string *)(*pos)->defaultData));
                out << "#include <" << s << ".h>" << endl;
            }
        }
        out << endl;
        int count = 0;
        for(pos = attributes.begin(); pos != attributes.end(); ++pos)
        {
            if((*pos)->attrType == string("A") ||
               (*pos)->attrType == string("a*"))
            {
                ++count;
                string &s = (*((string *)(*pos)->defaultData));
                out << "class " << s << ";" << endl;
            }
        }
        if(count > 0)
            out << endl;
    }

    bool SelectFunctionsNeeded()
    {
        bool retval = false;
        AttributeInfoVector::iterator pos;

        // Look for strings, attributegroups and vectors.
        for(pos = attributes.begin(); pos != attributes.end(); ++pos)
        {
            if((*pos)->CanHaveConst())
            {
                retval = true;
                break;
            }
        }

        return (retval && (attributes.size() > 1));
    }

    int CalculateTotalWidth(bool considerConst)
    {
        int retval = 0;

        // Iterate through the list of attibutes and find the one with
        // the longest name.
        AttributeInfoVector::iterator pos;
        for(pos = attributes.begin(); pos != attributes.end(); ++pos)
        {
            if((*pos)->attrType == "a*" && considerConst)
                continue;

            int len = (*pos)->GetCPPName(0).length();

            if(considerConst)
            {
                if((*pos)->CanHaveConst())
                    len += 6; // the length of const and a space.
            }

            if(len > retval)
                retval = len;
        }
 
        return retval;
    }

    void WriteHeaderFile(ostream &out)
    {
        // Look for string type attributes so we can include string.
        bool include_string = false, found_AG_vec = false;
        int private_count = 0;
        AttributeInfoVector::iterator pos;

        // Look for strings. If there are strings, we need to include <string>
        for(pos = attributes.begin();
            pos != attributes.end() && !include_string; ++pos)
        {
            include_string = ((*pos)->attrType == string("s") || 
                              (*pos)->attrType == string("S"));
        }
        // Look for any AttributeGroupVectors.
        for(pos = attributes.begin();
            pos != attributes.end() && !found_AG_vec; ++pos)
        {
            found_AG_vec = ((*pos)->attrType == std::string("a*"));
        }
        // Count the number of private attributes that are NOT a*.
        for(pos = attributes.begin();
            pos != attributes.end(); ++pos)
        {
            if((*pos)->publicMode || (*pos)->attrType == "a*")
                continue;

            ++private_count;
        }
        // Write the header file.
        out << "#ifndef " << AllCaps(ClassName) << "_H" << endl;
        out << "#define " << AllCaps(ClassName) << "_H" << endl;
                if(include_string)
            out << "#include <string>" << endl;
        out << "#include <AttributeSubject.h>" << endl;
        WriteForewardDeclares(out);
        WriteClassComment(out);
        out << "class " << ClassName << " : public AttributeSubject" << endl;
        out << "{" << endl;
        out << "public:" << endl;
        out << "    " << ClassName << "();" << endl;
        out << "    " << ClassName << "(const " << ClassName << " &obj);" << endl;
        out << "    virtual ~" << ClassName << "();" << endl;
        out << endl;
        out << "    virtual void operator = (const " << ClassName << " &obj);" << endl;
        out << "    virtual bool operator == (const " << ClassName << " &obj);" << endl;
        out << "    virtual bool operator != (const " << ClassName << " &obj);" << endl;
        out << endl;
        out << "    // Property selection methods" << endl;
        out << "    virtual void SelectAll();" << endl;
        if(SelectFunctionsNeeded())
        {
            // Write out all the select prototypes
            for(pos = attributes.begin(); pos != attributes.end(); ++pos)
                (*pos)->WriteSelectFunctionProto(out);
        }

        // If there are private attributes, write set/get methods.
        if(private_count > 0)
        {
            out << endl;
            out << "    // Property setting methods" << endl;
            // Write out all the set prototypes
            for(pos = attributes.begin(); pos != attributes.end(); ++pos)
                (*pos)->WriteSetFunctionProto(out);


            int totalWidth = CalculateTotalWidth(true);
            out << endl;
            out << "    // Property getting methods" << endl;
            // Write out all the get prototypes
            for(pos = attributes.begin(); pos != attributes.end(); ++pos)
            {
                int minus = 0;
                if((*pos)->CanHaveConst())
                {
                     minus = 6;
                }

                (*pos)->WriteGetFunctionProto(out, totalWidth - minus);
            }
        }

        // Persistance methods
        out << endl;
        out << "    // Persistance methods" << endl;
        out << "    virtual void CreateNode(DataNode *node);" << endl;
        out << "    virtual void SetFromNode(DataNode *node);" << endl;
        out << endl;

        // If there are AttributeGroupVectors in the list, write out
        // the convenience methods.
        if(found_AG_vec)
        {
            out << endl;
            out << "    // Attributegroup convenience methods" << endl;
            for(pos = attributes.begin();
                pos != attributes.end(); ++pos)
            {
                if((*pos)->attrType != std::string("a*"))
                    continue;

                (*pos)->WriteAttributeGroupVectorProto(out);
            }
        }

        // Count the number of public attributes
        int public_attr = 0, private_attr = 0, ag_count = 0;
        for(pos = attributes.begin(); pos != attributes.end(); ++pos)
        {
            if((*pos)->publicMode)
                ++public_attr;
            else
                ++private_attr;

            if((*pos)->attrType == "a*")
                ++ag_count;
        }

        // If there are any AttributeGroupVectors, we'll need this method.
        if(ag_count > 0)
        {
            out << "protected:" << endl;
            out << "    AttributeGroup *CreateSubAttributeGroup(int index);" << endl;
        }

        int totalWidth = CalculateTotalWidth(false);

        // Write out all the public attributes
        if(public_attr > 0)
        {
            out << "public:" << endl;
            for(pos = attributes.begin(); pos != attributes.end(); ++pos)
            {
                if((*pos)->publicMode)
                    (*pos)->WriteAttribute(out, totalWidth);
            }
        }

        // Write out all the private attributes
        if(private_attr > 0)
        {
            out << "private:" << endl;
            for(pos = attributes.begin(); pos != attributes.end(); ++pos)
            {
                if(!((*pos)->publicMode))
                    (*pos)->WriteAttribute(out, totalWidth);
            }
        }
        
        out << "};" << endl;
        out << endl;
        out << "#endif" << endl;
    }

    void WriteIncludes(ostream &out)
    {
        out << "#include <DataNode.h>" << endl;

        AttributeInfoVector::iterator pos;
        for(pos = attributes.begin(); pos != attributes.end(); ++pos)
        {
            if((*pos)->attrType == string("a*") || (*pos)->attrType == string("A"))
            {
                string &s = (*((string *)(*pos)->defaultData));
                out << "#include <" << s << ".h>" << endl;
            }
        }

        out << endl;
    }

    void WriteConstructor(ostream &out)
    {
        // Write the method comment.
        string purposeString("Constructor for the ");
        purposeString += (ClassName + " class.");
        WriteMethodComment(out, ClassName, ClassName, purposeString);

        // Figure out the format string.        
        AttributeInfoVector::iterator pos;
        string formatString;
        for(pos = attributes.begin(); pos != attributes.end(); ++pos)
            formatString += (*pos)->attrType;

        out << ClassName << "::" << ClassName << "() : AttributeSubject(\"" << formatString << "\")";

        // For any attributes that are strings or vectors, add the initializer.
        int count = 0;
        for(pos = attributes.begin(); pos != attributes.end(); ++pos)
        {
            if((*pos)->attrType == string("s"))
            {
                if(count == 0)
                    out << "," << endl << "    ";
                else
                    out << ", ";
// TBD - see if the string is in quotes before writing the default.
                string *sptr = (string *)((*pos)->defaultData);
                out << (*pos)->attrName << "(" << *sptr << ")";
                ++count;

                if(count == 3)
                    count = 0;
            }
            else if((*pos)->attrType == "a")
            {
                if(count == 0)
                    out << "," << endl << "    ";
                else
                    out << ", ";
                out << (*pos)->attrName << "()";
                ++count;

                if(count == 3)
                    count = 0;                
            }
            else if((*pos)->isVector())
            {
                if(count == 0)
                    out << "," << endl << "    ";
                else
                    out << ", ";

                out << (*pos)->attrName << "()";
                ++count;

                if(count == 3)
                    count = 0;
            }
        }
        out << endl << "{" << endl;

        // Write the default values into the constructor.
        for(pos = attributes.begin(); pos != attributes.end(); ++pos)
        {
            if(((*pos)->attrType == string("s")) ||
               (*pos)->isVector())
                continue;
            (*pos)->WriteDefault(out);
        }
        out << "}" << endl << endl;
    }

    void WriteCopyCode(ostream &out)
    {
        AttributeInfoVector::iterator pos;

        // See if there are any list elements or AG vectors.
        int listcount = 0; int AG_vec_count = 0;
        for(pos = attributes.begin(); pos != attributes.end(); ++pos)
        {
            if(((*pos)->isList() && ((*pos)->length > 3)) || ((*pos)->attrType == "A"))
                ++listcount;
            else if((*pos)->attrType == "a*")
                ++AG_vec_count;
        }
        if(listcount > 0)
            out << "    int i;" << endl;
        if(AG_vec_count > 0)
            out << "    AttributeGroupVector::const_iterator pos;" << endl;
        if((listcount > 0) || (AG_vec_count > 0))
            out << endl;
        // Write out the code to copy attributes.
        for(pos = attributes.begin(); pos != attributes.end(); ++pos)
        {
            if((*pos)->attrType == "A")
            {
                // Write code to copy the AttributeGroupVector.
                string &s = (*((string *)((*pos)->defaultData)));
                out << "    // *** Copy the " << (*pos)->attrName << " field ***" << endl;
                out << "    // Delete the AttributeGroup objects.." << endl;
                out << "    for(i = 0; i < " << (*pos)->length << "; ++i)" << endl;
                out << "    {" << endl;
                out << "        if(" << (*pos)->attrName << "[i]) delete " << (*pos)->attrName << "[i];" << endl;
                out << "        " << (*pos)->attrName << "[i] = 0;" << endl;
                out << "    }" << endl;
                out << "    // Duplicate the " << (*pos)->attrName << " from obj." << endl;
                out << "    for(i = 0; i < " << (*pos)->length << "; ++i)" << endl;
                out << "    {" << endl;
                out << "        if(obj." << (*pos)->attrName << "[i])" << endl;
                out << "        {" << endl;
                out << "            " << s << " *old" << s << " = (" << s << " *)(" << (*pos)->attrName << "[i]);" << endl;
                out << "            " << (*pos)->attrName << "[i] = new " << s << "(*old" << s << ");" << endl;
                out << "        }" << endl;
                out << "        else" << endl;
                out << "            " << (*pos)->attrName << "[i] = 0;" << endl;
                out << "    }" << endl << endl;
            }
            else if((*pos)->isList())
            {
                if((*pos)->length < 4)
                {
                    for(int i = 0; i < (*pos)->length; ++i)
                    {
                        out << "    " << (*pos)->attrName << "[" << i
                            << "] = obj." << (*pos)->attrName << "[" << i
                            << "];" << endl;
                    }
                }
                else
                {
                    out << "    for(i = 0; i < " << (*pos)->length
                        << "; ++i)" << endl;
                    out << "        " << (*pos)->attrName << "[i] = obj."
                        << (*pos)->attrName << "[i];" << endl;
                }
                out << endl;
            }
            else if((*pos)->attrType == "a*")
            {
                // Write code to copy the AttributeGroupVector.
                string &s = (*((string *)((*pos)->defaultData)));
                out << "    // *** Copy the " << (*pos)->attrName << " field ***" << endl;
                out << "    // Delete the AttributeGroup objects and clear the vector." << endl;
                out << "    for(pos = " << (*pos)->attrName << ".begin(); pos != "
                    << (*pos)->attrName << ".end(); ++pos)" << endl;
                out << "        delete *pos;" << endl;
                out << "    " << (*pos)->attrName << ".clear();" << endl;
                out << "    if(obj." << (*pos)->attrName << ".size() > 0)" << endl;
                out << "        " << (*pos)->attrName << ".reserve(obj." << (*pos)->attrName << ".size());" << endl;
                out << "    // Duplicate the " << (*pos)->attrName << " from obj." << endl;
                out << "    for(pos = obj." << (*pos)->attrName << ".begin(); pos != obj." << (*pos)->attrName << ".end(); ++pos)" << endl;
                out << "    {" << endl;
                out << "        " << s << " *old" << s << " = (" << s << " *)(*pos);" << endl;
                out << "        " << s << " *new" << s << " = new " << s << "(*old" << s << ");" << endl;
                out << "        " << (*pos)->attrName << ".push_back(new" << s << ");" << endl;
                out << "    }" << endl << endl;
            }
            else
            {
                out << "    " << (*pos)->attrName << " = obj."
                    << (*pos)->attrName << ";" << endl;
            }
        }

        out << endl << "    SelectAll();" << endl;
    }

    void WriteCopyConstructor(ostream &out)
    {
        // Write the method comment.
        string purposeString("Copy constructor for the ");
        purposeString += (ClassName + " class.");
        WriteMethodComment(out, ClassName, ClassName, purposeString);

        // Figure out the format string.        
        AttributeInfoVector::iterator pos;
        string formatString;
        for(pos = attributes.begin(); pos != attributes.end(); ++pos)
            formatString += (*pos)->attrType;

        out << ClassName << "::" << ClassName << "(const "
            << ClassName << " &obj) : AttributeSubject(\"" << formatString
            << "\")" << endl;
        out << "{" << endl;
        WriteCopyCode(out);
        out << "}" << endl << endl;
    }

    void WriteDestructor(ostream &out)
    {
        // Write the method comment.
        string purposeString("Destructor for the ");
        purposeString += (ClassName + " class.");
        string methodName("~");
        methodName += ClassName;
        WriteMethodComment(out, ClassName, methodName, purposeString);

        AttributeInfoVector::iterator pos;
        // See if there are any AG vectors.
        int AG_vec_count = 0, AG_array_count = 0;
        for(pos = attributes.begin(); pos != attributes.end(); ++pos)
        {
            if((*pos)->attrType == "a*")
                ++AG_vec_count;
            if((*pos)->attrType == "A")
                ++AG_array_count;
        }
        out << ClassName << "::~" << ClassName << "()" << endl;
        out << "{" << endl;
        if(AG_vec_count < 1 && AG_array_count < 1)
            out << "    // nothing here" << endl;
        else 
        {
            if(AG_vec_count > 0)
                out << "    AttributeGroupVector::iterator pos;" << endl;
            if(AG_array_count > 0)
                out << "    int i;" << endl;
            out << endl;

            if(AG_vec_count > 0)
            {
                for(pos = attributes.begin(); pos != attributes.end(); ++pos)             
                {
                    // If it's an AttributeGroupVector, delete it.
                    if((*pos)->attrType == "a*")
                    {
                        out << "    // Destroy the " << (*pos)->attrName << " field."
                            << endl;
                        out << "    for(pos = " << (*pos)->attrName << ".begin();"
                            << " pos != " << (*pos)->attrName << ".end(); ++pos)"
                            << endl;
                        out << "        delete *pos;" << endl;
                    }
                }
            }

            if(AG_array_count > 0)
            {
                for(pos = attributes.begin(); pos != attributes.end(); ++pos)             
                {
                    // If it's an AttributeGroup* array, delete it.
                    if((*pos)->attrType == "A")
                    {
                        out << "    // Destroy the " << (*pos)->attrName << " field."
                            << endl;
                        out << "    for(i = 0; i < " << (*pos)->length << "; ++i)" << endl;
                        out << "        if(" << (*pos)->attrName << "[i]) delete " << (*pos)->attrName
                            << "[i];" << endl;
                    }
                }
            }
        }
        out << "}" << endl << endl;
    }

    void WriteSelectAll(ostream &out)
    {
        // Write the method comment.
        string purposeString("Selects all attributes.");
        string methodName("SelectAll");
        WriteMethodComment(out, ClassName, methodName, purposeString);

        out << "void" << endl;
        out << ClassName << "::SelectAll()" << endl;
        out << "{" << endl;

        AttributeInfoVector::iterator pos;
        int index = 0;
        for(pos = attributes.begin(); pos != attributes.end(); ++pos, ++index)
        {
            if((*pos)->isList())
            {
                out << "    Select(" << index << ", (void *)"
                    << (*pos)->attrName << ", " << (*pos)->length  << ");";
            }
            else
            {
                out << "    Select(" << index << ", (void *)&"
                    << (*pos)->attrName << ");";
            }
            out << endl;
        }

        out << "}" << endl << endl;
    }

    void WriteAssignmentOperator(ostream &out)
    {
        // Write the method comment.
        string purposeString("Assignment operator for the ");
        purposeString += (ClassName + " class.");
        string methodName("operator = ");
        WriteMethodComment(out, ClassName, methodName, purposeString);

        out << "void" << endl;
        out << ClassName << "::operator = (const "
            << ClassName << " &obj)" << endl;
        out << "{" << endl;
        WriteCopyCode(out);
        out << "}" << endl << endl;
    }

    void WriteComparisonOperators(ostream &out)
    {
        // Write the method comment.
        string purposeString("Comparison operator == for the ");
        purposeString += (ClassName + " class.");
        string methodName("operator == ");
        WriteMethodComment(out, ClassName, methodName, purposeString);

        out << "bool" << endl;
        out << ClassName << "::operator == (const "
            << ClassName << " &obj)" << endl;
        out << "{" << endl;

        // See if there are any list elements
        AttributeInfoVector::iterator pos;
        int listcount = 0;
        for(pos = attributes.begin(); pos != attributes.end(); ++pos)
        {
            if((*pos)->isList() || ((*pos)->attrType == "a*"))
                ++listcount;
        }
        if(listcount > 0)
            out << "    int i;" << endl << endl;

        // Create bool values to evaluate the arrays.
        string prevValue("true");
        for(pos = attributes.begin(); pos != attributes.end(); ++pos)
        {
            if((*pos)->attrType == "A")
            {
                string &s = (*((string *)((*pos)->defaultData)));
                out << "    bool " << (*pos)->attrName << "_equal = "
                    << prevValue << ";" << endl;
                out << "    for(i = 0; (i < " << (*pos)->length
                    << ") && " << (*pos)->attrName << "_equal; ++i)"
                    << endl;
                out << "    {" << endl;
                out << "        if(" << (*pos)->attrName << "[i] == 0 || obj." << (*pos)->attrName
                    << "[i] == 0)" << endl;
                out << "             break;" << endl;
                out << "        // Make references to " << s
                    << " from AttributeGroup *." << endl;
                out << "        " << s << " &" << (*pos)->attrName
                    << "1 = *((" << s << " *)(" << (*pos)->attrName << "[i]));"
                    << endl;
                out << "        " << s << " &" << (*pos)->attrName
                    << "2 = *((" << s << " *)(obj." << (*pos)->attrName
                    << "[i]));" << endl;
                out << "        " << (*pos)->attrName << "_equal = ("
                    << (*pos)->attrName << "1 == "
                    << (*pos)->attrName << "2);" << endl;
                out << "    }" << endl << endl;
                prevValue = ((*pos)->attrName + "_equal");
            }
            else if((*pos)->isList())
            {
                out << "    // Compare the " << (*pos)->attrName << " arrays."
                    << endl;
                out << "    bool " << (*pos)->attrName << "_equal = " 
                    << prevValue << ";" << endl;
                out << "    for(i = 0; i < " << (*pos)->length << " && "
                    << (*pos)->attrName << "_equal; ++i)" << endl;
                out << "        " << (*pos)->attrName << "_equal = ("
                    << (*pos)->attrName << "[i] == obj." << (*pos)->attrName
                    << "[i]);" << endl << endl;
                prevValue = ((*pos)->attrName + "_equal");
            }
            else if((*pos)->attrType == "a*")
            {
                string &s = (*((string *)((*pos)->defaultData)));
                out << "    bool " << (*pos)->attrName << "_equal = "
                    << prevValue << " && (obj." << (*pos)->attrName
                    << ".size() == " << (*pos)->attrName << ".size());"
                    << endl;
                out << "    for(i = 0; (i < " << (*pos)->attrName
                    << ".size()) && " << (*pos)->attrName << "_equal; ++i)"
                    << endl;
                out << "    {" << endl;
                out << "        // Make references to " << s
                    << " from AttributeGroup *." << endl;
                out << "        " << s << " &" << (*pos)->attrName
                    << "1 = *((" << s << " *)(" << (*pos)->attrName << "[i]));"
                    << endl;
                out << "        " << s << " &" << (*pos)->attrName
                    << "2 = *((" << s << " *)(obj." << (*pos)->attrName
                    << "[i]));" << endl;
                out << "        " << (*pos)->attrName << "_equal = ("
                    << (*pos)->attrName << "1 == "
                    << (*pos)->attrName << "2);" << endl;
                out << "    }" << endl << endl;
                prevValue = ((*pos)->attrName + "_equal");
            }
        }

        out << "    // Create the return value" << endl;
        out << "    return (";

        // Create a big boolean return statement.
        int index = 0;
        for(pos = attributes.begin(); pos != attributes.end(); ++pos, ++index)
        {
            if(index > 0)
                out << "            ";

            if((*pos)->isList() || ((*pos)->attrType == "a*"))
            {
                out << (*pos)->attrName << "_equal";
            }
            else
            {
                out << "(" << (*pos)->attrName << " == obj."
                    << (*pos)->attrName << ")";
            }

            if(index < attributes.size() - 1)
                out << " &&" << endl;
        }
        out << ");" << endl;

        out << "}" << endl << endl;

        // Write the != operator
        purposeString = "Comparison operator != for the ";
        purposeString += (ClassName + " class.");
        methodName = "operator != ";
        WriteMethodComment(out, ClassName, methodName, purposeString);

        out << "bool" << endl;
        out << ClassName << "::operator != (const "
            << ClassName << " &obj)" << endl;
        out << "{" << endl;
        out << "    return !(this->operator == (obj));" << endl;
        out << "}" << endl << endl;
    }

    void WriteSubAttributeGroup(ostream &out)
    {
        // See if there are any AG vectors.
        int AG_dynamic_count = 0;
        AttributeInfoVector::iterator pos;
        for(pos = attributes.begin(); pos != attributes.end(); ++pos)
        {
            if((*pos)->attrType == "a*" || (*pos)->attrType == "A")
                ++AG_dynamic_count;
        }
        if(AG_dynamic_count < 1)
            return;

        WriteMethodComment(out, ClassName, "CreateSubAttributeGroup",
            purposeString);
        out << "AttributeGroup *" << endl;
        out << ClassName << "::CreateSubAttributeGroup(int";

        if(AG_dynamic_count == 1)
        {
            out << ")" << endl;
            out << "{" << endl;

            for(pos = attributes.begin(); pos != attributes.end(); ++pos)
            {
                if((*pos)->attrType == "a*" || (*pos)->attrType == "A")
                {
                    string &s = (*((string *)(*pos)->defaultData));
                    out << "    return new " << s << ";" << endl;
                    break;
                }
            }
        }
        else
        {
            out << " attr_id)" << endl;
            out << "{" << endl;

            int index = 0;
            out << "    AttributeGroup *retval = 0;" << endl;
            out << "    switch(attr_id)" << endl;
            out << "    {" << endl;
            for(pos = attributes.begin(); pos != attributes.end(); ++pos, ++index)
            {
                if((*pos)->attrType == "a*" || (*pos)->attrType == "A")
                {
                    string &s = (*((string *)(*pos)->defaultData));
                    out << "    case " << index << ":" << endl;
                    out << "        retval = new " << s << ";" << endl;
                    out << "        break;" << endl;
                }
            }
            out << "    }" << endl;
            out << endl << "    return retval;" << endl;
        }
        out << "}" << endl << endl;
    }

    void WriteCreateNode(ostream &out)
    {
        out << "///////////////////////////////////////////////////////////////////////////////" << endl;
        out << "// Persistance methods" << endl;
        out << "///////////////////////////////////////////////////////////////////////////////" << endl;
        out << endl;
        WriteMethodComment(out, ClassName, "CreateNode",
            "This method creates a DataNode representation of the object so it can be saved to a config file.");

        out << "void" << endl;
        out << ClassName << "::CreateNode(DataNode *parentNode)" << endl;
        out << "{" << endl;
        out << "    if(parentNode == 0)" << endl;
        out << "        return;" << endl << endl;
        out << "    // Create a node for " << ClassName << "." << endl;
        out << "    DataNode *node = new DataNode(\"" << ClassName << "\");" << endl;

        // Write out the DataNode creation for all attributes.
        AttributeInfoVector::iterator pos;
        for(pos = attributes.begin(); pos != attributes.end(); ++pos)
        {
            if((*pos)->attrType == "a")
            {
                string nodeName = (*pos)->attrName + "Node";
                out << "    DataNode *" << nodeName << " = new DataNode(\""
                    << (*pos)->attrName << "\");" << endl;
                out << "    node->AddNode(" << nodeName << ");" << endl;
                out << "    " << (*pos)->attrName << ".CreateNode("
                    << nodeName << ");" << endl;
            }
            else if((*pos)->attrType == "A")
            {
                out << "    for(int i = 0; i < " << (*pos)->length << "; ++i)" << endl;
                out << "        " << (*pos)->attrName << "[i]->CreateNode(node);" << endl;
            }
            else if((*pos)->attrType == "a*")
            {
                out << "    for(int i = 0; i < " << (*pos)->attrName << ".size(); ++i)" << endl;
                out << "        " << (*pos)->attrName << "[i]->CreateNode(node);" << endl;
            }
            else if((*pos)->isList())
            {
                out << "    node->AddNode(new DataNode(\"" << (*pos)->attrName
                    << "\", " << (*pos)->attrName << ", " << (*pos)->length << "));" << endl;
            }
            else
            {
                out << "    node->AddNode(new DataNode(\"" << (*pos)->attrName
                    << "\", " << (*pos)->attrName << "));" << endl;
            }
        }

        out << endl;
        out << "    // Add the node to the parent node." << endl;
        out << "    parentNode->AddNode(node);" << endl;
        out << "}" << endl;
        out << endl;
    }

    void WriteSetFromNode(ostream &out)
    {
        // See if there are any AG vectors.
        int count = 0, AG_dynamic_count = 0;
        AttributeInfoVector::iterator pos;
        for(pos = attributes.begin(); pos != attributes.end(); ++pos)
        {
            if((*pos)->attrType == "a*" || (*pos)->attrType == "A")
                ++AG_dynamic_count;
            else
                ++count;
        }

        WriteMethodComment(out, ClassName, "SetFromNode",
            "This method sets attributes in this object from values in a DataNode representation of the object.");

        out << "void" << endl;
        out << ClassName << "::SetFromNode(DataNode *parentNode)" << endl;
        out << "{" << endl;
        out << "    if(parentNode == 0)" << endl;
        out << "        return;" << endl << endl;
        out << "    DataNode *searchNode = parentNode->GetNode(\"" << ClassName << "\");" << endl;
        out << "    if(searchNode == 0)" << endl;
        out << "        return;" << endl;
        out << endl;
        if(count > 0)
            out << "    DataNode *node;" << endl;
        if(AG_dynamic_count > 0)
            out << "    DataNode **children;" << endl;

        for(pos = attributes.begin(); pos != attributes.end(); ++pos)
        {
            if((*pos)->attrType == "a")
            {
                out << "    if((node = searchNode->GetNode(\"" << (*pos)->attrName
                    << "\")) != 0)" << endl;
                out << "        " << (*pos)->attrName << ".SetFromNode(node);" << endl;
            }
            else if((*pos)->attrType == "A")
            {
                const string &element = *((string *)((*pos)->defaultData));
                out << "    // Go through all of the children and construct a new" << endl;
                out << "    // " << element << " for each one of them." << endl;
                out << "    children = searchNode->GetChildren();" << endl;
                out << "    for(int i = 0, j = 0; i < searchNode->GetNumChildren(); ++i)" << endl;
                out << "    {" << endl;
                out << "        if(children[i]->GetKey() == std::string(\"" << element << "\") &&" << endl;
                out << "           j < " << (*pos)->length << ")" << endl;
                out << "        {" << endl;
                out << "            " << element << "*temp = new " << element << ";" << endl;
                out << "            temp->SetFromNode(children[i]);" << endl;
                out << "            " << (*pos)->attrName << "[i] = temp;" << endl;
                out << "        }" << endl;
                out << "    }" << endl << endl;
            }
            else if((*pos)->attrType == "a*")
            {
                const string &element = *((string *)((*pos)->defaultData));
                out << "    // Clear all the " << element << "s." << endl;
                out << "    Clear" << MakeName(element) << "s();" << endl;
                out << endl;
                out << "    // Go through all of the children and construct a new" << endl;
                out << "    // " << element << " for each one of them." << endl;
                  
                out << "    children = searchNode->GetChildren();" << endl;
                out << "    for(int i = 0; i < searchNode->GetNumChildren(); ++i)" << endl;
                out << "    {" << endl;
                out << "        if(children[i]->GetKey() == std::string(\"" << element << "\"))" << endl;
                out << "        {" << endl;
                out << "            " << element << " temp;" << endl;
                out << "            temp.SetFromNode(children[i]);" << endl;
                out << "            Add" << MakeName(element) << "(temp);" << endl;
                out << "        }" << endl;
                out << "    }" << endl << endl;
            }
            else
            {
                out << "    if((node = searchNode->GetNode(\"" << (*pos)->attrName
                    << "\")) != 0)" << endl;
                if((*pos)->publicMode)
                {
                    if((*pos)->isList())
                    {
                        out << "        for(int i = 0; i < " << (*pos)->length << "; ++i)" << endl;
                        out << "            " << (*pos)->attrName << "[i] = node->"
                            << DataNodeConversion((*pos)->attrType) << "()[i];" << endl;
                    }
                    else
                    {
                        out << "        " << (*pos)->attrName << " = node->"
                            << DataNodeConversion((*pos)->attrType) << "();" << endl;
                    }
                }
                else
                {
                    out << "        Set" << MakeName((*pos)->attrName) << "(node->"
                        << DataNodeConversion((*pos)->attrType) << "());" << endl;
                }
            }
        } // end for
        out << "}" << endl << endl;
    }

    void WriteSourceFile(ostream &out)
    {
        out << "#include <" << ClassName << ".h>" << endl;
        WriteIncludes(out);

        // Write the more complex methods.
        WriteConstructor(out);
        WriteCopyConstructor(out);
        WriteDestructor(out);
        WriteAssignmentOperator(out);
        WriteComparisonOperators(out);
        WriteSelectAll(out);
        WriteSubAttributeGroup(out);
        WriteCreateNode(out);
        WriteSetFromNode(out);

        // Count the number of AttributeGroupVectors and private attributes.
        AttributeInfoVector::iterator pos;
        int ag_count = 0, priv_count = 0;
        for(pos = attributes.begin(); pos != attributes.end(); ++pos)
        {
            if((*pos)->attrType == "a*")
                ++ag_count;
            else if(!((*pos)->publicMode))
                ++priv_count;
        }

        // Write out all the set methods
        int index = 0;
        if(priv_count > 0)
        {
            out << "///////////////////////////////////////////////////////////////////////////////" << endl;
            out << "// Set property methods" << endl;
            out << "///////////////////////////////////////////////////////////////////////////////" << endl << endl;
            for(pos = attributes.begin(); pos != attributes.end(); ++pos, ++index)
                (*pos)->WriteSetFunction(out, ClassName, index);

            // Write out all the get methods
            index = 0;
            out << "///////////////////////////////////////////////////////////////////////////////" << endl;
            out << "// Get property methods" << endl;
            out << "///////////////////////////////////////////////////////////////////////////////" << endl << endl;
            for(pos = attributes.begin(); pos != attributes.end(); ++pos, ++index)
            {
                bool noConst = ((*pos)->CanHaveConst());
                (*pos)->WriteGetFunction(out, ClassName, true);
                if(noConst)
                    (*pos)->WriteGetFunction(out, ClassName, false);
            }

            if(SelectFunctionsNeeded())
            {
                // Write out all the select methods
                index = 0;
                out << "///////////////////////////////////////////////////////////////////////////////" << endl;
                out << "// Select property methods" << endl;
                out << "///////////////////////////////////////////////////////////////////////////////" << endl << endl;
                for(pos = attributes.begin(); pos != attributes.end(); ++pos, ++index)
                    (*pos)->WriteSelectFunction(out, ClassName, index);
            }
        }

        if(ag_count > 0)
        {
            index = 0;
            out << "///////////////////////////////////////////////////////////////////////////////" << endl;
            out << "// AttributeGroupVector convenience methods." << endl;
            out << "///////////////////////////////////////////////////////////////////////////////" << endl << endl;
            for(pos = attributes.begin(); pos != attributes.end(); ++pos, ++index)
            {
                (*pos)->WriteAttributeGroupVectorFunctions(out, ClassName, 
                    purposeString, index);
            }
        }

        out << "///////////////////////////////////////////////////////////////////////////////" << endl;
        out << "// User-defined methods." << endl;
        out << "///////////////////////////////////////////////////////////////////////////////" << endl << endl;
    }

public:
    string              ClassName;
    AttributeInfoVector attributes;
    string              purposeString;
};

// *******************************************************************
// Function: WriteFiles
//
// Purpose:
//   Writes the class definition out to files or to stdout.
//
// Notes:      
//
// Programmer: Brad Whitlock
// Creation:   Tue Sep 5 13:40:33 PST 2000
//
// Modifications:
//   
//   Hank Childs, Tue May 22 08:32:15 PDT 2001
//   Added check to make sure the file could be opened.
//
// *******************************************************************

void
WriteFiles(bool writeFiles, ClassAttributes &classDef)
{
    if(writeFiles)
    {
        ofstream out;

        string filename = classDef.ClassName + ".h";
        out.open(filename.c_str(), ios::out);
        if (out.fail())
        {
            cerr << "Could not open file \"" << filename << "\" ... giving up."
                 << endl;
            return;
        }
        classDef.WriteHeaderFile(out);
        out.close();

        filename = classDef.ClassName + ".C";
        out.open(filename.c_str(), ios::out);
        if (out.fail())
        {
            cerr << "Could not open file \"" << filename << "\" ... giving up."
                 << endl;
            return;
        }
        classDef.WriteSourceFile(out);
        out.close();
    }
    else
    {
        classDef.WriteHeaderFile(cout);
        classDef.WriteSourceFile(cout);
    }
}

// *******************************************************************
// Function: main
//
// Purpose:
//   This is the main function for the classwriter program. Its job is
//   to open the input file, read tokens and decide what to do with
//   them.
//
// Notes:      
//
// Programmer: Brad Whitlock
// Creation:   Tue Sep 5 13:17:17 PST 2000
//
// Modifications:
//   
// *******************************************************************

void
main(int argc, char *argv[])
{
    bool            writeFile = true;
    bool            readingClassDef = false;
    bool            publicMode = false;
    string          inputFile("attr.def");
    ClassAttributes currentClass;
    char            tmpline[200];

    // List of classes to be re-generated.
    bool            generateAll = true;
    vector<string>  classList;

    // Process some command line arguments.
    for(int i = 1; i < argc; ++i)
    {
        if(string(argv[i]) == string("-stdout"))
            writeFile = false;
        else if(string(argv[i]) == string("-file"))
        {
            // Set the input file.
            inputFile = string(argv[i + 1]);
            ++i;
        }
        else 
        {
            // Assume it is a class name and add it to the list.
            classList.push_back(string(argv[i]));
            generateAll = false;
        }
    }

    // Open the input file.
    ifstream def;
    def.open(inputFile.c_str(), ios::in);

    // While the file has stuff, read the classes.
    while(!def.eof())
    {
        string token;
        // read the token from the file.
        def >> token;

        if(token == "")
        {
            // Got a bad token
            break;
        }
        if(string(token) == string("class:"))
        {
            if(readingClassDef)
            {
                if(generateAll)
                    WriteFiles(writeFile, currentClass);
                else
                {
                    // See if the class is in the list that we're generating.
                    if(find(classList.begin(), classList.end(),
                            currentClass.ClassName) != classList.end())
                        WriteFiles(writeFile, currentClass);
                }
                currentClass.Clear();
            }

            if(!def.eof())
            {
                // Read the next class name
                def >> currentClass.ClassName;

                readingClassDef = true;
            }
            else
                readingClassDef = false;

            // We're doing a new class, reset to access to private.
            publicMode = false;
        }
        else if(string(token) == string("purpose:"))
        {
            // Read the rest of the line and assign it into the
            // current class's purpose string.
            def.getline(tmpline, 150, '\n');
            currentClass.purposeString = string(tmpline);
        }
        else if(string(token) == string("public:"))
        {
            publicMode = true;
        }
        else if(string(token) == string("private:"))
        {
            publicMode = false;
        }
        else if(string(token) == string("#"))
        {
            // Read the rest of the line and ignore it.
            def.getline(tmpline, 150, '\n');            
        }
        else
        {
            // Create a new attribute and read it in.
            AttributeInfo *newAttr = new AttributeInfo;
            def >> *newAttr;

            // Add the new attribute to the current class.
            currentClass.AddAttribute(token, newAttr, publicMode);
        }
    } // end while

    // Write out the last classdef if it was in the list that we want.
    if(generateAll)
        WriteFiles(writeFile, currentClass);
    else
    {
        // See if the class is in the list that we're generating.
        if(find(classList.begin(), classList.end(), currentClass.ClassName) !=
           classList.end())
            WriteFiles(writeFile, currentClass);
    }

    // close the input file
    def.close();
}

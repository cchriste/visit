<html>
<!-- generated by mif2help on Mon Nov 5 11:31:44 PDT 2007 --><head>
<title>Built-in expressions</title>
</head>
<body link="#0000FF" vlink="#800080" alink="#FF0000" bgcolor="#FFFFFF">
<center align="right">[<a href="help0342.html">Back</a>]  [<a href="help0329.html">Up</a>]  [<a href="help0344.html">Next</a>]</center>
<h2><p>Built-in expressions</h2></p>
<p>The following table lists built-in expressions that can be used to create more advanced expressions. Unless otherwise noted in the description, each expression takes scalar variables as its arguments.</p>
<table width="90%" border="1" align="center" cellpadding="5" cellspacing="1">
<tr>
<td width="20%"><p>Expression</p>
</td>
<td width="25%"><p>Meaning</p>
</td>
<td width="54%"><p>Usage</p>
</td>
</tr>
<tr>
<td width="20%"><p>{}</p>
</td>
<td width="25%"><p>Associate a list of expressions into a single variable. Usually used for defining a vector or tensor variable.</p>
</td>
<td width="54%"><p>{expr<sub>1</sub>, expr<sub>2</sub> [, ...]}</p>
<p>expr<sub>i</sub> can be an expression of variables, another expression, or a constant defined over a mesh.</p>
<p>Examples:</p>
<p>vector = {a,b,c}</p>
<p>tensor = {{a,b,c},{d,e,f},{g,h,i}}</p>
</td>
</tr>
<tr>
<td width="20%"><p>[]</p>
</td>
<td width="25%"><p>Access a subscript of a vector or tensor variable.</p>
</td>
<td width="54%"><p>expr[index]</p>
<p>expr must be an expression that evaluates to a vector of tensor variable and index must be an integer greater than or equal to zero and less than the number of components in the variable being indexed.</p>
<p>Example: velocity[0]</p>
</td>
</tr>
<tr>
<td width="20%"><p>()</p>
</td>
<td width="25%"><p>Associative parenthesis.</p>
</td>
<td width="54%"><p>Group mathematical operations to influence the order in which expressions are evaluated.</p>
</td>
</tr>
<tr>
<td width="20%"><p>-</p>
</td>
<td width="25%"><p>Unary negation</p>
</td>
<td width="54%"><p>-expr</p>
<p>expr is any expression that evaluates to a scalar or vector field defined on a mesh.</p>
<p>Example: -charge</p>
</td>
</tr>
<tr>
<td width="20%"><p>-</p>
</td>
<td width="25%"><p>Subtraction</p>
</td>
<td width="54%"><p>expr<sub>1</sub> - expr<sub>2</p>
<p></sub>expressions involving subtraction can be database variables, constants, or other expressions.</p>
<p>Example: a - b</p>
</td>
</tr>
<tr>
<td width="20%"><p>+</p>
</td>
<td width="25%"><p>Addition</p>
</td>
<td width="54%"><p>expr<sub>1</sub> + expr<sub>2</p>
<p></sub>Expressions involving addition can be database variables, constants, or other expressions.</p>
<p>Example: a + b</p>
</td>
</tr>
<tr>
<td width="20%"><p>*</p>
</td>
<td width="25%"><p>Multiplication</p>
</td>
<td width="54%"><p>expr<sub>1</sub> * expr<sub>2</p>
<p></sub>Expressions involving multiplication can be database variables, constants, or other expressions. Multiplication is most often used with two scalar inputs but one of the inputs to the multiplication operator can be a vector if you want to scale a vector using a scalar or a constant.</p>
<p>Example: a * b</p>
</td>
</tr>
<tr>
<td width="20%"><p>/</p>
</td>
<td width="25%"><p>Division</p>
</td>
<td width="54%"><p>expr<sub>1</sub> / expr<sub>2</p>
<p></sub>Expressions involving division can be database variables, constants, or other expressions. Division is most often used with two scalar inputs but the first input can be a vector if you want to scale a vector using a scalar or a constant.</p>
<p>Example: a / b</p>
</td>
</tr>
<tr>
<td width="20%"><p>^</p>
</td>
<td width="25%"><p>Exponentiation</p>
</td>
<td width="54%"><p>expr<sub>1</sub> ^ expr<sub>2</p>
<p></sub>Expressions involving exponentiation can be database variables, constants, or other expressions.</p>
<p>Example: a ^ b (a<sup>b</sup>)</p>
</td>
</tr>
<tr>
<td width="20%"><p>abs</p>
</td>
<td width="25%"><p>Absolute value</p>
</td>
<td width="54%"><p>abs(expr)</p>
<p>expr can be an expression of database variables, constants, or other scalar expressions.</p>
</td>
</tr>
<tr>
<td width="20%"><p>acos</p>
</td>
<td width="25%"><p>Arccosine</p>
</td>
<td width="54%"><p>acos(expr)</p>
<p>expr can be an expression of database variables, constants, or other scalar expressions. The acos expression returns an angle in radians.</p>
<p>Example: angle = acos(value)</p>
</td>
</tr>
<tr>
<td width="20%"><p>and</p>
</td>
<td width="25%"><p>Logical and</p>
</td>
<td width="54%"><p>and(expr<sub>1</sub>, expr<sub>2</sub>)</p>
<p>The logical and function returns a value of 1 (true) if both scalar input expressions expr<sub>1</sub> and expr<sub>2</sub> are not equal to zero. Otherwise, the logical and function returns zero. The logical and function is often used with other conditionals such as the<i> if</i> expression.</p>
<p>Example: if(and(gt(pressure, 2.0), lt(pressure, 4.0)), pressure, 0.0)</p>
<p>Meaning: if pressure is in the range (2.0, 4.0) then use the value for pressure. Otherwise, use zero.</p>
</td>
</tr>
<tr>
<td width="20%"><p>area</p>
</td>
<td width="25%"><p>Cell Area</p>
</td>
<td width="54%"><p>area(expr)</p>
<p>expr must evaluate to a 2D mesh expression so VisIt can calculate the area of each 2D cell in the mesh and returns scalar values.</p>
<p>Example: density = mass / area(hydro_mesh2d)</p>
</td>
</tr>
<tr>
<td width="20%"><p>array_compose</p>
</td>
<td width="25%"><p>Array compose</p>
</td>
<td width="54%"><p>array_compose(expr<sub>1</sub>, expr<sub>2</sub>, ..., expr<sub>N</sub>)</p>
<p>Each argument to the array_compose expression, expr<sub>i</sub>, must evaluate to a scalar expression and all of the input expressions must have the same centering. The array_compose expression creates a new array variable from the input expressions. Array variables are collections of scalar variables that are commonly used with certain plots to display the contents of multiple variables simultaneously. For example, the Label plot can display the values in an array variable.</p>
<p>Example: array_compose(density, pressure, velocity[0], velocity[1], velocity[2])</p>
</td>
</tr>
<tr>
<td width="20%"><p>array_decompose</p>
</td>
<td width="25%"><p>Array decompose</p>
</td>
<td width="54%"><p>array_decompose(expr<sub>1</sub>, expr<sub>2</sub>)</p>
<p>expr<sub>1</sub> must evaluate to an array variable. expr<sub>2</sub> must evaluate to a number between 0 and the number of scalar components in the array variable minus 1. This expression isolates one scalar variable from an array variable.</p>
<p>Example: array_decompose(array, 0)</p>
</td>
</tr>
<tr>
<td width="20%"><p>asin</p>
</td>
<td width="25%"><p>Arcsine</p>
</td>
<td width="54%"><p>asin(expr)</p>
<p>expr can be an expression of database variables, constants, or other scalar expressions. The asin expression returns an angle in radians.</p>
<p>Example: angle = asin(value)</p>
</td>
</tr>
<tr>
<td width="20%"><p>aspect</p>
</td>
<td width="25%"><p>Cell aspect ratio</p>
</td>
<td width="54%"><p>aspect(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The aspect function computes the aspect ratio for each cell in the mesh and returns scalar values. Cells with high aspect ratios (long and skinny) are often considered to be less fit than more squat cells.</p>
<p>Example: aspect(hydro_mesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>aspect_gamma</p>
</td>
<td width="25%"><p>Cell aspect gamma</p>
</td>
<td width="54%"><p>aspect_gamma(expr)</p>
<p>expr must be an expression that evaluates to a mesh.</p>
<p>Example: aspect_gamma(hydro_mesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>atan</p>
</td>
<td width="25%"><p>Arctangent</p>
</td>
<td width="54%"><p>atan(expr)</p>
<p>expr can be an expression of database variables, constants, or other scalar expression variables. The atan expression returns an angle in radians.</p>
<p>Example: angle = atan(value)</p>
</td>
</tr>
<tr>
<td width="20%"><p>ceil</p>
</td>
<td width="25%"><p>Ceiling</p>
</td>
<td width="54%"><p>ceil(expr)</p>
<p>expr must evaluate to a scalar expression. The ceil expression calculates the ceiling function. The ceiling is defined to be smallest integer that is bigger than the current value.</p>
<p>Example: ceil(pressure)</p>
</td>
</tr>
<tr>
<td width="20%"><p>condition</p>
</td>
<td width="25%"><p>Condition number</p>
</td>
<td width="54%"><p>condition(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The condition expression returns the maximum condition number of the Jacobian matrix at the nodes of each cell in the mesh, resulting in a zone-centered, scalar expression.</p>
<p>Example: condition(hydro_mesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>conn_cmfe</p>
</td>
<td width="25%"><p>Connectivity-based common mesh field evaluation</p>
</td>
<td width="54%"><p>conn_cmfe(expr<sub>1</sub>, expr<sub>2</sub>)</p>
<p>Examples:</p>
<p><i>Map wave0020.silo's pressure variable the current mesh.</p>
<p></i>conn_cmfe(&lt;wave0020.silo:pressure&gt;, quadmesh)</p>
<p><i>Substract &lt;mesh/ireg&gt; variable from the last time state from the current time state.</p>
<p></i>&lt;mesh/ireg&gt; - conn_cmfe(&lt;allinone00.pdb[-1]id:mesh/ireg&gt;, mesh)</p>
</td>
<tr>
<td><p>conservative_smooth</p>
</td>
<td><p>Conservative smooth</p>
</td>
<td><p>conservative_smooth(expr)</p>
<p>expr must be an expression that evaluates to a scalar field. This expression applies the conservative smooth filter (an image processing filter) to a scalar field.  The filter only considers a value and its immediation neighbors (26 neighbors in three dimensions, 8 in two dimensions).  The filter only works on structured meshes.  When performing a conserv tive smooth operation, a value is only replaced if it is outside the range of its immediate neighbors. If so, it is replaced with the closest value from its immediate neighbors.</p>
<p>Example: conservative_smooth(intensity)</p>
</td>
</tr>
<tr>
<td width="20%"><p>coord, coords</p>
</td>
<td width="25%"><p>Mesh coordinates</p>
</td>
<td width="54%"><p>coord(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The coord expression extracts the coordinate fields from a mesh and returns them as a vector variable with 3 components. The resulting vector can be used to extract the x,y,z components of the mesh's coordinate field.</p>
<p>Example: x = coord(Mesh)[0]</p>
</td>
</tr>
<tr>
<td width="20%"><p>cos</p>
</td>
<td width="25%"><p>Cosine</p>
</td>
<td width="54%"><p>cos(expr)</p>
<p>Compute the cosine of an angle in radians. Expr can be an expression of database variables, constants, or other scalar expression that evaluate to an angle in radians. The cos expression returns a scalar expression.</p>
<p>Example: x = radius * cos(angle)</p>
</td>
</tr>
<tr>
<td width="20%"><p>cosh</p>
</td>
<td width="25%"><p>Hyperbolic Cosine</p>
</td>
<td width="54%"><p>cosh(expr)</p>
<p>Compute the hyperbolic cosine of an angle in radians. Expr can be an expression of database variables, constants, or other scalar expression that evaluate to an angle in radians. The cosh expression returns a scalar expression.</p>
<p>Example: x = radius * cosh(angle)</p>
</td>
</tr>
<tr>
<td width="20%"><p>cross</p>
</td>
<td width="25%"><p>Vector cross product</p>
</td>
<td width="54%"><p>cross(expr<sub>1</sub>, expr<sub>2</sub>)</p>
<p>The cross expression returns the vector cross product of the expr<sub>1</sub> and expr<sub>2</sub> vector expressions.</p>
<p>Example: viewvec = cross(right_vec, up_vec)</p>
</td>
</tr>
<tr>
<td width="20%"><p>curl</p>
</td>
<td width="25%"><p>Curl</p>
</td>
<td width="54%"><p>curl(expr)</p>
<p>The curl expression calculates the curl of the input expression, which must evaluate to a vector field. The result is also a vector unless the input data is 2D. When the input data set is 2D, the resulting curl vector always is (0,0,V) so the curl expression instead returns the scalar V.  The curl expression must be declared as a vector for 3D data sets, but as a scalar for 2D data sets.</p>
<p>Example: curl(vecfield)</p>
</td>
</tr>
<tr>
<td width="20%"><p>cylindrical_radius</p>
</td>
<td width="25%"><p>Cylindrical radius</p>
</td>
<td width="54%"><p>cylindrical_radius(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The cylindrical radius expression converts the coordinates of the input mesh from cartesian coordinates to cylindrical coordinates and returns the radius component of the cylindrical coordinates.</p>
<p>Example: cylindrical_radius(hydro_mesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>cylindrical_theta</p>
</td>
<td width="25%"><p>Cylindrical theta</p>
</td>
<td width="54%"><p>cylindrical_theta(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The cylindrical theta expression converts the coordinates of the input mesh from cartesian coordinates to cylindrical coordinates and then returns the theta component of the cylindrical coordinates.</p>
<p>Example: cylindrical_theta(hydro_mesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>deg2rad</p>
</td>
<td width="25%"><p>Degrees to radians</p>
</td>
<td width="54%"><p>deg2rad(expr)</p>
<p>The deg2rad expression converts the input scalar expression, which is assumed to be in degrees, to radians.</p>
<p>Example: angle_rad = deg2rad(angle)</p>
</td>
</tr>
<tr>
<td width="20%"><p>degree</p>
</td>
<td width="25%"><p>Mesh degree</p>
</td>
<td width="54%"><p>degree(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The degree expression creates a nodal scalar field that contains the number of cells that use each node.</p>
<p>Example: degree(Mesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>det, determinant</p>
</td>
<td width="25%"><p>Matrix determinant</p>
</td>
<td width="54%"><p>determinant(expr)</p>
<p>expr must evaluate to a 3x3 tensor. The determinant expression computes the determinant of a 3x3 matrix and returns the scalar result.</p>
<p>Expression: detA = determinant(A)</p>
</td>
</tr>
<tr>
<td width="20%"><p>diagonal</p>
</td>
<td width="25%"><p>Diagonal ratio</p>
</td>
<td width="54%"><p>diagonal(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The diagonal expression computes the minimum and maximum diagonals for 3D hexahedral cells and returns the minimum diagonal length divided by the maximum diagonal length. Cells that have equal aspect ratios will have diagonal ratios of 1.0 while more oblong cells will have differing values. For cells that are not hexahedral, the diagonal expression returns -1.</p>
<p>Example: diagonal(Mesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>dimension</p>
</td>
<td width="25%"><p>Pronto-specific length of stable time step</p>
</td>
<td width="54%"><p>dimension(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The dimension expression computes the characteristic length for stable time step calculation in the Pronto simulation code. </p>
<p>Example: dimension(Mesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>divergence</p>
</td>
<td width="25%"><p>Divergence</p>
</td>
<td width="54%"><p>divergence(expr)</p>
<p>The divergence filter calculates the divergence, which is the tendency of a fluid to spread out. The input expression must evaluate to a vector field. Divergence results in a scalar field.</p>
<p>Example: divergence(vec)</p>
</td>
</tr>
<tr>
<td width="20%"><p>dot</p>
</td>
<td width="25%"><p>Vector dot product</p>
</td>
<td width="54%"><p>dot(expr<sub>1</sub>, expr<sub>2</sub>)</p>
<p>The dot expression takes 2 vector inputs expr<sub>1</sub> and expr<sub>2</sub> and computes their vector dot product and returns the resulting scalar expression.</p>
<p>Example: dot(vector1, vector2)</p>
</td>
</tr>
<tr>
<td width="20%"><p>effective_tensor</p>
</td>
<td width="25%"><p>Effective tensor</p>
</td>
<td width="54%"><p>effective_tensor(expr)</p>
<p>expr must evaluate to a tensor expression. The effective_tensor expression determines the effective part of a 3x3 tensor and returns the resulting scalar expression.</p>
<p>Example: effective_tensor(tensor1)</p>
</td>
</tr>
<tr>
<td width="20%"><p>eigenvalue</p>
</td>
<td width="25%"><p>Eigenvalue</p>
</td>
<td width="54%"><p>eigenvalue(expr)</p>
<p>expr must evaluate to a 3x3 tensor. The eigenvalue expression returns the eigenvalues of a matrix as a scalar expression.</p>
<p>Example: scalars = eigenvalue(tensor)</p>
</td>
</tr>
<tr>
<td width="20%"><p>eigenvector</p>
</td>
<td width="25%"><p>Eigenvector</p>
</td>
<td width="54%"><p>eigenvector(expr)</p>
<p>expr must evaluate to a 3x3 tensor. The eigenvector expression returns the eigenvectors of a matrix as a vector expression.</p>
<p>Example: vectors = eigenvector(tensor)</p>
</td>
</tr>
<tr>
<td width="20%"><p>eq, equal, equals</p>
</td>
<td width="25%"><p>Equality</p>
</td>
<td width="54%"><p>equal(expr<sub>1</sub>, expr<sub>2</sub>)</p>
<p>The equal expression returns a value of 1 (true) if both input scalar expressions expr<sub>1</sub> and expr<sub>2</sub> are equal. Otherwise, the equal expression returns zero. The equal expression is often used with other conditionals such as the if expression.</p>
<p>Example: if(eq(density, 1.0), density*2.0, 0.0)</p>
</td>
</tr>
<tr>
<td width="20%"><p>external_node</p>
</td>
<td width="25%"><p>External node</p>
</td>
<td width="54%"><p>external_node(expr)</p>
<p>The external_node expression marks every node that is incident to an external face as '1', every node incident to only internal faces as '0'. Expr must be a mesh.  If expr is a two-dimensional mesh, then the expression returns '1' if a node is incident to an external edge.</p>
<p>Example: external_node(hydro_mesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>floor</p>
</td>
<td width="25%"><p>Floor</p>
</td>
<td width="54%"><p>floor(expr)</p>
<p>expr must be an expression that evaluates to a scalar expression. The floor expression takes the floor of its expression argument, which is defined to be biggest integer that is smaller than the current value.</p>
<p>Example: floor(pressure)</p>
</td>
</tr>
<tr>
<td width="20%"><p>ge, gte</p>
</td>
<td width="25%"><p>Greater than or equal</p>
</td>
<td width="54%"><p>ge(expr<sub>1</sub>, expr<sub>2</sub>)</p>
<p>The ge expression returns a value of 1 (true) if expr<sub>1</sub> &gt;= expr<sub>2</sub>. Both input expressions must be scalar expressions.</p>
<p>Example: if(ge(pressure, density), 1.0, 0.0)</p>
</td>
</tr>
<tr>
<td width="20%"><p>global_nodeid</p>
</td>
<td width="25%"><p>Global node numbers</p>
</td>
<td width="54%"><p>global_nodeid(expr)</p>
<p>The global_nodeid expression returns a scalar field containing the global node numbers for a domain-decomposed mesh so that each node in the mesh is numbered such that it is part of the whole mesh. expr can be any expression that ultimately involves a single mesh.</p>
<p>Example: global_nodeid(MESH)</p>
<p>N = global_nodeid(x)</p>
</td>
</tr>
<tr>
<td width="20%"><p>global_zoneid</p>
</td>
<td width="25%"><p>Global zone numbers</p>
</td>
<td width="54%"><p>global_zoneid(expr)</p>
<p>The global_zonid expression returns a scalar field containing the global cell numbers for a domain-decomposed mesh so that each cell in the mesh is numbered such that it is part of the whole mesh. expr can be any expression that ultimately involves a single mesh.</p>
<p>Example: global_zoneid(MESH)</p>
<p>N = global_zoneid(x)</p>
</td>
</tr>
<tr>
<td width="20%"><p>gradient</p>
</td>
<td width="25%"><p>Gradient</p>
</td>
<td width="54%"><p>gradient(expr)</p>
<p>The gradient expression computes the gradient, which results in a vector expression, from expr, which must evaluate to a scalar expression. The gradient calculation method varies depending on the type of the mesh over which the input is defined.</p>
<p>Example: volume_normals = gradient(vals)</p>
</td>
</tr>
<tr>
<td width="20%"><p>gt</p>
</td>
<td width="25%"><p>Greater than</p>
</td>
<td width="54%"><p>gt(expr<sub>1</sub>, expr<sub>2</sub>)</p>
<p>The <i>gt</i> expression returns a value of 1 (true) if expr<sub>1</sub> &gt; expr<sub>2</sub>. Both input expressions must be scalar expressions.</p>
<p>Example: density = mass / if(gt(volume, 0.0), volume, 0.00001)</p>
</td>
</tr>
<tr>
<td width="20%"><p>if</p>
</td>
<td width="25%"><p>Conditional</p>
</td>
<td width="54%"><p>if(expr<sub>1</sub>, expr<sub>2</sub>, expr<sub>3</sub>)</p>
<p>The <i>if</i> expression is used to select values based on a condition. Expr<sub>1</sub> must evaluate to a scalar. When expr<sub>1</sub>'s values are not equal to zero then the condition is true and the if expression returns the value for expr<sub>2</sub>. When expr<sub>1</sub>'s values are equal to zero, values for expr<sub>3</sub> are returned.</p>
<p>Example: inv_pressure = 1.0 / if(gt(pressure,0.0), pressure, 0.001)</p>
</td>
</tr>
<tr>
<td width="20%"><p>inverse</p>
</td>
<td width="25%"><p>Matrix inverse</p>
</td>
<td width="54%"><p>inverse(expr)</p>
<p>expr must evaluate to a 3x3 tensor expression. The inverse expression calculates the matrix inverse of the input matrix.</p>
<p>Example: invA = inverse(A)</p>
</td>
</tr>
<tr>
<td width="20%"><p>jacobian</p>
</td>
<td width="25%"><p>Jacobian</p>
</td>
<td width="54%"><p>jacobian(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The jacobian expression returns a scalar expression.</p>
<p>Example: jacobian(hydro_mesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>laplacian, Laplacian</p>
</td>
<td width="25%"><p>Laplacian</p>
</td>
<td width="54%"><p>laplacian(expr)</p>
<p>expr must be an expression that evaluates to a scalar. The laplacian expression returns a scalar expression containing the Laplacian of the input scalar field.</p>
<p>Example: Laplacian(pressure)</p>
</td>
</tr>
<tr>
<td width="20%"><p>largest_angle</p>
</td>
<td width="25%"><p>Largest angle</p>
</td>
<td width="54%"><p>largest_angle(expr)</p>
<p>expr must be an expression that evaluates to a 2D mesh. The largest_angle expression calculates a cell-centered scalar field containing the value of the largest interior angle in degrees. Only triangle and quadrilateral cells are considered.</p>
<p>Example: largest_angle(hydro_mesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>le, lte</p>
</td>
<td width="25%"><p>Less than or equal</p>
</td>
<td width="54%"><p>le(expr<sub>1</sub>, expr<sub>2</sub>)</p>
<p>The le expression returns a value of 1 (true) if expr<sub>1</sub> &lt;= expr<sub>2</sub>. Both input expressions must be scalar expressions.</p>
<p>Example: if(le(pressure, density), 1.0, 0.0)</p>
</td>
</tr>
<tr>
<td width="20%"><p>ln</p>
</td>
<td width="25%"><p>Natural logarithm</p>
</td>
<td width="54%"><p>ln(expr<sub>1</sub>, expr<sub>2</sub>)</p>
<p>expr<sub>1</sub> can be a database variable, constant, or other scalar expression. The ln expression computes the natural logarithm of the input scalar expression. expr<sub>2</sub> is optional and should be a numeric constant.  It is used to replace taking the ln of non-positive values in expr<sub>1</sub>, and prevents exceptions being thrown hen they are present.</p>
<p>Example: ln(density)</p>
<p>Example: ln(u, -1e38)</p>
</td>
</tr>
<tr>
<td width="20%"><p>log, log10</p>
</td>
<td width="25%"><p>Base 10 logarithm</p>
</td>
<td width="54%"><p>log(expr<sub>1</sub>, expr<sub>2</sub>)</p>
<p>expr<sub>1</sub> can be a database variable, constant, or other scalar expression. The log expression computes the base 10 logarithm of the input scalar expression. <sub>expr2</sub> is optional and should be a numeric constant.  It is used to replace taking the log of non-positive values in expr<sub>1</sub>, and prevents exceptions being thrown in this case.</p>
<p>Example: log(density)</p>
<p>Example: log(u, -1e38)</p>
</td>
</tr>
<tr>
<td width="20%"><p>lt</p>
</td>
<td width="25%"><p>Less than</p>
</td>
<td width="54%"><p>lt(expr<sub>1</sub>, expr<sub>2</sub>)</p>
<p>The le expression returns a value of 1 (true) if expr<sub>1</sub> &lt; expr<sub>2</sub>. Both input expressions must be scalar expressions.</p>
<p>Example: if(lt(pressure, density), 1.0, 0.0)</p>
</td>
</tr>
<tr>
<td width="20%"><p>magnitude</p>
</td>
<td width="25%"><p>Vector magnitude</p>
</td>
<td width="54%"><p>magnitude(expr)</p>
<p>expr can be a database variable, constant, or other vector expression. The magnitude expression computes the magnitude of the vector and returns a scalar expression.</p>
<p>Example: magnitude(vector1)</p>
</td>
</tr>
<tr>
<td width="20%"><p>materror</p>
</td>
<td width="25%"><p>Material error</p>
</td>
<td width="54%"><p>materror(expr<sub>1</sub>, expr<sub>2</sub>)</p>
<p>expr<sub>1</sub> must be an expression that evaluates to a material. expr<sub>2</sub> must be an identifier for the name of a material, which can be either numeric or a string constant matching the name of a material in the database. The materror expression computes the difference between the volume fractions stored in the database and those that were used by VisIt's material reconstruction algorithm.</p>
<p>Example: materror(mat1, 1)</p>
</td>
</tr>
<tr>
<td width="20%"><p>matvf</p>
</td>
<td width="25%"><p>Material volume fraction</p>
</td>
<td width="54%"><p>matvf(expr<sub>1</sub>, expr<sub>2</sub>)</p>
<p>expr<sub>1</sub> must be an expression that evaluates to a material. expr<sub>2</sub> must be an identifier for the name of a material, which can either be numeric or can be a string constant matching the name of a material in the database. The matvf expression extracts the material volume fractions from a material for a specified material name and returns the results in a scalar expression.</p>
<p>Examples:</p>
<p>percent_chrome = matvf(mat1, "2 chrome")</p>
<p>percent_1 = matvf(Material, 1)</p>
</td>
</tr>
<tr>
<td width="20%"><p>max_edge_length</p>
</td>
<td width="25%"><p>Maximum edge length</p>
</td>
<td width="54%"><p>max_edge_length(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The max_edge_length expression calculates the edge length for each edge in a cell, assigning the length of the longest edge to the entire cell. </p>
<p>Example: max_edge_length(hydro_mesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>max_side_volume</p>
</td>
<td width="25%"><p>Maximum side volume</p>
</td>
<td width="54%"><p>max_side_volume(expr)</p>
<p>expr must be an expression that evaluates to a three-dimensional mesh. The max_side_volume expression calculates the side volume for each side in a cell, assigning the value of the biggest side volume to the entire cell.  A "side" is a tetrahedron that covers one edge of a cell plus parts of the surrounding faces.When a cell has negative side volume, it is usually twisted.</p>
<p>Example: max_side_volume(hydro_mesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>mean</p>
</td>
<td width="25%"><p>Mean average</p>
</td>
<td width="54%"><p>mean(expr)</p>
<p>expr must evaluate to a scalar expression. The mean expression calculates the mean average of a scalar field.  The mean is calculated using the value and its immediate neighbors.  The mean expression only considers the value and its 26 neighbors in three dimensions, or just the eight neighbors in two dimensions.  <i>This expression only works on structured meshes</i>.</p>
<p>Example: mean(intensity)</p>
</td>
</tr>
<tr>
<td width="20%"><p>median</p>
</td>
<td width="25%"><p>Median</p>
</td>
<td width="54%"><p>median(expr)</p>
<p>expr must evaluate to a scalar expression. The median expression Calculates the median of a scalar field.  The median is calculated using the value and its immediate neighbors.  The median expression only considers the value and its 26 neighbors in three dimensions, or just the eight neighbors in two dimensions.  <i>This expression only works on structured meshes</i>.</p>
<p>Example: median(intensity)</p>
</td>
</tr>
<tr>
<td width="20%"><p>min_edge_length</p>
</td>
<td width="25%"><p>Minimum edge length</p>
</td>
<td width="54%"><p>min_edge_length(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The min_edge_length expression calculates the edge length for each edge in a cell, assigning the length of the smallest edge to the entire cell. </p>
<p>Example: min_edge_length(hydro_mesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>min_side_volume</p>
</td>
<td width="25%"><p>Minimum side volume</p>
</td>
<td width="54%"><p>min_side_volume(expr)</p>
<p>expr must be an expression that evaluates to a three-dimensional mesh. The min_side_volume expression calculates the side volume for each side in a cell, assigning the value of the smallest side volume to the entire cell.  A "side" is a tetrahedron that covers one edge of a cell plus parts of the surrounding faces. When a cell has negative side volume, it is usually twisted.</p>
<p>Example: max_side_volume(hydro_mesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>mirvf</p>
</td>
<td width="25%"><p>Material interface reconstruction volume fraction</p>
</td>
<td width="54%"><p>mirvf(expr<sub>1</sub>, expr<sub>2</sub>, expr<sub>3</sub>, expr<sub>4</sub>)</p>
<p>expr<sub>1</sub> must be an expression that evaluates to a material. expr<sub>2</sub> must be an expression that evaluates to a scalar field containing the zone id's for the mesh. expr<sub>3</sub> must be an expression variable that evaluates to a scalar field containing the volumes or areas of each cell in the mesh. expr<sub>4</sub> must be an expression that evaluates to a list of material names or numbers.</p>
<p>The mirvf expression returns the volume fractions computed by VisIt's material interface reconstruction algorithm. The volume fractions computed by VisIt's material interface reconstruction algorithm do not always match what is stored in the database because VisIt's algorithm strives to maintain continuous interfaces rather than accuracy.</p>
<p>Example: mirvf(mat1, zoneid(curvmesh2d), area(curvmesh2d), [1])</p>
</td>
</tr>
<tr>
<td width="20%"><p>mod</p>
</td>
<td width="25%"><p>Modulo</p>
</td>
<td width="54%"><p>mod(expr<sub>1</sub>, expr<sub>2</sub>)</p>
<p>expr<sub>1</sub> and expr<sub>2</sub> must be expressions that evaluate to integer scalar fields. The mod expression calculates expr<sub>1</sub> modulo expr<sub>2</sub>. This expression is typically used in conjunction with the expressions ceil, floor, or round.</p>
<p>Example: mod(var1, var2)</p>
</td>
</tr>
<tr>
<td width="20%"><p>neighbor</p>
</td>
<td width="25%"><p>Neighbor</p>
</td>
<td width="54%"><p>neighbor(expr)</p>
<p>expr must be an expression that evaluates to a mesh. Neighbor creates a node-centered scalar on a point mesh representation of the original mesh.</p>
<p>Expression: neighbor(hydro_mesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>nmats</p>
</td>
<td width="25%"><p>Number of materials</p>
</td>
<td width="54%"><p>nmats(expr)</p>
<p>expr must be an expression that evaluates to a material. The nmats expression creates a cell-centered scalar variable containing the number of materials in each cell. This expression can be used with the Threshold operator to remove cells that do not have a desired number of materials.</p>
<p>Example: nmats(material)</p>
</td>
</tr>
<tr>
<td width="20%"><p>node_degree</p>
</td>
<td width="25%"><p>Node degree</p>
</td>
<td width="54%"><p>node_degree(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The node_degree expression calculates how many edges each node it part of and stores that value as a node-centered scalar expression.</p>
<p>Example: node_degree(MESH)</p>
</td>
</tr>
<tr>
<td width="20%"><p>nodeid</p>
</td>
<td width="25%"><p>Node number</p>
</td>
<td width="54%"><p>nodeid(expr)</p>
<p>expr can be any expression that involves a single mesh. The nodeid expression creates a node-centered scalar field containing the node index of each mode in the mesh. The nodeid expression's primary use is in debugging VisIt plots.</p>
<p>Example: nodeid(MESH)</p>
</td>
</tr>
<tr>
<td width="20%"><p>not</p>
</td>
<td width="25%"><p>Logical not</p>
</td>
<td width="54%"><p>not(expr)</p>
<p>expr must be a database variable, constant, or other scalar expression. The not expression returns 1 (true) if the input expression equals zero and zero otherwise.</p>
<p>Expression: outside = not(inside)</p>
</td>
</tr>
<tr>
<td width="20%"><p>notequal, notequals. ne</p>
</td>
<td width="25%"><p>Not equal</p>
</td>
<td width="54%"><p>notequal(expr<sub>1</sub>, expr<sub>2</sub>)</p>
<p>The notequal expression returns 1 (true) if expr<sub>1</sub> != expr<sub>2</sub> and zero otherwise. Both expr<sub>1</sub> and expr<sub>2</sub> must be scalar expressions.</p>
<p>Example: if(notequal(mass, 12.3), 1, 0)</p>
</td>
</tr>
<tr>
<td width="20%"><p>oddy</p>
</td>
<td width="25%"><p>General distortion measure</p>
</td>
<td width="54%"><p>oddy(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The oddy expression calculates a general distortion measure based on the left Cauchy-Green tensor.</p>
<p>Example: oddy(MESH)</p>
</td>
</tr>
<tr>
<td width="20%"><p>or</p>
</td>
<td width="25%"><p>Logical or</p>
</td>
<td width="54%"><p>or(expr<sub>1</sub>, expr<sub>2</sub>)</p>
<p>The logical or expression returns a value of 1 (true) either of the scalar input expressions expr<sub>1</sub> and expr<sub>2</sub> are not equal to zero. If both input expressions are equal to zero then the expression returns zero. The logical or expression is often used with other conditionals such as the if expression.</p>
<p>Example: if(or(lt(pressure, 2.0), gt(pressure, 4.0)), pressure, 0.0)</p>
<p>Meaning: if pressure is in the range (,2.0) or (4.0, ) then use the value for pressure. Otherwise, use zero.</p>
</td>
</tr>
<tr>
<td width="20%"><p>polar</p>
</td>
<td width="25%"><p>Convert to polar coordinates</p>
</td>
<td width="54%"><p>polar(expr)</p>
<p>expr must be a database variable, constant, or other vector expression. The polar expression converts a vector, which is assumed to represent cartesian coordinates (x, y, z), into polar coordinates (r, theta, phi).</p>
<p>Example: vec = polar(coord(MESH))</p>
</td>
</tr>
<tr>
<td width="20%"><p>polar_phi</p>
</td>
<td width="25%"><p>Phi component of polar coordinate representation of mesh.</p>
</td>
<td width="54%"><p>polar_phi(expr)</p>
<p>expr must evaluate to a mesh. The polar_phi expression converts the coordinates of the input mesh from cartesian coordinates to polar coordinates and then returns the phi component of the cylindrical coordinates.</p>
<p>Example: polar_phi(hydro_mesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>polar_radius</p>
</td>
<td width="25%"><p>Radius component of polar coordinate representation of mesh.</p>
</td>
<td width="54%"><p>polar_radius(expr)</p>
<p>expr must evaluate to a mesh. The polar_radius expression converts the coordinates of the input mesh from cartesian coordinates to polar coordinates and then returns the radius component of the cylindrical coordinates.</p>
<p>Example: polar_radius(hydro_mesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>polar_theta</p>
</td>
<td width="25%"><p>Theta component of polar coordinate representation of mesh.</p>
</td>
<td width="54%"><p>polar_theta(expr)</p>
<p>expr must evaluate to a mesh. The polar_theta expression converts the coordinates of the input mesh from cartesian coordinates to polar coordinates and then returns the theta component of the cylindrical coordinates.</p>
<p>Example: polar_theta(hydro_mesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>principal_deviatoric_tensor</p>
</td>
<td width="25%"><p>Principal deviatoric vector of tensor</p>
</td>
<td width="54%"><p>principal_deviatoric_tensor(expr)</p>
<p>expr can be a database variable, constant, or other 3x3 tensor expression. The principal_tensor computes the deviatoric principals of a tensor, which result in a vector expression.</p>
<p>Example: principal_deviatoric_tensor(tensor1)</p>
</td>
</tr>
<tr>
<td width="20%"><p>principal_tensor</p>
</td>
<td width="25%"><p>Principals of tensor</p>
</td>
<td width="54%"><p>principal_tensor(expr)</p>
<p>expr can be a database variable, constant, or other 3x3 tensor expression. The principal_tensor computes the principals of a tensor, which result in a vector expression.</p>
<p>Example: principal_tensor(tensor1)</p>
</td>
</tr>
<tr>
<td width="20%"><p>procid</p>
</td>
<td width="25%"><p>Processor ID</p>
</td>
<td width="54%"><p>procid(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The procid expression returns the processor id of the compute engine that is handling the current domain of the specified mesh.</p>
<p>Example: pid = procid(MESH)</p>
</td>
</tr>
<tr>
<td width="20%"><p>rad2deg</p>
</td>
<td width="25%"><p>Radians to degrees</p>
</td>
<td width="54%"><p>rad2deg(expr)</p>
<p>The rad2deg expression converts the input scalar expression, which is assumed to be in radians, to degrees.</p>
<p>Example: angle_deg = rad2deg(angle)</p>
</td>
</tr>
<tr>
<td width="20%"><p>random, rand</p>
</td>
<td width="25%"><p>Random number</p>
</td>
<td width="54%"><p>random(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The random expression creates a scalar field over the specified mesh where each node in the mesh gets a different random number in the range: [0,1].</p>
<p>Expression random(MESH)</p>
</td>
</tr>
<tr>
<td width="20%"><p>recenter</p>
</td>
<td width="25%"><p>Recenter variable</p>
</td>
<td width="54%"><p>recenter(expr)</p>
<p>expr must be a database variable or other expression that eventually involves a database variable. Two common types of variable centering are cell-centered and node-centered. The recenter expression switches the centering for the input expression. Use the recenter expression to explicitly force a specific variable centering or to make another varia</p>
<p>Expression: density + recenter(temp)</p>
</td>
</tr>
<tr>
<td width="20%"><p>relative_difference</p>
</td>
<td width="25%"><p>Relative difference</p>
</td>
<td width="54%"><p>relative_difference(expr<sub>1</sub>, expr<sub>2</sub>)</p>
<p>The relative_difference expression computes the relative difference between two scalar expressions using the following formula:</p>
<p>if (A == B && A == 0) then 0.</p>
<p>else (A-B) / (abs(A) + abs(B))</p>
<p>Example: relative_difference(x,y)</p>
</td>
</tr>
<tr>
<td width="20%"><p>relative_size</p>
</td>
<td width="25%"><p>Relative cell size</p>
</td>
<td width="54%"><p>relative_size(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The relative_size calculates the relative size of cells in the mesh by finding the minimum value of J or 1/J where J is the determinant of a weighted Jacobian matrix.</p>
<p>Example: relative_size(MESH)</p>
</td>
</tr>
<tr>
<td width="20%"><p>revolved_surface_area</p>
</td>
<td width="25%"><p>Revolved surface area</p>
</td>
<td width="54%"><p>revolved_surface_area(expr)</p>
<p>expr must be an expression that evaluates to a 2D mesh. The revolved_surface_area expression revolves triangle and quad cells about the X-axis and calculates the surface area of the revolved cell. The result is a cell-centered scalar expression.</p>
<p>Example: revolved_surface_area(mesh2d)</p>
</td>
</tr>
<tr>
<td width="20%"><p>revolved_volume</p>
</td>
<td width="25%"><p>Revolved cell volume</p>
</td>
<td width="54%"><p>revolved_volume(expr)</p>
<p>expr must be an expression that evaluates to a 2D mesh. The revolved_volume expression calculates the volume of a triangle or quad cell revolved about the X-axis. The result is a cell-centered scalar expression.</p>
<p>Example: vol = revolved_volume(mesh2d)</p>
</td>
</tr>
<tr>
<td width="20%"><p>round</p>
</td>
<td width="25%"><p>Round</p>
</td>
<td width="54%"><p>round(expr)</p>
<p>expr must be an expression that evaluates to a scalar expression. The round expression rounds the value of its expression argument to the nearest integer value.  If two integers are equally close then the round expression rounds up. For example, 8.5 gets rounded up to 9.</p>
<p>Example: round(pressure)</p>
</td>
</tr>
<tr>
<td width="20%"><p>scaled_jacobian</p>
</td>
<td width="25%"><p>Scaled jacobian</p>
</td>
<td width="54%"><p>scaled_jacobian(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The scaled jacobian expression calculates a scalar expression based on the minimum of the Jacobian divided by the lengths of a cell's edge vectors.</p>
<p>Example: scaled_jacobian(MESH)</p>
</td>
</tr>
<tr>
<td width="20%"><p>shape</p>
</td>
<td width="25%"><p>Cell shape</p>
</td>
<td width="54%"><p>shape(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The shape expression calculates 2 divided by the condition number of the weighted Jacobian matrix.</p>
<p>Example: shape(MESH)</p>
</td>
</tr>
<tr>
<td width="20%"><p>shape_and_size</p>
</td>
<td width="25%"><p>Cell shape and size</p>
</td>
<td width="54%"><p>shape_and_size(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The shape_and_size expression calculates the shape and size expressions and multiplies their values.</p>
<p>Example: shape_and_size(MESH)</p>
</td>
</tr>
<tr>
<td width="20%"><p>shear</p>
</td>
<td width="25%"><p>Shear</p>
</td>
<td width="54%"><p>shear(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The shear expression calculates mesh shear and results in a scalar expression.</p>
<p>Example: shear(MESH)</p>
</td>
</tr>
<tr>
<td width="20%"><p>sin</p>
</td>
<td width="25%"><p>Sine</p>
</td>
<td width="54%"><p>sin(expr)</p>
<p>Compute the sine of an angle in radians. Expr can be an expression of database variables, constants, or other scalar expression that evaluate to an angle in radians. The sin expression returns a scalar expression.</p>
<p>Example: y= radius * sin(angle)</p>
</td>
</tr>
<tr>
<td width="20%"><p>sinh</p>
</td>
<td width="25%"><p>Hyperbolic Sine</p>
</td>
<td width="54%"><p>sinh(expr)</p>
<p>Compute the hyperbolic sine of an angle in radians. Expr can be an expression of database variables, constants, or other scalar expression that evaluate to an angle in radians. The sinh expression returns a scalar expression.</p>
<p>Example: y= radius * sinh(angle)</p>
</td>
</tr>
<tr>
<td width="20%"><p>skew</p>
</td>
<td width="25%"><p>Mesh skew</p>
</td>
<td width="54%"><p>skew(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The skew expression calculates the skew for each cell in the mesh and stores the result in a cell-centered scalar expression. The skew is the maximum |cosA| where A is the angle between the edges at the cell center. Cells with high skew are generally created in error.</p>
<p>Example: skew(MESH)</p>
</td>
</tr>
<tr>
<td width="20%"><p>smallest_angle</p>
</td>
<td width="25%"><p>Smallest angle</p>
</td>
<td width="54%"><p>smallest_angle(expr)</p>
<p>expr must be an expression that evaluates to a 2D mesh. The smallest_angle expression calculates a cell-centered scalar field containing the value of the smallest interior angle in degrees. Only triangle and quadrilateral cells are considered.</p>
<p>Example: smallest_angle(hydro_mesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>specmf</p>
</td>
<td width="25%"><p>Species mass fraction</p>
</td>
<td width="54%"><p>specmf(expr<sub>1</sub>, expr<sub>2</sub>, expr<sub>3 </sub>[, expr<sub>4</sub>])</p>
<p>The specmf expression extracts the mass fractions for a material species from a species variable and returns a mesh-sized scalar field that can be used in other expressions or plotted.</p>
<p>expr<sub>1</sub> must a species variable; the default name for a species variable is: Species. expr<sub>2</sub> must be a single material number or material name. expr<sub>3</sub> must be a single species name or number or list of species names or numbers for the given material. Lists of species are enclosed in square brackets [] and are comma-separated. The expr<sub>4</sub> argument is optional and is a boolean value that weights the species masses by the material volume fraction if it is set to true. When expr<sub>4</sub> is not provided, its value is assumed to be false.</p>
<p>Example: specmf(Species, "Air", "Argon")</p>
</td>
</tr>
<tr>
<td width="20%"><p>sq, sqr</p>
</td>
<td width="25%"><p>Square</p>
</td>
<td width="54%"><p>sqr(expr)</p>
<p>expr can be a database variable, constant, or other scalar expression. The sqr expression multiplies the input values by themselves, squaring them.</p>
<p>Example: x_times_x = sqr(x)</p>
</td>
</tr>
<tr>
<td width="20%"><p>sqrt</p>
</td>
<td width="25%"><p>Square root</p>
</td>
<td width="54%"><p>sqrt(expr)</p>
<p>expr can be a database variable, constant, or another scalar expression. The sqrt expression computes the square root of the input expression.</p>
<p>Example: dist = sqrt(x*x + y*y + z*z)</p>
</td>
</tr>
<tr>
<td width="20%"><p>stretch</p>
</td>
<td width="25%"><p>Cell stretch</p>
</td>
<td width="54%"><p>stretch(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The stretch expression calculates the square root of 3 times the minimum edge length divided by the maximum diagonal length. Stretch is only calculated for hex and quad cells.</p>
<p>Example: stretch(HexMesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>surface_normal</p>
</td>
<td width="25%"><p>Surface normal</p>
</td>
<td width="54%"><p>surface_normal(expr)</p>
<p>Calculates the direction normal to each vertex.  This incorporates the normal directions of each face a vertex is incident to. Expr must be a mesh that is a three dimensional surface. Note that you will have to apply the ExternalSurface operator and the DeferExpression operator in order for the surface_normal expression to be evaluated on the plot as it is displayed in the visualization window.</p>
<p>Example: surface_normal(surface_mesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>tan</p>
</td>
<td width="25%"><p>Tangent</p>
</td>
<td width="54%"><p>tan(expr)</p>
<p>Compute the tangent of an angle in radians. Expr can be an expression of database variables, constants, or other scalar expression that evaluate to an angle in radians. The tan expression returns a scalar expression.</p>
<p>Example: y = radius * tan(angle)</p>
</td>
</tr>
<tr>
<td width="20%"><p>tanh</p>
</td>
<td width="25%"><p>Hyperbolic Tangent</p>
</td>
<td width="54%"><p>tanh(expr)</p>
<p>Compute the hyperbolic tangent of an angle in radians. Expr can be an expression of database variables, constants, or other scalar expression that evaluate to an angle in radians. The tanh expression returns a scalar expression.</p>
<p>Example: y = radius * tanh(angle)</p>
</td>
</tr>
<tr>
<td width="20%"><p>taper</p>
</td>
<td width="25%"><p>Mesh taper</p>
</td>
<td width="54%"><p>taper(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The taper expression calculates cell taper, which is the maximum ratio of lengths derived from opposite edges. Taper is only calculated for hex and quad cells.</p>
<p>Example: taper(MESH)</p>
</td>
</tr>
<tr>
<td width="20%"><p>tensor_maximum_shear</p>
</td>
<td width="25%"><p>Maximum tensor shear</p>
</td>
<td width="54%"><p>tensor_maximum_shear(expr)</p>
<p>expr can be a database variable, constant, or other 3x3 tensor expression. The result is a scalar expression.</p>
<p>Example: tensor_maximum_shear(tensor)</p>
</td>
</tr>
<tr>
<td width="20%"><p>trace</p>
</td>
<td width="25%"><p>Trace of tensor</p>
</td>
<td width="54%"><p>trace(expr)</p>
<p>Expr can be an expression of database variables, constants, or other tensor expressions. The trace expression calculates the trace of a 3x3 tensor, which is the sum of the diagonal components. The result is a scalar expression.</p>
<p>Example: trace_times_3 = trace(tensor) * 3.0</p>
</td>
</tr>
<tr>
<td width="20%"><p>var_skew</p>
</td>
<td width="25%"><p>Apply skew scaling</p>
</td>
<td width="54%"><p>var_skew(expr<sub>1</sub>, expr<sub>2</sub>)</p>
<p>Both expr<sub>1</sub> and expr<sub>2</sub> must evaluate to scalar expressions. More commonly, expr<sub>2</sub> is a floating point constant indicating the skew factor to be used in the calculation. The var_skew expression applies skew scaling, as performed in the Pseudocolor plot, to the input data. Skew scaling can be used to highlight either small values or large values, depending on the skew factor that you provide.</p>
<p>Expression: var_skew(density)</p>
</td>
</tr>
<tr>
<td width="20%"><p>volume</p>
</td>
<td width="25%"><p>Cell volume</p>
</td>
<td width="54%"><p>volume(expr)</p>
<p>expr must be an expression that evaluates to a 3D mesh or database variable. The volume expression calculates the volume of each cell in the mesh and creates a cell-centered scalar expression containing those values. Volumes of 2D meshes are zero.</p>
<p>Example: volume(ucdmesh)</p>
<p>volume2(expr) is an alternate form that matches the DYNA engineering code. Only hexahedral volumes are calculated differently. This form of the expression is only available in the GUI as a write-in, not from the function drop-down. It is also available through the CLI.</p>
</td>
</tr>
<tr>
<td width="20%"><p>warpage</p>
</td>
<td width="25%"><p>Cell warpage</p>
</td>
<td width="54%"><p>warpage(expr)</p>
<p>expr must be an expression that evaluates to a mesh. The warpage expression calculates how much quad cells deviate from a plane. Warpage is only calculated for quad cells.</p>
<p>Example: warpage(quadmesh)</p>
</td>
</tr>
<tr>
<td width="20%"><p>zoneid</p>
</td>
<td width="25%"><p>Zone number</p>
</td>
<td width="54%"><p>zoneid(expr)</p>
<p>expr can be any expression involving a single mesh. The zoneid expression creates a zone-centered scalar field for the mesh used by the input expression. The zoneid expression is primarily used to debug new VisIt components such as plot plugins or database reader plugins.</p>
<p>Example: zoneid(density)</p>
</td>
</tr>
</tr>
</table>
</body>
</html>

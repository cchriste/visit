/*****************************************************************************
*
* Copyright (c) 2000 - 2009, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-400124
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

#include "QvisPoincarePlotWindow.h"

#include <PoincareAttributes.h>
#include <ViewerProxy.h>

#include <qcheckbox.h>
#include <qcombobox.h>
#include <qlabel.h>
#include <qlayout.h>
#include <qlineedit.h>
#include <qspinbox.h>
#include <qvbox.h>
#include <qbuttongroup.h>
#include <qradiobutton.h>
#include <qtabwidget.h>
#include <QvisColorTableButton.h>
#include <QvisOpacitySlider.h>
#include <QvisColorButton.h>
#include <QvisLineStyleWidget.h>
#include <QvisLineWidthWidget.h>
#include <QvisVariableButton.h>

#include <stdio.h>
#include <string>

using std::string;

// ****************************************************************************
// Method: QvisPoincarePlotWindow::QvisPoincarePlotWindow
//
// Purpose: 
//   Constructor
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

QvisPoincarePlotWindow::QvisPoincarePlotWindow(const int type,
                         PoincareAttributes *subj,
                         const QString &caption,
                         const QString &shortName,
                         QvisNotepadArea *notepad)
    : QvisPostableWindowObserver(subj, caption, shortName, notepad)
{
    plotType = type;
    atts = subj;
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::~QvisPoincarePlotWindow
//
// Purpose: 
//   Destructor
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

QvisPoincarePlotWindow::~QvisPoincarePlotWindow()
{
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::CreateWindowContents
//
// Purpose: 
//   Creates the widgets for the window.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//    Jeremy Meredith, Tue Apr 14 16:16:56 EDT 2009
//    Reworked and reorganized to make more usable.
//
//    Dave Pugmire, Fri Apr 17 11:32:40 EDT 2009
//    GUI reorganization.
//
//    Dave Pugmire, Tue Apr 28 09:26:06 EDT 2009
//    GUI reorganization.
//
//    Dave Pugmire, Tue Aug 11 10:33:05 EDT 2009
//    Add number of intersections termination criterion
//   
// ****************************************************************************

void
QvisPoincarePlotWindow::CreateWindowContents()
{
    QGridLayout *mainLayout = new QGridLayout(topLayout, 1,1,  10, "mainLayout");

    QTabWidget *tabs = new QTabWidget(central, "tabs");
    mainLayout->addMultiCellWidget(tabs, 1,1, 1,1);
    int row;

    // tab for source options
    QFrame *streamlineTab = new QFrame(tabs);
    QGridLayout *streamlineLayout = new QGridLayout(streamlineTab, 30, 2, 5);
    tabs->addTab(streamlineTab, "Streamlines");
    row = 0;

    terminationLabel = new QLabel(tr("Termination Criterion"), streamlineTab, "terminationLabel");
    streamlineLayout->addWidget(terminationLabel,row,0);
    row++;

    terminationType = new QComboBox(streamlineTab, "terminationType");
    terminationType->insertItem(tr("Distance"));
    terminationType->insertItem(tr("Time"));
    terminationType->insertItem(tr("Number of Steps"));
    terminationType->insertItem(tr("Number of Punctures"));
    connect(terminationType, SIGNAL(activated(int)),
            this, SLOT(terminationTypeChanged(int)));
    streamlineLayout->addWidget(terminationType, row,0);    

    termination = new QLineEdit(streamlineTab, "termination");
    connect(termination, SIGNAL(returnPressed()),
            this, SLOT(terminationProcessText()));
    streamlineLayout->addWidget(termination,row,1);
    row++;

    // Create the source type combo box.
    sourceTypeLabel = new QLabel(tr("Streamline Source"), streamlineTab, "sourceTypeLabel");
    streamlineLayout->addWidget(sourceTypeLabel,row,0);

    sourceType = new QComboBox(streamlineTab, "sourceType");
    sourceType->insertItem(tr("Point"));
    sourceType->insertItem(tr("Line"));
    sourceType->insertItem(tr("Plane"));
    connect(sourceType, SIGNAL(activated(int)),
            this, SLOT(sourceTypeChanged(int)));
    streamlineLayout->addWidget(sourceType, row,1);
    row++;

    // Create a group box for the source attributes.
    QGroupBox *pageSource = new QGroupBox(streamlineTab, "pageSource");
    sourceAtts = pageSource;
    sourceAtts->setTitle(tr("Point"));
    streamlineLayout->addMultiCellWidget(pageSource, row,row, 0,1);
    QVBoxLayout *svLayout = new QVBoxLayout(pageSource, 10, 2);
    svLayout->addSpacing(10);
    QGridLayout *sLayout = new QGridLayout(svLayout, 16, 2);
    sLayout->setMargin(10);
    row++;

    // Create the widgets that specify a point source.
    pointSource = new QLineEdit(pageSource, "pointSource");
    connect(pointSource, SIGNAL(returnPressed()),
            this, SLOT(pointSourceProcessText()));
    pointSourceLabel = new QLabel(pointSource, tr("Location"), pageSource, "pointSourceLabel");
    sLayout->addWidget(pointSourceLabel, 3, 0);
    sLayout->addWidget(pointSource, 3,1);

    // Create the widgets that specify a line source.
    lineStart = new QLineEdit(pageSource, "lineStart");
    connect(lineStart, SIGNAL(returnPressed()),
            this, SLOT(lineStartProcessText()));
    lineStartLabel = new QLabel(lineStart, tr("Start"), pageSource, "lineStartLabel");
    sLayout->addWidget(lineStartLabel,4,0);
    sLayout->addWidget(lineStart, 4,1);

    lineEnd = new QLineEdit(pageSource, "lineEnd");
    connect(lineEnd, SIGNAL(returnPressed()),
            this, SLOT(lineEndProcessText()));
    lineEndLabel = new QLabel(lineEnd, tr("End"), pageSource, "lineEndLabel");
    sLayout->addWidget(lineEndLabel,5,0);
    sLayout->addWidget(lineEnd, 5,1);

    // Create the widgets that specify a plane source.
    planeOrigin = new QLineEdit(pageSource, "planeOrigin");
    connect(planeOrigin, SIGNAL(returnPressed()),
            this, SLOT(planeOriginProcessText()));
    planeOriginLabel = new QLabel(planeOrigin, tr("Origin"), pageSource, "planeOriginLabel");
    sLayout->addWidget(planeOriginLabel,6,0);
    sLayout->addWidget(planeOrigin, 6,1);

    planeNormal = new QLineEdit(pageSource, "planeNormal");
    connect(planeNormal, SIGNAL(returnPressed()),
            this, SLOT(planeNormalProcessText()));
    planeNormalLabel = new QLabel(planeNormal, tr("Normal"), pageSource, "planeNormalLabel");
    sLayout->addWidget(planeNormalLabel,7,0);
    sLayout->addWidget(planeNormal, 7,1);

    planeUpAxis = new QLineEdit(pageSource, "planeUpAxis");
    connect(planeUpAxis, SIGNAL(returnPressed()),
            this, SLOT(planeUpAxisProcessText()));
    planeUpAxisLabel = new QLabel(planeUpAxis, tr("Up axis"), pageSource, "planeUpAxisLabel");
    sLayout->addWidget(planeUpAxisLabel,8,0);
    sLayout->addWidget(planeUpAxis, 8,1);

    planeRadius = new QLineEdit(pageSource, "planeRadius");
    connect(planeRadius, SIGNAL(returnPressed()),
            this, SLOT(planeRadiusProcessText()));
    planeRadiusLabel = new QLabel(planeRadius, tr("Radius"), pageSource, "planeRadiusLabel");
    sLayout->addWidget(planeRadiusLabel,9,0);
    sLayout->addWidget(planeRadius, 9,1);

    row++;

    pointDensityLabel = new QLabel(tr("Point density"), streamlineTab, "pointDensityLabel");
    streamlineLayout->addWidget(pointDensityLabel,row,0);
    pointDensity = new QSpinBox(2, 1000, 1, streamlineTab, "pointDensity");
    connect(pointDensity, SIGNAL(valueChanged(int)), 
            this, SLOT(pointDensityChanged(int)));
    streamlineLayout->addWidget(pointDensity,row,1);
    row++;

    // Create a group box for the intersect plane attributes.
    QGroupBox *intPlnGrp = new QGroupBox(streamlineTab, "intPlnGrp");
    //sourceAtts = intPlnGrp;
    intPlnGrp->setTitle(tr("Intersect Plane"));
    streamlineLayout->addMultiCellWidget(intPlnGrp, row,row, 0,1);
    QVBoxLayout *intPlnLayout = new QVBoxLayout(intPlnGrp, 10, 2);
    intPlnLayout->addSpacing(10);
    QGridLayout *intPlnGridLayout = new QGridLayout(intPlnLayout, 16, 2);
    intPlnGridLayout->setMargin(10);
    row++;

    // Create the widgets that specify a point source.
    intPlnLocation = new QLineEdit(intPlnGrp, "intPlnLocation");
    intPlnNormal = new QLineEdit(intPlnGrp, "intPlnNormal");
    connect(intPlnLocation, SIGNAL(returnPressed()),
            this, SLOT(intersectPlanePointSourceProcessText()));
    connect(intPlnNormal, SIGNAL(returnPressed()),
            this, SLOT(intersectPlaneNormalSourceProcessText()));
    
    intPlnLocationLabel = new QLabel(intPlnLocation, tr("Origin"), intPlnGrp, "intPlnLocationLabel");
    intPlnNormalLabel = new QLabel(intPlnNormal, tr("Normal"), intPlnGrp, "intPlnNormalLabel");
    intPlnGridLayout->addWidget(intPlnLocationLabel, 3, 0);
    intPlnGridLayout->addWidget(intPlnLocation, 3,1);
    intPlnGridLayout->addWidget(intPlnNormalLabel, 4, 0);
    intPlnGridLayout->addWidget(intPlnNormal, 4,1);

    integrationTypeLabel = new QLabel(tr("Integrator"), streamlineTab, "integrationTypeLabel");
    streamlineLayout->addWidget(integrationTypeLabel,row,0);
    integrationType = new QComboBox(streamlineTab, "integrationType");
    integrationType->insertItem(tr("Dormand-Prince (Runge-Kutta)"));
    integrationType->insertItem(tr("Adams-Bashforth (Multi-step)"));
    connect(integrationType, SIGNAL(activated(int)),
            this, SLOT(integrationTypeChanged(int)));
    streamlineLayout->addWidget(integrationType,row,1);
    row++;

    maxStepLengthLabel = new QLabel(tr("Maximum step length"), streamlineTab, "maxStepLengthLabel");
    streamlineLayout->addWidget(maxStepLengthLabel,row,0);
    maxStepLength = new QLineEdit(streamlineTab, "maxStepLength");
    connect(maxStepLength, SIGNAL(returnPressed()),
            this, SLOT(maxStepLengthProcessText()));
    streamlineLayout->addWidget(maxStepLength,row,1);
    row++;

    relTolLabel = new QLabel(tr("Relative tolerance"), streamlineTab, "relTolLabel");
    streamlineLayout->addWidget(relTolLabel,row,0);
    relTol = new QLineEdit(streamlineTab, "relTol");
    connect(relTol, SIGNAL(returnPressed()),
            this, SLOT(relTolProcessText()));
    streamlineLayout->addWidget(relTol,row,1);
    row++;

    absTolLabel = new QLabel(tr("Absolute tolerance"), streamlineTab, "absTolLabel");
    streamlineLayout->addWidget(absTolLabel,row,0);
    absTol = new QLineEdit(streamlineTab, "absTol");
    connect(absTol, SIGNAL(returnPressed()),
            this, SLOT(absTolProcessText()));
    streamlineLayout->addWidget(absTol,row,1);
    row++;

    // tab for analysis options
    QFrame *analysisTab = new QFrame(tabs);
    QGridLayout *analysisLayout = new QGridLayout(analysisTab, 30, 2, 5);
    tabs->addTab(analysisTab, "Analysis");
    row = 0;

    MaxToroidalWindingLabel = new QLabel(tr("Max toroidal winding"), analysisTab, "MaxToroidalWindingLabel");
    analysisLayout->addWidget(MaxToroidalWindingLabel,row,0);
    MaxToroidalWinding = new QSpinBox(1,10000, 1, analysisTab, "MaxToroidalWinding");
    connect(MaxToroidalWinding, SIGNAL(valueChanged(int)),
            this, SLOT(maxToroidalWindingSizeChanged(int)));
    analysisLayout->addWidget(MaxToroidalWinding,row,1);
    row++;

    OverrideToroidalWindingLabel = new QLabel(tr("OverrideToroidalWinding"), analysisTab, "OverrideToroidalWindingLabel");
    analysisLayout->addWidget(OverrideToroidalWindingLabel,row,0);
    OverrideToroidalWinding = new QLineEdit(analysisTab, "OverrideToroidalWinding");
    connect(OverrideToroidalWinding, SIGNAL(returnPressed()),
            this, SLOT(overrideToroidalWindingProcessText()));
    analysisLayout->addWidget(OverrideToroidalWinding,row,1);
    row++;

    HitRateLabel = new QLabel(tr("HitRate"), analysisTab, "HitRateLabel");
    analysisLayout->addWidget(HitRateLabel,row,0);
    HitRate = new QLineEdit(analysisTab, "HitRate");
    connect(HitRate, SIGNAL(returnPressed()),
            this, SLOT(hitRateProcessText()));
    analysisLayout->addWidget(HitRate,row,1);
    row++;

    AdjustPlaneLabel = new QLabel(tr("AdjustPlane"), analysisTab, "AdjustPlaneLabel");
    analysisLayout->addWidget(AdjustPlaneLabel,row,0);
    AdjustPlane = new QLineEdit(analysisTab, "AdjustPlane");
    connect(AdjustPlane, SIGNAL(returnPressed()),
            this, SLOT(adjustPlaneProcessText()));
    analysisLayout->addWidget(AdjustPlane,row,1);
    row++;

    OverlapsLabel = new QLabel(tr("Overlaps"), analysisTab, "OverlapsLabel");
    analysisLayout->addWidget(OverlapsLabel,row,0);
    Overlaps = new QButtonGroup(analysisTab, "Overlaps");
    Overlaps->setFrameStyle(QFrame::NoFrame);
    QHBoxLayout *OverlapsLayout = new QHBoxLayout(Overlaps);
    OverlapsLayout->setSpacing(10);
    QRadioButton *OverlapsOverlapTypeRaw = new QRadioButton(tr("Raw"), Overlaps);
    OverlapsLayout->addWidget(OverlapsOverlapTypeRaw);
    QRadioButton *OverlapsOverlapTypeRemove = new QRadioButton(tr("Remove"), Overlaps);
    OverlapsLayout->addWidget(OverlapsOverlapTypeRemove);
    QRadioButton *OverlapsOverlapTypeMerge = new QRadioButton(tr("Merge"), Overlaps);
    OverlapsLayout->addWidget(OverlapsOverlapTypeMerge);
    QRadioButton *OverlapsOverlapTypeSmooth = new QRadioButton(tr("Smooth"), Overlaps);
    OverlapsLayout->addWidget(OverlapsOverlapTypeSmooth);
    connect(Overlaps, SIGNAL(clicked(int)),
            this, SLOT(overlapsChanged(int)));
    analysisLayout->addWidget(Overlaps,row,1);
    row++;

    // tab for display options
    QFrame *displayTab = new QFrame(tabs);
    QGridLayout *displayLayout = new QGridLayout(displayTab, 30, 5, 5);
    tabs->addTab(displayTab, "Display");
    row = 0;

    DisplayTypeLabel = new QLabel(tr("Display type"), displayTab, "DisplayTypeLabel");
    displayLayout->addWidget(DisplayTypeLabel,row,0);
    
    DisplayType = new QComboBox(displayTab, "DisplayType");
    DisplayType->insertItem(tr("Curves"),0);
    DisplayType->insertItem(tr("Surfaces"),1);
    connect(DisplayType, SIGNAL(activated(int)),
            this, SLOT(displayTypeChanged(int)));
    displayLayout->addWidget(DisplayType,row,1);
    row++;

    NumberPlanesLabel = new QLabel(tr("Number of planes"), displayTab, "NumberPlanesLabel");
    displayLayout->addWidget(NumberPlanesLabel,row,0);
    NumberPlanes = new QSpinBox(1,10000, 1, displayTab, "NumberPlanes");
    connect(NumberPlanes, SIGNAL(valueChanged(int)),
            this, SLOT(numberPlanesSizeChanged(int)));
    displayLayout->addWidget(NumberPlanes,row,1);
    row++;

    int maxWidth = fontMetrics().width("1.0000000000");
    // Create the max toggle and line edit
    limitsGrp = new QGroupBox(displayTab, "limitsGrp");
    limitsGrp->setTitle(tr("Limits") );
    displayLayout->addMultiCellWidget(limitsGrp, row,row+1,0,2);
    row += 2;

    QVBoxLayout *limitsAVLayout = new QVBoxLayout(limitsGrp);
    limitsAVLayout->setMargin(10);
    limitsAVLayout->addSpacing(15);
    QGridLayout *limitsGLayout = new QGridLayout(limitsAVLayout, 2, 5);
    limitsGLayout->setSpacing(10);
    limitsGLayout->setColStretch(1,10);

    minToggle = new QCheckBox(tr("Min"), limitsGrp, "minToggle");
    limitsGLayout->addWidget(minToggle, 0, 0);
    connect(minToggle, SIGNAL(toggled(bool)),
            this, SLOT(minToggled(bool)));
    minLineEdit = new QLineEdit(limitsGrp, "minLineEdit");
    minLineEdit->setMaximumWidth(maxWidth);

    connect(minLineEdit, SIGNAL(returnPressed()),
            this, SLOT(processMinLimitText())); 
    limitsGLayout->addWidget(minLineEdit, 0, 1);

    maxToggle = new QCheckBox(tr("Max"), limitsGrp, "maxToggle");
    limitsGLayout->addWidget(maxToggle, 0, 2);
    connect(maxToggle, SIGNAL(toggled(bool)),
            this, SLOT(maxToggled(bool)));
    maxLineEdit = new QLineEdit(limitsGrp, "maxLineEdit");
    maxLineEdit->setMaximumWidth(maxWidth);
    connect(maxLineEdit, SIGNAL(returnPressed()),
            this, SLOT(processMaxLimitText())); 
    limitsGLayout->addWidget(maxLineEdit, 0, 3);

    //Coloring options.
    colorGrp = new QGroupBox(displayTab, "colorGrp");
    colorGrp->setTitle(tr("Color options") );
    displayLayout->addWidget(colorGrp, row, 0);
    row++;
    QVBoxLayout *colorVLayout = new QVBoxLayout(colorGrp);
    colorVLayout->setMargin(10);
    colorVLayout->addSpacing(15);

    colorModeButtons = new QButtonGroup(0, "colorModeButtons");
    connect(colorModeButtons, SIGNAL(clicked(int)),
            this, SLOT(colorModeChanged(int)));

    QGridLayout *colorGLayout = new QGridLayout(colorVLayout, 5, 2);
    colorGLayout->setSpacing(10);
    colorGLayout->setColStretch(2, 1000);

    QRadioButton *rb = new QRadioButton(tr("Single"), colorGrp, "singleColor");
    colorModeButtons->insert(rb);
    colorGLayout->addWidget(rb, 0, 0);

    singleColor = new QvisColorButton(colorGrp, "singleColorWidget");
    colorGLayout->addWidget(singleColor,0,1);
    connect(singleColor, SIGNAL(selectedColor(const QColor&)),
            this, SLOT(singleColorChanged(const QColor&)));

    rb = new QRadioButton(tr("Color table"), colorGrp, "colorTable");
    colorModeButtons->insert(rb);
    colorGLayout->addWidget(rb, 1, 0);
    
    colorTableName = new QvisColorTableButton(colorGrp, "colorTableName");
    connect(colorTableName, SIGNAL(selectedColorTable(bool, const QString&)),
            this, SLOT(colorTableNameChanged(bool, const QString&)));
    colorGLayout->addWidget(colorTableName,1,1);


    ColorByLabel = new QLabel(tr("Color by"), colorGrp, "colorByLabel");
    colorGLayout->addWidget(ColorByLabel, 2, 0, Qt::AlignRight);

    ColorBy = new QComboBox(colorGrp, "ColorStyle");
    ColorBy->insertItem(tr("OriginalValue"));
    ColorBy->insertItem(tr("InputOrder"));
    ColorBy->insertItem(tr("PointIndex"));
    ColorBy->insertItem(tr("Plane"));
    ColorBy->insertItem(tr("ToroidalWindingOrder"));
    ColorBy->insertItem(tr("ToroidalWindingPointOrder"));
    ColorBy->insertItem(tr("ToroidalWindings"));
    ColorBy->insertItem(tr("PoloidalWindings"));
    ColorBy->insertItem(tr("SafetyFactor"));
    connect(ColorBy, SIGNAL(activated(int)),
            this, SLOT(colorByChanged(int)));
    colorGLayout->addWidget(ColorBy,2,1);

    //row++;
    
    showIslands = new QCheckBox(tr("Show Islands"), displayTab, "showIslands");
    connect(showIslands, SIGNAL(toggled(bool)),
            this, SLOT(showIslandsChanged(bool)));
    displayLayout->addWidget(showIslands,row,0);

    showPoints = new QCheckBox(tr("Show Points"), displayTab, "showPoints");
    connect(showPoints, SIGNAL(toggled(bool)),
            this, SLOT(showPointsChanged(bool)));
    displayLayout->addWidget(showPoints,row,1);

    verboseFlag = new QCheckBox(tr("Verbose"), displayTab, "verboseFlag");
    connect(verboseFlag, SIGNAL(toggled(bool)),
            this, SLOT(verboseFlagChanged(bool)));
    displayLayout->addWidget(verboseFlag,row,2);

    legendFlag = new QCheckBox(tr("Legend"), displayTab, "legendFlag");
    connect(legendFlag, SIGNAL(toggled(bool)),
            this, SLOT(legendFlagChanged(bool)));
    displayLayout->addWidget(legendFlag,row,3);

    lightingFlag = new QCheckBox(tr("Lighting"), displayTab, "lightingFlag");
    connect(lightingFlag, SIGNAL(toggled(bool)),
            this, SLOT(lightingFlagChanged(bool)));
    displayLayout->addWidget(lightingFlag,row,4);
    row++;

}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::UpdateWindow
//
// Purpose: 
//   Updates the widgets in the window when the subject changes.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//    Jeremy Meredith, Tue Apr 14 16:16:56 EDT 2009
//    Reworked and reorganized to make more usable.
//
//    Dave Pugmire, Fri Apr 17 11:32:40 EDT 2009
//    GUI reorganization.
//
//    Dave Pugmire, Tue Apr 28 09:26:06 EDT 2009
//    GUI reorganization.
//
//    Dave Pugmire, Wed May 27 15:03:42 EDT 2009
//    Add blockSignals around min/max line edits.
//   
// ****************************************************************************

void
QvisPoincarePlotWindow::UpdateWindow(bool doAll)
{
    QString temp;
    double r;

    for(int i = 0; i < atts->NumAttributes(); ++i)
    {
        if(!doAll)
        {
            if(!atts->IsSelected(i))
            {
                continue;
            }
        }

        const double         *dptr;
        const float          *fptr;
        const int            *iptr;
        const char           *cptr;
        const unsigned char  *uptr;
        const string         *sptr;
        QColor                tempcolor;
        switch(i)
        {
          case PoincareAttributes::ID_sourceType:
            if (atts->GetSourceType() == PoincareAttributes::SpecifiedPoint)
            {
                sourceAtts->setTitle(tr("Point"));
                pointSource->setEnabled(true);
                if(pointSourceLabel)
                    pointSourceLabel->setEnabled(true);
                pointSource->show();
                pointSourceLabel->show();
            }
            else
            {
                pointSource->setEnabled(false);
                if(pointSourceLabel)
                    pointSourceLabel->setEnabled(false);
                pointSource->hide();
                pointSourceLabel->hide();
            }
            if (atts->GetSourceType() == PoincareAttributes::SpecifiedLine)
            {
                sourceAtts->setTitle(tr("Line"));
                lineStart->setEnabled(true);
                if(lineStartLabel)
                    lineStartLabel->setEnabled(true);
                lineEnd->setEnabled(true);
                if(lineEndLabel)
                    lineEndLabel->setEnabled(true);
                lineStart->show();
                lineStartLabel->show();
                lineEnd->show();
                lineEndLabel->show();
            }
            else
            {
                lineStart->setEnabled(false);
                if(lineStartLabel)
                    lineStartLabel->setEnabled(false);
                lineEnd->setEnabled(false);
                if(lineEndLabel)
                    lineEndLabel->setEnabled(false);
                lineStart->hide();
                lineStartLabel->hide();
                lineEnd->hide();
                lineEndLabel->hide();
            }
            if (atts->GetSourceType() == PoincareAttributes::SpecifiedPlane)
            {
                sourceAtts->setTitle(tr("Plane"));
                planeOrigin->setEnabled(true);
                if(planeOriginLabel)
                    planeOriginLabel->setEnabled(true);
                planeNormal->setEnabled(true);
                if(planeNormalLabel)
                    planeNormalLabel->setEnabled(true);
                planeUpAxis->setEnabled(true);
                if(planeUpAxisLabel)
                    planeUpAxisLabel->setEnabled(true);
                planeRadius->setEnabled(true);
                if(planeRadiusLabel)
                    planeRadiusLabel->setEnabled(true);

                planeOrigin->show();
                planeOriginLabel->show();
                planeNormal->show();
                planeNormalLabel->show();
                planeUpAxis->show();
                planeUpAxisLabel->show();
                planeRadius->show();
                planeRadiusLabel->show();
            }
            else
            {
                planeOrigin->setEnabled(false);
                if(planeOriginLabel)
                    planeOriginLabel->setEnabled(false);
                planeNormal->setEnabled(false);
                if(planeNormalLabel)
                    planeNormalLabel->setEnabled(false);
                planeUpAxis->setEnabled(false);
                if(planeUpAxisLabel)
                    planeUpAxisLabel->setEnabled(false);
                planeRadius->setEnabled(false);
                if(planeRadiusLabel)
                    planeRadiusLabel->setEnabled(false);

                planeOrigin->hide();
                planeOriginLabel->hide();
                planeNormal->hide();
                planeNormalLabel->hide();
                planeUpAxis->hide();
                planeUpAxisLabel->hide();
                planeRadius->hide();
                planeRadiusLabel->hide();
            }
            if (atts->GetSourceType() == PoincareAttributes::SpecifiedLine ||
                atts->GetSourceType() == PoincareAttributes::SpecifiedPlane)
            {
                pointDensity->setEnabled(true);
                if(pointDensityLabel)
                    pointDensityLabel->setEnabled(true);
            }
            else
            {
                pointDensity->setEnabled(false);
                if(pointDensityLabel)
                    pointDensityLabel->setEnabled(false);
            }
            sourceType->blockSignals(true);
            sourceType->setCurrentItem(atts->GetSourceType());
            sourceType->blockSignals(false);
            break;
          case PoincareAttributes::ID_maxStepLength:
            maxStepLength->blockSignals(true);
            temp.setNum(atts->GetMaxStepLength());
            maxStepLength->setText(temp);
            maxStepLength->blockSignals(false);
            break;
          case PoincareAttributes::ID_termination:
            termination->blockSignals(true);
            temp.setNum(atts->GetTermination());
            termination->setText(temp);
            termination->blockSignals(false);
            break;
          case PoincareAttributes::ID_pointSource:
            dptr = atts->GetPointSource();
            temp.sprintf("%g %g %g", dptr[0], dptr[1], dptr[2]);
            pointSource->blockSignals(true);
            pointSource->setText(temp);
            pointSource->blockSignals(false);
            break;
          case PoincareAttributes::ID_lineStart:
            dptr = atts->GetLineStart();
            temp.sprintf("%g %g %g", dptr[0], dptr[1], dptr[2]);
            lineStart->blockSignals(true);
            lineStart->setText(temp);
            lineStart->blockSignals(false);
            break;
          case PoincareAttributes::ID_lineEnd:
            dptr = atts->GetLineEnd();
            temp.sprintf("%g %g %g", dptr[0], dptr[1], dptr[2]);
            lineEnd->blockSignals(true);
            lineEnd->setText(temp);
            lineEnd->blockSignals(false);
            break;
          case PoincareAttributes::ID_planeOrigin:
            dptr = atts->GetPlaneOrigin();
            temp.sprintf("%g %g %g", dptr[0], dptr[1], dptr[2]);
            planeOrigin->blockSignals(true);
            planeOrigin->setText(temp);
            planeOrigin->blockSignals(false);
            break;
          case PoincareAttributes::ID_planeNormal:
            dptr = atts->GetPlaneNormal();
            temp.sprintf("%g %g %g", dptr[0], dptr[1], dptr[2]);
            planeNormal->blockSignals(true);
            planeNormal->setText(temp);
            planeNormal->blockSignals(false);
            break;
          case PoincareAttributes::ID_planeUpAxis:
            dptr = atts->GetPlaneUpAxis();
            temp.sprintf("%g %g %g", dptr[0], dptr[1], dptr[2]);
            planeUpAxis->blockSignals(true);
            planeUpAxis->setText(temp);
            planeUpAxis->blockSignals(false);
            break;
          case PoincareAttributes::ID_planeRadius:
            planeRadius->blockSignals(true);
            temp.setNum(atts->GetPlaneRadius());
            planeRadius->setText(temp);
            planeRadius->blockSignals(false);
            break;
          case PoincareAttributes::ID_pointDensity:
            pointDensity->blockSignals(true);
            pointDensity->setValue(atts->GetPointDensity());
            pointDensity->blockSignals(false);
            break;
          case PoincareAttributes::ID_colorTableName:
            colorTableName->blockSignals(true);
            colorTableName->setColorTable(atts->GetColorTableName().c_str());
            colorTableName->blockSignals(false);
            break;
          case PoincareAttributes::ID_singleColor:
            tempcolor = QColor(atts->GetSingleColor().Red(),
                               atts->GetSingleColor().Green(),
                               atts->GetSingleColor().Blue());
            singleColor->blockSignals(true);
            singleColor->setButtonColor(tempcolor);
            singleColor->blockSignals(false);
            break;
          case PoincareAttributes::ID_legendFlag:
            legendFlag->blockSignals(true);
            legendFlag->setChecked(atts->GetLegendFlag());
            legendFlag->blockSignals(false);
            break;
          case PoincareAttributes::ID_lightingFlag:
            lightingFlag->blockSignals(true);
            lightingFlag->setChecked(atts->GetLightingFlag());
            lightingFlag->blockSignals(false);
            break;
          case PoincareAttributes::ID_relTol:
            relTol->blockSignals(true);
            temp.setNum(atts->GetRelTol());
            relTol->setText(temp);
            relTol->blockSignals(false);
            break;
          case PoincareAttributes::ID_absTol:
            absTol->blockSignals(true);
            temp.setNum(atts->GetAbsTol());
            absTol->setText(temp);
            absTol->blockSignals(false);
            break;
          case PoincareAttributes::ID_terminationType:
            {
                bool intersectOn = atts->GetTerminationType() == PoincareAttributes::Intersections;
                intPlnLocation->setEnabled(intersectOn);
                intPlnLocationLabel->setEnabled(intersectOn);
                intPlnNormal->setEnabled(intersectOn);
                intPlnNormalLabel->setEnabled(intersectOn);
            }
            terminationType->blockSignals(true);
            terminationType->setCurrentItem(atts->GetTerminationType());
            terminationType->blockSignals(false);
            break;
          case PoincareAttributes::ID_intersectPlaneOrigin:
            dptr = atts->GetIntersectPlaneOrigin();
            temp.sprintf("%g %g %g", dptr[0], dptr[1], dptr[2]);
            intPlnLocation->blockSignals(true);
            intPlnLocation->setText(temp);
            intPlnLocation->blockSignals(false);
            break;
          case PoincareAttributes::ID_intersectPlaneNormal:
            dptr = atts->GetIntersectPlaneNormal();
            temp.sprintf("%g %g %g", dptr[0], dptr[1], dptr[2]);
            intPlnNormal->blockSignals(true);
            intPlnNormal->setText(temp);
            intPlnNormal->blockSignals(false);
            break;
          case PoincareAttributes::ID_integrationType:
            integrationType->blockSignals(true);
            integrationType->setCurrentItem(atts->GetIntegrationType());
            integrationType->blockSignals(false);
            break;
          case PoincareAttributes::ID_numberPlanes:
            NumberPlanes->blockSignals(true);
            NumberPlanes->setValue(atts->GetNumberPlanes());
            NumberPlanes->blockSignals(false);
            break;
          case PoincareAttributes::ID_colorType:
            colorModeButtons->blockSignals(true);
            colorModeButtons->setButton(atts->GetColorType());

            if (atts->GetColorType() == PoincareAttributes::ColorBySingleColor)
            {
                singleColor->setEnabled(true);
                ColorBy->setEnabled(false);
                colorTableName->setEnabled(false);
                ColorByLabel->setEnabled(false);
            }
            else if (atts->GetColorType() == PoincareAttributes::ColorByColorTable)
            {
                singleColor->setEnabled(false);
                ColorBy->setEnabled(true);
                colorTableName->setEnabled(true);
                ColorByLabel->setEnabled(true);
            }
            colorModeButtons->blockSignals(false);
            break;

          case PoincareAttributes::ID_maxToroidalWinding:
            MaxToroidalWinding->blockSignals(true);
            MaxToroidalWinding->setValue(atts->GetMaxToroidalWinding());
            MaxToroidalWinding->blockSignals(false);
            break;
          case PoincareAttributes::ID_overrideToroidalWinding:
            OverrideToroidalWinding->blockSignals(true);
            temp.sprintf("%d", atts->GetOverrideToroidalWinding());
            OverrideToroidalWinding->setText(temp);
            OverrideToroidalWinding->blockSignals(false);
            break;
          case PoincareAttributes::ID_hitRate:
            HitRate->blockSignals(true);
            temp.setNum(atts->GetHitRate());
            HitRate->setText(temp);
            HitRate->blockSignals(false);
            break;
          case PoincareAttributes::ID_showCurves:
            DisplayType->blockSignals(true);
            DisplayType->setCurrentItem(atts->GetShowCurves());
            DisplayType->blockSignals(false);
            break;
          case PoincareAttributes::ID_adjustPlane:
            AdjustPlane->blockSignals(true);
            temp.sprintf("%d", atts->GetAdjustPlane());
            AdjustPlane->setText(temp);
            AdjustPlane->blockSignals(false);
            break;
          case PoincareAttributes::ID_overlaps:
            Overlaps->blockSignals(true);
            Overlaps->setButton(atts->GetOverlaps());
            Overlaps->blockSignals(false);
            break;
          case PoincareAttributes::ID_min:
            temp.setNum(atts->GetMin());
            minLineEdit->blockSignals(true);
            minLineEdit->setText(temp);
            minLineEdit->blockSignals(false);
            break;
          case PoincareAttributes::ID_max:
            temp.setNum(atts->GetMax());
            maxLineEdit->blockSignals(true);
            maxLineEdit->setText(temp);
            maxLineEdit->blockSignals(false);
            break;
          case PoincareAttributes::ID_minFlag:
            minToggle->blockSignals(true);
            minToggle->setChecked(atts->GetMinFlag());
            minLineEdit->setEnabled(atts->GetMinFlag());
            minToggle->blockSignals(false);
            break;
          case PoincareAttributes::ID_maxFlag:
            maxToggle->blockSignals(true);
            maxToggle->setChecked(atts->GetMaxFlag());
            maxLineEdit->setEnabled(atts->GetMaxFlag());
            maxToggle->blockSignals(false);
            break;
          case PoincareAttributes::ID_verboseFlag:
            verboseFlag->blockSignals(true);
            verboseFlag->setChecked(atts->GetVerboseFlag());
            verboseFlag->blockSignals(false);
            break;
        }
    }
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::GetCurrentValues
//
// Purpose: 
//   Gets values from certain widgets and stores them in the subject.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//    Jeremy Meredith, Tue Apr 14 16:16:56 EDT 2009
//    Reworked and reorganized to make more usable.
//   
// ****************************************************************************

void
QvisPoincarePlotWindow::GetCurrentValues(int which_widget)
{
    bool okay, doAll = (which_widget == -1);
    QString msg, temp;

    // Do maxStepLength
    if(which_widget == PoincareAttributes::ID_maxStepLength || doAll)
    {
        temp = maxStepLength->displayText().simplifyWhiteSpace();
        okay = !temp.isEmpty();
        if(okay)
        {
            double val = temp.toDouble(&okay);
            if(okay)
                atts->SetMaxStepLength(val);
        }

        if(!okay)
        {
            msg = tr("The value of maxStepLength was invalid. "
                     "Resetting to the last good value of %1.").
                  arg(atts->GetMaxStepLength());
            Message(msg);
            atts->SetMaxStepLength(atts->GetMaxStepLength());
        }
    }

    // Do termination
    if(which_widget == PoincareAttributes::ID_termination || doAll)
    {
        temp = termination->displayText().simplifyWhiteSpace();
        okay = !temp.isEmpty();
        if(okay)
        {
            double val = temp.toDouble(&okay);
            if(okay)
                atts->SetTermination(val);
        }

        if(!okay)
        {
            msg = tr("The value of termination was invalid. "
                     "Resetting to the last good value of %1.").
                  arg(atts->GetTermination());
            Message(msg);
            atts->SetTermination(atts->GetTermination());
        }
    }

    // Do pointSource
    if(which_widget == PoincareAttributes::ID_pointSource || doAll)
    {
        temp = pointSource->displayText().simplifyWhiteSpace();
        okay = !temp.isEmpty();
        if(okay)
        {
            double val[3];
            if((okay = (sscanf(temp.latin1(), "%lg %lg %lg", &val[0], &val[1], &val[2]) == 3)) == true)
                atts->SetPointSource(val);
        }

        if(!okay)
        {
            const double *val = atts->GetPointSource();
            QString num; num.sprintf("<%g %g %g>", 
                val[0], val[1], val[2]);
            msg = tr("The value of pointSource was invalid. "
                     "Resetting to the last good value of %1.").
                  arg(num);
            Message(msg);
            atts->SetPointSource(atts->GetPointSource());
        }
    }

    // Do lineStart
    if(which_widget == PoincareAttributes::ID_lineStart || doAll)
    {
        temp = lineStart->displayText().simplifyWhiteSpace();
        okay = !temp.isEmpty();
        if(okay)
        {
            double val[3];
            if((okay = (sscanf(temp.latin1(), "%lg %lg %lg", &val[0], &val[1], &val[2]) == 3)) == true)
                atts->SetLineStart(val);
        }

        if(!okay)
        {
            const double *val = atts->GetLineStart();
            QString num; num.sprintf("<%g %g %g>", 
                val[0], val[1], val[2]);
            msg = tr("The value of lineStart was invalid. "
                     "Resetting to the last good value of %1.").
                  arg(num);
            Message(msg);
            atts->SetLineStart(atts->GetLineStart());
        }
    }

    // Do lineEnd
    if(which_widget == PoincareAttributes::ID_lineEnd || doAll)
    {
        temp = lineEnd->displayText().simplifyWhiteSpace();
        okay = !temp.isEmpty();
        if(okay)
        {
            double val[3];
            if((okay = (sscanf(temp.latin1(), "%lg %lg %lg", &val[0], &val[1], &val[2]) == 3)) == true)
                atts->SetLineEnd(val);
        }

        if(!okay)
        {
            const double *val = atts->GetLineEnd();
            QString num; num.sprintf("<%g %g %g>", 
                val[0], val[1], val[2]);
            msg = tr("The value of lineEnd was invalid. "
                     "Resetting to the last good value of %1.").
                  arg(num);
            Message(msg);
            atts->SetLineEnd(atts->GetLineEnd());
        }
    }

    // Do planeOrigin
    if(which_widget == PoincareAttributes::ID_planeOrigin || doAll)
    {
        temp = planeOrigin->displayText().simplifyWhiteSpace();
        okay = !temp.isEmpty();
        if(okay)
        {
            double val[3];
            if((okay = (sscanf(temp.latin1(), "%lg %lg %lg", &val[0], &val[1], &val[2]) == 3)) == true)
                atts->SetPlaneOrigin(val);
        }

        if(!okay)
        {
            const double *val = atts->GetPlaneOrigin();
            QString num; num.sprintf("<%g %g %g>", 
                val[0], val[1], val[2]);
            msg = tr("The value of planeOrigin was invalid. "
                     "Resetting to the last good value of %1.").
                  arg(num);
            Message(msg);
            atts->SetPlaneOrigin(atts->GetPlaneOrigin());
        }
    }

    // Do planeNormal
    if(which_widget == PoincareAttributes::ID_planeNormal || doAll)
    {
        temp = planeNormal->displayText().simplifyWhiteSpace();
        okay = !temp.isEmpty();
        if(okay)
        {
            double val[3];
            if((okay = (sscanf(temp.latin1(), "%lg %lg %lg", &val[0], &val[1], &val[2]) == 3)) == true)
                atts->SetPlaneNormal(val);
        }

        if(!okay)
        {
            const double *val = atts->GetPlaneNormal();
            QString num; num.sprintf("<%g %g %g>", 
                val[0], val[1], val[2]);
            msg = tr("The value of planeNormal was invalid. "
                     "Resetting to the last good value of %1.").
                  arg(num);
            Message(msg);
            atts->SetPlaneNormal(atts->GetPlaneNormal());
        }
    }

    // Do planeUpAxis
    if(which_widget == PoincareAttributes::ID_planeUpAxis || doAll)
    {
        temp = planeUpAxis->displayText().simplifyWhiteSpace();
        okay = !temp.isEmpty();
        if(okay)
        {
            double val[3];
            if((okay = (sscanf(temp.latin1(), "%lg %lg %lg", &val[0], &val[1], &val[2]) == 3)) == true)
                atts->SetPlaneUpAxis(val);
        }

        if(!okay)
        {
            const double *val = atts->GetPlaneUpAxis();
            QString num; num.sprintf("<%g %g %g>", 
                val[0], val[1], val[2]);
            msg = tr("The value of planeUpAxis was invalid. "
                     "Resetting to the last good value of %1.").
                  arg(num);
            Message(msg);
            atts->SetPlaneUpAxis(atts->GetPlaneUpAxis());
        }
    }

    // Do planeRadius
    if(which_widget == PoincareAttributes::ID_planeRadius || doAll)
    {
        temp = planeRadius->displayText().simplifyWhiteSpace();
        okay = !temp.isEmpty();
        if(okay)
        {
            double val = temp.toDouble(&okay);
            if(okay)
                atts->SetPlaneRadius(val);
        }

        if(!okay)
        {
            msg = tr("The value of planeRadius was invalid. "
                     "Resetting to the last good value of %1.").
                  arg(atts->GetPlaneRadius());
            Message(msg);
            atts->SetPlaneRadius(atts->GetPlaneRadius());
        }
    }

    // Do pointDensity
    if(which_widget == PoincareAttributes::ID_pointDensity || doAll)
    {
        // This can only be an integer, so no error checking is needed.
        int val = pointDensity->value();
        if (val >= 2)
            atts->SetPointDensity(val);
    }

    // Do planeOrigin
    if(which_widget == PoincareAttributes::ID_intersectPlaneOrigin || doAll)
    {
        temp = intPlnLocation->displayText().simplifyWhiteSpace();
        okay = !temp.isEmpty();
        if(okay)
        {
            double val[3];
            if((okay = (sscanf(temp.latin1(), "%lg %lg %lg", &val[0], &val[1], &val[2]) == 3)) == true)
                atts->SetIntersectPlaneOrigin(val);
        }

        if(!okay)
        {
            const double *val = atts->GetIntersectPlaneOrigin();
            QString num; num.sprintf("<%g %g %g>", 
                val[0], val[1], val[2]);
            msg = tr("The value of intersect planeOrigin was invalid. "
                     "Resetting to the last good value of %1.").
                  arg(num);
            Message(msg);
            atts->SetIntersectPlaneOrigin(atts->GetIntersectPlaneOrigin());
        }
    }

    // Do planeNormal
    if(which_widget == PoincareAttributes::ID_intersectPlaneNormal || doAll)
    {
        temp = intPlnNormal->displayText().simplifyWhiteSpace();
        okay = !temp.isEmpty();
        if(okay)
        {
            double val[3];
            if((okay = (sscanf(temp.latin1(), "%lg %lg %lg", &val[0], &val[1], &val[2]) == 3)) == true)
                atts->SetIntersectPlaneNormal(val);
        }

        if(!okay)
        {
            const double *val = atts->GetIntersectPlaneNormal();
            QString num; num.sprintf("<%g %g %g>", 
                val[0], val[1], val[2]);
            msg = tr("The value of intersectPlaneNormal was invalid. "
                     "Resetting to the last good value of %1.").
                  arg(num);
            Message(msg);
            atts->SetIntersectPlaneNormal(atts->GetIntersectPlaneNormal());
        }
    }

    // Do relTol
    if(which_widget == PoincareAttributes::ID_relTol || doAll)
    {
        temp = relTol->displayText().simplifyWhiteSpace();
        okay = !temp.isEmpty();
        if(okay)
        {
            double val = temp.toDouble(&okay);
            if(okay)
                atts->SetRelTol(val);
        }

        if(!okay)
        {
            msg = tr("The value of relTol was invalid. "
                     "Resetting to the last good value of %1.").
                  arg(atts->GetRelTol());
            Message(msg);
            atts->SetRelTol(atts->GetRelTol());
        }
    }

    // Do absTol
    if(which_widget == PoincareAttributes::ID_absTol || doAll)
    {
        temp = absTol->displayText().simplifyWhiteSpace();
        okay = !temp.isEmpty();
        if(okay)
        {
            double val = temp.toDouble(&okay);
            if(okay)
                atts->SetAbsTol(val);
        }

        if(!okay)
        {
            msg = tr("The value of absTol was invalid. "
                     "Resetting to the last good value of %1.").
                  arg(atts->GetAbsTol());
            Message(msg);
            atts->SetAbsTol(atts->GetAbsTol());
        }
    }

    // Do NumberPlanes
    if(which_widget == PoincareAttributes::ID_numberPlanes || doAll)
    {
        int val = NumberPlanes->value();
        if (val >= 1)
            atts->SetNumberPlanes(val);
        else
        {
            msg = tr("The value of NumberPlanes was invalid. "
                     "Resetting to the last good value of %1.").
                  arg(atts->GetNumberPlanes());
            Message(msg);
            atts->SetNumberPlanes(atts->GetNumberPlanes());
        }
    }

    // Do MaxToroidalWinding
    if(which_widget == PoincareAttributes::ID_maxToroidalWinding || doAll)
    {
        int val = MaxToroidalWinding->value();
        if (val >= 1)
            atts->SetMaxToroidalWinding(val);
        else
        {
            msg = tr("The value of MaxToroidalWinding was invalid. "
                     "Resetting to the last good value of %1.").
                  arg(atts->GetMaxToroidalWinding());
            Message(msg);
            atts->SetMaxToroidalWinding(atts->GetMaxToroidalWinding());
        }
    }

    // Do OverrideToroidalWinding
    if(which_widget == PoincareAttributes::ID_overrideToroidalWinding || doAll)
    {
        temp = OverrideToroidalWinding->displayText().simplifyWhiteSpace();
        okay = !temp.isEmpty();
        if(okay)
        {
            int val = temp.toInt(&okay);
            if(okay)
                atts->SetOverrideToroidalWinding(val);
        }

        if(!okay)
        {
            msg = tr("The value of OverrideToroidalWinding was invalid. "
                     "Resetting to the last good value of %1.").
                  arg(atts->GetOverrideToroidalWinding());
            Message(msg);
            atts->SetOverrideToroidalWinding(atts->GetOverrideToroidalWinding());
        }
    }

    // Do HitRate
    if(which_widget == PoincareAttributes::ID_hitRate || doAll)
    {
        temp = HitRate->displayText().simplifyWhiteSpace();
        okay = !temp.isEmpty();
        if(okay)
        {
            double val = temp.toDouble(&okay);
            if(okay)
                atts->SetHitRate(val);
        }

        if(!okay)
        {
            msg = tr("The value of HitRate was invalid. "
                     "Resetting to the last good value of %1.").
                  arg(atts->GetHitRate());
            Message(msg);
            atts->SetHitRate(atts->GetHitRate());
        }
    }

    // Do AdjustPlane
    if(which_widget == PoincareAttributes::ID_adjustPlane || doAll)
    {
        temp = AdjustPlane->displayText().simplifyWhiteSpace();
        okay = !temp.isEmpty();
        if(okay)
        {
            int val = temp.toInt(&okay);
            if(okay)
                atts->SetAdjustPlane(val);
        }

        if(!okay)
        {
            msg = tr("The value of AdjustPlane was invalid. "
                     "Resetting to the last good value of %1.").
                  arg(atts->GetAdjustPlane());
            Message(msg);
            atts->SetAdjustPlane(atts->GetAdjustPlane());
        }
    }

    //Min
    if(which_widget == PoincareAttributes::ID_min || doAll)
    {
        temp = minLineEdit->displayText().simplifyWhiteSpace();
        okay = !temp.isEmpty();
        if(okay)
        {
            double val = temp.toDouble(&okay);
            if(okay)
                atts->SetMin(val);
        }

        if(!okay)
        {
            msg = tr("The value of Min was invalid. "
                     "Resetting to the last good value of %1.").
                  arg(atts->GetMin());
            Message(msg);
            atts->SetMin(atts->GetMin());
        }
    }

    //Max
    if(which_widget == PoincareAttributes::ID_max || doAll)
    {
        temp = maxLineEdit->displayText().simplifyWhiteSpace();
        okay = !temp.isEmpty();
        if(okay)
        {
            double val = temp.toDouble(&okay);
            if(okay)
                atts->SetMax(val);
        }

        if(!okay)
        {
            msg = tr("The value of Max was invalid. "
                     "Resetting to the last good value of %1.").
                  arg(atts->GetMax());
            Message(msg);
            atts->SetMax(atts->GetMax());
        }
    }
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::Apply
//
// Purpose: 
//   Called to apply changes in the subject.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisPoincarePlotWindow::Apply(bool ignore)
{
    if(AutoUpdate() || ignore)
    {
        GetCurrentValues(-1);
        atts->Notify();

        GetViewerMethods()->SetPlotOptions(plotType);
    }
    else
        atts->Notify();
}


//
// Qt Slot functions
//


// ****************************************************************************
// Method: QvisPoincarePlotWindow::apply
//
// Purpose: 
//   Qt slot function called when apply button is clicked.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisPoincarePlotWindow::apply()
{
    Apply(true);
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::makeDefault
//
// Purpose: 
//   Qt slot function called when "Make default" button is clicked.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisPoincarePlotWindow::makeDefault()
{
    GetCurrentValues(-1);
    atts->Notify();
    GetViewerMethods()->SetDefaultPlotOptions(plotType);
}


// ****************************************************************************
// Method: QvisPoincarePlotWindow::reset
//
// Purpose: 
//   Qt slot function called when reset button is clicked.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisPoincarePlotWindow::reset()
{
    GetViewerMethods()->ResetPlotOptions(plotType);
}


void
QvisPoincarePlotWindow::sourceTypeChanged(int val)
{
    if(val != atts->GetSourceType())
    {
        atts->SetSourceType(PoincareAttributes::SourceType(val));
        Apply();
    }
}


void
QvisPoincarePlotWindow::maxStepLengthProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_maxStepLength);
    Apply();
}


void
QvisPoincarePlotWindow::terminationProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_termination);
    Apply();
}


void
QvisPoincarePlotWindow::pointSourceProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_pointSource);
    Apply();
}


void
QvisPoincarePlotWindow::lineStartProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_lineStart);
    Apply();
}


void
QvisPoincarePlotWindow::lineEndProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_lineEnd);
    Apply();
}


void
QvisPoincarePlotWindow::planeOriginProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_planeOrigin);
    Apply();
}


void
QvisPoincarePlotWindow::planeNormalProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_planeNormal);
    Apply();
}


void
QvisPoincarePlotWindow::planeUpAxisProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_planeUpAxis);
    Apply();
}


void
QvisPoincarePlotWindow::planeRadiusProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_planeRadius);
    Apply();
}


void
QvisPoincarePlotWindow::pointDensityChanged(int val)
{
    atts->SetPointDensity(val);
    Apply();
}

void
QvisPoincarePlotWindow::intersectPlanePointSourceProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_intersectPlaneOrigin);
    Apply();
}

void
QvisPoincarePlotWindow::intersectPlaneNormalSourceProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_intersectPlaneNormal);
    Apply();
}

void
QvisPoincarePlotWindow::colorTableNameChanged(bool useDefault, const QString &ctName)
{
    atts->SetColorTableName(ctName.latin1());
    SetUpdate(false);
    Apply();
}


void
QvisPoincarePlotWindow::singleColorChanged(const QColor &color)
{
    ColorAttribute temp(color.red(), color.green(), color.blue());
    atts->SetSingleColor(temp);
    SetUpdate(false);
    Apply();
}


void
QvisPoincarePlotWindow::verboseFlagChanged(bool val)
{
    atts->SetVerboseFlag(val);
    SetUpdate(false);
    Apply();
}


void
QvisPoincarePlotWindow::legendFlagChanged(bool val)
{
    atts->SetLegendFlag(val);
    SetUpdate(false);
    Apply();
}


void
QvisPoincarePlotWindow::lightingFlagChanged(bool val)
{
    atts->SetLightingFlag(val);
    SetUpdate(false);
    Apply();
}


void
QvisPoincarePlotWindow::relTolProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_relTol);
    Apply();
}


void
QvisPoincarePlotWindow::absTolProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_absTol);
    Apply();
}


void
QvisPoincarePlotWindow::terminationTypeChanged(int val)
{
    if(val != atts->GetTerminationType())
    {
        atts->SetTerminationType(PoincareAttributes::TerminationType(val));
        //SetUpdate(false);
        Apply();
    }
}


void
QvisPoincarePlotWindow::integrationTypeChanged(int val)
{
    if(val != atts->GetIntegrationType())
    {
        atts->SetIntegrationType(PoincareAttributes::IntegrationType(val));
        SetUpdate(false);
        Apply();
    }
}


void
QvisPoincarePlotWindow::showStreamlinesChanged(bool val)
{
    atts->SetShowStreamlines(val);
    SetUpdate(false);
    Apply();
}


void
QvisPoincarePlotWindow::showPointsChanged(bool val)
{
    atts->SetShowPoints(val);
    SetUpdate(false);
    Apply();
}


void
QvisPoincarePlotWindow::numberPlanesSizeChanged(int val)
{
    atts->SetNumberPlanes(val);
    Apply();
}


void
QvisPoincarePlotWindow::colorByChanged(int val)
{
    if(val != atts->GetColorBy())
    {
        atts->SetColorBy(PoincareAttributes::ColorBy(val));
        Apply();
    }
}


void
QvisPoincarePlotWindow::maxToroidalWindingSizeChanged(int val)
{
    atts->SetMaxToroidalWinding(val);
    Apply();
}


void
QvisPoincarePlotWindow::overrideToroidalWindingProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_overrideToroidalWinding);
    Apply();
}


void
QvisPoincarePlotWindow::hitRateProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_hitRate);
    Apply();
}


void
QvisPoincarePlotWindow::displayTypeChanged(int val)
{
    if(val != atts->GetShowCurves())
    {
        atts->SetShowCurves(PoincareAttributes::ShowMeshType(val));
        SetUpdate(false);
        Apply();
    }
}


void
QvisPoincarePlotWindow::adjustPlaneProcessText()
{
    GetCurrentValues(PoincareAttributes::ID_adjustPlane);
    Apply();
}


void
QvisPoincarePlotWindow::showIslandsChanged(bool val)
{
    atts->SetShowIslands(val);
    SetUpdate(false);
    Apply();
}


void
QvisPoincarePlotWindow::overlapsChanged(int val)
{
    if(val != atts->GetOverlaps())
    {
        atts->SetOverlaps(PoincareAttributes::OverlapType(val));
        SetUpdate(false);
        Apply();
    }
}

void
QvisPoincarePlotWindow::colorModeChanged(int val)
{
    if(val == 0)
        atts->SetColorType(PoincareAttributes::ColorBySingleColor);
    else if(val == 1)
        atts->SetColorType(PoincareAttributes::ColorByColorTable);
    Apply();
}


void
QvisPoincarePlotWindow::processMinLimitText()
{
    GetCurrentValues(PoincareAttributes::ID_min);
    Apply();

    QString temp, msg;
    temp = minLineEdit->displayText().stripWhiteSpace();
    bool okay = !temp.isEmpty();
    if(okay)
    {
        double val = temp.toDouble(&okay);
        if(okay)
            atts->SetMin(val);
    }

    if(!okay)
    {
        msg = tr("The minimum value was invalid. "
                 "Resetting to the last good value of %1.").
            arg(atts->GetMin());
        Message(msg);

        atts->SetMin(atts->GetMin());
    }
    cout<<"min= "<<atts->GetMin()<<endl;
    Apply();
}

void
QvisPoincarePlotWindow::processMaxLimitText()
{
    GetCurrentValues(PoincareAttributes::ID_max);
    Apply();


    QString temp, msg;
    
    temp = maxLineEdit->displayText().stripWhiteSpace();
    bool okay = !temp.isEmpty();
    if(okay)
    {
        double val = temp.toDouble(&okay);
        if(okay)
            atts->SetMax(val);
    }

    if(!okay)
    {
        msg = tr("The maximum value was invalid. "
                 "Resetting to the last good value of %1.").
            arg(atts->GetMax());
        Message(msg);

        atts->SetMax(atts->GetMax());
    }
    cout<<"max= "<<atts->GetMax()<<endl;
    Apply();
}

void
QvisPoincarePlotWindow::minToggled(bool val)
{
    atts->SetMinFlag(val);
    Apply();
}

void
QvisPoincarePlotWindow::maxToggled(bool val)
{
    atts->SetMaxFlag(val);
    Apply();
}


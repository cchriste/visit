/*****************************************************************************
*
* Copyright (c) 2000 - 2014, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                             avtPoincarePlot.C                             //
// ************************************************************************* //

#include <avtPoincarePlot.h>

#include <vtkPlane.h>
#include <PoincareAttributes.h>

#include <avtColorTables.h>
#include <avtExtents.h>
#include <avtLookupTable.h>
#include <avtPoincareFilter.h>
#include <avtShiftCenteringFilter.h>
#include <avtVariableLegend.h>
#include <avtVariablePointGlyphMapper.h>

#include <DebugStream.h>
#include <InvalidLimitsException.h>

#include <string>
#include <vector>

// ****************************************************************************
//  Method: avtPoincarePlot constructor
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//
//   Dave Pugmire, Wed May 27 15:03:42 EDT 2009
//   Set color LUT.
//
//   Dave Pugmire, Thu Jul  1 13:55:28 EDT 2010
//   Switch to variablePointGlyphMapper
//
// ****************************************************************************

avtPoincarePlot::avtPoincarePlot()
{
    varLegend = new avtVariableLegend;
    varLegend->SetTitle("Poincare");
    glyphMapper = new avtVariablePointGlyphMapper;

    colorsInitialized = false;
    topoDim = 3;

    avtLUT  = new avtLookupTable;

    shiftCenteringFilter = NULL;
    poincareFilter = NULL;
    colorTableIsFullyOpaque = true;
#ifdef ENGINE
    poincareFilter = new avtPoincareFilter;
#endif

    //
    // This is to allow the legend to reference counted so the behavior can
    // still access it after the plot is deleted.  The legend cannot be
    // reference counted all of the time since we need to know that it is a 
    // VariableLegend.
    //
    varLegendRefPtr = varLegend;
}


// ****************************************************************************
//  Method: avtPoincarePlot destructor
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//
//   Dave Pugmire, Thu Jul  1 13:55:28 EDT 2010
//   Switch to variablePointGlyphMapper
//
// ****************************************************************************

avtPoincarePlot::~avtPoincarePlot()
{
    if (shiftCenteringFilter != NULL)
    {
        delete shiftCenteringFilter;
        shiftCenteringFilter = NULL;
    }
#if ENGINE
    if (poincareFilter != NULL)
    {
        delete poincareFilter;
        poincareFilter = NULL;
    }
#endif

    if (avtLUT != NULL)
    {
        delete avtLUT;
        avtLUT = NULL;
    }
    if (glyphMapper != NULL)
    {
        delete glyphMapper;
        glyphMapper = NULL;
    }

    //
    // Do not delete the varLegend since it is being held by varLegendRefPtr.
    //
}


// ****************************************************************************
//  Method:  avtPoincarePlot::Create
//
//  Purpose:
//    Call the constructor.
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************

avtPlot*
avtPoincarePlot::Create()
{
    return new avtPoincarePlot;
}

// ****************************************************************************
//  Method: avtPoincarePlot::GetMapper
//
//  Purpose:
//      Gets a mapper for this plot, it is actually a variable mapper.
//
//  Returns:    The variable mapper typed as its base class mapper.
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************

avtMapper *
avtPoincarePlot::GetMapper(void)
{
    return glyphMapper;
}


// ****************************************************************************
//  Method: avtPoincarePlot::ApplyOperators
//
//  Purpose:
//      Applies the operators associated with a Poincare plot.  
//      The output from this method is a query-able object.
//
//  Arguments:
//      input   The input data object.
//
//  Returns:    The data object after the Poincare plot has been applied.
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//
//   Dave Pugmire, Thu Jul  8 09:03:20 EDT 2010
//   Add force node centering option.
//
// ****************************************************************************

avtDataObject_p
avtPoincarePlot::ApplyOperators(avtDataObject_p input)
{
#ifdef ENGINE
    avtDataObject_p dob = input; 

    // Try to determine the centering.  If we have an expression, we won't
    // be able to.  So be conservative and assume the worst.
    avtCentering centering = AVT_ZONECENT;
    if (input->GetInfo().GetAttributes().ValidVariable(varname))
        centering = input->GetInfo().GetAttributes().GetCentering(varname);

    //Convert from zonal to nodal, if requested.
    if(centering == AVT_ZONECENT && atts.GetForceNodeCenteredData())
    {
        if(shiftCenteringFilter != NULL)
            delete shiftCenteringFilter;
        shiftCenteringFilter = new avtShiftCenteringFilter(AVT_NODECENT);
        shiftCenteringFilter->SetInput(input);
        dob = shiftCenteringFilter->GetOutput();
    }

    poincareFilter->SetInput(input);
    dob = poincareFilter->GetOutput();
    return dob;
#else
    return input;
#endif
}

// ****************************************************************************
//  Method: avtPoincarePlot::ApplyRenderingTransformation
//
//  Purpose:
//      Applies the rendering transformation associated with a Poincare plot.  
//
//  Arguments:
//      input   The input data object.
//
//  Returns:    The data object after the Poincare plot has been applied.
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************

avtDataObject_p
avtPoincarePlot::ApplyRenderingTransformation(avtDataObject_p input)
{
    return input;
}

// ****************************************************************************
//  Method: avtPoincarePlot::CustomizeBehavior
//
//  Purpose:
//      Customizes the behavior as appropriate for a Poincare plot.
//      This includes behavior like shifting towards or away from the
//      screen.
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications
//   Dave Pugmire, Thu Jul  1 13:55:28 EDT 2010
//   Switch to variablePointGlyphMapper
//
// ****************************************************************************

void
avtPoincarePlot::CustomizeBehavior()
{
    //SetLimitsMode(atts.GetLimitsMode());
    SetLimitsMode(0);

    SetPointGlyphSize();

    bool fullyOpaque = atts.GetOpacityType() ?
        colorTableIsFullyOpaque : (atts.GetOpacity() == 1.);
    if (!fullyOpaque)
    {
       behavior->SetRenderOrder(MUST_GO_LAST);
       behavior->SetAntialiasedRenderOrder(MUST_GO_LAST);
    }
    else
    {
       behavior->SetRenderOrder(DOES_NOT_MATTER);
       behavior->SetAntialiasedRenderOrder(DOES_NOT_MATTER);
    }

    behavior->SetLegend(varLegendRefPtr);
    if (behavior->GetInfo().GetAttributes().GetTopologicalDimension() <= 1)
        behavior->SetShiftFactor(0.1);
    else
        behavior->SetShiftFactor(0.0);
}


// ****************************************************************************
//  Method: avtPoincarePlot::SetAtts
//
//  Purpose:
//      Sets the atts for the Poincare plot.
//
//  Arguments:
//      atts    The attributes for this Poincare plot.
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//
// ****************************************************************************

void
avtPoincarePlot::SetAtts(const AttributeGroup *a)
{
    const PoincareAttributes *newAtts = (const PoincareAttributes *)a;

    // See if the colors will need to be updated.
    bool updateColors = (!colorsInitialized) ||
        (atts.GetColorTableName() != newAtts->GetColorTableName()) ||
        (atts.GetOpacityType() != newAtts->GetOpacityType());

    // See if any attributes that require the plot to be regenerated were
    // changed and copy the state object.
    needsRecalculation = atts.ChangesRequireRecalculation(*newAtts);
    atts = *newAtts;


#ifdef ENGINE

    poincareFilter->SetFieldType(atts.GetFieldType());
    poincareFilter->SetFieldConstant(atts.GetFieldConstant());

    poincareFilter->SetMaxPunctures(atts.GetMaxPunctures());
    
    vtkPlane *intPlane = vtkPlane::New();
    intPlane->SetOrigin( 0,0,0 );

    if ( atts.GetPuncturePlane() == PoincareAttributes::Toroidal )
        intPlane->SetNormal( 0,0,1 );
    else if ( atts.GetPuncturePlane() == PoincareAttributes::Poloidal )
        intPlane->SetNormal( 0,1,0 );
    
    // Make the number of punctures 2x because the Poincare analysis
    // uses only the punctures in the same direction as the plane normal
    // while the integral curve uses the plane regardless of the normal.
    poincareFilter->SetIntersectionCriteria(intPlane, 2*atts.GetMinPunctures());
    poincareFilter->SetIntegrationDirection(0);

    switch (atts.GetSourceType())
    {
      case PoincareAttributes::SpecifiedPoint:
        poincareFilter->SetPointSource(atts.GetPointSource());
        break;
        
      case PoincareAttributes::SpecifiedLine:
        if( atts.GetPointDensity() > 1 )
        {
            poincareFilter->SetLineSource(atts.GetLineStart(), atts.GetLineEnd(),
                                          atts.GetPointDensity(),
                                          false, 0, 0);
        }
        else
        {
            double pt[3];

            pt[0] = (atts.GetLineStart()[0] + atts.GetLineEnd()[0]) / 2;
            pt[1] = (atts.GetLineStart()[1] + atts.GetLineEnd()[1]) / 2;
            pt[2] = (atts.GetLineStart()[2] + atts.GetLineEnd()[2]) / 2;
            
            poincareFilter->SetPointSource(pt);
        }
        
        break;
    }
    
    // Set the attributes.
    poincareFilter->SetIntegrationType(atts.GetIntegrationType());
    poincareFilter->SetMaxStepLength(atts.GetMaxStepLength());

    double absTol = 0.;
    bool doBBox = (atts.GetAbsTolSizeType() ==
                   PoincareAttributes::FractionOfBBox);
    if (doBBox)
        absTol = atts.GetAbsTolBBox();
    else
        absTol = atts.GetAbsTolAbsolute();
    poincareFilter->SetTolerances(atts.GetRelTol(), absTol, doBBox);
    
    poincareFilter->SetParallelizationAlgorithm(atts.GetParallelizationAlgorithmType(), 
                                                atts.GetMaxProcessCount(),
                                                atts.GetMaxDomainCacheSize(),
                                                atts.GetWorkGroupSize());

    int CMFEType = (atts.GetPathlinesCMFE() == PoincareAttributes::CONN_CMFE
                    ? PICS_CONN_CMFE : PICS_POS_CMFE);

    poincareFilter->SetPathlines(atts.GetPathlines(),
                                 atts.GetPathlinesOverrideStartingTimeFlag(),
                                 atts.GetPathlinesOverrideStartingTime(),
                                 atts.GetPathlinesPeriod(),
                                 CMFEType);

    poincareFilter->IssueWarningForMaxStepsTermination(atts.GetIssueTerminationWarnings());
    poincareFilter->IssueWarningForStiffness(atts.GetIssueStiffnessWarnings());
    poincareFilter->IssueWarningForCriticalPoints(atts.GetIssueCriticalPointsWarnings(), atts.GetCriticalPointThreshold());

    if (atts.GetFieldType() == PoincareAttributes::M3DC12DField ||
        atts.GetFieldType() == PoincareAttributes::M3DC13DField ||
//      atts.GetIntegrationType() == PoincareAttributes::NIMRODField ||
        0 )
      poincareFilter->ConvertToCartesian( true );
    else
      poincareFilter->ConvertToCartesian( false );

    // Poincare specific attributes.
    poincareFilter->SetPuncturePlane( atts.GetPuncturePlane() );
    poincareFilter->SetAnalysis( atts.GetAnalysis() );

    poincareFilter->SetMaximumToroidalWinding( atts.GetMaximumToroidalWinding() );
    poincareFilter->SetOverrideToroidalWinding( atts.GetOverrideToroidalWinding() );
    poincareFilter->SetOverridePoloidalWinding( atts.GetOverridePoloidalWinding() );
    poincareFilter->SetWindingPairConfidence( atts.GetWindingPairConfidence() );
    poincareFilter->SetRationalSurfaceFactor( atts.GetRationalSurfaceFactor() );
    poincareFilter->SetOverlaps( atts.GetOverlaps() );
    poincareFilter->SetAdjustPlane( atts.GetAdjustPlane() );


    poincareFilter->SetShowCurves( atts.GetMeshType() == 0 );

    std::vector < double > planes;
    unsigned int nplanes = atts.GetNumberPlanes();

    // Offset of M_PI/2.0 gives a Y normal but whether the
    // intersection is on the +X or -X side depends on the direction
    // of the fieldline.

    if( nplanes == 1 )
        planes.push_back( atts.GetSinglePlane() / 360.0 * 2.0 * M_PI + M_PI/2.0);
    else
        for( unsigned int i=0; i<nplanes; i++ )
            planes.push_back(2.0 * M_PI * (double) i / (double) nplanes + M_PI/2.0);

    poincareFilter->SetClipPlanes( planes );

    poincareFilter->SetDisplayMethod(PICS_DISPLAY_LINES);
    poincareFilter->SetColoringMethod(PICS_COLOR_SOLID);

    poincareFilter->SetDataValue( atts.GetDataValue() );

    poincareFilter->SetShowRationalSurfaces( atts.GetShowRationalSurfaces() );
    poincareFilter->SetRationalSurfaceMaxIterations( atts.GetRationalSurfaceMaxIterations() );

    poincareFilter->SetShowOPoints( atts.GetShowOPoints() );
    poincareFilter->SetOPointMaxIterations( atts.GetOPointMaxIterations() );

    poincareFilter->SetShowXPoints( atts.GetShowXPoints() );
    poincareFilter->SetXPointMaxIterations( atts.GetXPointMaxIterations() );

    poincareFilter->SetPerformOLineAnalysis( atts.GetPerformOLineAnalysis() );
    poincareFilter->SetOLineToroidalWinding( atts.GetOLineToroidalWinding() );
    poincareFilter->SetOLineAxisFileName( atts.GetOLineAxisFileName() );

    poincareFilter->SetShowChaotic( atts.GetShowChaotic() );
    poincareFilter->SetShowIslands( atts.GetShowIslands() );
    poincareFilter->SetShowLines(atts.GetShowLines());
    poincareFilter->SetShowPoints(atts.GetShowPoints());
    poincareFilter->SetPointScale(atts.GetPointSize());
    poincareFilter->SetShow1DPlots(atts.GetShow1DPlots());
    poincareFilter->SetSummaryFlag( atts.GetSummaryFlag() );
    poincareFilter->SetVerboseFlag( atts.GetVerboseFlag() );
#endif

    // Update the plot's colors if needed.
    if(updateColors || atts.GetColorTableName() == "Default")
    {
        colorsInitialized = true;
        SetColorTable(atts.GetColorTableName().c_str());
    }

    SetOpacityFromAtts();
    SetLighting(atts.GetLightingFlag());
    SetLegend(atts.GetLegendFlag());


    glyphMapper->SetLineWidth(Int2LineWidth(atts.GetLineWidth()));
    glyphMapper->SetLineStyle(Int2LineStyle(atts.GetLineStyle()));
    glyphMapper->SetScale(atts.GetPointSize());
    glyphMapper->DataScalingOff();
    if (atts.GetPointType() == PoincareAttributes::Box)
        glyphMapper->SetGlyphType(avtPointGlypher::Box);
    else if (atts.GetPointType() == PoincareAttributes::Axis)
        glyphMapper->SetGlyphType(avtPointGlypher::Axis);
    else if (atts.GetPointType() == PoincareAttributes::Icosahedron)
        glyphMapper->SetGlyphType(avtPointGlypher::Icosahedron);
    else if (atts.GetPointType() == PoincareAttributes::Octahedron)
        glyphMapper->SetGlyphType(avtPointGlypher::Octahedron);
    else if (atts.GetPointType() == PoincareAttributes::Tetrahedron)
        glyphMapper->SetGlyphType(avtPointGlypher::Tetrahedron);
    else if (atts.GetPointType() == PoincareAttributes::SphereGeometry)
        glyphMapper->SetGlyphType(avtPointGlypher::SphereGeometry);
    else if (atts.GetPointType() == PoincareAttributes::Point)
        glyphMapper->SetGlyphType(avtPointGlypher::Point);
    else if (atts.GetPointType() == PoincareAttributes::Sphere)
        glyphMapper->SetGlyphType(avtPointGlypher::Sphere);
    SetPointGlyphSize();

    if (varname != NULL)
    {
        glyphMapper->ColorByScalarOn(std::string(varname));
    }

    //SetScaling(atts.GetScaling(), atts.GetSkewFactor());
    SetScaling(0, 1);
    
    //SetLimitsMode(atts.GetLimitsMode());
    SetLimitsMode(0);
}


// ****************************************************************************
//  Method: avtPoincarePlot::GetDataExtents
//
//  Purpose:
//      Gets the data extents used by the plot.
//
//  Arguments:
//      extents The extents used by the plot.
//
//  Programmer: Dave Pugmire
//  Creation:   Thu Aug 26 12:46:33 EDT 2010
//   
//
// ****************************************************************************

void
avtPoincarePlot::GetDataExtents(std::vector<double> &extents)
{
    double min, max;

    varLegend->GetRange(min, max);

    extents.push_back(min);
    extents.push_back(max);
}


// ****************************************************************************
// Method: avtPoincarePlot::SetColorTable
//
// Purpose: 
//   Sets the plot's color table if the color table is the same as that of
//   the plot or we are using the default color table for the plot.
//
// Arguments:
//   ctName : The name of the color table to use.
//
// Returns:    Returns true if the color table is updated.
//
// Programmer: Dave Pugmire
// Creation:   Thu Aug 26 12:46:33 EDT 2010
//
// Modifications:
//
// ****************************************************************************

bool
avtPoincarePlot::SetColorTable(const char *ctName)
{
    bool oldColorTableIsFullyOpaque = colorTableIsFullyOpaque;
    colorTableIsFullyOpaque =
        avtColorTables::Instance()->ColorTableIsFullyOpaque(ctName);
    SetOpacityFromAtts();

    bool namesMatch = (atts.GetColorTableName() == std::string(ctName));
    bool retval = (namesMatch &&
                   (oldColorTableIsFullyOpaque != colorTableIsFullyOpaque));
    if (atts.GetColorTableName() == "Default")
        retval |= avtLUT->SetColorTable(NULL, namesMatch,
                                     atts.GetOpacityType()); 
    else
        retval |= avtLUT->SetColorTable(ctName, namesMatch,
                                     atts.GetOpacityType());
    return retval;
}


// ****************************************************************************
//  Method: avtPoincarePlot::SetLegend
//
//  Purpose:
//    Turns the legend on or off.
//
//  Arguments:
//    legendOn  : true if the legend should be turned on, false otherwise.
//
//  Programmer: Dave Pugmire
//  Creation:   Fri Nov  7 13:29:26 EST 2008
//
// ****************************************************************************

void
avtPoincarePlot::SetLegend(bool legendOn)
{
    if (legendOn)
        varLegend->LegendOn();
    else
        varLegend->LegendOff();
}

// ****************************************************************************
//  Method: avtPoincarePlot::SetScaling
//
//  Purpose:
//    Set up mapper and legend to perform needed scaling 
//
//  Arguments:
//    mode   Which scaling mode to use: 0 = Linear, 1 = Log, 2 = Skew
//    skew   The skew factor to use in the case of skew mode.
//
//  Programmer: Dave Pugmire
//  Creation:   Fri Nov  7 13:29:26 EST 2008
//
//  Modifications:
//
// ****************************************************************************

void
avtPoincarePlot::SetScaling(int mode, double skew)
{
    varLegend->SetLookupTable(avtLUT->GetLookupTable());
    varLegend->SetScaling(mode, skew);

    if (mode == 1)
    {
       glyphMapper->SetLookupTable(avtLUT->GetLogLookupTable());
    }
    else if (mode == 2)
    {
       avtLUT->SetSkewFactor(skew);
       glyphMapper->SetLookupTable(avtLUT->GetSkewLookupTable());
    }
    else 
    {
       glyphMapper->SetLookupTable(avtLUT->GetLookupTable());
    }
}

// ****************************************************************************
//  Method: avtPoincarePlot::SetLighting
//
//  Purpose:
//      Turns the lighting on or off.
//
//  Arguments:
//      lightingOn   true if the lighting should be turned on, false otherwise.
//
//  Programmer: Dave Pugmire
//  Creation:   Fri Nov  7 13:29:26 EST 2008
//
//  Modifications:
//
//
// ****************************************************************************

void
avtPoincarePlot::SetLighting(bool lightingOn)
{
    if (lightingOn)
    {
        glyphMapper->TurnLightingOn();
        glyphMapper->SetSpecularIsInappropriate(false);
    }
    else
    {
        glyphMapper->TurnLightingOff();
        glyphMapper->SetSpecularIsInappropriate(true);
    }
}


// ****************************************************************************
//  Method: avtPoincarePlot::SetLimitsMode
//
//  Purpose:  To determine the proper limits the mapper should be using.
//
//  Arguments:
//    limitsMode  Specifies which type of limits.
//
//  Programmer: Dave Pugmire
//  Creation:   Fri Nov  7 13:29:26 EST 2008
//
//  Modifications:
//
// ****************************************************************************

void
avtPoincarePlot::SetLimitsMode(int limitsMode)
{
    double min, max;

    // Retrieve the actual range of the data
    glyphMapper->GetVarRange(min, max);

    double userMin = atts.GetMinFlag() ? atts.GetMin() : min;
    double userMax = atts.GetMaxFlag() ? atts.GetMax() : max;

    if (dataExtents.size() == 2)
    {
        glyphMapper->SetMin(dataExtents[0]);
        glyphMapper->SetMax(dataExtents[1]);
    }
    else if (atts.GetMinFlag() && atts.GetMaxFlag())
    {
        if (userMin >= userMax)
        {
            EXCEPTION1(InvalidLimitsException, false); 
        }
        else
        {
            glyphMapper->SetMin(userMin);
            glyphMapper->SetMax(userMax);
        }
    } 
    else if (atts.GetMinFlag())
    {
        glyphMapper->SetMin(userMin);
        if (userMin > userMax)
            glyphMapper->SetMax(userMin);
        else
            glyphMapper->SetMaxOff();
    }
    else if (atts.GetMaxFlag())
    {
        glyphMapper->SetMax(userMax);
        if (userMin > userMax)
            glyphMapper->SetMin(userMax);
        else
            glyphMapper->SetMinOff();
    }
    else
    {
        glyphMapper->SetMinOff();
        glyphMapper->SetMaxOff();
    }
    
    glyphMapper->SetLimitsMode(limitsMode);
    SetLegendRanges();
}


// ****************************************************************************
//  Method: avtPoincarePlot::SetOpacity
//
//  Purpose:
//      Allows for plots to be non-opaque.
//
//  Arguments:
//      opacity     The new opacity.
//
//  Programmer: Dave Pugmire
//  Creation:   Fri Nov  7 13:29:26 EST 2008
//
//  Modifications:
//
// ****************************************************************************

void
avtPoincarePlot::SetOpacityFromAtts()
{
    double origOpacity = atts.GetOpacity();
    double realOpacity = atts.GetOpacityType() ?
        (colorTableIsFullyOpaque ? 1.0 : 0.99) : origOpacity;
    
    glyphMapper->SetOpacity(realOpacity);
    if (realOpacity < 1.0)
    {
        behavior->SetRenderOrder(MUST_GO_LAST);
        behavior->SetAntialiasedRenderOrder(MUST_GO_LAST);
    }
    else
    {
        behavior->SetRenderOrder(DOES_NOT_MATTER);
        behavior->SetAntialiasedRenderOrder(DOES_NOT_MATTER);
    }
}


// ****************************************************************************
// Method: avtPoincarePlot::SetLegendRanges
//
// Purpose: 
//   Sets the range to use for the legend.
//
// Programmer: Dave Pugmire
// Creation:   Fri Nov  7 13:31:08 EST 2008
//
// Modifications:
//
// Dave Pugmire, Fri Apr 24 15:47:02 EDT 2009
// Add min/max variable ranges.
//
// Dave Pugmire, Thu Jul  1 13:55:28 EDT 2010
// Switch to variablePointGlyphMapper
//
// ****************************************************************************

void
avtPoincarePlot::SetLegendRanges()
{
    double min, max;

    // set and get the range for the legend's color bar labels 
    bool validRange = glyphMapper->GetRange(min, max);

    varLegend->SetRange(min, max);

    /*
    if (atts.GetScaling() == PoincareAttributes::Log &&
       ( min <= 0. || max <= 0. ) && validRange == true)
    {
        EXCEPTION1(InvalidLimitsException, true); 
    }
    */
 
    //varLegend->SetScaling(atts.GetScaling(), atts.GetSkewFactor());
    varLegend->SetScaling(0);

    // set and get the range for the legend's limits text
    glyphMapper->GetVarRange(min, max);
    varLegend->SetVarRange(min, max);
}

// ****************************************************************************
// Method: avtPoincarePlot::SetPointGlyphSize
//
// Purpose: 
//   Sets the point glyph size into the mapper.
//
// Programmer: Dave Pugmire
// Creation:   Thu Aug 26 12:43:22 EDT 2010
//
// Modifications:
//
// ****************************************************************************

void
avtPoincarePlot::SetPointGlyphSize()
{
    // Size used for points when using a point glyph.
    if(atts.GetPointType() == PoincareAttributes::Point ||
       atts.GetPointType() == PoincareAttributes::Sphere)
        glyphMapper->SetPointSize(atts.GetPointSizePixels());
}

// ****************************************************************************
//  Method: avtPoincarePlot::ReleaseData
//
//  Purpose:
//      Release the problem sized data associated with this plot.
//
//  Programmer: Dave Pugmire
//  Creation:   Thu Aug 26 12:43:22 EDT 2010
//
//  Modifications:
//
// ****************************************************************************
 
void
avtPoincarePlot::ReleaseData(void)
{
    avtSurfaceDataPlot::ReleaseData();
 
    if (shiftCenteringFilter != NULL)
        shiftCenteringFilter->ReleaseData();
    if (poincareFilter != NULL)
        poincareFilter->ReleaseData();
}


// ****************************************************************************
//  Method: avtPoincarePlot::EnhanceSpecification
//
//  Purpose:
//      Modifies the contract to tell it we want the "colorVar" to be the 
//      primary variable for the pipeline.  If we don't do that, the primary
//      variable will be some vector variable and it will confuse our mapper.
//      The only reason that this works is that the poincare filter 
//      understands the colorVar trick and produces that variable.
//
//  Programmer: Dave Pugmire
//  Creation:   Fri Nov  7 13:22:17 EST 2008
//
// ****************************************************************************

avtContract_p
avtPoincarePlot::EnhanceSpecification(avtContract_p in_contract)
{
    avtDataRequest_p in_dr = in_contract->GetDataRequest();
    const char *var = in_dr->GetVariable();
    avtDataRequest_p out_dr = new avtDataRequest(in_dr, "colorVar");
    out_dr->AddSecondaryVariable(var);
    out_dr->SetOriginalVariable(var);
    avtContract_p out_contract = new avtContract(in_contract, out_dr);
    return out_contract;
}

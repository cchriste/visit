/*****************************************************************************
*
* Copyright (c) 2000 - 2011, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                             avtPoincareFilter.C                           //
// ************************************************************************* //

#include <avtPoincareFilter.h>

#include <vtkAppendPolyData.h>
#include <vtkCellArray.h>
#include <vtkCellData.h>
#include <vtkCleanPolyData.h>
#include <vtkDataSet.h>
#include <vtkFloatArray.h>
#include <vtkPointData.h>
#include <vtkPolyData.h>
#include <vtkPolyLine.h>
#include <vtkQuad.h>
#include <vtkSlicer.h>
#include <vtkSphereSource.h>
#include <vtkTubeFilter.h>
#include <vtkUnstructuredGrid.h>

#include <avtDatasetExaminer.h>
#include <avtExtents.h>
#include <avtPoincareIC.h>
#include <utility>

#include "StreamlineAnalyzerLib.h"

#ifdef STRAIGHTLINE_SKELETON
#include "skelet.h"
#endif


using namespace std;

#define SIGN(x) ((x) < 0.0 ? -1 : 1)

static const int DATA_None = 0;
static const int DATA_OriginalValue = 1;
static const int DATA_InputOrder = 2;
static const int DATA_PointIndex = 3;
static const int DATA_Plane = 4;
static const int DATA_WindingOrder = 5;
static const int DATA_WindingPointOrder = 6;
static const int DATA_WindingPointOrderModulo = 7;
static const int DATA_ToroidalWindings = 8;
static const int DATA_PoloidalWindings = 9;
static const int DATA_SafetyFactor = 10;
static const int DATA_Confidence = 11;
static const int DATA_RidgelineVariance = 12;

// ****************************************************************************
//  Method: CreateSphere
//
//  Programmer:
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//
//   Dave Pugmire, Thu Jul  1 13:55:28 EDT 2010
//   Create a vertex instead of a sphere.
//   
//    Dave Pugmire, Mon Jul 12 15:34:29 EDT 2010
//    Remove rad argument.
//    
// ****************************************************************************

static vtkPolyData *
CreateSphere(float val, double p[3])
{
    vtkPoints *pt = vtkPoints::New();
    pt->SetNumberOfPoints(1);
    pt->SetPoint(0, p[0], p[1], p[2]);
    
    vtkPolyData *point = vtkPolyData::New();
    point->SetPoints(pt);
    pt->Delete();

    vtkIdType ids[1] = {0};
    point->Allocate(1);
    point->InsertNextCell(VTK_VERTEX, 1, ids);

    vtkFloatArray *arr = vtkFloatArray::New();
    arr->SetName("colorVar");
    arr->SetNumberOfTuples(1);
    arr->SetTuple1(0, val);
    point->GetPointData()->SetScalars(arr);
    arr->Delete();

    return point;
}


// ****************************************************************************
//  Method: avtPoincareFilter constructor
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//
//    Dave Pugmire, Wed Feb 25 09:52:11 EST 2009
//    Add terminate by steps, add AdamsBashforth solver,
//    Allen Sanderson's new code.
//
//    Dave Pugmire, Fri Apr 17 11:32:40 EDT 2009
//    Add variables for dataValue var.
//
//    Dave Pugmire, Tue Apr 28 09:26:06 EDT 2009
//    Changed color to dataValue
//
//    Dave Pugmire, Wed May 27 15:03:42 EDT 2009
//    Initialize points.
//
//    Dave Pugmire, Tue Aug 18 09:10:49 EDT 2009
//    Add ability to restart streamline integration.
//
// ****************************************************************************

avtPoincareFilter::avtPoincareFilter() :
    maximumToroidalWinding( 0 ),
    overrideToroidalWinding( 0 ),
    overridePoloidalWinding( 0 ),
    windingPairConfidence( 0.90 ),
    adjust_plane(-1),
    overlaps(1),

    is_curvemesh(1),
    dataValue(DATA_SafetyFactor),

    showOPoints( false ),
    OPointMaxIterations(2),
    XPointMaxIterations(2),
    showIslands( false ),
    showLines( true ),
    showPoints( false ),
    verboseFlag( true ),
    pointScale(1)
{
    planes.resize(1);
    planes[0] = 0;
//    fieldlines.erase( fieldlines.begin(), fieldlines.end() );
    intersectObj = NULL;
    maxIntersections = 0;
}


// ****************************************************************************
//  Method: avtPoincareFilter destructor
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//
//    Dave Pugmire, Wed May 27 15:03:42 EDT 2009
//    Zero out streaminePts.
//
// ****************************************************************************

avtPoincareFilter::~avtPoincareFilter()
{
//    fieldlines.erase( fieldlines.begin(), fieldlines.end() );
    if (intersectObj)
        intersectObj->Delete();
}

// ****************************************************************************
//  Method: avtPoincareFilter::PreExecute
//
//  Purpose:
//      Get the current spatial extents if necessary.
//
//  Programmer: Dave Pugmire
//  Creation:   Fri Nov  7 13:01:47 EST 2008
//
//  Modifications:
//
//
// ****************************************************************************

void
avtPoincareFilter::PreExecute(void)
{
    avtStreamlineFilter::PreExecute();
}


// ****************************************************************************
//  Method: avtPoincareFilter::PostExecute
//
//  Purpose:
//      Get the current spatial extents if necessary.
//
//  Programmer: Dave Pugmire
//  Creation:   Fri Nov  7 13:01:47 EST 2008
//
//  Modifications:
//
//    Hank Childs, Thu Aug 26 13:47:30 PDT 2010
//    Change extents names.
//
// ****************************************************************************

void
avtPoincareFilter::PostExecute(void)
{
    avtStreamlineFilter::PostExecute();
    
    double range[2];
    avtDataset_p ds = GetTypedOutput();
    avtDatasetExaminer::GetDataExtents(ds, range, "colorVar");

    avtExtents *e;
    e = GetOutput()->GetInfo().GetAttributes().GetThisProcsOriginalDataExtents();
    e->Merge(range);
    e = GetOutput()->GetInfo().GetAttributes().GetThisProcsActualDataExtents();
    e->Merge(range);
}

// ****************************************************************************
//  Method: avtPoincareFilter::CreateIntegralCurve
//
//  Purpose:
//      Create an integral curve and set its properties.
//
//  Programmer: Christoph Garth
//  Creation:   Thu July 15, 2010
//
//  Modifications:
//
//    Hank Childs, Fri Oct  8 23:30:27 PDT 2010
//    Create PoincareICs, not StateRecorderICs.
//
// ****************************************************************************

avtIntegralCurve *
avtPoincareFilter::CreateIntegralCurve( const avtIVPSolver* model,
                                        avtIntegralCurve::Direction dir,
                                        const double& t_start,
                                        const avtVector &p_start, long ID ) 
{
    // need at least these three attributes
    unsigned char attr = avtStateRecorderIntegralCurve::SAMPLE_POSITION;

    avtPoincareIC *rv = new avtPoincareIC( attr, model, dir, 
                                           t_start, p_start, ID );

    if (intersectObj)
        rv->SetIntersectionCriteria(intersectObj, maxIntersections);

    return rv;
}

// ****************************************************************************
//  Method: avtPoincareFilter::GetStreamlinePoints
//
//  Purpose:
//      Gets the points from the streamline and changes them in to a Vector.
//
//  Programmer: Dave Pugmire
//  Creation:   Tue Dec  23 12:51:29 EST 2008
//
//  Modifications:
//
//    Hank Childs, Fri Jun  4 19:58:30 CDT 2010
//    Use avtStreamlines, not avtStreamlineWrappers.
//
// ****************************************************************************

void
avtPoincareFilter::GetIntegralCurvePoints(vector<avtIntegralCurve *> &ics)
{
    for ( int i=0; i<ics.size(); ++i )
    {
        avtPoincareIC * poincare_ic = (avtPoincareIC *) ics[i];

        // Get all of the points from the streamline which are stored
        // as an array and move them into a vector for easier
        // manipulation by the analsysi code.
        poincare_ic->points.resize( poincare_ic->GetNumberOfSamples() );

        for( size_t p=0; p<poincare_ic->points.size(); ++p )
          poincare_ic->points[p] = poincare_ic->GetSample( p ).position;
    }
}

// ****************************************************************************
//  Method: avtPoincareFilter::Execute
//
//  Purpose:
//      Calculate poincare points.
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//    Dave Pugmire (for Allen Sanderson), Wed Feb 25 09:52:11 EST 2009
//    Add terminate by steps, add AdamsBashforth solver, Allen Sanderson's new code.
//
//    Dave Pugmire, Wed May 27 15:03:42 EDT 2009
//    Re-organization. GetStreamlinePoints removed.
//
//    Dave Pugmire, Tue Aug 18 09:10:49 EDT 2009
//    Add ability to restart streamline integration.
//
// ****************************************************************************

void
avtPoincareFilter::Execute()
{
    avtStreamlineFilter::Execute();

    vector<avtIntegralCurve *> ics;
    GetTerminatedIntegralCurves(ics);

    avtDataTree *dt = CreatePoincareOutput( ics );
    SetOutputDataTree(dt);
}

// ****************************************************************************
//  Method: avtPoincareFilter::ContinueExecute
//
//  Purpose:
//      See if execution needs to continue.
//
//  Programmer: Dave Pugmire
//  Creation:   Mon Aug 17 08:30:06 EDT 2009
//
//  Modifications:
//
//    Hank Childs, Sun Jun  6 11:53:33 CDT 2010
//    Use new names that have integral curves instead of fieldlines.
//
// ****************************************************************************

bool
avtPoincareFilter::ContinueExecute()
{
    debug5 << "Continue execute " << endl;

    vector<avtIntegralCurve *> ics;
    
    GetTerminatedIntegralCurves(ics);
    GetIntegralCurvePoints(ics);

    if (analysis && ! ClassifyStreamlines(ics))
    {
      vector< int > ids_to_delete;

      for ( int i=0; i<ics.size(); ++i )
      {
        avtPoincareIC * poincare_ic = (avtPoincareIC *) ics[i];

#ifdef STRAIGHTLINE_SKELETON
        cerr << "Looking at seed " << poincare_ic->id << "  "
             << poincare_ic->properties.type << "  " <<
          poincare_ic->properties.analysisState << endl;

        // For Island Chains add in the O Points.
        if( showOPoints &&

            (poincare_ic->properties.type ==
             FieldlineProperties::ISLAND_CHAIN ||

             poincare_ic->properties.type ==
             FieldlineProperties::ISLANDS_WITHIN_ISLANDS) &&

            poincare_ic->properties.analysisState ==
            FieldlineProperties::ADD_O_POINTS &&

            !(poincare_ic->properties.OPoints.empty()) )
        {
          poincare_ic->properties.analysisState =
            FieldlineProperties::COMPLETED;

          cerr << "Adding seed points" << endl;
            
          cerr << "Iterations " << poincare_ic->properties.iteration << "  " <<
            OPointMaxIterations << endl;

          if( poincare_ic->properties.iteration < OPointMaxIterations )
          {
            vector<avtIntegralCurve *> new_ics;
            AddSeedPoint( poincare_ic->properties.OPoints[0], ics );
          
            for( unsigned int i=0; i<new_ics.size(); i++ )
            {
                cerr << "New island seed ids " << new_ics[i]->id << "  ";

                avtPoincareIC * seed_poincare_ic = (avtPoincareIC *) new_ics[i];

                // Transfer and update properties.
                seed_poincare_ic->properties = poincare_ic->properties;
              
                seed_poincare_ic->properties.source =
                  FieldlineProperties::ISLAND_CHAIN;

                seed_poincare_ic->properties.iteration =
                  poincare_ic->properties.iteration + 1;
            }

            cerr << endl;
          }

          // The source was an island_chain so delete it as it was an
          // iterative process.
          if( poincare_ic->properties.source ==
              FieldlineProperties::ISLAND_CHAIN )
          {
            cerr << "Deleting old O Point seed " <<  poincare_ic->id << endl;

            ids_to_delete.push_back( poincare_ic->id );
          }
        }
#endif
      }

      DeleteIntegralCurves( ids_to_delete );

      return true;
    }
    // No analysis requested or analysis complete, no need to
    // continue.
    else 
       return false;
}


// ****************************************************************************
//  Method: avtPoincareFilter::UpdateDataObjectInfo
//
//  Purpose:
//      Allows the filter to change its output's data object information, which
//      is a description of the data object.
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//    Jeremy Meredith, Wed Apr  8 13:23:10 EDT 2009
//    Set topological dimension and normals request appropriately.
//
// ****************************************************************************

void
avtPoincareFilter::UpdateDataObjectInfo(void)
{ 
    avtStreamlineFilter::UpdateDataObjectInfo();

    avtDataAttributes &atts = GetOutput()->GetInfo().GetAttributes();
    avtDataValidity   &val  = GetOutput()->GetInfo().GetValidity();
    if (is_curvemesh)
    {
        atts.SetTopologicalDimension(1);
        val.SetNormalsAreInappropriate(true);
    }
    else
    {
        atts.SetTopologicalDimension(2);
        val.SetNormalsAreInappropriate(false);
    }

    if (! atts.ValidVariable("colorVar"))
    {
        atts.AddVariable("colorVar");
        atts.SetActiveVariable("colorVar");
        atts.SetVariableDimension(1);
    }
}

// ****************************************************************************
//  Method: avtPoincareFilter::ClassifyStreamlines
//
//  Purpose:
//      Classify the streamlines (toroidal/poloidal winding).
//
//  Arguments:
//
//  Returns:      void
//
//  Programmer: Dave Pugmire
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//    Dave Pugmire (for Allen Sanderson), Wed Feb 25 09:52:11 EST 2009
//    Add terminate by steps, add AdamsBashforth solver, Allen Sanderson's new 
//    code.
//
//    Dave Pugmire, Tue Aug 18 09:10:49 EDT 2009
//    Add ability to restart streamline integration.
//
//    Hank Childs, Fri Jun  4 19:58:30 CDT 2010
//    Use avtStreamlines, not avtStreamlineWrappers.
//
//    Hank Childs, Fri Oct  8 23:30:27 PDT 2010
//    Max intersections is now represented by an explicit data member, not
//    by generic "termination" field.
//
// ****************************************************************************

bool
avtPoincareFilter::ClassifyStreamlines(vector<avtIntegralCurve *> &ics)
{
    FusionPSE::FieldlineLib FLlib;
    FLlib.verboseFlag = verboseFlag;

    debug5 << "Classifying Fieldlines " << endl;

    bool analysisComplete = true;

    for ( int i=0; i<ics.size(); ++i )
    {
        avtPoincareIC * poincare_ic = (avtPoincareIC *) ics[i];

        FieldlineProperties fp = poincare_ic->properties;

        // If the analysis is completed then skip it.
        if( fp.analysisState == FieldlineProperties::COMPLETED ||
            fp.analysisState == FieldlineProperties::TERMINATED )
        {
          cerr <<"Skipping Classified Streamline: id = "
               << poincare_ic->id << endl;

          continue;
        }

        poincare_ic->properties.maxPunctures = maxPunctures;

        FLlib.fieldlineProperties( poincare_ic->points,
                                   poincare_ic->properties,
                                   overrideToroidalWinding,
                                   overridePoloidalWinding,
                                   maximumToroidalWinding,
                                   windingPairConfidence,
                                   showOPoints );

        fp = poincare_ic->properties;

        // Make the number of punctures 2x because the Poincare analysis
        // uses only the punctures in the same direction as the plane normal
        // while the streamline uses the plane regardless of the normal.

        if( fp.nPuncturesNeeded > maxPunctures )
          fp.nPuncturesNeeded = maxPunctures;

        // Check to see if there are enough points for the analysis.
        if( fp.nPuncturesNeeded != 0 &&
            fp.nPuncturesNeeded != poincare_ic->maxIntersections/2 )
        {
          analysisComplete = false;

          poincare_ic->maxIntersections = 2 * fp.nPuncturesNeeded;
          poincare_ic->status = avtIntegralCurve::STATUS_OK;
        }
        else
        {
          poincare_ic->status = avtIntegralCurve::STATUS_FINISHED;
        }

        cerr << fp.analysisState << endl;

        // See if O Points from an island need to be added.
        if( fp.analysisState & FieldlineProperties::ADD_O_POINTS )
          analysisComplete = false;

        double safetyFactor;
        
        if ( fp.poloidalWinding > 0 )
            safetyFactor =
              (double) fp.toroidalWinding / (double) fp.poloidalWinding;
        else
            safetyFactor = 0;

        if(verboseFlag )
          cerr << "Classify Streamline: id = "<< poincare_ic->id
               << "  ptCnt = " << poincare_ic->points.size()
               << "  type = " << fp.type
               << "  toroidal/poloidal windings = " <<  fp.toroidalWinding
               << "/" << fp.poloidalWinding
               << "  (" << safetyFactor << ")"
               << "  windingGroupOffset = " << fp.windingGroupOffset
               << "  islands = " << fp.islands
               << "  nodes = " << fp.nnodes
               << "  confidence = " << fp.confidence
               << "  toroidalPeriod = " << fp.toroidalPeriod
               << "  poloidalPeriod = " << fp.poloidalPeriod
               << "  complete " << (fp.analysisState == FieldlineProperties::COMPLETED ? "Yes " : "No ")
//               << (poincare_ic->ic->status == avtIntegralCurve::STATUS_FINISHED ? 
//                   0 : poincare_ic->ic->maxIntersections )
               << endl << endl;
    }

    debug5 << "Classifying Streaming "
         << (analysisComplete ? "Analysis completed" : "Analysis was not complete")
         << endl;

    return analysisComplete;
}

// ****************************************************************************
//  Method: avtPoincareFilter::misc crap
//
//  Purpose:
//      Create poincare output
//
//  Arguments:
//
//  Returns:      Poincare segments
//
//  Programmer: Allen Sanderson
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************
template< class T > int
pairsortfirst( const pair < T, T > s0, const pair < T, T > s1 )
{
  return (s0.first > s1.first );
}

template< class T > int
pairsortsecond( const pair < T, T > s0, const pair < T, T > s1 )
{
  return (s0.second > s1.second );
}

void realDFTamp( vector< double > &g, vector< double > &G )
{
  unsigned int N = g.size();

  G.resize(N/2);

  for(unsigned int i=0; i<N/2; i++)
  {
    double freq = double(i) / double(N);

    double GRe = 0;
    double GIm = 0;

    for( unsigned int j=0; j<N; j++)
    {
      double a = -2.0 * M_PI * double(j) * freq;
//    if(inverse) a *= -1.0;
      double ca = cos(a);
      double sa = sin(a);
      
      GRe += g[j] * ca; // - in[x][1] * sa;
      GIm += g[j] * sa; // + in[x][1] * ca;
    }

    G[i] = sqrt(GRe*GRe + GIm*GIm);
  }
}


// ****************************************************************************
//  Method: avtPoincareFilter::CreatePoincareOutput
//
//  Purpose:
//      Create poincare output
//
//  Arguments:
//
//  Returns:      Poincare segments
//
//  Programmer: Dave Pugmire
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//    Dave Pugmire (for Allen Sanderson), Wed Feb 25 09:52:11 EST 2009
//    Add terminate by steps, add AdamsBashforth solver, Allen Sanderson's new code.
//
//    Dave Pugmire, Fri Apr 17 11:32:40 EDT 2009
//    Add variables for dataValue var.
//
//    Dave Pugmire, Tue Apr 28 09:26:06 EDT 2009
//    Changed color to dataValue
//
//    Dave Pugmire, Wed May 27 15:03:42 EDT 2009
//    Replaced cerr/cout with debug5.
//
// ****************************************************************************
avtDataTree *
avtPoincareFilter::CreatePoincareOutput(vector<avtIntegralCurve *> &ic)
{
    FusionPSE::FieldlineLib FLlib;
    FLlib.verboseFlag = verboseFlag;

    debug5 << "Creating output " << endl;

    avtDataTree *dt = new avtDataTree();
    
    for ( int i=0; i<ic.size(); ++i )
    {
        avtPoincareIC * poincare_ic = (avtPoincareIC *) ic[i];

        FieldlineProperties &properties = poincare_ic->properties;

        FieldlineProperties::FieldlineType type = properties.type;
        bool complete =
          (properties.analysisState == FieldlineProperties::COMPLETED);

        unsigned int toroidalWinding    = properties.toroidalWinding;
        unsigned int poloidalWinding    = properties.poloidalWinding;
        unsigned int islands            = properties.islands;
        unsigned int windingGroupOffset = properties.windingGroupOffset;
        unsigned int nnodes             = properties.nnodes;
        double confidence               = properties.confidence;
        unsigned int toroidalPeriod     = properties.toroidalPeriod;
        unsigned int poloidalPeriod     = properties.poloidalPeriod;
        double ridgelineVariance        = properties.ridgelineVariance;

        vector< avtVector > &OPoints         = properties.OPoints;

        bool completeIslands = true;

        if( verboseFlag ) 
        {
          cerr << "Surface id = " << poincare_ic->id << "  "
               << "< " << poincare_ic->points[0].x << " "
               << poincare_ic->points[0].y << " "
               << poincare_ic->points[0].z << " >  "
               << toroidalPeriod << ":" << poloidalPeriod << "  "
               << toroidalWinding << ":" << poloidalWinding << " ("
               << (double) toroidalWinding / (double) poloidalWinding << ")  ";

          if( type == FieldlineProperties::RATIONAL )
            cerr << "rational surface  ";

          else if( type == FieldlineProperties::FLUX_SURFACE )
            cerr << "flux surface  ";

          else if( type == FieldlineProperties::ISLAND_CHAIN )
            cerr << islands << " island chain  ";

          else if( type == FieldlineProperties::ISLANDS_WITHIN_ISLANDS )
            cerr << islands << " islands within islands  ";

          else if( type == FieldlineProperties::CHAOTIC )
            cerr << "chaotic  ";

          else if( type == FieldlineProperties::UNKNOWN_TYPE )
            cerr << "unknown  ";

          cerr << "with " << nnodes << " nodes"
               << (complete ? " (Complete)  " : "  ")
//               << "confidence " << confidence
               << endl;

          if( (type == FieldlineProperties::ISLAND_CHAIN ||
               type == FieldlineProperties::ISLANDS_WITHIN_ISLANDS) &&
              islands != toroidalWinding ) 
            cerr << "WARNING - The island count does not match the toroidalWinding count" << endl;
        }
    
        // If toroidal winding is zero, skip it.
        if( type == FieldlineProperties::CHAOTIC )
        {
          if( showChaotic )
          {
            if( toroidalWinding == 0 )
              toroidalWinding = 1;
            if( poloidalWinding == 0 )
              poloidalWinding = 1;
          }
          else
          {
            continue;
          }
        }
        else if( type == FieldlineProperties::UNKNOWN_TYPE ) 
        {
          if( analysis == 0 )
          {
            toroidalWinding = 1;
          }
          else
          {
            if( verboseFlag ) 
              cerr << " id = " << poincare_ic->id
                   << " SKIPPING UNKNOWN TYPE " << endl;
            
            std::pair< unsigned int, unsigned int > topo( 0, 0 );
            
            continue;
          }
        }
        else if( toroidalWinding == 0 ) 
        {
            if( verboseFlag ) 
              cerr << " id = " << poincare_ic->id
                   << " SKIPPING TOROIDALWINDING OF 0" << endl;
            
            std::pair< unsigned int, unsigned int > topo( 0, 0 );
            
            continue;
        }

        // Get the direction of the streamline toroidalWinding.
        Point lastPt = poincare_ic->points[0];
        Point currPt = poincare_ic->points[1];
        
        bool CCWstreamline = (atan2( lastPt.y, lastPt.x ) <
                              atan2( currPt.y, currPt.x ));
        
        double lastDist, currDist;

        // Put all of the points into the bins for each plane.
        std::vector< std::vector< std::vector < avtVector > > > puncturePts;
        
        puncturePts.resize( planes.size() );

        std::vector < avtVector > tempPts;

        std::vector< std::vector < avtVector > > islandPts;
        
        unsigned int startIndex = 0;
        
        for( unsigned int p=0; p<planes.size(); ++p ) 
        {
            Vector planeN;
            Vector planePt(0,0,0);
            
            if( puncturePlane == 0 ) // Poloidal Plane
            {
              // Go through the planes in the same direction as the streamline.
              if( CCWstreamline )
              {
                planeN = Vector( cos(planes[p]),
                                 sin(planes[p]),
                                 0 );
              }
              else
              {
                planeN = Vector( cos(planes[planes.size()-1-p]),
                                 sin(planes[planes.size()-1-p]),
                                 0 );
              }
            }

            else //if( puncturePlane == 1 ) // Toroidal Plane
            {
              planeN = Vector( 0, 0, -1 );
            }

            // Set up the plane equation.
            double plane[4];
            
            plane[0] = planeN.x;
            plane[1] = planeN.y;
            plane[2] = planeN.z;
            plane[3] = planePt.dot(planeN);
            
            puncturePts[p].resize( toroidalWinding );
            int bin = 0;
            
            // So to get the winding groups consistant start examining
            // the streamline in the same place for each plane.
            currPt = poincare_ic->points[startIndex];
            currDist = planeN.dot( currPt ) - plane[3];
            
            for( unsigned int j=startIndex+1; j<poincare_ic->points.size(); ++j )
            {
                lastPt = currPt;
                currPt = Vector(poincare_ic->points[j]);
                
                lastDist = currDist;
                currDist = Dot( planeN, currPt ) - plane[3];
                
                // First look at only points that intersect the plane.
                if( SIGN(lastDist) != SIGN(currDist) ) 
                {
                    Vector dir(currPt-lastPt);
                    
                    double dot = Dot(planeN, dir);
                    
                    // If the segment is in the same direction as the plane then
                    // find where it intersects the plane.
                    if( dot > 0.0 )
                    {
                        // In order to get the winding groups
                        // consistant start examining the streamline
                        // in the same place for each plane so store
                        // the index of the first puncture point.
                        if( startIndex == 0 )
                            startIndex = j - 1;
                        
                        Vector w = lastPt - planePt;
                        
                        double t = -Dot(planeN, w ) / dot;
                        
                        Point point = Point(lastPt + dir * t);
                        
                        puncturePts[p][bin].push_back( point );
                        
                        if( p == 0 && puncturePts[p][bin].size() > 1 )
                        {
                          int ic = puncturePts[p][bin].size()-2;

                          double len = (puncturePts[p][bin][ic]-
                                        puncturePts[p][bin][ic+1]).length();
                  
                          tempPts.push_back( Point( (float) tempPts.size()/50.0,
                                                    0,
                                                    len) );
                        }

                        bin = (bin + 1) % toroidalWinding;

                    }
                }
            }

            if( p == 0 && islands )
            {
              int offset = nnodes;
              
              islandPts.resize( toroidalWinding );
              
              for( unsigned int i=0; i<toroidalWinding; ++i )
              {
                for( unsigned int j=offset; j<puncturePts[p][i].size(); ++j )
                {
                  double len = (puncturePts[p][i][j-offset]-
                                puncturePts[p][i][j]).length();
                  
                  islandPts[i].push_back( Point( (float) islandPts[i].size()/50.0,
                                                 0,
                                                 -1.5+(float)i*.1+len) );
                  
                }
                
//              vector< pair< unsigned int, double > > stats;           
//              FLlib.periodicityStats( islandPts[i], stats, 2 );
              }
            }
        }
        

        // Get the ridgeline points. There is one point between each
        // Z plane puncture.
        Vector planeN( 0, 0, 1 );
        Vector planePt(0,0,0);
        
        // Set up the plane equation.
        double plane[4];

        plane[0] = planeN.x;
        plane[1] = planeN.y;
        plane[2] = planeN.z;
        plane[3] = planePt.dot(planeN);
            
        std::vector < avtVector > ridgelinePts;

        // Start looking for the z max after the first Z plane
        // intersetion is found.
        bool haveFirstIntersection = false;
        double maxZ = 0;

        // To get the winding groups consistant start examining the
        // streamline in the same place for each plane.
        currPt = poincare_ic->points[0];
        currDist = planeN.dot( currPt ) - plane[3];
            
        for( unsigned int j=startIndex+1;
             j<poincare_ic->points.size();
             ++j )
        {
          lastPt = currPt;
          currPt = Vector(poincare_ic->points[j]);
          
          lastDist = currDist;
          currDist = Dot( planeN, currPt ) - plane[3];
          
          // First look at only points that intersect the plane.
          if( SIGN(lastDist) != SIGN(currDist) ) 
          {
            Vector dir(currPt-lastPt);
            
            double dot = Dot(planeN, dir);
            
            // If the segment is in the same direction as the plane then
            // record the max Z value.
            if( dot > 0.0 )
            {
              if( haveFirstIntersection )
              {
                ridgelinePts.push_back( Point( (float) ridgelinePts.size()/50.0,
                                               0,
                                               maxZ) );
              }
              else
                haveFirstIntersection = true;

              maxZ = 0;
            }
          }

          if( maxZ < currPt.z )
            maxZ = currPt.z;
        }
   
//      // Get the rest of the info only from the phi = zero plane.
//         unsigned int p;
        
//         if( CCWstreamline )
//             p = 0;
//         else
//             p = planes.size()-1;
        
//         // Get the centroid of each toroidal winding group and all
//         // puncture points.

//      Vector globalCentroid(0,0,0);
//      unsigned int npts = 0;

//         std::vector< Vector > localCentroids;
//         std::vector< Vector > localSeparatrices[2];
        
//         localCentroids.resize(toroidalWinding);
//         localSeparatrices[0].resize(toroidalWinding);
//         localSeparatrices[1].resize(toroidalWinding);
        
//         for( unsigned int j=0; j<toroidalWinding; ++j ) 
//         {
//             localCentroids[j] = Vector(0,0,0);
            
//             for( unsigned int k=0; k<puncturePts[p][j].size(); ++k ) 
//                 localCentroids[j] += (Vector) puncturePts[p][j][k];
            
//             if( puncturePts[p][j].size() ) 
//             {
//                 localCentroids[j] /= (double) puncturePts[p][j].size();
//          }
//         }


//         // Get the direction of the points within a group.
//         //    Vector v0 = (Vector) puncturePts[p][0][0] - globalCentroid;
//         //    Vector v1 = (Vector) puncturePts[p][0][1] - globalCentroid;
        
//         //    bool groupCCW = (FLlib.ccw( v0, v1 ) == 1);
//         //    cerr << 0.0<< "  " << groupCCW << endl;
        
//         if( type == ISLAND_CHAIN ) 
//         {
//             for( unsigned int j=0; j<toroidalWinding; ++j ) 
//             {
//                 unsigned int startIndex;
//                 unsigned int middleIndex;
//                 unsigned int stopIndex;
//                 unsigned int nodes;
                
//                 Vector localCentroid;
                
//                 unsigned int turns =
//                     FLlib.islandProperties( puncturePts[p][j], localCentroid,
//                                             startIndex, middleIndex, stopIndex, nodes );
                
//                 //      cerr << "Island " << i  << "   "
//                 //           << "Turns " << turns  << "   "
//                 //           << "nodes " << nodes  << "   "
//                 //           << "Indexes "
//                 //           << startIndex  << "  "
//                 //           << middleIndex << "  "
//                 //           << stopIndex   << endl;
                
                
//              if( turns < 3 )
//                completeIslands = false;
                
//                 if( turns >= 2 ) 
//                 {
//                     //        localSeparatrices[0][j] = (Vector) puncturePts[p][j][startIndex];
//                     //        localSeparatrices[1][j] = (Vector) puncturePts[p][j][middleIndex];
//                 }
                
//                 if( turns == 3 ) 
//                 {
//                     unsigned int index0 = (middleIndex - startIndex ) / 2;
//                     unsigned int index1 = (  stopIndex - middleIndex) / 2;
                    
//                     //      cerr << "Indexes mid " << nodes << " nodes "
//                     //           << "  " << ( startIndex + index0)%nodes 
//                     //           << "  " << (middleIndex - index0)%nodes
//                     //           << "  " << (middleIndex + index1)%nodes
//                     //           << "  " << (  stopIndex - index1)%nodes << endl;
                    
//                     localCentroids[j] =
//                         ( (Vector) puncturePts[p][j][( startIndex + index0)%nodes] + 
//                           (Vector) puncturePts[p][j][(middleIndex - index0)%nodes] +
                          
//                           (Vector) puncturePts[p][j][(middleIndex + index1)%nodes] + 
//                           (Vector) puncturePts[p][j][(  stopIndex - index1)%nodes] ) / 4.0;
//                 }
//                 else if( turns == 2 ) 
//                 {
//                     unsigned int index0 = (middleIndex - startIndex ) / 2;
                    
//                     //      cerr << "Indexes mid " << nodes << " nodes "
//                     //           << "  " << ( startIndex + index0)%nodes 
//                     //           << "  " << (middleIndex - index0)%nodes
//                     //           << "  " << (middleIndex + index1)%nodes
//                     //           << "  " << (  stopIndex - index1)%nodes << endl;
                    
//                     localCentroids[j] =
//                         ( (Vector) puncturePts[p][j][( startIndex + index0)%nodes] + 
//                           (Vector) puncturePts[p][j][(middleIndex - index0)%nodes] ) / 2.0;
                    
//                 } 
//                 else if( turns == 1 ) 
//                 {
//                     unsigned int index0 = (stopIndex - startIndex ) / 2;
                    
//                     //      cerr << "Indexes mid " << nodes << " nodes "
//                     //           << "  " << ( startIndex + index0)%nodes 
//                     //           << "  " << (middleIndex - index0)%nodes
//                     //           << "  " << (middleIndex + index1)%nodes
//                     //           << "  " << (  stopIndex - index1)%nodes << endl;
                    
//                     localCentroids[j] =
//                         ( (Vector) puncturePts[p][j][(startIndex + index0)%nodes] + 
//                           (Vector) puncturePts[p][j][( stopIndex - index0)%nodes] ) / 2.0;
//                 }
                
//                 //      // Get the principal axes of the island.
//                 //      Vector localCentroid(0,0,0);
                
//                 //      for( unsigned int k=0; k<puncturePts[p][j].size(); ++k )
//                 //        localCentroid += (Vector) puncturePts[p][j][k];
                
//                 //      localCentroid /= (float) puncturePts[p][j].size();
                
//                 //      float Ixx = 0.0;
//                 //      float Ixz = 0.0;
//                 //      float Izz = 0.0;
                
//                 //      double maxDist = 0;
                
//                 //      for( unsigned int k=0; k<puncturePts[p][j].size(); k++ ) {
                
//                 //        Vector vec = (Vector) puncturePts[p][j][k] - localCentroid;
                
//                 //        if( maxDist < vec.length() )
//                 //          maxDist = vec.length();
                
//                 //        Ixx += vec.z()*vec.z();
//                 //        Ixz -= vec.x()*vec.z();
//                 //        Izz += vec.x()*vec.x();
//                 //      }
                
//                 //      float alpha = atan( 2.0 * Ixz / (Ixx - Izz) ) / 2.0;
                
//                 // //       cerr << "PRINCIPAL AXES " << alpha * 180.0 / M_PI << "    "
//                 // //      << Ixx + Ixz * sin(alpha       )/cos(alpha       ) << "    "
//                 // //      << Izz + Ixz * cos(alpha+M_PI/2)/sin(alpha+M_PI/2) << endl;
                
//                 //      if( Ixx + Ixz * sin(alpha       )/cos(alpha       ) >
//                 //          Izz + Ixz * cos(alpha+M_PI/2)/sin(alpha+M_PI/2) )
//                 //        localCentroid += Vector(  cos(alpha), 0, sin(alpha) ) * maxDist;
//                 //      else
//                 //        localCentroid += Vector( -sin(alpha), 0, cos(alpha) ) * maxDist;
                
//                 //      localCentroids[j] = localCentroid;
                
//             }
//         }  // if( type == ISLAND_CHAIN )

        for( unsigned int p=0; p<planes.size(); p++ ) 
        {
            if( type == FieldlineProperties::UNKNOWN_TYPE ||
                type == FieldlineProperties::CHAOTIC )
              nnodes = puncturePts[p][0].size();

            else if( type == FieldlineProperties::FLUX_SURFACE )
            {
                if( overlaps == 1 || overlaps == 3 )
                    FLlib.removeOverlap( puncturePts[p], nnodes,
                                         toroidalWinding, poloidalWinding,
                                         windingGroupOffset, islands );
                if( overlaps == 2 )
                    FLlib.mergeOverlap( puncturePts[p], nnodes,
                                        toroidalWinding, poloidalWinding,
                                        windingGroupOffset, islands );
                else if( overlaps == 3 )
                    FLlib.smoothCurve( puncturePts[p], nnodes,
                                       toroidalWinding, poloidalWinding,
                                       windingGroupOffset, islands );
            }
            else if( type == FieldlineProperties::ISLAND_CHAIN )
            {
              if( overlaps != 0 )
              {
                if( properties.analysisState == FieldlineProperties::COMPLETED )
                {
                  // Loop through each island.
                  for( unsigned int i=0; i<toroidalWinding; i++ )
                  {
                    // Erase all of the overlapping points.
                    puncturePts[p][i].erase( puncturePts[p][i].begin()+nnodes,
                                             puncturePts[p][i].end() );
                    
                    // Close the island if it is complete
                    puncturePts[p][i].push_back( puncturePts[p][i][0] );
                  }
                }
                else
                {
                  // If the analysis did result in a complete island try
                  // to find the boundary manually
//                if( verboseFlag )
//                  cerr << "Cleaning up island " << endl;

//                FLlib.removeOverlap( puncturePts[p], nnodes,
//                                     toroidalWinding, poloidalWinding,
//                                     windingGroupOffset, islands );
                }
              }
            }
            
            bool VALID = true;
            
            // Sanity check
            for( unsigned int j=0; j<toroidalWinding; ++j ) 
            {
                if( nnodes > puncturePts[p][j].size() )
                    nnodes = puncturePts[p][j].size();
                
                if( puncturePts[p][j].size() < 1 ) 
                {
                    if( verboseFlag ) 
                      cerr << "Clean up check failed - Plane " << p
                           << " bin  " << j
                           << " number of points " << puncturePts[p][j].size()
                           << endl;
                    
                    VALID = false;
                    
//                    return NULL;
                }
                
                //      cerr << "Surface " << i
                //           << " plane " << p
                //           << " bin " << j
                //           << " base number of nodes " << nnodes
                //           << " number of points " << puncturePts[p][j].size()
                //           << endl;
            }
        }


        if( !showIslands ||
            (showIslands &&
             (type == FieldlineProperties::ISLAND_CHAIN ||
              type == FieldlineProperties::ISLANDS_WITHIN_ISLANDS)) )
        {
            double color_value;
            
            if( dataValue == DATA_OriginalValue ||
                dataValue == DATA_InputOrder )
                color_value = poincare_ic->id;
            else if( dataValue == DATA_ToroidalWindings )
                color_value = toroidalWinding;
            else if( dataValue == DATA_PoloidalWindings )
                color_value = poloidalWinding;
            else if( dataValue == DATA_SafetyFactor )
                color_value = (double) toroidalWinding / (double) poloidalWinding;
            else if( dataValue == DATA_Confidence )
              color_value = confidence;
            else if( dataValue == DATA_RidgelineVariance )
              color_value = ridgelineVariance;
            else
              color_value = 0;

            // Currently the surface mesh is a structquad so set the dims - it
            // really should be and unstructured surface so multiple surface
            // can be generated.
            if( is_curvemesh ) 
            {
              if( type == FieldlineProperties::UNKNOWN_TYPE ||
                  type == FieldlineProperties::CHAOTIC )
              {
                bool tmpLines  = showLines;
                bool tmpPoints = showPoints;

                if( windingGroupOffset == 0 )
                {
                  showLines  = false;
                  showPoints = true;
                }

                drawIrrationalCurve( dt, puncturePts, nnodes, islands,
                                     windingGroupOffset,
                                     dataValue, color_value, 0, 0 );

                showLines  = tmpLines;
                showPoints = tmpPoints;
              }
              else if( type == FieldlineProperties::RATIONAL )
              {
                drawRationalCurve( dt, puncturePts, nnodes, islands,
                                   windingGroupOffset,
                                   dataValue, color_value );
              }
              else if( type == FieldlineProperties::ISLANDS_WITHIN_ISLANDS )
              {
                drawIrrationalCurve( dt, puncturePts, nnodes, islands,
                                     windingGroupOffset,
                                     dataValue, color_value,
                                     false,
                                     true );
              }
              else if( type & FieldlineProperties::IRRATIONAL )
              {
                drawIrrationalCurve( dt, puncturePts, nnodes, islands,
                                     windingGroupOffset,
                                     dataValue, color_value,
                                     overlaps ? true : false,
                                     dataValue == DATA_WindingPointOrderModulo );
              }

              if( showOPoints &&
                  (type == FieldlineProperties::ISLAND_CHAIN ||
                   type == FieldlineProperties::ISLANDS_WITHIN_ISLANDS) )
              {
                drawPoints( dt, OPoints );
              }
            }
            else
            {
              drawSurface( dt, puncturePts, nnodes, islands,
                           windingGroupOffset,
                           dataValue, color_value );
            }

            if( show1DPlots )
              drawPeriodicity( dt, tempPts,
                               toroidalPeriod,
//                             tempPts.size(),
                               nnodes, islands, poloidalWinding,
                               dataValue, color_value, true );

            
            if( show1DPlots )
              drawPeriodicity( dt, ridgelinePts,
                               poloidalPeriod,
//                             ridgelinePts.size(),
                               nnodes, islands, poloidalWinding,
                               dataValue, color_value, true );
            

            if( islands && show1DPlots )
            {
              for( unsigned int i=0; i<toroidalWinding; ++i )
              {
                drawPeriodicity( dt, islandPts[i],
                                 islandPts[i].size(),
                                 nnodes, islands, poloidalWinding,
                                 dataValue, color_value, true );
              }
            }

//     double best_period = 0;
//     double best_amp = 0;


//     vector< unsigned int > periodList;

//     for(unsigned int p=2; p<ridgelinePts.size()/2; p++)
//     {
//       unsigned int N = p * (ridgelinePts.size() / p);

//       if( find( periodList.begin(), periodList.end(), N/2 ) != periodList.end())
//      continue;
//       else
//      periodList.push_back( N/2 );

//       vector< pair < double, double > > dft;
//       dft.resize( N/2 );

//       vector< pair < double, double > > g, G;

//       g.resize( N/2 );
//       G.resize( N/2 );

//       double local_best_period = 0;
//       double local_best_amp = 0;

//       for(unsigned int f=1; f<N/2; f++)
//       {
//      double freq = double(f) / double(N);
        
//      double GRe = 0;
//      double GIm = 0;

//      for( unsigned int cc=0; cc<N; cc++)
//      {
//        double a = -2.0 * M_PI * double(cc) * freq;
// //        if(inverse) a *= -1.0;
//        double ca = cos(a);
//        double sa = sin(a);
          
//        GRe += ridgelinePts[cc].z * ca; // - in[x][1] * sa;
//        GIm += ridgelinePts[cc].z * sa; // + in[x][1] * ca;
//      }

//      G[f].first  = GRe;
//      G[f].second = GIm;

//      double amp = sqrt(GRe*GRe + GIm*GIm);

//      dft[f] = pair< double, double >(freq, amp);

//      if( local_best_amp < amp )
//      {
//        local_best_amp = amp;
//        local_best_period = 1.0 / freq;
//      }
//       }

//       if( best_amp < local_best_amp )
//       {
//      best_amp = local_best_amp;
//      best_period = local_best_period;
//       }
      
//       cerr << "local  "
//         << p << "  "
//         << N << "  "
//         << local_best_period << "  " << local_best_amp << endl;
      
//       continue;
      
//       for( unsigned int cc=1; cc<N/2; ++cc )
//       {
//      double period = ((int) (10000.0 / dft[cc].first) / 10000.0);
        
//      double amp_1 = dft[cc-1].second;
//      double amp   = dft[cc  ].second;
//      double amp1  = dft[cc+1].second;
        
// //       cerr << period << "  "
// //      << dft[cc].first  << "  "
// //      << dft[cc].second << "  "
// //      << ((amp_1<amp && amp>amp1) ? "******" : "")
// //      << endl;
//       }
//     }
    
//     cerr << "best overall  "
//       << best_period << "  " << best_amp << endl;

    ///////////////////////////
  
//     best_period = 0;
//     best_amp = 0;

//     unsigned int N = ridgelinePts.size();

//     vector< double > height;
//     vector< double > Gamp;
//     vector< double > gamp;

//     height.resize( N );

//     for( unsigned int cc=0; cc<N; cc++)
//       height[cc] = ridgelinePts[cc].z;

//     // DFT of the original height signal
//     realDFTamp( height, Gamp );

// //     ridgelinePts.resize( N / 2 );
// //     ridgelinePts[0].z = 0;
// //     for(unsigned int f=1; f<ridgelinePts.size(); f++)
// //       ridgelinePts[f].z = Gamp[f] / 100.0;

//     // Throw awway the DC component and compute the log of the amplitude.
//     gamp.resize( Gamp.size() - 1 );

//     for( unsigned int cc=1; cc<Gamp.size(); cc++)
//       gamp[cc-1] = log2( Gamp[cc] );

//     // DFT of the amplitude signal
//     realDFTamp( gamp, Gamp );

//     bool foundFirstMin = false;
//     double last_amp = 1.0e15;

//     for(unsigned int cc=1; cc<Gamp.size(); cc++)
//     {
//       cerr << cc << "  " << Gamp[cc];

//       if( 1<cc && cc<Gamp.size()-1 &&
//        Gamp[cc-1] < Gamp[cc] && Gamp[cc] > Gamp[cc+1] )
//      cerr << "**" << endl;
//       else
//      cerr << endl;

//       if( !foundFirstMin && last_amp < Gamp[cc] )
//      foundFirstMin = true;

//       if( foundFirstMin && best_amp < Gamp[cc] )
//       {
//        best_amp = Gamp[cc];
//        best_period = cc;
//       }

//       last_amp = Gamp[cc];
//     }

//     cerr << __LINE__ << endl;

//     cerr << "best  " << best_period << "  " << best_amp << endl;

 //    ridgelinePts.resize( Gamp.size() - 1 );
//     for(unsigned int f=1; f<Gamp.size(); f++)
//       ridgelinePts[f-1].z = Gamp[f] / 100.0;


//     loadPoints( dt, ridgelinePts, ridgelinePts.size(),
//              nnodes, islands, poloidalWinding,
//              dataValue, color_value, true );
        }
    }
    
    if( verboseFlag ) 
        cerr << endl << endl << "count " << ic.size() << endl << endl;

    debug5 << "Finished creating output " << endl;
    
    return dt;
}

// ****************************************************************************
//  Method: avtPoincareFilter::drawRationalCurve
//
//  Purpose: This method is for RATIONAL surfaces.
//           Creates a curve from the puncture points. Each curve
//           represents one toroidal winding group. 
//
//  Arguments:
//
//  Returns:      void
//
//  Programmer: Allen Sanderson
//  Creation:   Wed Feb 25 09:52:11 EST 2009
//
//  Modifications:
//
// ****************************************************************************

void
avtPoincareFilter::drawRationalCurve( avtDataTree *dt,
                                      vector< vector < vector < avtVector > > > &nodes,
                                      unsigned int nnodes,
                                      unsigned int islands,
                                      unsigned int skip,
                                      unsigned int color,
                                      double color_value ) 
{
    vtkAppendPolyData *append = vtkAppendPolyData::New();
    
    unsigned int nplanes = nodes.size();
    unsigned int toroidalWindings = nodes[0].size();

    // If an island then only points.
    if( showLines && islands == 0 && toroidalWindings > 1 )
    {
      // Loop through each plane
      for( unsigned int p=0; p<nplanes; ++p ) 
      {
        if( color == DATA_Plane )
            color_value = p;
        
        //Create groups that represent the toroidial groups.
        vtkPoints *points = vtkPoints::New();
        vtkCellArray *cells = vtkCellArray::New();
        vtkFloatArray *scalars = vtkFloatArray::New();
            
        cells->InsertNextCell(toroidalWindings+1);
        scalars->Allocate    (toroidalWindings+1);
            
        // Loop through each toroidial group taking just the first
        // point from each group.
        for( unsigned int jj=0; jj<=toroidalWindings*skip; jj+=skip ) 
        {
            unsigned int j = jj % toroidalWindings;

            if( color == DATA_WindingOrder )
                color_value = j;
            
            // Use the first point in each toroidial group
            unsigned int i=0;

            points->InsertPoint(j,
                                nodes[p][j][i].x,
                                nodes[p][j][i].y,
                                nodes[p][j][i].z);

            cells->InsertCellPoint(j);

            if( color == DATA_PointIndex )
              color_value = (i*toroidalWindings+j)*nplanes + p;
            else if( color == DATA_WindingPointOrder )
              color_value = i;
            else if( color == DATA_WindingPointOrderModulo )
              color_value = i % nnodes;
                
            scalars->InsertTuple1(j, color_value);
        }
         
        // Create a new VTK polyline.
        vtkPolyData *pd = vtkPolyData::New();
        pd->SetPoints(points);
        pd->SetLines(cells);
        scalars->SetName("colorVar");
        pd->GetPointData()->SetScalars(scalars);
        append->AddInput(pd);
        
        points->Delete();
        cells->Delete();
        scalars->Delete();
      }   
    }

    if (showPoints || toroidalWindings == 1 )
    {
        for( unsigned int p=0; p<nplanes; ++p ) 
        {
            if( color == DATA_Plane )
                color_value = p;
            
            // Loop through each toroidial group
            for( unsigned int j=0; j<toroidalWindings; ++j ) 
            {
                if( color == DATA_WindingOrder )
                    color_value = j;

                unsigned int npts;

                if( toroidalWindings > 1 )
                  npts = 1;
                else
                  npts = nodes[p][j].size();

                // Draw each point in the toroidial group
                for( unsigned int i=0; i<npts; ++i )
                {      
                    double pt[3] =
                      { nodes[p][j][i].x, nodes[p][j][i].y, nodes[p][j][i].z };
                    
                    if( color == DATA_PointIndex )
                      color_value = (i*toroidalWindings+j)*nplanes + p;
                    else if( color == DATA_WindingPointOrder )
                      color_value = i;
                    else if( color == DATA_WindingPointOrderModulo )
                      color_value = i % nnodes;
                    
                    vtkPolyData *ball = CreateSphere(color_value, pt);
                    
                    append->AddInput(ball);
                    ball->Delete();
                }
            }
        }
    }
    
    if (0 && showPoints)
    {
        for( unsigned int p=0; p<nplanes; ++p ) 
        {
            if( color == DATA_Plane )
                color_value = p;
            
            // Loop through each toroidial group
            for( unsigned int j=0; j<toroidalWindings; ++j ) 
            {
                if( color == DATA_WindingOrder )
                    color_value = j;
                
                //Create groups that represent the toroidial groups.
                vtkPoints *points = vtkPoints::New();
                vtkCellArray *cells = vtkCellArray::New();
                vtkFloatArray *scalars = vtkFloatArray::New();

                scalars->Allocate( nodes[p][j].size() );
        
                // Loop through each point in toroidial group
                for( unsigned int i=0; i<nodes[p][j].size(); ++i )
                {      
                    points->InsertNextPoint(nodes[p][j][i].x,
                                            nodes[p][j][i].y,
                                            nodes[p][j][i].z );
                    
                    cells->InsertNextCell(1, (vtkIdType*) &i);
                    
                    if( color == DATA_PointIndex )
                      color_value = (i*toroidalWindings+j)*nplanes + p;
                    else if( color == DATA_WindingPointOrder )
                      color_value = i;
                    else if( color == DATA_WindingPointOrderModulo )
                      color_value = i % nnodes;
                    
                    scalars->InsertTuple1(i, color_value);
                }

                // Create a new VTK point clouds.
                vtkPolyData *pd = vtkPolyData::New();
                pd->SetPoints(points);
                pd->SetVerts(cells);
                scalars->SetName("colorVar");
                pd->GetPointData()->SetScalars(scalars);
                append->AddInput(pd);
    
                points->Delete();
                cells->Delete();
                scalars->Delete();  
            }
        }
    }
    
    append->Update();
    vtkPolyData *outPD = append->GetOutput();
    outPD->Register(NULL);
    outPD->SetSource(NULL);
    append->Delete();
    
    dt->Merge( new avtDataTree(outPD, 0) );
}


// ****************************************************************************
//  Method: avtPoincareFilter::drawIrrationalCurve
//
//  Purpose: Creates a curve from the puncture points. Each curve
//           represents one toroidal winding group.
//
//  Arguments:
//
//  Returns:      void
//
//  Programmer: Allen Sanderson
//  Creation:   Wed Feb 25 09:52:11 EST 2009
//
//  Modifications:
//
// ****************************************************************************

void
avtPoincareFilter::drawIrrationalCurve( avtDataTree *dt,
                                        vector< vector < vector < avtVector > > > &nodes,
                                        unsigned int nnodes,
                                        unsigned int islands,
                                        unsigned int skip,
                                        unsigned int color,
                                        double color_value,
                                        bool connect,
                                        bool modulo ) 
{
    vtkAppendPolyData *append = vtkAppendPolyData::New();
    
    unsigned int nplanes = nodes.size();
    unsigned int toroidalWindings = nodes[0].size();
    connect = 0;
    if (showLines)
    {
      if( !modulo )
      {
        // Determine if the winding group order matches the point
        // ordering. This is only needed when building surfaces.
        Vector intra = nodes[0][   0][1] - nodes[0][0][0];
        Vector inter = nodes[0][skip][0] - nodes[0][0][0];

        int offset;

        if( !islands && connect )
          offset = (Dot( intra, inter ) < 0 ) ? toroidalWindings-skip : skip;
        else
          offset = 0;

        // Loop through each plane
        for( unsigned int p=0; p<nplanes; ++p ) 
        {
            if( color == DATA_Plane )
              color_value = p;
        
            // Loop through each toroidial group
            for( unsigned int j=0; j<toroidalWindings; ++j ) 
            {
                //Create groups that represent the toroidial groups.
              vtkPoints *points = vtkPoints::New();
              vtkCellArray *cells = vtkCellArray::New();
              vtkFloatArray *scalars = vtkFloatArray::New();
            
              cells->InsertNextCell(nodes[p][j].size()+(offset?1:0));
              scalars->Allocate    (nodes[p][j].size()+(offset?1:0));
            
              if( color == DATA_WindingOrder )
                color_value = j;
            
              // Loop through each point in toroidial group
              for( unsigned int i=0; i<nodes[p][j].size(); ++i ) 
              {
                  points->InsertPoint(i,
                                      nodes[p][j][i].x,
                                      nodes[p][j][i].y,
                                      nodes[p][j][i].z);

                  cells->InsertCellPoint(i);

                  if( color == DATA_PointIndex )
                    color_value = (i*toroidalWindings+j)*nplanes + p;
                  else if( color == DATA_WindingPointOrder )
                    color_value = i;
                  else if( color == DATA_WindingPointOrderModulo )
                    color_value = i % nnodes;
                
                  scalars->InsertTuple1(i, color_value);
              }

              if( offset )
              {
                // Add one point in from the previous neighbor to create
                // a complete boundary.

                unsigned int ii = nodes[p][j].size();
                unsigned int jj = (j+offset) % toroidalWindings;
                
                points->InsertPoint(ii,
                                    nodes[p][jj][0].x,
                                    nodes[p][jj][0].y,
                                    nodes[p][jj][0].z);
                
                cells->InsertCellPoint(ii);

                if( color == DATA_PointIndex )
                  color_value = (ii*toroidalWindings+j)*nplanes + p;
                else if( color == DATA_WindingPointOrder )
                  color_value = ii;
                else if( color == DATA_WindingPointOrderModulo )
                  color_value = ii % nnodes;
                
                scalars->InsertTuple1(ii, color_value);
              }

            
              // Create a new VTK polyline.
              vtkPolyData *pd = vtkPolyData::New();
              pd->SetPoints(points);
              pd->SetLines(cells);
              scalars->SetName("colorVar");
              pd->GetPointData()->SetScalars(scalars);
              append->AddInput(pd);
            
              points->Delete();
              cells->Delete();
              scalars->Delete();
            }
        }
      }
      else //if( modulo )
      {
        Vector intra = nodes[0][0][0] - nodes[0][0][nnodes];
        Vector inter = nodes[0][0][0] - nodes[0][0][1];

        int offset = Dot( intra, inter ) ? skip : -skip;
        offset = 0;

        // Loop through each plane
        for( unsigned int p=0; p<nplanes; ++p ) 
        {
          if( color == DATA_Plane )
            color_value = p;
          
          // Loop through each toroidial group
          for( unsigned int j=0; j<toroidalWindings; ++j ) 
          {
//          unsigned int bb = 0;

            for( unsigned int n=0; n<nnodes; ++n ) 
            {
              //Create groups that represent the toroidial groups.
              vtkPoints *points = vtkPoints::New();
              vtkCellArray *cells = vtkCellArray::New();
              vtkFloatArray *scalars = vtkFloatArray::New();

              unsigned int npts = ceil((nodes[p][j].size()-n) / (float) nnodes);
            
              cells->InsertNextCell(npts+(offset?1:0));
              scalars->Allocate    (npts+(offset?1:0));
            
              unsigned int cc = 0;

              // Loop through each point in toroidial group
              for( unsigned int i=n; i<nodes[p][j].size(); i+=nnodes ) 
              {
                points->InsertPoint(cc,
                                    nodes[p][j][i].x,
                                    nodes[p][j][i].y,
                                    nodes[p][j][i].z);

                cells->InsertCellPoint(cc);

                if( color == DATA_PointIndex )
                  color_value = (i*toroidalWindings+j)*nplanes + p;
                else if( color == DATA_WindingPointOrder )
                  color_value = i;
                else if( color == DATA_WindingPointOrderModulo )
                  color_value = i % nnodes;
                
//              color_value = bb++;
                
                scalars->InsertTuple1(cc++, color_value);
              }

              if( offset )
              {
                // Add one point in from the previous neighbor to create
                // a complete boundary.
                unsigned int i = (n+offset+nnodes) % nnodes;
                
                points->InsertPoint(cc,
                                    nodes[p][j][i].x,
                                    nodes[p][j][i].y,
                                    nodes[p][j][i].z);
                
                cells->InsertCellPoint(cc);
                
                if( color == DATA_PointIndex )
                  color_value = (i*toroidalWindings+j)*nplanes + p;
                else if( color == DATA_WindingPointOrder )
                  color_value = i;
                else if( color == DATA_WindingPointOrderModulo )
                  color_value = i % nnodes;

//              color_value = bb++;
                
                scalars->InsertTuple1(cc++, color_value);
              }

              // Create a new VTK polyline.
              vtkPolyData *pd = vtkPolyData::New();
              pd->SetPoints(points);
              pd->SetLines(cells);
              scalars->SetName("colorVar");
              pd->GetPointData()->SetScalars(scalars);
              append->AddInput(pd);
            
              points->Delete();
              cells->Delete();
              scalars->Delete();       
            }
          }
        }
      }
    }
    
    if (showPoints)
    {
        for( unsigned int p=0; p<nplanes; ++p ) 
        {
            if( color == DATA_Plane )
                color_value = p;
            
            // Loop through each toroidial group
            for( unsigned int j=0; j<toroidalWindings; ++j ) 
            {
                if( color == DATA_WindingOrder )
                    color_value = j;

                // Loop through each point in toroidial group
                for( unsigned int i=0; i<nodes[p][j].size(); ++i )
                {      
                    double pt[3] =
                      { nodes[p][j][i].x, nodes[p][j][i].y, nodes[p][j][i].z };
                    
                    if( color == DATA_PointIndex )
                      color_value = (i*toroidalWindings+j)*nplanes + p;
                    else if( color == DATA_WindingPointOrder )
                      color_value = i;
                    else if( color == DATA_WindingPointOrderModulo )
                      color_value = i % nnodes;
                    
                    vtkPolyData *ball = CreateSphere(color_value, pt);

                    append->AddInput(ball);
                    ball->Delete();
                }
            }
        }
    }
    
    if (0 && showPoints)
    {
        for( unsigned int p=0; p<nplanes; ++p ) 
        {
            if( color == DATA_Plane )
                color_value = p;
            
            // Loop through each toroidial group
            for( unsigned int j=0; j<toroidalWindings; ++j ) 
            {
                if( color == DATA_WindingOrder )
                    color_value = j;

                //Create groups that represent the toroidial groups.
                vtkPoints *points = vtkPoints::New();
                vtkCellArray *cells = vtkCellArray::New();
                vtkFloatArray *scalars = vtkFloatArray::New();

                scalars->Allocate( nodes[p][j].size() );
        
                // Loop through each point in toroidial group
                for( unsigned int i=0; i<nodes[p][j].size(); ++i )
                {      
                    points->InsertNextPoint(nodes[p][j][i].x,
                                            nodes[p][j][i].y,
                                            nodes[p][j][i].z );
                  
                    cells->InsertNextCell(1, (vtkIdType*) &i);
                  
                    if( color == DATA_PointIndex )
                      color_value = (i*toroidalWindings+j)*nplanes + p;
                    else if( color == DATA_WindingPointOrder )
                      color_value = i;
                    else if( color == DATA_WindingPointOrderModulo )
                      color_value = i % nnodes;
                  
                    scalars->InsertTuple1(i, color_value);
                }

                // Create a new VTK point clouds.
                vtkPolyData *pd = vtkPolyData::New();
                pd->SetPoints(points);
                pd->SetVerts(cells);
                scalars->SetName("colorVar");
                pd->GetPointData()->SetScalars(scalars);
                append->AddInput(pd);
    
                points->Delete();
                cells->Delete();
                scalars->Delete();  
            }
        } 
    }
    
    append->Update();
    vtkPolyData *outPD = append->GetOutput();
    outPD->Register(NULL);
    outPD->SetSource(NULL);
    append->Delete();

    
    dt->Merge( new avtDataTree(outPD, 0) );
}



// ****************************************************************************
//  Method: avtPoincareFilter::drawSurface
//
//  Purpose: Creates a surface from a series the puncture points. The
//           surface is sweep from each toroidal winding group around
//           each plane in the torus. Each is connected together to
//           form a circular cross section.
//
//  Arguments:
//
//  Returns:      void
//
//  Programmer: Allen Sanderson
//  Creation:   Wed Feb 25 09:52:11 EST 2009
//
//  Modifications:
//
// ****************************************************************************

void
avtPoincareFilter::drawSurface( avtDataTree *dt,
                                vector< vector < vector < avtVector > > > &nodes,
                                unsigned int nnodes,
                                unsigned int islands,
                                unsigned int skip,
                                unsigned int color,
                                double color_value,
                                bool modulo ) 
{
    unsigned int nplanes = nodes.size();
    unsigned int toroidalWindings = nodes[0].size();
    
    int dims[2];
    
    // Add one to the first dimension to create a closed cylinder. Add
    // one to the second dimension to form a torus.
    dims[0] = nnodes + 1;
    dims[1] = nplanes * toroidalWindings + 1;
    
    // Create an unstructured quad for the island surface.
    vtkUnstructuredGrid *grid = vtkUnstructuredGrid::New();
    vtkQuad *quad = vtkQuad::New();
    vtkPoints *points = vtkPoints::New();
    vtkFloatArray *scalars = vtkFloatArray::New();
    
    points->SetNumberOfPoints(dims[0]*dims[1]);
    scalars->Allocate(dims[0]*dims[1]);
    
    float *points_ptr = (float *) points->GetVoidPointer(0);
    
    // Determine if the winding group order matches the point
    // ordering. This is only needed when building surfaces.
    Vector intra = nodes[0][   0][1] - nodes[0][0][0];
    Vector inter = nodes[0][skip][0] - nodes[0][0][0];

    int offset = (Dot( intra, inter ) < 0 ) ? -skip : skip;

    // Loop through each toroidial group
    for( unsigned int j=0; j<toroidalWindings; ++j )
    {
        if( color == DATA_WindingOrder )
            color_value = j;

        // Loop through each plane.
        for( unsigned int p=0; p<nplanes; ++p ) 
        {
            // Normally each toroidial winding group can be displayed
            // in the order received. Except for the last plane where
            // it needs to be adjusted by one group. That is if the
            // streamline started in the "correct" place. This is not
            // always the case so it may be necessary to adjust the
            // toroidal winding group location by one.
            unsigned int k;
            
            if( p == adjust_plane )
            {
                k = (j-1 + toroidalWindings) % toroidalWindings;
            }
            else
            {
                k = j;
            }
            
            unsigned int jj = nplanes * j + p;
            
            if( color == DATA_Plane )
                color_value = jj;
            
            // Loop through each point in toroidial group.
            for(unsigned int i=0; i<nnodes; ++i )
            {
                unsigned int n1 = jj * dims[0] + i;

                points_ptr[n1*3+0] = nodes[p][k][i].x;
                points_ptr[n1*3+1] = nodes[p][k][i].y;
                points_ptr[n1*3+2] = nodes[p][k][i].z;

                if( color == DATA_PointIndex )
                    color_value = (i*toroidalWindings+j)*nplanes + p;
                else if( color == DATA_WindingPointOrder )
                    color_value = i;
                else if( color == DATA_WindingPointOrderModulo )
                    color_value = i % nnodes;
                
                scalars->InsertTuple1(n1, color_value);

                // Create the quad.
                quad->GetPointIds()->SetId( 0,   jj    * dims[0] + i );
                quad->GetPointIds()->SetId( 1,  (jj+1) * dims[0] + i );
                quad->GetPointIds()->SetId( 2,  (jj+1) * dims[0] + i + 1);
                quad->GetPointIds()->SetId( 3,   jj    * dims[0] + i + 1);
                
                grid->InsertNextCell( quad->GetCellType(),
                                      quad->GetPointIds() );                
            }

            // For a surface add in the first point from the adjacent
            // toroidial group. Otherwise for an island add in the
            // first point from the current toroidal group.
            if( !islands )
                k = (k+offset+toroidalWindings) % toroidalWindings;

            unsigned int i = nnodes;

            unsigned int n1 = jj * dims[0] + i;
            
            points_ptr[n1*3+0] = nodes[p][k][0].x;
            points_ptr[n1*3+1] = nodes[p][k][0].y;
            points_ptr[n1*3+2] = nodes[p][k][0].z;
            
            if( color == DATA_PointIndex )
              color_value = (i*toroidalWindings+j)*nplanes + p;
            else if( color == DATA_WindingPointOrder )
              color_value = i;
            else if( color == DATA_WindingPointOrderModulo )
              color_value = i % nnodes;
            
            scalars->InsertTuple1(n1, color_value);
        }
    }
    
    // Add in the first toroidal group from the first plane to complete
    // the torus.
    unsigned int j = 0;
    
    if( color == DATA_WindingOrder )
        color_value = j;
    
    // Add in the first toroidal group from the first plane to complete
    // the torus.
    unsigned int p = 0;
    
    // Normally each toroidial group can be displayed in the order
    // received. Except for the last plane where it needs to be
    // adjusted by one group. That is if the streamline started in
    // the "correct" place. This is not always the case so it may be
    // necessary to adjust the winding group location by one.
    unsigned int k;
    
    if( p == adjust_plane )
    {
        k = (j-1 + toroidalWindings) % toroidalWindings;
    }
    else
    {
        k = j;
    }
    
    unsigned int jj = nplanes * toroidalWindings;
    
    if( color == DATA_Plane )
        color_value = jj;
    
    // Loop through each point in toroidial group.
    for(unsigned int i=0; i<nnodes; ++i )
    {
      // Normally each point in a toroidial group can be displayed in
      // the order received. Except when dealing with 1:1 surfaces for
      // the last plane where it needs to be adjusted by one
      // location. That is if the streamline started in the "correct"
      // place. This is not always the case so it may be necessary to
      // adjust the point ordering by one.
      unsigned int ii;

      if( p == adjust_plane && toroidalWindings == 1) 
        ii = (i-1 + nnodes) % nnodes;
      else
        ii = i;

        unsigned int n1 = jj * dims[0] + ii;
        
        points_ptr[n1*3+0] = nodes[p][k][i].x;
        points_ptr[n1*3+1] = nodes[p][k][i].y;
        points_ptr[n1*3+2] = nodes[p][k][i].z;

        if( color == DATA_PointIndex )
            color_value = (i*toroidalWindings+j)*nplanes + p;
        else if( color == DATA_WindingPointOrder )
          color_value = i;
        else if( color == DATA_WindingPointOrderModulo )
          color_value = i % nnodes;
        
        scalars->InsertTuple1(n1, color_value);
    }

    // For a surface add in the first point from the adjacent
    // toroidial group. Otherwise for an island add in the
    // first point from the current toroidal group.
    if( !islands )
        k = (k+offset+toroidalWindings) % toroidalWindings;

    unsigned int i = nnodes;
    unsigned int n1 = jj * dims[0] + i;
    
    points_ptr[n1*3+0] = nodes[p][k][0].x;
    points_ptr[n1*3+1] = nodes[p][k][0].y;
    points_ptr[n1*3+2] = nodes[p][k][0].z;
    
    if( color == DATA_PointIndex )
      color_value = (i*toroidalWindings+j)*nplanes + p;
    else if( color == DATA_WindingPointOrder )
      color_value = i;
    else if( color == DATA_WindingPointOrderModulo )
      color_value = i % nnodes;
    
    scalars->InsertTuple1(n1, color_value);


    // Stuff the points and scalars into the VTK unstructure grid.
    grid->SetPoints(points);
    scalars->SetName("colorVar");
    grid->GetPointData()->SetScalars(scalars);
    dt->Merge( new avtDataTree(grid, 0) );
    
    quad->Delete();
    points->Delete();
    scalars->Delete();
}


void
avtPoincareFilter::drawPeriodicity( avtDataTree *dt,
                                    vector < Point  > &nodes,
                                    unsigned int period,
                                    unsigned int nnodes,
                                    unsigned int islands,
                                    unsigned int poloidalWindings,
                                    unsigned int color,
                                    double color_value,
                                    bool ptFlag )
{
  if( period <= 1 )
    period = nodes.size();

  unsigned int colorMax = 0;

  vtkAppendPolyData *append = vtkAppendPolyData::New();

  if( islands )
    poloidalWindings *= nnodes;
  
  if (showLines)
  {
    //Create groups that represent the toroidial groups.
    vtkPoints *points;
    vtkCellArray *cells;
    vtkFloatArray *scalars;
    
    unsigned int cc = 0;
  
    // Loop through each point in poloidal group
    for( unsigned int i=0; i<nodes.size(); ++i )
    {      
      if( i % period == 0 )
      {
        //Create groups that represent the toroidial groups.
        points = vtkPoints::New();
        cells = vtkCellArray::New();
        scalars = vtkFloatArray::New();

        unsigned int npts = period < (nodes.size()-i) ?
          period : (nodes.size()-i);
      
        cells->InsertNextCell( npts );
        scalars->Allocate    ( npts );
      
        cc = 0;
      }

      if( ptFlag )
        points->InsertPoint(cc,
                            (float) (i % period) / 50.0,
                            nodes[i].y,
                            nodes[i].z);
      else
        points->InsertPoint(cc, nodes[i].x, nodes[i].y, nodes[i].z);
    
      cells->InsertCellPoint(cc);

      if( color == DATA_PointIndex )
        color_value = i;
      else if( color == DATA_WindingOrder )
        color_value = i / poloidalWindings;
      else if( color == DATA_WindingPointOrder )
        color_value = i % poloidalWindings;
      else if( color == DATA_WindingPointOrderModulo )
        color_value = (i % poloidalWindings) % nnodes;
          
      scalars->InsertTuple1(cc, color_value);
        
      ++cc;
            
      if( i % period == 0 )
      {
        // Create a new VTK polyline.
        vtkPolyData *pd = vtkPolyData::New();
        pd->SetPoints(points);
        pd->SetLines(cells);
        scalars->SetName("colorVar");
        pd->GetPointData()->SetScalars(scalars);
        append->AddInput(pd);
        
        points->Delete();
        cells->Delete();
        scalars->Delete();       
      }
    }
  }

  if (showPoints)
  {
    // Loop through each poloidal group
    // Loop through each point in poloidial group
    for( unsigned int i=0; i<nodes.size(); ++i )
    {
      double pt[3] = { nodes[i].x, nodes[i].y, nodes[i].z };
      
      if( ptFlag )
        pt[0] = (float) (i % period) / 50.0;
      else
        pt[0] = nodes[i].x;
          
      if( color == DATA_PointIndex )
        color_value = i;
      else if( color == DATA_WindingOrder )
        color_value = i / poloidalWindings;
      else if( color == DATA_WindingPointOrder )
        color_value = i % poloidalWindings;
      else if( color == DATA_WindingPointOrderModulo )
        color_value = (i % poloidalWindings) % nnodes;

      if( colorMax < color_value )
        colorMax = color_value;
      
      vtkPolyData *ball = CreateSphere(color_value, pt);
      append->AddInput(ball);
      ball->Delete();
    }
  }

  if (0 && showPoints)
  {
    //Create groups that represent the toroidial groups.
    vtkPoints *points = vtkPoints::New();
    vtkCellArray *cells = vtkCellArray::New();
    vtkFloatArray *scalars = vtkFloatArray::New();

    scalars->Allocate( nodes.size() );

    // Loop through each poloidal group
    // Loop through each point in poloidial group
    for( unsigned int i=0; i<nodes.size(); ++i )
    {      
      if( ptFlag )
        points->InsertNextPoint( (float) (i % period) / 50.0,
                                 nodes[i].y,
                                 nodes[i].z);
      else
        points->InsertNextPoint(nodes[i].x, nodes[i].y, nodes[i].z);

      cells->InsertNextCell(1, (vtkIdType*) &i);
      
      if( color == DATA_PointIndex )
        color_value = i;
      else if( color == DATA_WindingOrder )
        color_value = i / poloidalWindings;
      else if( color == DATA_WindingPointOrder )
        color_value = i % poloidalWindings;
      else if( color == DATA_WindingPointOrderModulo )
        color_value = (i % poloidalWindings) % nnodes;

      if( colorMax < color_value )
        colorMax = color_value;

      scalars->InsertTuple1(i, color_value);
    }
    
    // Create a new VTK point clouds.
    vtkPolyData *pd = vtkPolyData::New();
    pd->SetPoints(points);
    pd->SetVerts(cells);
    scalars->SetName("colorVar");
    pd->GetPointData()->SetScalars(scalars);
    append->AddInput(pd);
    
    points->Delete();
    cells->Delete();
    scalars->Delete();       
  }

  append->Update();
  vtkPolyData *outPD = append->GetOutput();
  outPD->Register(NULL);
  outPD->SetSource(NULL);
  append->Delete();
  
  dt->Merge( new avtDataTree(outPD, 0) );
}


// ****************************************************************************
//  Method: avtPoincareFilter::drawPoints
//
//  Purpose: Draws a bunch of points.
//
//  Arguments:
//
//  Returns:      void
//
//  Programmer: Allen Sanderson
//  Creation:   Wed Feb 25 09:52:11 EST 2009
//
//  Modifications:
//
// ****************************************************************************

void
avtPoincareFilter::drawPoints( avtDataTree *dt,
                               vector < avtVector > &nodes ) 
{
  vtkAppendPolyData *append = vtkAppendPolyData::New();

  if (showPoints)
  {
    //Create groups that represent the toroidial groups.
    vtkPoints *points = vtkPoints::New();
    vtkCellArray *cells = vtkCellArray::New();
    vtkFloatArray *scalars = vtkFloatArray::New();

    scalars->Allocate( nodes.size() );

    for( unsigned int i=0; i<nodes.size(); ++i )
    {      
      points->InsertNextPoint(nodes[i].x, nodes[i].y, nodes[i].z);

      cells->InsertNextCell(1, (vtkIdType*) &i);
      
      scalars->InsertTuple1(i, 0);
    }
    
    // Create a new VTK point clouds.
    vtkPolyData *pd = vtkPolyData::New();
    pd->SetPoints(points);
    pd->SetVerts(cells);
    scalars->SetName("colorVar");
    pd->GetPointData()->SetScalars(scalars);
    append->AddInput(pd);
    
    points->Delete();
    cells->Delete();
    scalars->Delete();       
  }

  append->Update();
  vtkPolyData *outPD = append->GetOutput();
  outPD->Register(NULL);
  outPD->SetSource(NULL);
  append->Delete();
  
  dt->Merge( new avtDataTree(outPD, 0) );
}


// ****************************************************************************
// Method: avtPoincareFilter::SetIntersectionCriteria
//
// Purpose:
//   Sets the intersection object.
//
// Arguments:
//   obj : Intersection object.
//
// Programmer: Dave Pugmire
// Creation:   11 August 2009
//
// Modifications:
//
// ****************************************************************************

void
avtPoincareFilter::SetIntersectionCriteria(vtkObject *obj, int mi)
{
    if (obj)
    {
        intersectObj = obj;
        intersectObj->Register(NULL);
    }
    maxIntersections = mi;
}

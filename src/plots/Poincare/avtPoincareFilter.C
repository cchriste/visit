/*****************************************************************************
*
* Copyright (c) 2000 - 2008, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-400142
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                              avtPoincareFilter.C                              //
// ************************************************************************* //

#include <avtPoincareFilter.h>

#include <vtkDataSet.h>
#include <vtkSlicer.h>
#include <vtkPolyData.h>
#include <vtkTubeFilter.h>
#include <vtkPolyLine.h>
#include <vtkCleanPolyData.h>

#include <vtkCellArray.h>
#include <vtkCellData.h>
#include <vtkPointData.h>
#include <vtkAppendPolyData.h>
#include <vtkSphereSource.h>
#include <vtkFloatArray.h>
#include <avtDatasetExaminer.h>
#include <avtExtents.h>

#include "StreamlineAnalyzerLib.h"

#define SIGN(x) ((x) < 0.0 ? -1 : 1)


// ****************************************************************************
//  Method: avtPoincareFilter constructor
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************

avtPoincareFilter::avtPoincareFilter()
{
    clipPlanePt.x = 0.0;
    clipPlanePt.y = 0.0;
    clipPlanePt.z = 0.0;
    clipPlaneN.x = 0.0;
    clipPlaneN.y = 0.0;
    clipPlaneN.z = 1.0;
    showStreamlines = true;
    showPoints = true;
}


// ****************************************************************************
//  Method: avtPoincareFilter destructor
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************

avtPoincareFilter::~avtPoincareFilter()
{
}

static vtkPolyData *
CreateSphere(float val, double rad, double pt[3])
{
    // Create the sphere polydata.
    vtkSphereSource *sphere = vtkSphereSource::New();
    sphere->SetCenter(pt[0], pt[1], pt[2]);
    sphere->SetRadius(rad);
    sphere->SetLatLongTessellation(1);
    sphere->SetPhiResolution(8);
    sphere->SetThetaResolution(8);
    vtkPolyData *sphereData = sphere->GetOutput();
    sphereData->Update();

    // Set the sphere's scalar to val.
    vtkFloatArray *arr = vtkFloatArray::New();
    int npts = sphereData->GetNumberOfPoints();
    arr->SetNumberOfTuples(npts);
    for (int i = 0; i < npts; ++i)
        arr->SetTuple1(i, val);
    arr->SetName("colorVar");
    sphereData->GetPointData()->SetScalars(arr);
    arr->Delete();

    sphereData->Register(NULL);
    sphere->Delete();

    return sphereData;
}


// ****************************************************************************
//  Method: avtPoincareFilter::SetClipPlane
//
//  Purpose:
//      Sets the definition of the clip plane.
//
//  Arguments:
//      pt        Point on plane.
//      norm      Plane Normal.
//
//  Returns:      void
//
//  Programmer: Dave Pugmire
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************

void
avtPoincareFilter::SetClipPlane( const double *pt, const double *norm )
{
    clipPlanePt.x = pt[0];
    clipPlanePt.y = pt[1];
    clipPlanePt.z = pt[2];
    
    clipPlaneN.x = norm[0];
    clipPlaneN.y = norm[1];
    clipPlaneN.z = norm[2];
    clipPlaneN.normalize();
}

// ****************************************************************************
//  Method: avtPoincareFilter::PreExecute
//
//  Purpose:
//      Get the current spatial extents if necessary.
//
//  Programmer: Dave Pugmire
//  Creation:   Fri Nov  7 13:01:47 EST 2008
//
//  Modifications:
//
//
// ****************************************************************************

void
avtPoincareFilter::PreExecute(void)
{
    avtStreamlineFilter::PreExecute();
}


// ****************************************************************************
//  Method: avtPoincareFilter::PostExecute
//
//  Purpose:
//      Get the current spatial extents if necessary.
//
//  Programmer: Dave Pugmire
//  Creation:   Fri Nov  7 13:01:47 EST 2008
//
//  Modifications:
//
//
// ****************************************************************************

void
avtPoincareFilter::PostExecute(void)
{
    avtStreamlineFilter::PostExecute();

    double range[2];
    avtDataset_p ds = GetTypedOutput();
    avtDatasetExaminer::GetDataExtents(ds, range, "colorVar");

    avtExtents *e;
    e = GetOutput()->GetInfo().GetAttributes().GetCumulativeTrueDataExtents();
    e->Merge(range);
    e = GetOutput()->GetInfo().GetAttributes().GetCumulativeCurrentDataExtents();
    e->Merge(range);
}

// ****************************************************************************
//  Method: avtPoincareFilter::CreateStreamlineOutput
//
//  Purpose:
//      Create the VTK poly data output from the streamline.
//
//  Programmer: Dave Pugmire
//  Creation:   Tue Dec  23 12:51:29 EST 2008
//
//  Modifications:
//
//
// ****************************************************************************

void
avtPoincareFilter::CreateStreamlineOutput( vector<avtStreamlineWrapper *> &streamlines)
{
    cout<<"There are have "<<streamlines.size()<<" streamlines.\n";
    GeneratePoincarePoints(streamlines);
    ClassifyPoincarePoints();
    
    vtkPolyData *poincPD = CreatePoincareOutput();
    avtDataTree *dt = new avtDataTree(poincPD, 0);
    SetOutputDataTree(dt);

#if 0
    cout<<"CreateStreamlineOutput()\n";
    cout<<"streamlines sz= "<<streamlines.size()<<endl;
    debug1 << "::CreateStreamlineOutput " << streamlines.size() << endl;

    bool doTubes = true;
    radius = 0.025;
    if (streamlines.size() == 0)
        return;

    // Join all the streamline pieces.
    vtkAppendPolyData *append = vtkAppendPolyData::New();
    for (int i = 0; i < streamlines.size(); i++)
    {
        avtStreamlineWrapper *slSeg = (avtStreamlineWrapper *) streamlines[i];
        vector<float> thetas;
        vtkPolyData *pd = slSeg->GetVTKPolyData(3, 
                                                STREAMLINE_COLOR_SOLID,
                                                STREAMLINE_DISPLAY_LINES,
                                                thetas);
        cout<<"GetPolyData: "<<pd<<endl;
        debug1<<"Done w/ GetVTKPolyData\n";
        
        if (pd == NULL)
            continue;

        vtkCleanPolyData *clean = vtkCleanPolyData::New();
        clean->SetInput(pd);
        clean->Update();
        pd->Delete();

        pd = clean->GetOutput();
        pd->Register(NULL);
        pd->SetSource(NULL);
        clean->Delete();

        if (showStart)
        {
            float val = pd->GetPointData()->GetScalars()->GetTuple1(0);
            double *pt = NULL;
            if (slSeg->dir == avtStreamlineWrapper::FWD)
                pt = pd->GetPoints()->GetPoint(0);
            else
                pt = pd->GetPoints()->GetPoint(
                                       pd->GetPoints()->GetNumberOfPoints()-1);
            vtkPolyData *ball = StartSphere(val, pt);
            
            append->AddInput(ball);
            ball->Delete();
        }
        
        if (doTubes)
        {
            cout<<"Do tubeys"<<endl;
            vtkTubeFilter* tubes = vtkTubeFilter::New();
            tubes->SetRadius(radius);
            tubes->SetNumberOfSides(8);
            tubes->SetRadiusFactor(2.);
            tubes->SetCapping(1);
            tubes->ReleaseDataFlagOn();
            tubes->SetInput(pd);
            tubes->Update();
            
            pd->Delete();
            pd = tubes->GetOutput();
            pd->Register(NULL);
            pd->SetSource(NULL);
            tubes->Delete();
            
            append->AddInput(pd);
            cout<<"DONE Do tubeys"<<endl<<endl;
        }
        /*
        else if (doRibbons)
        {
            vtkRibbonFilter* ribbons = vtkRibbonFilter::New();
            ribbons->SetWidth(radius);

            int nPts = pd->GetPointData()->GetNumberOfTuples();
            
            vtkIdList *ids = vtkIdList::New();
            vtkPoints *pts = vtkPoints::New();
            vtkCellArray *lines = vtkCellArray::New();
            for (int i = 0; i < nPts; i++)
            {
                vtkIdType id = pts->InsertNextPoint(
                                                 pd->GetPoints()->GetPoint(i));
                ids->InsertNextId(id);
            }

            lines->InsertNextCell(ids);
            //Create normals, initialize them. (Remove the init later....)
            vtkFloatArray *normals = vtkFloatArray::New();
            normals->SetNumberOfComponents(3);
            normals->SetNumberOfTuples(nPts);

            vtkPolyLine *lineNormalGenerator = vtkPolyLine::New();
            lineNormalGenerator->GenerateSlidingNormals(pts, lines, normals);
            
            //Now, rotate the normals according to the vorticity..
            //double normal[3], local1[3], local2[3],length,costheta, sintheta;
            double normal[3], tan[3], biNormal[3], p0[3], p1[3];
            for (int i = 0; i < nPts; i++)
            {
                double theta = thetas[i];

                pts->GetPoint(i, p0);
                if (i < nPts-1)
                    pts->GetPoint(i+1, p1);
                else
                {
                    pts->GetPoint(i-1, p0);
                    pts->GetPoint(i, p1);
                }
                for (int j = 0; j < 3; j++)
                    tan[j] = p1[j]-p0[j];

                //cout<<i<<": p= ["<<p0[0]<<" "<<p0[1]<<" "<<p0[2]<<"] ["
                //    <<p1[0]<<" "<<p1[1]<<" "<<p1[2]<<"]\n";
                //cout<<i<<": T=["<<tan[0]<<" "<<tan[1]<<" "<<tan[2]<<"]\n\n";
                normals->GetTuple(i, normal);
                vtkMath::Normalize(tan);
                vtkMath::Normalize(normal);

                vtkMath::Cross(normal, tan, biNormal);
                double cosTheta = cos(theta);
                double sinTheta = sin(theta);
                for (int j = 0; j < 3; j++)
                    normal[j] = cosTheta*normal[j] + sinTheta*biNormal[j];
                
                //cout<<i<<": T=["<<tan[0]<<" "<<tan[1]<<" "<<tan[2]<<"] N= ["
                //    <<normal[0]<<" "<<normal[1]<<" "<<normal[2]<<endl;
                normals->SetTuple(i,normal);
            }

            ids->Delete();
            pts->Delete();
            lines->Delete();
            
            pd->GetPointData()->SetNormals(normals);
            normals->Delete();
            lineNormalGenerator->Delete();

            ribbons->SetInput(pd);
            ribbons->Update();
            
            pd->Delete();
            pd = ribbons->GetOutput();
            pd->Register(NULL);
            pd->SetSource(NULL);

            ribbons->Delete();
            append->AddInput(pd);
        }
        */
        else
        {
            append->AddInput(pd);
            pd->Delete();
        }
    }

    cout<<"Get ready to set some output!\n";
    append->Update();
    vtkPolyData *outPD = append->GetOutput();
    outPD->Register(NULL);
    outPD->SetSource(NULL);
    append->Delete();

    //ReportStatistics(streamlines);
    cout<<"SetOutputDataTree= "<<outPD<<endl;
    avtDataTree *dt = new avtDataTree(outPD, 0);
    SetOutputDataTree(dt);
#endif
}

// ****************************************************************************
//  Method: avtPoincareFilter::ModifyContract
//
//  Purpose:
//      
//
//  Programmer: Dave Pugmire
//  Creation:   Fri Nov  7 13:15:45 EST 2008
//
//  Modifications:
//
//
// ****************************************************************************

avtContract_p
avtPoincareFilter::ModifyContract(avtContract_p in_contract)
{
    avtDataRequest_p in_dr = in_contract->GetDataRequest();
    avtDataRequest_p out_dr = NULL;

    if (strcmp(in_dr->GetVariable(), "colorVar") == 0)
    {
        // The avtPoincarePlot requested "colorVar", so remove that from the
        // contract now.
        out_dr = new avtDataRequest(in_dr,in_dr->GetOriginalVariable());
    }
    
    avtContract_p out_contract;
    if ( *out_dr )
        out_contract = new avtContract(in_contract, out_dr);
    else
        out_contract = new avtContract(in_contract);

    return avtStreamlineFilter::ModifyContract(out_contract);
}

// ****************************************************************************
//  Method: avtPoincareFilter::Execute
//
//  Purpose:
//      Calculate poincare points.
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************

void
avtPoincareFilter::Execute()
{
    // Execute the baseclass.
    avtStreamlineFilter::Execute();

    /*

    //Get streamline points. This will be replaced w/ Hank's changes.
    vtkPolyData *inPD = (vtkPolyData *)inDS;
    std::vector<int> slInfo;
    slFilter->GetSLInfo( slInfo );

    terminatedSTreamlines.resize(slInfo.size());
    int cnt = 0;
    for (int i = 0; i < slInfo.size(); i++)
    {
        for (int j = 0; j < slInfo[i]; j++)
        {
            double *polyPt = inPD->GetPoints()->GetPoint(cnt);
            avtVector pt(polyPt[0], polyPt[1], polyPt[2]);
            streamlinePts[i].push_back(pt);
            //cout<<cnt<<": "<<pt<<endl;
            cnt++;
        }
    }

    GeneratePoincarePoints();
    ClassifyPoincarePoints();
    vtkPolyData *poincPD = CreatePoincareOutput();
   
    //Add streamlines to output, if requested.
    if (showStreamlines)
    {
        vtkAppendPolyData *append = vtkAppendPolyData::New();
        append->AddInput(inPD);
        append->AddInput(poincPD);
        append->Update();

        inPD->Delete();
        
        poincPD = append->GetOutput();
        poincPD->Register(NULL);
        poincPD->SetSource(NULL);
        append->Delete();
    }

    return poincPD;
    */
}


// ****************************************************************************
//  Method: avtPoincareFilter::UpdateDataObjectInfo
//
//  Purpose:
//      Allows the filter to change its output's data object information, which
//      is a description of the data object.
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************

void
avtPoincareFilter::UpdateDataObjectInfo(void)
{ 
    avtStreamlineFilter::UpdateDataObjectInfo();

    avtDataAttributes &atts = GetOutput()->GetInfo().GetAttributes();
    atts.SetTopologicalDimension(1);
    if (! atts.ValidVariable("colorVar"))
    {
        atts.AddVariable("colorVar");
        atts.SetActiveVariable("colorVar");
        atts.SetVariableDimension(1);
    }
}



// ****************************************************************************
//  Method: avtPoincareFilter::GetFieldlineProperties
//
//  Purpose:
//      Calculate properties of fieldline.  Code courtesy of Allen Sanderson,
//      University of Utah.
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************

void
avtPoincareFilter::GetFieldlineProperties( std::vector<avtVector> &points,
                                           unsigned int maxWinding,
                                           unsigned int &winding,
                                           unsigned int &twist,
                                           unsigned int &island )
{
    getFieldlineProperties( points, maxWinding, &winding, &twist, &island );
    //cout<<"Winding:Twist:Island = "<<winding<<" : "<<twist<<" : "<<island<<endl;
}


// ****************************************************************************
//  Method: avtPoincareFilter::GeneratePoincarePoints
//
//  Purpose:
//      Create poincare points from the streamlines.
//
//  Arguments:
//
//  Returns:      void
//
//  Programmer: Dave Pugmire
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************

void
avtPoincareFilter::GeneratePoincarePoints( vector<avtStreamlineWrapper*> &streamlines)
{
  poincarePts.resize(streamlines.size());

  for ( int i=0; i<streamlines.size(); ++i )
  {
    avtStreamline *sl = streamlines[i]->sl;
    
    avtStreamline::iterator siter = sl->begin();

    while( siter != sl->end() )
    {
      avtVector pt;
      pt.x = (*siter)->front()[0];
      pt.y = (*siter)->front()[1];
      pt.z = (*siter)->front()[2];

      poincarePts[i].push_back(pt);

      ++siter;
    }

    cout << i << ": There are " << poincarePts[i].size() << " fieldline points\n";
  }
}

// ****************************************************************************
//  Method: avtPoincareFilter::ClassifyPoincarePoints
//
//  Purpose:
//      Classify the poincare points.
//
//  Arguments:
//
//  Returns:      void
//
//  Programmer: Dave Pugmire
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************

void
avtPoincareFilter::ClassifyPoincarePoints()
{
    poincareClassification.resize(poincarePts.size());

    for ( int i = 0; i < poincarePts.size(); i++ )
    {
      unsigned int toroidalWinding, poloidalWinding, islands;
      GetFieldlineProperties(poincarePts[i], 30, toroidalWinding, poloidalWinding, islands);
      
      poincareClassification[i].push_back((int) toroidalWinding);
      poincareClassification[i].push_back((int) poloidalWinding);
      poincareClassification[i].push_back((int) islands);
      
      double safetyFactor = 0.0;
      
      if ( poloidalWinding > 0 )
        safetyFactor = (double) toroidalWinding / (double) poloidalWinding;

      cout << i
            << "  ptCnt = " << poincarePts[i].size()
            << "  toroidal windings = " <<  toroidalWinding
            << "  poloiddal windings = " << poloidalWinding
            << "  islands = " << islands
            << "  safety factor = " << safetyFactor
            << endl;
    }

    cout << endl;
}

// ****************************************************************************
//  Method: avtPoincareFilter::CreatePoincareOutput
//
//  Purpose:
//      Create poincare output
//
//  Arguments:
//
//  Returns:      Poincare segments
//
//  Programmer: Dave Pugmire
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************

vtkPolyData *
avtPoincareFilter::CreatePoincareOutput()
{
  vtkAppendPolyData *append = vtkAppendPolyData::New();

  for ( int i=0; i<poincarePts.size(); ++i )
  {
    unsigned int toroidalWinding = poincareClassification[i][0];
    unsigned int poloidalWinding = poincareClassification[i][1];
    unsigned int islands         = poincareClassification[i][2];
    
    // If toroidal winding is zero, skip it.
    if ( toroidalWinding == 0 )
      continue;
      
    double safetyFactor = 0.0;
    
    if ( poloidalWinding > 0 )
      safetyFactor = (double) toroidalWinding / (double) poloidalWinding;
    
    // Plane equation.
    double plane[4];
    plane[0] = clipPlaneN.x = 1.0;
    plane[1] = clipPlaneN.y = 0.0;
    plane[2] = clipPlaneN.z = 0.0;
    plane[3] = clipPlanePt.dot(clipPlaneN);
    
    // Collect all of the points that intersect the desired plane.
    // In this case it is currently fixed to the X plane.
    vector< avtVector > puncturePoints;
    
    avtVector p0, p1 = poincarePts[i][0];
    double dist0, dist1 = plane[0]*p1.x + plane[1]*p1.y + plane[2]*p1.z - plane[3];
    
    for( unsigned int j=1; j<poincarePts[i].size(); ++j )
    {
      p0 = p1;
      p1 = poincarePts[i][j];
      
      dist0 = dist1;
      dist1 = plane[0]*p1.x + plane[1]*p1.y + plane[2]*p1.z - plane[3];
      
      if (SIGN(dist0) != SIGN(dist1))
      {
        avtVector lnDir = p1 - p0;
        double dot = lnDir.dot(clipPlaneN);
  
        // Collect the points that intersect the desired plane.
        if ( dot > 0.0 )
        {
          avtVector w = p0 - clipPlanePt;
          double s = -clipPlaneN.dot(w) / dot;
          avtVector intersectPt = p0 + lnDir*s;
        
          puncturePoints.push_back(intersectPt);
        }
      }
    }
    
    cout << i << ": There are " << puncturePoints.size() << " puncture points\n";

    int cnt = 0;

    for ( int j=0; j<toroidalWinding; ++j )
    {
      std::vector<avtVector> ptSet;
      
      for ( int idx=j; idx<puncturePoints.size(); idx += toroidalWinding )
      {
        ptSet.push_back(puncturePoints[idx]);
      }

      cout << "Toroidal group " << j << " has " << ptSet.size() << " points." << endl;
      
      //Create groups that represent the toroidial groups.
      vtkPoints *points = vtkPoints::New();
      vtkCellArray *cells = vtkCellArray::New();
      vtkFloatArray *scalars = vtkFloatArray::New();
      
      cells->InsertNextCell(ptSet.size());
      scalars->Allocate(ptSet.size());
      
      for ( int k=0; k<ptSet.size(); ++k )
      {
         points->InsertPoint(k, ptSet[k].x, ptSet[k].y, ptSet[k].z);
         cells->InsertCellPoint(k);
         scalars->InsertTuple1(k, (double) cnt);
      }

      cnt++;
      
      // Create a new VTK polyline.
      vtkPolyData *pd = vtkPolyData::New();
      pd->SetPoints(points);
      pd->SetLines(cells);
      scalars->SetName("colorVar");
      pd->GetPointData()->SetScalars(scalars);
      
      append->AddInput(pd);
      
      points->Delete();
      cells->Delete();
      scalars->Delete();
      
      if (showPoints)
      {
        for ( int k=0; k<ptSet.size(); ++k )
        {
          double pt[3] = { ptSet[k].x, ptSet[k].y, ptSet[k].z };

          double rad = 0.005;
    
          vtkPolyData *ball = CreateSphere(-1.0, rad, pt);
          append->AddInput(ball);
          ball->Delete();
        }
      }
    }

    if (showStreamlines)
    {
      vtkPoints *points = vtkPoints::New();
      vtkCellArray *cells = vtkCellArray::New();
      vtkFloatArray *scalars = vtkFloatArray::New();
      
      cells->InsertNextCell(poincarePts[i].size());
      scalars->Allocate(poincarePts[i].size());
      
      for ( int j=0; j<poincarePts[i].size(); ++j )
      {
          points->InsertPoint(j,
          poincarePts[i][j].x,
          poincarePts[i][j].y,
          poincarePts[i][j].z);

          cells->InsertCellPoint(j);
          scalars->InsertTuple1(j, (double) i);
      }

      // Create a new VTK polyline.
      vtkPolyData *pd = vtkPolyData::New();
      pd->SetPoints(points);
      pd->SetLines(cells);
      scalars->SetName("colorVar");
      pd->GetPointData()->SetScalars(scalars);
      
      append->AddInput(pd);
      
      points->Delete();
      cells->Delete();
      scalars->Delete();
    }
  }
    
  append->Update();
  vtkPolyData *outPD = append->GetOutput();
  outPD->Register(NULL);
  outPD->SetSource(NULL);
  append->Delete();
  
  return outPD;
}

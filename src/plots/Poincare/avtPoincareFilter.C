/*****************************************************************************
*
* Copyright (c) 2000 - 2008, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-400142
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                              avtPoincareFilter.C                              //
// ************************************************************************* //

#include <avtPoincareFilter.h>
#include <avtStreamlineWrapper.h>

#include <vtkDataSet.h>
#include <vtkSlicer.h>
#include <vtkPolyData.h>
#include <vtkTubeFilter.h>
#include <vtkPolyLine.h>
#include <vtkQuad.h>
#include <vtkUnstructuredGrid.h>
#include <vtkCleanPolyData.h>

#include <vtkCellArray.h>
#include <vtkCellData.h>
#include <vtkPointData.h>
#include <vtkAppendPolyData.h>
#include <vtkSphereSource.h>
#include <vtkFloatArray.h>
#include <avtDatasetExaminer.h>
#include <avtExtents.h>

#define SIGN(x) ((x) < 0.0 ? -1 : 1)


// ****************************************************************************
//  Method: avtPoincareFilter constructor
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//
//    Dave Pugmire, Wed Feb 25 09:52:11 EST 2009
//    Add terminate by steps, add AdamsBashforth solver, Allen Sanderson's new code.
//
// ****************************************************************************

avtPoincareFilter::avtPoincareFilter() :
    showStreamlines(false),
    showPoints(false),
    override( 0 ),
    maxToroidalWinding( 30 ),
    hitrate( 0.90 ),
    showIslands(0),
    overlaps(1),
    color(8),
    is_curvemesh(1),
    adjust_plane(-1)
{
    planes.resize(1);
    planes[0] = 0;
}


// ****************************************************************************
//  Method: avtPoincareFilter destructor
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
// ****************************************************************************

avtPoincareFilter::~avtPoincareFilter()
{
}

static vtkPolyData *
CreateSphere(float val, double rad, double pt[3])
{
    // Create the sphere polydata.
    vtkSphereSource *sphere = vtkSphereSource::New();
    sphere->SetCenter(pt[0], pt[1], pt[2]);
    sphere->SetRadius(rad);
    sphere->SetLatLongTessellation(1);
    sphere->SetPhiResolution(8);
    sphere->SetThetaResolution(8);
    vtkPolyData *sphereData = sphere->GetOutput();
    sphereData->Update();

    // Set the sphere's scalar to val.
    vtkFloatArray *arr = vtkFloatArray::New();
    int npts = sphereData->GetNumberOfPoints();
    arr->SetNumberOfTuples(npts);
    for (int i = 0; i < npts; ++i)
        arr->SetTuple1(i, val);
    arr->SetName("colorVar");
    sphereData->GetPointData()->SetScalars(arr);
    arr->Delete();

    sphereData->Register(NULL);
    sphere->Delete();

    return sphereData;
}


// ****************************************************************************
//  Method: avtPoincareFilter::SetClipPlanes
//
//  Purpose:
//      Sets the attribute values from the GUI
//
//  Arguments:
//  Returns:      void
//
//  Creationist: Allen Sanderson
//  Creation:    Wed Feb 25 09:52:11 EST 2009
//
// ****************************************************************************

void
avtPoincareFilter::SetClipPlanes( vector< double > planeAngles )
{
    planes = planeAngles;
}

// ****************************************************************************
//  Method: avtPoincareFilter::SetOverrideToroidalWinding
//
//  Purpose:
//      Sets the attribute values from the GUI
//
//  Arguments:
//  Returns:      void
//
//  Creationist: Allen Sanderson
//  Creation:    Wed Feb 25 09:52:11 EST 2009
//
// ****************************************************************************

void
avtPoincareFilter::SetOverrideToroidalWinding( unsigned int value )
{
    override = value;
}

// ****************************************************************************
//  Method: avtPoincareFilter::SetMaxToroidalWinding
//
//  Purpose:
//      Sets the attribute values from the GUI
//
//  Arguments:
//  Returns:      void
//
//  Creationist: Allen Sanderson
//  Creation:    Wed Feb 25 09:52:11 EST 2009
//
// ****************************************************************************

void
avtPoincareFilter::SetMaxToroidalWinding( unsigned int value )
{
    maxToroidalWinding = value;
}

// ****************************************************************************
//  Method: avtPoincareFilter::SetHitRate
//
//  Purpose:
//      Sets the attribute values from the GUI
//
//  Arguments:
//  Returns:      void
//
//  Creationist: Allen Sanderson
//  Creation:    Wed Feb 25 09:52:11 EST 2009
//
// ****************************************************************************

void
avtPoincareFilter::SetHitRate( double val )
{
    hitrate = val;
}

// ****************************************************************************
//  Method: avtPoincareFilter::SetShowIslands
//
//  Purpose:
//      Sets the attribute values from the GUI
//
//  Arguments:
//  Returns:      void
//
//  Creationist: Allen Sanderson
//  Creation:    Wed Feb 25 09:52:11 EST 2009
//
// ****************************************************************************

void
avtPoincareFilter::SetShowIslands( bool val )
{
    showIslands = val;
}

// ****************************************************************************
//  Method: avtPoincareFilter::SetOverlaps
//
//  Purpose:
//      Sets the attribute values from the GUI
//
//  Arguments:
//  Returns:      void
//
//  Creationist: Allen Sanderson
//  Creation:    Wed Feb 25 09:52:11 EST 2009
//
// ****************************************************************************

void
avtPoincareFilter::SetOverlaps( unsigned int val )
{
    overlaps = val;
}

// ****************************************************************************
//  Method: avtPoincareFilter::SetColorStyle
//
//  Purpose:
//      Sets the attribute values from the GUI
//
//  Arguments:
//  Returns:      void
//
//  Creationist: Allen Sanderson
//  Creation:    Wed Feb 25 09:52:11 EST 2009
//
// ****************************************************************************

void
avtPoincareFilter::SetColorStyle( unsigned int value )
{
    color = value;
}

// ****************************************************************************
//  Method: avtPoincareFilter::SetShowCurves
//
//  Purpose:
//      Sets the attribute values from the GUI
//
//  Arguments:
//  Returns:      void
//
//  Creationist: Allen Sanderson
//  Creation:    Wed Feb 25 09:52:11 EST 2009
//
// ****************************************************************************

void
avtPoincareFilter::SetShowCurves( unsigned int val )
{
    is_curvemesh = val;
}

// ****************************************************************************
//  Method: avtPoincareFilter::SetAdjustPlane
//
//  Purpose:
//      Sets the attribute values from the GUI
//
//  Arguments:
//  Returns:      void
//
//  Creationist: Allen Sanderson
//  Creation:    Wed Feb 25 09:52:11 EST 2009
//
// ****************************************************************************

void
avtPoincareFilter::SetAdjustPlane( unsigned int val )
{
    adjust_plane = val;
}

// ****************************************************************************
//  Method: avtPoincareFilter::PreExecute
//
//  Purpose:
//      Get the current spatial extents if necessary.
//
//  Programmer: Dave Pugmire
//  Creation:   Fri Nov  7 13:01:47 EST 2008
//
//  Modifications:
//
//
// ****************************************************************************

void
avtPoincareFilter::PreExecute(void)
{
    avtStreamlineFilter::PreExecute();
}


// ****************************************************************************
//  Method: avtPoincareFilter::PostExecute
//
//  Purpose:
//      Get the current spatial extents if necessary.
//
//  Programmer: Dave Pugmire
//  Creation:   Fri Nov  7 13:01:47 EST 2008
//
//  Modifications:
//
//
// ****************************************************************************

void
avtPoincareFilter::PostExecute(void)
{
    avtStreamlineFilter::PostExecute();
    
    double range[2];
    avtDataset_p ds = GetTypedOutput();
    avtDatasetExaminer::GetDataExtents(ds, range, "colorVar");

    avtExtents *e;
    e = GetOutput()->GetInfo().GetAttributes().GetCumulativeTrueDataExtents();
    e->Merge(range);
    e = GetOutput()->GetInfo().GetAttributes().GetCumulativeCurrentDataExtents();
    e->Merge(range);
}

// ****************************************************************************
//  Method: avtPoincareFilter::CreateStreamlineOutput
//
//  Purpose:
//      Create the VTK poly data output from the streamline.
//
//  Programmer: Dave Pugmire
//  Creation:   Tue Dec  23 12:51:29 EST 2008
//
//  Modifications:
//
//    Dave Pugmire (for Allen Sanderson), Wed Feb 25 09:52:11 EST 2009
//    Add terminate by steps, add AdamsBashforth solver, Allen Sanderson's new code.
//
// ****************************************************************************

void
avtPoincareFilter::CreateStreamlineOutput( vector<avtStreamlineWrapper *> &streamlines)
{
    cout<<"There are " << streamlines.size()<<" streamlines.\n";
    GetStreamlinePoints(streamlines);
    ClassifyStreamlines();
    
    avtDataTree *dt = CreatePoincareOutput();
    SetOutputDataTree(dt);
}

// ****************************************************************************
//  Method: avtPoincareFilter::ModifyContract
//
//  Purpose:
//      
//
//  Programmer: Dave Pugmire
//  Creation:   Fri Nov  7 13:15:45 EST 2008
//
//  Modifications:
//
//
// ****************************************************************************

avtContract_p
avtPoincareFilter::ModifyContract(avtContract_p in_contract)
{
    avtDataRequest_p in_dr = in_contract->GetDataRequest();
    avtDataRequest_p out_dr = NULL;

    if (strcmp(in_dr->GetVariable(), "colorVar") == 0)
    {
        // The avtPoincarePlot requested "colorVar", so remove that from the
        // contract now.
        out_dr = new avtDataRequest(in_dr,in_dr->GetOriginalVariable());
    }
    
    avtContract_p out_contract;
    if ( *out_dr )
        out_contract = new avtContract(in_contract, out_dr);
    else
        out_contract = new avtContract(in_contract);

    return avtStreamlineFilter::ModifyContract(out_contract);
}

// ****************************************************************************
//  Method: avtPoincareFilter::Execute
//
//  Purpose:
//      Calculate poincare points.
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//    Dave Pugmire (for Allen Sanderson), Wed Feb 25 09:52:11 EST 2009
//    Add terminate by steps, add AdamsBashforth solver, Allen Sanderson's new code.
//
// ****************************************************************************

void
avtPoincareFilter::Execute()
{
    // Execute the baseclass which generates the streamlines.
    avtStreamlineFilter::Execute();
}


// ****************************************************************************
//  Method: avtPoincareFilter::UpdateDataObjectInfo
//
//  Purpose:
//      Allows the filter to change its output's data object information, which
//      is a description of the data object.
//
//  Programmer: Dave Pugmire -- generated by xml2avt
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//    Jeremy Meredith, Wed Apr  8 13:23:10 EDT 2009
//    Set topological dimension and normals request appropriately.
//
// ****************************************************************************

void
avtPoincareFilter::UpdateDataObjectInfo(void)
{ 
    avtStreamlineFilter::UpdateDataObjectInfo();

    avtDataAttributes &atts = GetOutput()->GetInfo().GetAttributes();
    avtDataValidity   &val  = GetOutput()->GetInfo().GetValidity();
    if (is_curvemesh)
    {
        atts.SetTopologicalDimension(1);
        val.SetNormalsAreInappropriate(true);
    }
    else
    {
        atts.SetTopologicalDimension(2);
        val.SetNormalsAreInappropriate(false);
    }

    if (! atts.ValidVariable("colorVar"))
    {
        atts.AddVariable("colorVar");
        atts.SetActiveVariable("colorVar");
        atts.SetVariableDimension(1);
    }
}

// ****************************************************************************
//  Method: avtPoincareFilter::GetStreamlinePoints
//
//  Purpose:
//      Get the points from the streamlines.
//
//  Arguments:
//
//  Returns:      void
//
//  Programmer: Dave Pugmire
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//    Dave Pugmire (for Allen Sanderson), Wed Feb 25 09:52:11 EST 2009
//    Add terminate by steps, add AdamsBashforth solver, Allen Sanderson's new code.
//
// ****************************************************************************

void
avtPoincareFilter::GetStreamlinePoints( vector<avtStreamlineWrapper*> &streamlines)
{
    streamlinePts.resize(streamlines.size());
    
    for ( int i=0; i<streamlines.size(); ++i )
    {
        avtStreamline *sl = streamlines[i]->sl;
        
        avtStreamline::iterator siter = sl->begin();
        
        while( siter != sl->end() )
        {
            avtVector pt;
            pt.x = (*siter)->front()[0];
            pt.y = (*siter)->front()[1];
            pt.z = (*siter)->front()[2];
            
            streamlinePts[i].push_back(pt);
            
            ++siter;
        }
        
        cout << i << ": There are " << streamlinePts[i].size() << " fieldline points\n";
    }
}

// ****************************************************************************
//  Method: avtPoincareFilter::ClassifyStreamlines
//
//  Purpose:
//      Classify the streamlines (toroidal/poloidal winding).
//
//  Arguments:
//
//  Returns:      void
//
//  Programmer: Dave Pugmire
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//    Dave Pugmire (for Allen Sanderson), Wed Feb 25 09:52:11 EST 2009
//    Add terminate by steps, add AdamsBashforth solver, Allen Sanderson's new code.
//
// ****************************************************************************

void
avtPoincareFilter::ClassifyStreamlines()
{
    for ( int i = 0; i < streamlinePts.size(); i++ )
    {
        FieldlineInfo fi = FLlib.fieldlineProperties( streamlinePts[i],
                                                      override,
                                                      maxToroidalWinding,
                                                      hitrate );

        poincareClassification.push_back( fi );
        
        double safetyFactor;
        
        if ( fi.poloidalWinding > 0 )
            safetyFactor = (double) fi.toroidalWinding / (double) fi.poloidalWinding;
        else
            safetyFactor = 0;
        
        cout << i
             << "  ptCnt = " << streamlinePts[i].size()
             << "  toroidal windings = " <<  fi.toroidalWinding
             << "  poloiddal windings = " << fi.poloidalWinding
             << "  islands = " << fi.islands
             << "  safety factor = " << safetyFactor
             << endl;
    }
    
    cout << endl;
}

// ****************************************************************************
//  Method: avtPoincareFilter::CreatePoincareOutput
//
//  Purpose:
//      Create poincare output
//
//  Arguments:
//
//  Returns:      Poincare segments
//
//  Programmer: Dave Pugmire
//  Creation:   Tue Oct 7 09:02:52 PDT 2008
//
//  Modifications:
//    Dave Pugmire (for Allen Sanderson), Wed Feb 25 09:52:11 EST 2009
//    Add terminate by steps, add AdamsBashforth solver, Allen Sanderson's new code.
//
// ****************************************************************************

avtDataTree *
avtPoincareFilter::CreatePoincareOutput()
{
    avtDataTree *dt = new avtDataTree();
    
    for ( int i=0; i<streamlinePts.size(); ++i )
    {
        FieldlineType type           = poincareClassification[i].type;
        unsigned int toroidalWinding = poincareClassification[i].toroidalWinding;
        unsigned int poloidalWinding = poincareClassification[i].poloidalWinding;
        unsigned int islands         = poincareClassification[i].islands;
        unsigned int skip            = poincareClassification[i].skip;
        unsigned int nnodes          = (unsigned int) poincareClassification[i].nnodes;
        bool completeIslands = true;

        // If toroidal winding is zero, skip it.
        if( toroidalWinding == 0 ) 
        {
            std::cerr << i << " SKIPPING TOROIDALWINDING OF 0" << std::endl;
            
            std::pair< unsigned int, unsigned int > topo( 0, 0 );
            //      topology.push_back(topo);
            
            continue;
        }
        
        else if( type == UNKNOWN || type == CHAOTIC ) 
        {
            std::cerr << i << " SKIPPING " << std::endl;
            
            std::pair< unsigned int, unsigned int > topo( 0, 0 );
            //      topology.push_back(topo);
            
            continue;
        }
        
        // Get the direction of the streamline toroidalWinding.
        Point lastPt = streamlinePts[i][0];
        Point currPt = streamlinePts[i][1];
        
        bool CCWstreamline = (atan2( lastPt.y, lastPt.x ) <
                              atan2( currPt.y, currPt.x ));
        

        // Put all of the points into the bins for each plane.
        std::vector< std::vector< std::vector < Point > > > puncturePts;
        
        puncturePts.resize( planes.size() );
        
        unsigned int startIndex = 0;
        
        for( unsigned int p=0; p<planes.size(); ++p ) 
        {
            Vector planeN;
            Vector planePt(0,0,0);
            
            // Go through the planes in the same direction as the streamline.
            if( CCWstreamline )
            {
                planeN = Vector( cos(planes[p]),
                                 sin(planes[p]),
                                 0 );
            }
            else
            {
                planeN = Vector( cos(planes[planes.size()-1-p]),
                                 sin(planes[planes.size()-1-p]),
                                 0 );
            }
            
            // Set up the plane equation.
            double plane[4];
            
            plane[0] = planeN.x;
            plane[1] = planeN.y;
            plane[2] = planeN.z;
            plane[3] = planePt.dot(planeN);
            
            //      cerr << "Plane " << p << " is " << plane << endl;
            
            //    cerr << "Starting new streamline binning " << c << endl;
            
            puncturePts[p].resize( toroidalWinding );
            int bin = 0;
            
            // So to get the winding groups consistant start examining the
            // streamline in the same place for each plane.
            Vector lastPt, currPt( streamlinePts[i][startIndex] );
            double lastDist, currDist = planeN.dot( currPt ) - plane[3];
            
            for( unsigned int j=startIndex+1; j<streamlinePts[i].size(); ++j )
            {
                lastPt = currPt;
                currPt = Vector(streamlinePts[i][j]);
                
                lastDist = currDist;
                currDist = Dot( planeN, currPt ) - plane[3];
                
                // First look at only points that intersect the plane.
                if( SIGN(lastDist) != SIGN(currDist) ) 
                {
                    Vector dir(currPt-lastPt);
                    
                    double dot = Dot(planeN, dir);
                    
                    // If the segment is in the same direction as the plane then
                    // find where it intersects the plane.
                    if( dot > 0.0 )
                    {
                        // So to get the winding groups consistant start examining
                        // the streamline in the same place for each plane so
                        // store the index of the first puncture point.
                        if( p == 0 && puncturePts[p][bin].size() == 0 )
                            startIndex = j - 1;
                        
                        Vector w = lastPt - planePt;
                        
                        double t = -Dot(planeN, w ) / dot;
                        
                        Point point = Point(lastPt + dir * t);
                        
                        puncturePts[p][bin].push_back( point );
                        
                        bin = (bin + 1) % toroidalWinding;
                        
                    }
                }
            }
        }
        
        bool VALID = true;
        
        // Sanity check
        for( unsigned int p=0; p<planes.size(); ++p ) 
        {
            for( unsigned int j=0; j<toroidalWinding; ++j ) 
            {
                if( nnodes > puncturePts[p][j].size() )
                    nnodes = puncturePts[p][j].size();
                
                if( puncturePts[p][j].size() < 1 ) 
                {
                    std::cerr << "INVALID - Plane " << p
                              << " bin  " << j
                              << " number of points " << puncturePts[p][j].size()
                              << std::endl;
                    VALID = false;
                    
                    return NULL;
                }
            }
        }
        
        
        
        // Get the rest of the info only from the phi = zero plane.
        unsigned int p;
        
        if( CCWstreamline )
            p = 0;
        else
            p = planes.size()-1;
        
        // Get the centroid of each toroidal winding group and all
        // puncture points.
        //    Vector globalCentroid(0,0,0);
        std::vector< Vector > localCentroids;
        std::vector< Vector > localSeparatrices[2];
        
        localCentroids.resize(toroidalWinding);
        localSeparatrices[0].resize(toroidalWinding);
        localSeparatrices[1].resize(toroidalWinding);
        
        for( unsigned int j=0; j<toroidalWinding; ++j ) 
        {
            localCentroids[j] = Vector(0,0,0);
            
            for( unsigned int k=0; k<puncturePts[p][j].size(); ++k ) 
                localCentroids[j] += (Vector) puncturePts[p][j][k];
            
            if( puncturePts[p][j].size() ) 
            {
                localCentroids[j] /= (double) puncturePts[p][j].size();
                
                //        globalCentroid += localCentroids[j];
            }
        }
        
        //    globalCentroid /= toroidalWinding;
        
        // Get the direction of the points within a group.
        //    Vector v0 = (Vector) puncturePts[p][0][0] - globalCentroid;
        //    Vector v1 = (Vector) puncturePts[p][0][1] - globalCentroid;
        
        //    bool groupCCW = (FLlib.ccw( v0, v1 ) == 1);
        //    cerr << 0.0<< "  " << groupCCW << endl;
        
        if( type == ISLAND_CHAIN ) 
        {
            for( unsigned int j=0; j<toroidalWinding; ++j ) 
            {
                unsigned int startIndex;
                unsigned int middleIndex;
                unsigned int stopIndex;
                unsigned int nodes;
                
                Vector localCentroid;
                
                unsigned int turns =
                    FLlib.islandProperties( puncturePts[p][j], localCentroid,
                                            startIndex, middleIndex, stopIndex, nodes );
                
                //      cerr << "Island " << i  << "   "
                //           << "Turns " << turns  << "   "
                //           << "nodes " << nodes  << "   "
                //           << "Indexes "
                //           << startIndex  << "  "
                //           << middleIndex << "  "
                //           << stopIndex   << endl;
                
                
                //      if( turns < 3 )
                //      completeIslands = false;
                
                if( turns >= 2 ) 
                {
                    //        localSeparatrices[0][j] = (Vector) puncturePts[p][j][startIndex];
                    //        localSeparatrices[1][j] = (Vector) puncturePts[p][j][middleIndex];
                }
                
                if( turns == 3 ) 
                {
                    unsigned int index0 = (middleIndex - startIndex ) / 2;
                    unsigned int index1 = (  stopIndex - middleIndex) / 2;
                    
                    //      cerr << "Indexes mid " << nodes << " nodes "
                    //           << "  " << ( startIndex + index0)%nodes 
                    //           << "  " << (middleIndex - index0)%nodes
                    //           << "  " << (middleIndex + index1)%nodes
                    //           << "  " << (  stopIndex - index1)%nodes << endl;
                    
                    localCentroids[j] =
                        ( (Vector) puncturePts[p][j][( startIndex + index0)%nodes] + 
                          (Vector) puncturePts[p][j][(middleIndex - index0)%nodes] +
                          
                          (Vector) puncturePts[p][j][(middleIndex + index1)%nodes] + 
                          (Vector) puncturePts[p][j][(  stopIndex - index1)%nodes] ) / 4.0;
                } 
                else if( turns == 2 ) 
                {
                    unsigned int index0 = (middleIndex - startIndex ) / 2;
                    
                    //      cerr << "Indexes mid " << nodes << " nodes "
                    //           << "  " << ( startIndex + index0)%nodes 
                    //           << "  " << (middleIndex - index0)%nodes
                    //           << "  " << (middleIndex + index1)%nodes
                    //           << "  " << (  stopIndex - index1)%nodes << endl;
                    
                    localCentroids[j] =
                        ( (Vector) puncturePts[p][j][( startIndex + index0)%nodes] + 
                          (Vector) puncturePts[p][j][(middleIndex - index0)%nodes] ) / 2.0;
                    
                } 
                else if( turns == 1 ) 
                {
                    unsigned int index0 = (stopIndex - startIndex ) / 2;
                    
                    //      cerr << "Indexes mid " << nodes << " nodes "
                    //           << "  " << ( startIndex + index0)%nodes 
                    //           << "  " << (middleIndex - index0)%nodes
                    //           << "  " << (middleIndex + index1)%nodes
                    //           << "  " << (  stopIndex - index1)%nodes << endl;
                    
                    localCentroids[j] =
                        ( (Vector) puncturePts[p][j][(startIndex + index0)%nodes] + 
                          (Vector) puncturePts[p][j][( stopIndex - index0)%nodes] ) / 2.0;
                }
                
                //      // Get the principal axes of the island.
                //      Vector localCentroid(0,0,0);
                
                //      for( unsigned int k=0; k<puncturePts[p][j].size(); ++k )
                //        localCentroid += (Vector) puncturePts[p][j][k];
                
                //      localCentroid /= (float) puncturePts[p][j].size();
                
                //      float Ixx = 0.0;
                //      float Ixz = 0.0;
                //      float Izz = 0.0;
                
                //      double maxDist = 0;
                
                //      for( unsigned int k=0; k<puncturePts[p][j].size(); k++ ) {
                
                //        Vector vec = (Vector) puncturePts[p][j][k] - localCentroid;
                
                //        if( maxDist < vec.length() )
                //          maxDist = vec.length();
                
                //        Ixx += vec.z()*vec.z();
                //        Ixz -= vec.x()*vec.z();
                //        Izz += vec.x()*vec.x();
                //      }
                
                //      float alpha = atan( 2.0 * Ixz / (Ixx - Izz) ) / 2.0;
                
                // //       cerr << "PRINCIPAL AXES " << alpha * 180.0 / M_PI << "    "
                // //      << Ixx + Ixz * sin(alpha       )/cos(alpha       ) << "    "
                // //      << Izz + Ixz * cos(alpha+M_PI/2)/sin(alpha+M_PI/2) << endl;
                
                //      if( Ixx + Ixz * sin(alpha       )/cos(alpha       ) >
                //          Izz + Ixz * cos(alpha+M_PI/2)/sin(alpha+M_PI/2) )
                //        localCentroid += Vector(  cos(alpha), 0, sin(alpha) ) * maxDist;
                //      else
                //        localCentroid += Vector( -sin(alpha), 0, cos(alpha) ) * maxDist;
                
                //      localCentroids[j] = localCentroid;
                
            }
        }  // if( type == ISLAND_CHAIN )
        
        for( unsigned int p=0; p<planes.size(); p++ ) 
        {
            if( type != RATIONAL ) 
            {
                if( overlaps == 1 || overlaps == 3 )
                    FLlib.removeOverlap( puncturePts[p], nnodes,
                                         toroidalWinding, poloidalWinding,
                                         skip, islands );
                if( overlaps == 2 )
                    FLlib.mergeOverlap( puncturePts[p], nnodes,
                                        toroidalWinding, poloidalWinding,
                                        skip, islands );
                else if( overlaps == 3 )
                    FLlib.smoothCurve( puncturePts[p], nnodes,
                                       toroidalWinding, poloidalWinding,
                                       skip, islands );
            }
            
            bool VALID = true;
            
            // Sanity check
            for( unsigned int j=0; j<toroidalWinding; ++j ) 
            {
                if( nnodes > puncturePts[p][j].size() )
                    nnodes = puncturePts[p][j].size();
                
                if( puncturePts[p][j].size() < 1 ) 
                {
                    std::cerr << "INVALID - Plane " << p
                              << " bin  " << j
                              << " number of points " << puncturePts[p][j].size()
                              << std::endl;
                    
                    VALID = false;
                    
                    return NULL;
                }
                
                //      cerr << "Surface " << i
                //           << " plane " << p
                //           << " bin " << j
                //           << " base number of nodes " << nnodes
                //           << " number of points " << puncturePts[p][j].size()
                //           << endl;
            }
        }
        
        std::cerr << "Surface " << i << " is a " << type << "  "
                  << toroidalWinding << ":" << poloidalWinding << " surface ("
                  << (double) toroidalWinding / (double) poloidalWinding << ") ";
        
        if( type == ISLAND_CHAIN ) 
            std::cerr << "that contains " << islands << " islands"
                      << (completeIslands ? " (Complete)" : "");
        
        std::cerr << " and has " << nnodes << " nodes" << std::endl;
        
        if( type == ISLAND_CHAIN && islands != toroidalWinding ) 
        {
            std::cerr << "WARNING - The island count does not match the toroidalWinding count" 
                      << std::endl;
        }
        
        // Record the topology.
        std::pair< unsigned int, unsigned int >
            topo( toroidalWinding, poloidalWinding );
        
        //    topology.push_back(topo);
        
        
        if( !showIslands || (showIslands && islands) ) 
        {
            double color_value = 0;
            
            if( color == 1 )
                color_value = i;
            else if( color == 6 )
                color_value = toroidalWinding;
            else if( color == 7 )
                color_value = poloidalWinding;
            else if( color == 8 )
                color_value = (double) toroidalWinding / (double) poloidalWinding;
            
            // Currently the surface mesh is a structquad so set the dims - it
            // really should be and unstructured surface so multiple surface
            // can be generated.
            if( is_curvemesh ) 
            {
                loadCurve( dt, puncturePts, color, color_value );
            }
            else
            {
              loadSurface( dt, puncturePts, nnodes, islands, skip, color, color_value );
            }
        }
    }
    
    for ( int i=0; i<streamlinePts.size(); ++i )
    {
        if (showStreamlines)
        {
            vtkPoints *points = vtkPoints::New();
            vtkCellArray *cells = vtkCellArray::New();
            vtkFloatArray *scalars = vtkFloatArray::New();
            
            cells->InsertNextCell(streamlinePts[i].size());
            scalars->Allocate(streamlinePts[i].size());
            
            for ( int j=0; j<streamlinePts[i].size(); ++j )
            {
                points->InsertPoint(j,
                                    streamlinePts[i][j].x,
                                    streamlinePts[i][j].y,
                                    streamlinePts[i][j].z);
                
                cells->InsertCellPoint(j);
                scalars->InsertTuple1(j, (double) i);
            }
            
            // Create a new VTK polyline.
            vtkPolyData *pd = vtkPolyData::New();
            pd->SetPoints(points);
            pd->SetLines(cells);
            scalars->SetName("colorVar");
            pd->GetPointData()->SetScalars(scalars);
            
            pd->Register(NULL);
            pd->SetSource(NULL);
            
            dt->Merge( new avtDataTree(pd, 0) );
            
            points->Delete();
            cells->Delete();
            scalars->Delete();
        }
    }
    
    std::cerr << std::endl << std::endl
              << "count " << streamlinePts.size()
        //          << "  safetyFactorConsistant  " << safetyFactorConsistant
        //          << "  poloidalPeriodicyMatch  " << poloidalPeriodicyMatch
        //          << "  poloidalPeriodicyMismatch  " << poloidalPeriodicyMismatch
              << std::endl << std::endl;
    
    return dt;
}

// ****************************************************************************
//  Method: avtPoincareFilter::loadCurve
//
//  Purpose: Creates a curve from the puncture points. Each curve represent one
//           toroidal winding group.
//
//  Arguments:
//
//  Returns:      void
//
//  Programmer: Allen Sanderson
//  Creation:   Wed Feb 25 09:52:11 EST 2009
//
//  Modifications:
//
// ****************************************************************************

void
avtPoincareFilter::loadCurve( avtDataTree *dt,
                              vector< vector < vector < Point > > > &nodes,
                              unsigned int color,
                              double color_value ) 
{
    vtkAppendPolyData *append = vtkAppendPolyData::New();
    
    unsigned int nplanes = nodes.size();
    unsigned int toroidalWindings = nodes[0].size();
    
    // Loop through each plane
    for( unsigned int p=0; p<nplanes; ++p ) 
    {
        if( color == 3 )
            color_value = p;
        
        // Loop through each toroidial group
        for( unsigned int j=0; j<toroidalWindings; ++j ) 
        {
            //Create groups that represent the toroidial groups.
            vtkPoints *points = vtkPoints::New();
            vtkCellArray *cells = vtkCellArray::New();
            vtkFloatArray *scalars = vtkFloatArray::New();
            
            cells->InsertNextCell(nodes[p][j].size());
            scalars->Allocate(nodes[p][j].size());
            
            if( color == 4 )
                color_value = j;
            
            // Loop through each point in toroidial group
            for( unsigned int i=0; i<nodes[p][j].size(); ++i ) 
            {
                points->InsertPoint(i, nodes[p][j][i].x, nodes[p][j][i].y, nodes[p][j][i].z);
                cells->InsertCellPoint(i);

                if( color == 2 )
                    color_value = (i*toroidalWindings+j)*nplanes + p;
                else if( color == 5 )
                    color_value =  i;
                
                scalars->InsertTuple1(i, color_value);
            }
            
            // Create a new VTK polyline.
            vtkPolyData *pd = vtkPolyData::New();
            pd->SetPoints(points);
            pd->SetLines(cells);
            scalars->SetName("colorVar");
            pd->GetPointData()->SetScalars(scalars);
            
            append->AddInput(pd);
            
            points->Delete();
            cells->Delete();
            scalars->Delete();       
        }
    }
    
    if (showPoints)
    {
        for( unsigned int p=0; p<nplanes; ++p ) 
        {
            if( color == 3 )
                color_value = p;
            
            // Loop through each toroidial group
            for( unsigned int j=0; j<toroidalWindings; ++j ) 
            {
                if( color == 4 )
                    color_value = j;
                
                // Loop through each point in toroidial group
                for( unsigned int i=1; i<nodes[p][j].size(); ++i )
                {      
                    double pt[3] = { nodes[p][j][i].x, nodes[p][j][i].y, nodes[p][j][i].z };
                    
                    double rad = 0.005;
                    
                    vtkPolyData *ball = CreateSphere(-1.0, rad, pt);
                    
                    //         if( color == 2 )
                    //           color_value = (i*toroidalWindings+j)*nplanes + p;
                    //         else if( color == 5 )
                    //           color_value =  i;
                    
                    //        scalars->InsertTuple1(i, color_value);
                    
                    append->AddInput(ball);
                    ball->Delete();
                }
            }
        }
    }
    
    append->Update();
    vtkPolyData *outPD = append->GetOutput();
    outPD->Register(NULL);
    outPD->SetSource(NULL);
    append->Delete();
    
    dt->Merge( new avtDataTree(outPD, 0) );
}

// ****************************************************************************
//  Method: avtPoincareFilter::loadSurface
//
//  Purpose: Creates a surface from a series the puncture points. The
//           surface is sweep from each toroidal winding group around
//           each plane in the torus. Each is connected together to
//           form a circular cross section.
//
//  Arguments:
//
//  Returns:      void
//
//  Programmer: Allen Sanderson
//  Creation:   Wed Feb 25 09:52:11 EST 2009
//
//  Modifications:
//
// ****************************************************************************

void
avtPoincareFilter::loadSurface( avtDataTree *dt,
                                vector< vector < vector < Point > > > &nodes,
                                unsigned int nnodes,
                                unsigned int islands,
                                unsigned int skip,
                                unsigned int color,
                                double color_value) 
{
    unsigned int nplanes = nodes.size();
    unsigned int toroidalWindings = nodes[0].size();
    
    int dims[2];
    
    // Add one to the first dimension to create a closed cylinder. Add
    // one to the second dimension to form a torus.
    dims[0] = nnodes + 1;
    dims[1] = nplanes * toroidalWindings + 1;
    
    // Create an unstructured quad for the island surface.
    vtkUnstructuredGrid *grid = vtkUnstructuredGrid::New();
    vtkQuad *quad = vtkQuad::New();
    vtkPoints *points = vtkPoints::New();
    vtkFloatArray *scalars = vtkFloatArray::New();
    
    points->SetNumberOfPoints(dims[0]*dims[1]);
    scalars->Allocate(dims[0]*dims[1]);
    
    float *points_ptr = (float *) points->GetVoidPointer(0);
    
    // Determine if the winding group order matches the point
    // ordering. This is only needed when building surfaces.
    Vector v0 = nodes[0][   0][1] - nodes[0][0][0];
    Vector v1 = nodes[0][skip][0] - nodes[0][0][0];

    bool flip;

    if( Dot( v0, v1 ) < 0 )
      flip = true;
    else
      flip = false;

    // Loop through each toroidial group
    for( unsigned int j=0; j<toroidalWindings; ++j )
    {
        if( color == 4 )
            color_value = j;

        // Loop through each plane.
        for( unsigned int p=0; p<nplanes; ++p ) 
        {
            // Normally each toroidial winding group can be displayed in the
            // order received. Except for the last plane where it needs to
            // be adjusted by one group. That is if the streamline started
            // in the "correct" place. This is not always the case so it may
            // be necessary to adjust the toroidal winding group location by
            // one.
            unsigned int k;
            
            if( p == adjust_plane )
            {
                k = (j-1 + toroidalWindings) % toroidalWindings;
            }
            else
            {
                k = j;
            }
            
            unsigned int jj = nplanes * j + p;
            
            if( color == 3 )
                color_value = jj;
            
            // Loop through each point in toroidial group.
            for(unsigned int i=0; i<nnodes; ++i )
            {
                unsigned int n1 = jj * dims[0] + i;

                points_ptr[n1*3+0] = nodes[p][k][i].x;
                points_ptr[n1*3+1] = nodes[p][k][i].y;
                points_ptr[n1*3+2] = nodes[p][k][i].z;

                if( color == 2 )
                    color_value = (i*toroidalWindings+j)*nplanes + p;
                else if( color == 5 )
                    color_value =  i;
                
                scalars->InsertTuple1(n1, color_value);

                // Create the quad.
                quad->GetPointIds()->SetId( 0,   jj    * dims[0] + i );
                quad->GetPointIds()->SetId( 1,  (jj+1) * dims[0] + i );
                quad->GetPointIds()->SetId( 2,  (jj+1) * dims[0] + i + 1);
                quad->GetPointIds()->SetId( 3,   jj    * dims[0] + i + 1);
                
                grid->InsertNextCell( quad->GetCellType(), quad->GetPointIds() );                
            }

            // For a surface add in the first point from the adjacent
            // toroidial group. Otherwise for an island add in the
            // first point from the current toroidal group.
            if( !islands )
            {
              if( flip )
                k = (k-skip+toroidalWindings) % toroidalWindings;
              else
                k = (k+skip) % toroidalWindings;
            }

            unsigned int i = nnodes;

            unsigned int n1 = jj * dims[0] + i;
            
            points_ptr[n1*3+0] = nodes[p][k][0].x;
            points_ptr[n1*3+1] = nodes[p][k][0].y;
            points_ptr[n1*3+2] = nodes[p][k][0].z;
            
            if( color == 2 )
              color_value = (i*toroidalWindings+j)*nplanes + p;
            else if( color == 5 )
              color_value =  i;
            
            scalars->InsertTuple1(n1, color_value);
        }
    }
    
    // Add in the first toroidal group from the first plane to complete
    // the torus.
    unsigned int j = 0;
    
    if( color == 4 )
        color_value = j;
    
    // Add in the first toroidal group from the first plane to complete
    // the torus.
    unsigned int p = 0;
    
    // Normally each toroidial group can be displayed in the order
    // received. Except for the last plane where it needs to be
    // adjusted by one group. That is if the streamline started in
    // the "correct" place. This is not always the case so it may be
    // necessary to adjust the winding group location by one.
    unsigned int k;
    
    if( p == adjust_plane )
    {
        k = (j-1 + toroidalWindings) % toroidalWindings;
    }
    else
    {
        k = j;
    }
    
    unsigned int jj = nplanes * toroidalWindings;
    
    if( color == 3 )
        color_value = jj;
    
    // Loop through each point in toroidial group.
    for(unsigned int i=0; i<nnodes; ++i )
    {
        unsigned int n1 = jj * dims[0] + i;
        
        points_ptr[n1*3+0] = nodes[p][k][i].x;
        points_ptr[n1*3+1] = nodes[p][k][i].y;
        points_ptr[n1*3+2] = nodes[p][k][i].z;

        if( color == 2 )
            color_value = (i*toroidalWindings+j)*nplanes + p;
        else if( color == 5 )
          color_value =  i;
        
        scalars->InsertTuple1(n1, color_value);
    }

    // For a surface add in the first point from the adjacent
    // toroidial group. Otherwise for an island add in the
    // first point from the current toroidal group.
    if( !islands )
    {
      if( flip )
        k = (k-skip+toroidalWindings) % toroidalWindings;
      else
        k = (k+skip) % toroidalWindings;
    }

    unsigned int i = nnodes;
    unsigned int n1 = jj * dims[0] + i;
    
    points_ptr[n1*3+0] = nodes[p][k][0].x;
    points_ptr[n1*3+1] = nodes[p][k][0].y;
    points_ptr[n1*3+2] = nodes[p][k][0].z;
    
    if( color == 2 )
      color_value = (i*toroidalWindings+j)*nplanes + p;
    else if( color == 5 )
      color_value =  i;
    
    scalars->InsertTuple1(n1, color_value);


    // Stuff the points and scalars into the VTK unstructure grid.
    grid->SetPoints(points);
    scalars->SetName("colorVar");
    grid->GetPointData()->SetScalars(scalars);
    
    dt->Merge( new avtDataTree(grid, 0) );
    
    quad->Delete();
    points->Delete();
    scalars->Delete();
}


/*****************************************************************************
*
* Copyright (c) 2000 - 2007, The Regents of the University of California
* Produced at the Lawrence Livermore National Laboratory
* All rights reserved.
*
* This file is part of VisIt. For details, see http://www.llnl.gov/visit/. The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or materials provided with the distribution.
*  - Neither the name of the UC/LLNL nor  the names of its contributors may be
*    used to  endorse or  promote products derived from  this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED.  IN  NO  EVENT  SHALL  THE  REGENTS  OF  THE  UNIVERSITY OF
* CALIFORNIA, THE U.S.  DEPARTMENT  OF  ENERGY OR CONTRIBUTORS BE  LIABLE  FOR
* ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

#include <ParallelAxisAttributes.h>
#include <DataNode.h>

// Type map format string
const char *ParallelAxisAttributes::TypeMapFormatString = "s*id*d*d*d*i*i*is*i*d*s*id*babfia";

// ****************************************************************************
// Method: ParallelAxisAttributes::ParallelAxisAttributes
//
// Purpose: 
//   Constructor for the ParallelAxisAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 16 12:20:06 PDT 2007
//
// Modifications:
//   
// ****************************************************************************

ParallelAxisAttributes::ParallelAxisAttributes() : 
    AttributeSubject(ParallelAxisAttributes::TypeMapFormatString),
    linesColor(128, 0, 0), contextColor(0, 255, 0)
{
    orderedAxisNames.push_back("default");
    shownVarAxisOrdinal = 0;
    axisMinima.push_back(-1e+37);
    axisMaxima.push_back(1e+37);
    extentMinima.push_back(0);
    extentMaxima.push_back(1);
    extMinTimeOrds.push_back(0);
    extMaxTimeOrds.push_back(0);
    plotToolModeFlags = EA_AXIS_INFO_AUTO_LAYOUT_FLAG;
    axisGroupNames.push_back("(not_in_a_group)");
    axisInfoFlagSets.push_back(EA_THRESHOLD_BY_EXTENT_FLAG |
        EA_SHOW_ALL_AXIS_INFO_FLAGS | EA_AXIS_INFO_SHOWN_FLAG);
    axisXPositions.push_back(-1);
    axisAttributeVariables.push_back("default");
    attributesPerAxis = PCP_ATTRIBUTES_PER_AXIS;
    for (int attDataID = 0; attDataID <= PCP_ATTRIBUTES_PER_AXIS; attDataID++)
        axisAttributeData.push_back(0.0);
    drawLines = true;
    drawContext = true;
    contextGamma = 2;
    contextNumPartitions = 32;
}

// ****************************************************************************
// Method: ParallelAxisAttributes::ParallelAxisAttributes
//
// Purpose: 
//   Copy constructor for the ParallelAxisAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 16 12:20:06 PDT 2007
//
// Modifications:
//   
// ****************************************************************************

ParallelAxisAttributes::ParallelAxisAttributes(const ParallelAxisAttributes &obj) : 
    AttributeSubject(ParallelAxisAttributes::TypeMapFormatString)
{
    orderedAxisNames = obj.orderedAxisNames;
    shownVarAxisOrdinal = obj.shownVarAxisOrdinal;
    axisMinima = obj.axisMinima;
    axisMaxima = obj.axisMaxima;
    extentMinima = obj.extentMinima;
    extentMaxima = obj.extentMaxima;
    extMinTimeOrds = obj.extMinTimeOrds;
    extMaxTimeOrds = obj.extMaxTimeOrds;
    plotToolModeFlags = obj.plotToolModeFlags;
    axisGroupNames = obj.axisGroupNames;
    axisInfoFlagSets = obj.axisInfoFlagSets;
    axisXPositions = obj.axisXPositions;
    axisAttributeVariables = obj.axisAttributeVariables;
    attributesPerAxis = obj.attributesPerAxis;
    axisAttributeData = obj.axisAttributeData;
    drawLines = obj.drawLines;
    linesColor = obj.linesColor;
    drawContext = obj.drawContext;
    contextGamma = obj.contextGamma;
    contextNumPartitions = obj.contextNumPartitions;
    contextColor = obj.contextColor;

    SelectAll();
}

// ****************************************************************************
// Method: ParallelAxisAttributes::~ParallelAxisAttributes
//
// Purpose: 
//   Destructor for the ParallelAxisAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 16 12:20:06 PDT 2007
//
// Modifications:
//   
// ****************************************************************************

ParallelAxisAttributes::~ParallelAxisAttributes()
{
    // nothing here
}

// ****************************************************************************
// Method: ParallelAxisAttributes::operator = 
//
// Purpose: 
//   Assignment operator for the ParallelAxisAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 16 12:20:06 PDT 2007
//
// Modifications:
//   
// ****************************************************************************

ParallelAxisAttributes& 
ParallelAxisAttributes::operator = (const ParallelAxisAttributes &obj)
{
    if (this == &obj) return *this;
    orderedAxisNames = obj.orderedAxisNames;
    shownVarAxisOrdinal = obj.shownVarAxisOrdinal;
    axisMinima = obj.axisMinima;
    axisMaxima = obj.axisMaxima;
    extentMinima = obj.extentMinima;
    extentMaxima = obj.extentMaxima;
    extMinTimeOrds = obj.extMinTimeOrds;
    extMaxTimeOrds = obj.extMaxTimeOrds;
    plotToolModeFlags = obj.plotToolModeFlags;
    axisGroupNames = obj.axisGroupNames;
    axisInfoFlagSets = obj.axisInfoFlagSets;
    axisXPositions = obj.axisXPositions;
    axisAttributeVariables = obj.axisAttributeVariables;
    attributesPerAxis = obj.attributesPerAxis;
    axisAttributeData = obj.axisAttributeData;
    drawLines = obj.drawLines;
    linesColor = obj.linesColor;
    drawContext = obj.drawContext;
    contextGamma = obj.contextGamma;
    contextNumPartitions = obj.contextNumPartitions;
    contextColor = obj.contextColor;

    SelectAll();
    return *this;
}

// ****************************************************************************
// Method: ParallelAxisAttributes::operator == 
//
// Purpose: 
//   Comparison operator == for the ParallelAxisAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 16 12:20:06 PDT 2007
//
// Modifications:
//   
// ****************************************************************************

bool
ParallelAxisAttributes::operator == (const ParallelAxisAttributes &obj) const
{
    // Create the return value
    return ((orderedAxisNames == obj.orderedAxisNames) &&
            (shownVarAxisOrdinal == obj.shownVarAxisOrdinal) &&
            (axisMinima == obj.axisMinima) &&
            (axisMaxima == obj.axisMaxima) &&
            (extentMinima == obj.extentMinima) &&
            (extentMaxima == obj.extentMaxima) &&
            (extMinTimeOrds == obj.extMinTimeOrds) &&
            (extMaxTimeOrds == obj.extMaxTimeOrds) &&
            (plotToolModeFlags == obj.plotToolModeFlags) &&
            (axisGroupNames == obj.axisGroupNames) &&
            (axisInfoFlagSets == obj.axisInfoFlagSets) &&
            (axisXPositions == obj.axisXPositions) &&
            (axisAttributeVariables == obj.axisAttributeVariables) &&
            (attributesPerAxis == obj.attributesPerAxis) &&
            (axisAttributeData == obj.axisAttributeData) &&
            (drawLines == obj.drawLines) &&
            (linesColor == obj.linesColor) &&
            (drawContext == obj.drawContext) &&
            (contextGamma == obj.contextGamma) &&
            (contextNumPartitions == obj.contextNumPartitions) &&
            (contextColor == obj.contextColor));
}

// ****************************************************************************
// Method: ParallelAxisAttributes::operator != 
//
// Purpose: 
//   Comparison operator != for the ParallelAxisAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 16 12:20:06 PDT 2007
//
// Modifications:
//   
// ****************************************************************************

bool
ParallelAxisAttributes::operator != (const ParallelAxisAttributes &obj) const
{
    return !(this->operator == (obj));
}

// ****************************************************************************
// Method: ParallelAxisAttributes::TypeName
//
// Purpose: 
//   Type name method for the ParallelAxisAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 16 12:20:06 PDT 2007
//
// Modifications:
//   
// ****************************************************************************

const std::string
ParallelAxisAttributes::TypeName() const
{
    return "ParallelAxisAttributes";
}

// ****************************************************************************
// Method: ParallelAxisAttributes::CopyAttributes
//
// Purpose: CopyAttributes method for the ParallelAxisAttributes class.
//
// Programmer: Mark Blair
// Creation:   Mon Mar 27 18:24:00 PST 2006
//
// Modifications:
//
//    Mark Blair, Wed Sep 20 10:59:41 PDT 2006
//    Added time ordinals, for those operators and tools that need them.
//   
//    Mark Blair, Thu Nov  2 12:33:23 PST 2006
//    Added support for non-uniform axis spacing and axis labeling by Extents
//    tool when enabled.
//
//    Mark Blair, Fri Feb 23 12:19:33 PST 2007
//    Now supports all variable axis spacing and axis group conventions.
//   
// ****************************************************************************

bool
ParallelAxisAttributes::CopyAttributes(const AttributeGroup *atts)
{
    bool retval = false;

    if (TypeName() == atts->TypeName())
    {
        // Call assignment operator.
        const ParallelAxisAttributes *tmp =
            (const ParallelAxisAttributes *)atts;
        *this = *tmp;
        retval = true;
    }
    else if (atts->TypeName() == "ExtentsAttributes")
    {
        const ExtentsAttributes *extAtts = (const ExtentsAttributes *)atts;
        
        stringVector toolVarNames     = extAtts->GetScalarNames();
        doubleVector toolVarMinima    = extAtts->GetScalarMinima();
        doubleVector toolVarMaxima    = extAtts->GetScalarMaxima();
        doubleVector toolSliderMinima = extAtts->GetMinima();
        doubleVector toolSliderMaxima = extAtts->GetMaxima();
        intVector    toolMinTimeOrds  = extAtts->GetMinTimeOrdinals();
        intVector    toolMaxTimeOrds  = extAtts->GetMaxTimeOrdinals();
        stringVector toolGroupNames   = extAtts->GetAxisGroupNames();
        intVector    toolInfoFlagSets = extAtts->GetAxisInfoFlagSets();
        doubleVector toolXPositions   = extAtts->GetAxisXPositions();

        int toolVarCount = toolVarNames.size();
        int axisCount = orderedAxisNames.size();
        int toolVarNum, axisNum;
        std::string toolVarName;

        for (toolVarNum = 0; toolVarNum < toolVarCount; toolVarNum++)
        {
            toolVarName = toolVarNames[toolVarNum];

            for (axisNum = 0; axisNum < axisCount; axisNum++ )
            {
                if (orderedAxisNames[axisNum] == toolVarName)
                {
                    axisMinima[axisNum] = toolVarMinima[toolVarNum];
                    axisMaxima[axisNum] = toolVarMaxima[toolVarNum];

                    extentMinima[axisNum] = toolSliderMinima[toolVarNum];
                    extentMaxima[axisNum] = toolSliderMaxima[toolVarNum];
                    
                    extMinTimeOrds[axisNum] = toolMinTimeOrds[toolVarNum];
                    extMaxTimeOrds[axisNum] = toolMaxTimeOrds[toolVarNum];
                    
                    axisGroupNames[axisNum]   = toolGroupNames[toolVarNum];
                    axisInfoFlagSets[axisNum] = toolInfoFlagSets[toolVarNum];
                    axisXPositions[axisNum]   = toolXPositions[toolVarNum];

                    break;
                }
            }
        }

        plotToolModeFlags = extAtts->GetPlotToolModeFlags();
        
        retval = true;
    }

    return retval;
}

// ****************************************************************************
// Method: ParallelAxisAttributes::CreateCompatible
//
// Purpose: 
//   CreateCompatible method for the ParallelAxisAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 16 12:20:06 PDT 2007
//
// Modifications:
//   
// ****************************************************************************

AttributeSubject *
ParallelAxisAttributes::CreateCompatible(const std::string &tname) const
{
    AttributeSubject *retval = 0;
    if(TypeName() == tname)
        retval = new ParallelAxisAttributes(*this);
    // Other cases could go here too. 

    return retval;
}

// ****************************************************************************
// Method: ParallelAxisAttributes::NewInstance
//
// Purpose: 
//   NewInstance method for the ParallelAxisAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 16 12:20:06 PDT 2007
//
// Modifications:
//   
// ****************************************************************************

AttributeSubject *
ParallelAxisAttributes::NewInstance(bool copy) const
{
    AttributeSubject *retval = 0;
    if(copy)
        retval = new ParallelAxisAttributes(*this);
    else
        retval = new ParallelAxisAttributes;

    return retval;
}

// ****************************************************************************
// Method: ParallelAxisAttributes::SelectAll
//
// Purpose: 
//   Selects all attributes.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 16 12:20:06 PDT 2007
//
// Modifications:
//   
// ****************************************************************************

void
ParallelAxisAttributes::SelectAll()
{
    Select(0, (void *)&orderedAxisNames);
    Select(1, (void *)&shownVarAxisOrdinal);
    Select(2, (void *)&axisMinima);
    Select(3, (void *)&axisMaxima);
    Select(4, (void *)&extentMinima);
    Select(5, (void *)&extentMaxima);
    Select(6, (void *)&extMinTimeOrds);
    Select(7, (void *)&extMaxTimeOrds);
    Select(8, (void *)&plotToolModeFlags);
    Select(9, (void *)&axisGroupNames);
    Select(10, (void *)&axisInfoFlagSets);
    Select(11, (void *)&axisXPositions);
    Select(12, (void *)&axisAttributeVariables);
    Select(13, (void *)&attributesPerAxis);
    Select(14, (void *)&axisAttributeData);
    Select(15, (void *)&drawLines);
    Select(16, (void *)&linesColor);
    Select(17, (void *)&drawContext);
    Select(18, (void *)&contextGamma);
    Select(19, (void *)&contextNumPartitions);
    Select(20, (void *)&contextColor);
}

///////////////////////////////////////////////////////////////////////////////
// Persistence methods
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: ParallelAxisAttributes::CreateNode
//
// Purpose: 
//   This method creates a DataNode representation of the object so it can be saved to a config file.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 16 12:20:06 PDT 2007
//
// Modifications:
//   
// ****************************************************************************

bool
ParallelAxisAttributes::CreateNode(DataNode *parentNode, bool completeSave, bool forceAdd)
{
    if(parentNode == 0)
        return false;

    ParallelAxisAttributes defaultObject;
    bool addToParent = false;
    // Create a node for ParallelAxisAttributes.
    DataNode *node = new DataNode("ParallelAxisAttributes");

    if(completeSave || !FieldsEqual(0, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("orderedAxisNames", orderedAxisNames));
    }

    if(completeSave || !FieldsEqual(1, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("shownVarAxisOrdinal", shownVarAxisOrdinal));
    }

    if(completeSave || !FieldsEqual(2, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("axisMinima", axisMinima));
    }

    if(completeSave || !FieldsEqual(3, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("axisMaxima", axisMaxima));
    }

    if(completeSave || !FieldsEqual(4, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("extentMinima", extentMinima));
    }

    if(completeSave || !FieldsEqual(5, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("extentMaxima", extentMaxima));
    }

    if(completeSave || !FieldsEqual(6, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("extMinTimeOrds", extMinTimeOrds));
    }

    if(completeSave || !FieldsEqual(7, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("extMaxTimeOrds", extMaxTimeOrds));
    }

    if(completeSave || !FieldsEqual(8, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("plotToolModeFlags", plotToolModeFlags));
    }

    if(completeSave || !FieldsEqual(9, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("axisGroupNames", axisGroupNames));
    }

    if(completeSave || !FieldsEqual(10, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("axisInfoFlagSets", axisInfoFlagSets));
    }

    if(completeSave || !FieldsEqual(11, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("axisXPositions", axisXPositions));
    }

    if(completeSave || !FieldsEqual(12, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("axisAttributeVariables", axisAttributeVariables));
    }

    if(completeSave || !FieldsEqual(13, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("attributesPerAxis", attributesPerAxis));
    }

    if(completeSave || !FieldsEqual(14, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("axisAttributeData", axisAttributeData));
    }

    if(completeSave || !FieldsEqual(15, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("drawLines", drawLines));
    }

        DataNode *linesColorNode = new DataNode("linesColor");
        if(linesColor.CreateNode(linesColorNode, completeSave, true))
        {
            addToParent = true;
            node->AddNode(linesColorNode);
        }
        else
            delete linesColorNode;
    if(completeSave || !FieldsEqual(17, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("drawContext", drawContext));
    }

    if(completeSave || !FieldsEqual(18, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("contextGamma", contextGamma));
    }

    if(completeSave || !FieldsEqual(19, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("contextNumPartitions", contextNumPartitions));
    }

        DataNode *contextColorNode = new DataNode("contextColor");
        if(contextColor.CreateNode(contextColorNode, completeSave, true))
        {
            addToParent = true;
            node->AddNode(contextColorNode);
        }
        else
            delete contextColorNode;

    // Add the node to the parent node.
    if(addToParent || forceAdd)
        parentNode->AddNode(node);
    else
        delete node;

    return (addToParent || forceAdd);
}

// ****************************************************************************
// Method: ParallelAxisAttributes::SetFromNode
//
// Purpose: 
//   This method sets attributes in this object from values in a DataNode representation of the object.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 16 12:20:06 PDT 2007
//
// Modifications:
//   
// ****************************************************************************

void
ParallelAxisAttributes::SetFromNode(DataNode *parentNode)
{
    int i;
    if(parentNode == 0)
        return;

    DataNode *searchNode = parentNode->GetNode("ParallelAxisAttributes");
    if(searchNode == 0)
        return;

    DataNode *node;
    if((node = searchNode->GetNode("orderedAxisNames")) != 0)
        SetOrderedAxisNames(node->AsStringVector());
    if((node = searchNode->GetNode("shownVarAxisOrdinal")) != 0)
        SetShownVarAxisOrdinal(node->AsInt());
    if((node = searchNode->GetNode("axisMinima")) != 0)
        SetAxisMinima(node->AsDoubleVector());
    if((node = searchNode->GetNode("axisMaxima")) != 0)
        SetAxisMaxima(node->AsDoubleVector());
    if((node = searchNode->GetNode("extentMinima")) != 0)
        SetExtentMinima(node->AsDoubleVector());
    if((node = searchNode->GetNode("extentMaxima")) != 0)
        SetExtentMaxima(node->AsDoubleVector());
    if((node = searchNode->GetNode("extMinTimeOrds")) != 0)
        SetExtMinTimeOrds(node->AsIntVector());
    if((node = searchNode->GetNode("extMaxTimeOrds")) != 0)
        SetExtMaxTimeOrds(node->AsIntVector());
    if((node = searchNode->GetNode("plotToolModeFlags")) != 0)
        SetPlotToolModeFlags(node->AsInt());
    if((node = searchNode->GetNode("axisGroupNames")) != 0)
        SetAxisGroupNames(node->AsStringVector());
    if((node = searchNode->GetNode("axisInfoFlagSets")) != 0)
        SetAxisInfoFlagSets(node->AsIntVector());
    if((node = searchNode->GetNode("axisXPositions")) != 0)
        SetAxisXPositions(node->AsDoubleVector());
    if((node = searchNode->GetNode("axisAttributeVariables")) != 0)
        SetAxisAttributeVariables(node->AsStringVector());
    if((node = searchNode->GetNode("attributesPerAxis")) != 0)
        SetAttributesPerAxis(node->AsInt());
    if((node = searchNode->GetNode("axisAttributeData")) != 0)
        SetAxisAttributeData(node->AsDoubleVector());
    if((node = searchNode->GetNode("drawLines")) != 0)
        SetDrawLines(node->AsBool());
    if((node = searchNode->GetNode("linesColor")) != 0)
        linesColor.SetFromNode(node);
    if((node = searchNode->GetNode("drawContext")) != 0)
        SetDrawContext(node->AsBool());
    if((node = searchNode->GetNode("contextGamma")) != 0)
        SetContextGamma(node->AsFloat());
    if((node = searchNode->GetNode("contextNumPartitions")) != 0)
        SetContextNumPartitions(node->AsInt());
    if((node = searchNode->GetNode("contextColor")) != 0)
        contextColor.SetFromNode(node);
}

///////////////////////////////////////////////////////////////////////////////
// Set property methods
///////////////////////////////////////////////////////////////////////////////

void
ParallelAxisAttributes::SetOrderedAxisNames(const stringVector &orderedAxisNames_)
{
    orderedAxisNames = orderedAxisNames_;
    Select(0, (void *)&orderedAxisNames);
}

void
ParallelAxisAttributes::SetShownVarAxisOrdinal(int shownVarAxisOrdinal_)
{
    shownVarAxisOrdinal = shownVarAxisOrdinal_;
    Select(1, (void *)&shownVarAxisOrdinal);
}

void
ParallelAxisAttributes::SetAxisMinima(const doubleVector &axisMinima_)
{
    axisMinima = axisMinima_;
    Select(2, (void *)&axisMinima);
}

void
ParallelAxisAttributes::SetAxisMaxima(const doubleVector &axisMaxima_)
{
    axisMaxima = axisMaxima_;
    Select(3, (void *)&axisMaxima);
}

void
ParallelAxisAttributes::SetExtentMinima(const doubleVector &extentMinima_)
{
    extentMinima = extentMinima_;
    Select(4, (void *)&extentMinima);
}

void
ParallelAxisAttributes::SetExtentMaxima(const doubleVector &extentMaxima_)
{
    extentMaxima = extentMaxima_;
    Select(5, (void *)&extentMaxima);
}

void
ParallelAxisAttributes::SetExtMinTimeOrds(const intVector &extMinTimeOrds_)
{
    extMinTimeOrds = extMinTimeOrds_;
    Select(6, (void *)&extMinTimeOrds);
}

void
ParallelAxisAttributes::SetExtMaxTimeOrds(const intVector &extMaxTimeOrds_)
{
    extMaxTimeOrds = extMaxTimeOrds_;
    Select(7, (void *)&extMaxTimeOrds);
}

void
ParallelAxisAttributes::SetPlotToolModeFlags(int plotToolModeFlags_)
{
    plotToolModeFlags = plotToolModeFlags_;
    Select(8, (void *)&plotToolModeFlags);
}

void
ParallelAxisAttributes::SetAxisGroupNames(const stringVector &axisGroupNames_)
{
    axisGroupNames = axisGroupNames_;
    Select(9, (void *)&axisGroupNames);
}

void
ParallelAxisAttributes::SetAxisInfoFlagSets(const intVector &axisInfoFlagSets_)
{
    axisInfoFlagSets = axisInfoFlagSets_;
    Select(10, (void *)&axisInfoFlagSets);
}

void
ParallelAxisAttributes::SetAxisXPositions(const doubleVector &axisXPositions_)
{
    axisXPositions = axisXPositions_;
    Select(11, (void *)&axisXPositions);
}

void
ParallelAxisAttributes::SetAxisAttributeVariables(const stringVector &axisAttributeVariables_)
{
    axisAttributeVariables = axisAttributeVariables_;
    Select(12, (void *)&axisAttributeVariables);
}

void
ParallelAxisAttributes::SetAttributesPerAxis(int attributesPerAxis_)
{
    attributesPerAxis = attributesPerAxis_;
    Select(13, (void *)&attributesPerAxis);
}

void
ParallelAxisAttributes::SetAxisAttributeData(const doubleVector &axisAttributeData_)
{
    axisAttributeData = axisAttributeData_;
    Select(14, (void *)&axisAttributeData);
}

void
ParallelAxisAttributes::SetDrawLines(bool drawLines_)
{
    drawLines = drawLines_;
    Select(15, (void *)&drawLines);
}

void
ParallelAxisAttributes::SetLinesColor(const ColorAttribute &linesColor_)
{
    linesColor = linesColor_;
    Select(16, (void *)&linesColor);
}

void
ParallelAxisAttributes::SetDrawContext(bool drawContext_)
{
    drawContext = drawContext_;
    Select(17, (void *)&drawContext);
}

void
ParallelAxisAttributes::SetContextGamma(float contextGamma_)
{
    contextGamma = contextGamma_;
    Select(18, (void *)&contextGamma);
}

void
ParallelAxisAttributes::SetContextNumPartitions(int contextNumPartitions_)
{
    contextNumPartitions = contextNumPartitions_;
    Select(19, (void *)&contextNumPartitions);
}

void
ParallelAxisAttributes::SetContextColor(const ColorAttribute &contextColor_)
{
    contextColor = contextColor_;
    Select(20, (void *)&contextColor);
}

///////////////////////////////////////////////////////////////////////////////
// Get property methods
///////////////////////////////////////////////////////////////////////////////

const stringVector &
ParallelAxisAttributes::GetOrderedAxisNames() const
{
    return orderedAxisNames;
}

stringVector &
ParallelAxisAttributes::GetOrderedAxisNames()
{
    return orderedAxisNames;
}

int
ParallelAxisAttributes::GetShownVarAxisOrdinal() const
{
    return shownVarAxisOrdinal;
}

const doubleVector &
ParallelAxisAttributes::GetAxisMinima() const
{
    return axisMinima;
}

doubleVector &
ParallelAxisAttributes::GetAxisMinima()
{
    return axisMinima;
}

const doubleVector &
ParallelAxisAttributes::GetAxisMaxima() const
{
    return axisMaxima;
}

doubleVector &
ParallelAxisAttributes::GetAxisMaxima()
{
    return axisMaxima;
}

const doubleVector &
ParallelAxisAttributes::GetExtentMinima() const
{
    return extentMinima;
}

doubleVector &
ParallelAxisAttributes::GetExtentMinima()
{
    return extentMinima;
}

const doubleVector &
ParallelAxisAttributes::GetExtentMaxima() const
{
    return extentMaxima;
}

doubleVector &
ParallelAxisAttributes::GetExtentMaxima()
{
    return extentMaxima;
}

const intVector &
ParallelAxisAttributes::GetExtMinTimeOrds() const
{
    return extMinTimeOrds;
}

intVector &
ParallelAxisAttributes::GetExtMinTimeOrds()
{
    return extMinTimeOrds;
}

const intVector &
ParallelAxisAttributes::GetExtMaxTimeOrds() const
{
    return extMaxTimeOrds;
}

intVector &
ParallelAxisAttributes::GetExtMaxTimeOrds()
{
    return extMaxTimeOrds;
}

int
ParallelAxisAttributes::GetPlotToolModeFlags() const
{
    return plotToolModeFlags;
}

const stringVector &
ParallelAxisAttributes::GetAxisGroupNames() const
{
    return axisGroupNames;
}

stringVector &
ParallelAxisAttributes::GetAxisGroupNames()
{
    return axisGroupNames;
}

const intVector &
ParallelAxisAttributes::GetAxisInfoFlagSets() const
{
    return axisInfoFlagSets;
}

intVector &
ParallelAxisAttributes::GetAxisInfoFlagSets()
{
    return axisInfoFlagSets;
}

const doubleVector &
ParallelAxisAttributes::GetAxisXPositions() const
{
    return axisXPositions;
}

doubleVector &
ParallelAxisAttributes::GetAxisXPositions()
{
    return axisXPositions;
}

const stringVector &
ParallelAxisAttributes::GetAxisAttributeVariables() const
{
    return axisAttributeVariables;
}

stringVector &
ParallelAxisAttributes::GetAxisAttributeVariables()
{
    return axisAttributeVariables;
}

int
ParallelAxisAttributes::GetAttributesPerAxis() const
{
    return attributesPerAxis;
}

const doubleVector &
ParallelAxisAttributes::GetAxisAttributeData() const
{
    return axisAttributeData;
}

doubleVector &
ParallelAxisAttributes::GetAxisAttributeData()
{
    return axisAttributeData;
}

bool
ParallelAxisAttributes::GetDrawLines() const
{
    return drawLines;
}

const ColorAttribute &
ParallelAxisAttributes::GetLinesColor() const
{
    return linesColor;
}

ColorAttribute &
ParallelAxisAttributes::GetLinesColor()
{
    return linesColor;
}

bool
ParallelAxisAttributes::GetDrawContext() const
{
    return drawContext;
}

float
ParallelAxisAttributes::GetContextGamma() const
{
    return contextGamma;
}

int
ParallelAxisAttributes::GetContextNumPartitions() const
{
    return contextNumPartitions;
}

const ColorAttribute &
ParallelAxisAttributes::GetContextColor() const
{
    return contextColor;
}

ColorAttribute &
ParallelAxisAttributes::GetContextColor()
{
    return contextColor;
}

///////////////////////////////////////////////////////////////////////////////
// Select property methods
///////////////////////////////////////////////////////////////////////////////

void
ParallelAxisAttributes::SelectOrderedAxisNames()
{
    Select(0, (void *)&orderedAxisNames);
}

void
ParallelAxisAttributes::SelectAxisMinima()
{
    Select(2, (void *)&axisMinima);
}

void
ParallelAxisAttributes::SelectAxisMaxima()
{
    Select(3, (void *)&axisMaxima);
}

void
ParallelAxisAttributes::SelectExtentMinima()
{
    Select(4, (void *)&extentMinima);
}

void
ParallelAxisAttributes::SelectExtentMaxima()
{
    Select(5, (void *)&extentMaxima);
}

void
ParallelAxisAttributes::SelectExtMinTimeOrds()
{
    Select(6, (void *)&extMinTimeOrds);
}

void
ParallelAxisAttributes::SelectExtMaxTimeOrds()
{
    Select(7, (void *)&extMaxTimeOrds);
}

void
ParallelAxisAttributes::SelectAxisGroupNames()
{
    Select(9, (void *)&axisGroupNames);
}

void
ParallelAxisAttributes::SelectAxisInfoFlagSets()
{
    Select(10, (void *)&axisInfoFlagSets);
}

void
ParallelAxisAttributes::SelectAxisXPositions()
{
    Select(11, (void *)&axisXPositions);
}

void
ParallelAxisAttributes::SelectAxisAttributeVariables()
{
    Select(12, (void *)&axisAttributeVariables);
}

void
ParallelAxisAttributes::SelectAxisAttributeData()
{
    Select(14, (void *)&axisAttributeData);
}

void
ParallelAxisAttributes::SelectLinesColor()
{
    Select(16, (void *)&linesColor);
}

void
ParallelAxisAttributes::SelectContextColor()
{
    Select(20, (void *)&contextColor);
}

///////////////////////////////////////////////////////////////////////////////
// Keyframing methods
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: ParallelAxisAttributes::GetFieldName
//
// Purpose: 
//   This method returns the name of a field given its index.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 16 12:20:06 PDT 2007
//
// Modifications:
//   
// ****************************************************************************

std::string
ParallelAxisAttributes::GetFieldName(int index) const
{
    switch (index)
    {
        case 0:  return "orderedAxisNames";
        case 1:  return "shownVarAxisOrdinal";
        case 2:  return "axisMinima";
        case 3:  return "axisMaxima";
        case 4:  return "extentMinima";
        case 5:  return "extentMaxima";
        case 6:  return "extMinTimeOrds";
        case 7:  return "extMaxTimeOrds";
        case 8:  return "plotToolModeFlags";
        case 9:  return "axisGroupNames";
        case 10:  return "axisInfoFlagSets";
        case 11:  return "axisXPositions";
        case 12:  return "axisAttributeVariables";
        case 13:  return "attributesPerAxis";
        case 14:  return "axisAttributeData";
        case 15:  return "Draw individual lines";
        case 16:  return "Line color";
        case 17:  return "Draw context";
        case 18:  return "Gamma brightness adjustment";
        case 19:  return "Number of partitions";
        case 20:  return "Context color";
        default:  return "invalid index";
    }
}

// ****************************************************************************
// Method: ParallelAxisAttributes::GetFieldType
//
// Purpose: 
//   This method returns the type of a field given its index.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 16 12:20:06 PDT 2007
//
// Modifications:
//   
// ****************************************************************************

AttributeGroup::FieldType
ParallelAxisAttributes::GetFieldType(int index) const
{
    switch (index)
    {
        case 0:  return FieldType_stringVector;
        case 1:  return FieldType_int;
        case 2:  return FieldType_doubleVector;
        case 3:  return FieldType_doubleVector;
        case 4:  return FieldType_doubleVector;
        case 5:  return FieldType_doubleVector;
        case 6:  return FieldType_intVector;
        case 7:  return FieldType_intVector;
        case 8:  return FieldType_int;
        case 9:  return FieldType_stringVector;
        case 10:  return FieldType_intVector;
        case 11:  return FieldType_doubleVector;
        case 12:  return FieldType_stringVector;
        case 13:  return FieldType_int;
        case 14:  return FieldType_doubleVector;
        case 15:  return FieldType_bool;
        case 16:  return FieldType_color;
        case 17:  return FieldType_bool;
        case 18:  return FieldType_float;
        case 19:  return FieldType_int;
        case 20:  return FieldType_color;
        default:  return FieldType_unknown;
    }
}

// ****************************************************************************
// Method: ParallelAxisAttributes::GetFieldTypeName
//
// Purpose: 
//   This method returns the name of a field type given its index.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 16 12:20:06 PDT 2007
//
// Modifications:
//   
// ****************************************************************************

std::string
ParallelAxisAttributes::GetFieldTypeName(int index) const
{
    switch (index)
    {
        case 0:  return "stringVector";
        case 1:  return "int";
        case 2:  return "doubleVector";
        case 3:  return "doubleVector";
        case 4:  return "doubleVector";
        case 5:  return "doubleVector";
        case 6:  return "intVector";
        case 7:  return "intVector";
        case 8:  return "int";
        case 9:  return "stringVector";
        case 10:  return "intVector";
        case 11:  return "doubleVector";
        case 12:  return "stringVector";
        case 13:  return "int";
        case 14:  return "doubleVector";
        case 15:  return "bool";
        case 16:  return "color";
        case 17:  return "bool";
        case 18:  return "float";
        case 19:  return "int";
        case 20:  return "color";
        default:  return "invalid index";
    }
}

// ****************************************************************************
// Method: ParallelAxisAttributes::FieldsEqual
//
// Purpose: 
//   This method compares two fields and return true if they are equal.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 16 12:20:06 PDT 2007
//
// Modifications:
//   
// ****************************************************************************

bool
ParallelAxisAttributes::FieldsEqual(int index_, const AttributeGroup *rhs) const
{
    const ParallelAxisAttributes &obj = *((const ParallelAxisAttributes*)rhs);
    bool retval = false;
    switch (index_)
    {
    case 0:
        {  // new scope
        retval = (orderedAxisNames == obj.orderedAxisNames);
        }
        break;
    case 1:
        {  // new scope
        retval = (shownVarAxisOrdinal == obj.shownVarAxisOrdinal);
        }
        break;
    case 2:
        {  // new scope
        retval = (axisMinima == obj.axisMinima);
        }
        break;
    case 3:
        {  // new scope
        retval = (axisMaxima == obj.axisMaxima);
        }
        break;
    case 4:
        {  // new scope
        retval = (extentMinima == obj.extentMinima);
        }
        break;
    case 5:
        {  // new scope
        retval = (extentMaxima == obj.extentMaxima);
        }
        break;
    case 6:
        {  // new scope
        retval = (extMinTimeOrds == obj.extMinTimeOrds);
        }
        break;
    case 7:
        {  // new scope
        retval = (extMaxTimeOrds == obj.extMaxTimeOrds);
        }
        break;
    case 8:
        {  // new scope
        retval = (plotToolModeFlags == obj.plotToolModeFlags);
        }
        break;
    case 9:
        {  // new scope
        retval = (axisGroupNames == obj.axisGroupNames);
        }
        break;
    case 10:
        {  // new scope
        retval = (axisInfoFlagSets == obj.axisInfoFlagSets);
        }
        break;
    case 11:
        {  // new scope
        retval = (axisXPositions == obj.axisXPositions);
        }
        break;
    case 12:
        {  // new scope
        retval = (axisAttributeVariables == obj.axisAttributeVariables);
        }
        break;
    case 13:
        {  // new scope
        retval = (attributesPerAxis == obj.attributesPerAxis);
        }
        break;
    case 14:
        {  // new scope
        retval = (axisAttributeData == obj.axisAttributeData);
        }
        break;
    case 15:
        {  // new scope
        retval = (drawLines == obj.drawLines);
        }
        break;
    case 16:
        {  // new scope
        retval = (linesColor == obj.linesColor);
        }
        break;
    case 17:
        {  // new scope
        retval = (drawContext == obj.drawContext);
        }
        break;
    case 18:
        {  // new scope
        retval = (contextGamma == obj.contextGamma);
        }
        break;
    case 19:
        {  // new scope
        retval = (contextNumPartitions == obj.contextNumPartitions);
        }
        break;
    case 20:
        {  // new scope
        retval = (contextColor == obj.contextColor);
        }
        break;
    default: retval = false;
    }

    return retval;
}

///////////////////////////////////////////////////////////////////////////////
// User-defined methods.
///////////////////////////////////////////////////////////////////////////////

void
ParallelAxisAttributes::InsertAxis(const std::string &axisName_)
{
    std::string newAxisName = axisName_;

    int curAxisCount = orderedAxisNames.size();
    int leftShownAxisID, rightShownAxisID, leftSelectedAxisID, rightSelectedAxisID;
    int axisOrdinal, insertOrdinal, flagAxisID;
    int saveMinTimeOrd, saveMaxTimeOrd, saveInfoFlags;
    double saveAxisMin, saveAxisMax, saveExtentMin, saveExtentMax, saveXPosition;
    std::string saveGroupName;

    stringVector::iterator axisNamesIt;
    doubleVector::iterator axisMinIt;
    doubleVector::iterator axisMaxIt;
    doubleVector::iterator extentMinIt;
    doubleVector::iterator extentMaxIt;
    intVector::iterator minTimeOrdIt;
    intVector::iterator maxTimeOrdIt;
    stringVector::iterator groupNamesIt;
    intVector::iterator infoFlagsIt;
    doubleVector::iterator xPositionIt;
    
    DetermineShownAndSelectedAxisSequences(leftShownAxisID, rightShownAxisID,
        leftSelectedAxisID, rightSelectedAxisID);

    for (axisOrdinal = 0; axisOrdinal < curAxisCount; axisOrdinal++)
    {
        if (orderedAxisNames[axisOrdinal] == newAxisName) break;
    }

    if (axisOrdinal < curAxisCount)
    {
        if (axisOrdinal == shownVarAxisOrdinal) return;

        saveAxisMin    = axisMinima[axisOrdinal];
        saveAxisMax    = axisMaxima[axisOrdinal];
        saveExtentMin  = extentMinima[axisOrdinal];
        saveExtentMax  = extentMaxima[axisOrdinal];
        saveMinTimeOrd = extMinTimeOrds[axisOrdinal];
        saveMaxTimeOrd = extMaxTimeOrds[axisOrdinal];
        saveGroupName  = axisGroupNames[axisOrdinal];
        saveInfoFlags  = axisInfoFlagSets[axisOrdinal];
        saveXPosition  = axisXPositions[axisOrdinal];

        axisNamesIt  = orderedAxisNames.begin() + axisOrdinal;
        axisMinIt    = axisMinima.begin()       + axisOrdinal;
        axisMaxIt    = axisMaxima.begin()       + axisOrdinal;
        extentMinIt  = extentMinima.begin()     + axisOrdinal;
        extentMaxIt  = extentMaxima.begin()     + axisOrdinal;
        minTimeOrdIt = extMinTimeOrds.begin()   + axisOrdinal;
        maxTimeOrdIt = extMaxTimeOrds.begin()   + axisOrdinal;
        groupNamesIt = axisGroupNames.begin()   + axisOrdinal;
        infoFlagsIt  = axisInfoFlagSets.begin() + axisOrdinal;
        xPositionIt  = axisXPositions.begin()   + axisOrdinal;

        orderedAxisNames.erase(axisNamesIt);
        axisMinima.erase(axisMinIt);
        axisMaxima.erase(axisMaxIt);
        extentMinima.erase(extentMinIt);
        extentMaxima.erase(extentMaxIt);
        extMinTimeOrds.erase(minTimeOrdIt);
        extMaxTimeOrds.erase(maxTimeOrdIt);
        axisGroupNames.erase(groupNamesIt);
        axisInfoFlagSets.erase(infoFlagsIt);
        axisXPositions.erase(xPositionIt);
        
        AdjustAxisSequencesAfterDeletingAxis(leftShownAxisID, rightShownAxisID,
            leftSelectedAxisID, rightSelectedAxisID, axisOrdinal, curAxisCount);

        if (axisOrdinal < shownVarAxisOrdinal)
            insertOrdinal = shownVarAxisOrdinal;
        else
            insertOrdinal = ++shownVarAxisOrdinal;
    }
    else
    {
        saveAxisMin    = -1e+37;
        saveAxisMax    = +1e+37;
        saveExtentMin  = 0.0;
        saveExtentMax  = 1.0;
        saveMinTimeOrd = 0;
        saveMaxTimeOrd = 0;
        saveGroupName  = std::string("(not_in_a_group)");
        saveXPosition  = -1.0;
        
        saveInfoFlags = (axisInfoFlagSets[0] & EA_SHOW_ALL_AXIS_INFO_FLAGS) |
                        EA_AXIS_INFO_SHOWN_FLAG;
                         
        if (shownVarAxisOrdinal != rightSelectedAxisID)
            flagAxisID = shownVarAxisOrdinal;
        else if (rightSelectedAxisID == curAxisCount-1)
            flagAxisID = 0;
        else
            flagAxisID = rightSelectedAxisID + 1;
            
        saveInfoFlags |=
            (axisInfoFlagSets[flagAxisID] & EA_THRESHOLD_BY_EXTENT_FLAG);
                         
        insertOrdinal = ++shownVarAxisOrdinal;
    }

    axisNamesIt  = orderedAxisNames.begin() + insertOrdinal;
    axisMinIt    = axisMinima.begin()       + insertOrdinal;
    axisMaxIt    = axisMaxima.begin()       + insertOrdinal;
    extentMinIt  = extentMinima.begin()     + insertOrdinal;
    extentMaxIt  = extentMaxima.begin()     + insertOrdinal;
    minTimeOrdIt = extMinTimeOrds.begin()   + insertOrdinal;
    maxTimeOrdIt = extMaxTimeOrds.begin()   + insertOrdinal;
    groupNamesIt = axisGroupNames.begin()   + insertOrdinal;
    infoFlagsIt  = axisInfoFlagSets.begin() + insertOrdinal;
    xPositionIt  = axisXPositions.begin()   + insertOrdinal;

    orderedAxisNames.insert(axisNamesIt, newAxisName);
    axisMinima.insert(axisMinIt, saveAxisMin);
    axisMaxima.insert(axisMaxIt, saveAxisMax);
    extentMinima.insert(extentMinIt, saveExtentMin);
    extentMaxima.insert(extentMaxIt, saveExtentMax);
    extMinTimeOrds.insert(minTimeOrdIt, saveMinTimeOrd);
    extMaxTimeOrds.insert(maxTimeOrdIt, saveMaxTimeOrd);
    axisGroupNames.insert(groupNamesIt, saveGroupName);
    axisInfoFlagSets.insert(infoFlagsIt, saveInfoFlags);
    axisXPositions.insert(xPositionIt, saveXPosition);
    
    AdjustAxisSequencesAfterInsertingNewAxis(leftShownAxisID, rightShownAxisID,
        leftSelectedAxisID, rightSelectedAxisID, insertOrdinal-1);
        
    MarkShownAndSelectedAxisSequences(leftShownAxisID, rightShownAxisID,
        leftSelectedAxisID, rightSelectedAxisID);

    plotToolModeFlags |= EA_PLOT_AXES_WERE_MODIFIED_FLAG;

    SelectAll();
}

void
ParallelAxisAttributes::DeleteAxis(const std::string &axisName_, int minAxisCount)
{
    if (orderedAxisNames.size() <= minAxisCount) return;

    std::string newAxisName = axisName_;

    int curAxisCount = orderedAxisNames.size();
    int leftShownAxisID, rightShownAxisID, leftSelectedAxisID, rightSelectedAxisID;
    int axisOrdinal;

    for (axisOrdinal = 0; axisOrdinal < curAxisCount; axisOrdinal++)
    {
        if (orderedAxisNames[axisOrdinal] == newAxisName) break;
    }

    if (axisOrdinal < curAxisCount)
    {
        DetermineShownAndSelectedAxisSequences(leftShownAxisID, rightShownAxisID,
            leftSelectedAxisID, rightSelectedAxisID);

        orderedAxisNames.erase(orderedAxisNames.begin() + axisOrdinal);
        axisMinima.erase(axisMinima.begin() + axisOrdinal);
        axisMaxima.erase(axisMaxima.begin() + axisOrdinal);
        extentMinima.erase(extentMinima.begin() + axisOrdinal);
        extentMaxima.erase(extentMaxima.begin() + axisOrdinal);
        extMinTimeOrds.erase(extMinTimeOrds.begin() + axisOrdinal);
        extMaxTimeOrds.erase(extMaxTimeOrds.begin() + axisOrdinal);
        axisGroupNames.erase(axisGroupNames.begin() + axisOrdinal);
        axisInfoFlagSets.erase(axisInfoFlagSets.begin() + axisOrdinal);
        axisXPositions.erase(axisXPositions.begin() + axisOrdinal);
        
        if (axisOrdinal <= shownVarAxisOrdinal)
        {
            shownVarAxisOrdinal =
            (shownVarAxisOrdinal + curAxisCount - 2) % (curAxisCount - 1);
        }
        
        AdjustAxisSequencesAfterDeletingAxis(leftShownAxisID, rightShownAxisID,
            leftSelectedAxisID, rightSelectedAxisID, axisOrdinal, curAxisCount);
        
        MarkShownAndSelectedAxisSequences(leftShownAxisID, rightShownAxisID,
            leftSelectedAxisID, rightSelectedAxisID);

        plotToolModeFlags |= EA_PLOT_AXES_WERE_MODIFIED_FLAG;

        SelectAll();
    }
}

// ****************************************************************************
// Method: ParallelAxisAttributes::AttributesAreConsistent
//
// Purpose: Returns true only if (1) all vector attributes are the same length,
//          (2) all axis names are unique, and (3) the index of the currently
//          displayable axis information in the ParallelAxis GUI is in range.
//
// Programmer: Mark Blair
// Creation:   Mon Mar 27 18:24:00 PST 2006
//
// Modifications:
//   
//    Mark Blair, Wed Sep 20 10:59:41 PDT 2006
//    Added time ordinals, for those operators and tools that need them.
//   
//    Mark Blair, Thu Oct 26 18:40:28 PDT 2006
//    Added attributes to support non-uniform axis spacing.
//   
//    Mark Blair, Fri Feb 23 12:19:33 PST 2007
//    Added attributes to support  all variable axis spacing and axis group
//    conventions.
//   
// ****************************************************************************

bool
ParallelAxisAttributes::AttributesAreConsistent() const
{
    int axisNamesSize = orderedAxisNames.size();
    int axisNum, axis2Num;
    std::string axisName;
    
    if (axisNamesSize < 2)
        return false;
    
    if ((axisMinima.size()       != axisNamesSize) ||
        (axisMaxima.size()       != axisNamesSize) ||
        (extentMinima.size()     != axisNamesSize) ||
        (extentMaxima.size()     != axisNamesSize) ||
        (extMinTimeOrds.size()   != axisNamesSize) ||
        (extMaxTimeOrds.size()   != axisNamesSize) ||
        (axisGroupNames.size()   != axisNamesSize) ||
        (axisInfoFlagSets.size() != axisNamesSize) ||
        (axisXPositions.size()   != axisNamesSize))
    {
        return false;
    }
    
    if (axisAttributeVariables.size()*(attributesPerAxis+1) != axisAttributeData.size())
        return false;
            
    for (axisNum = 0; axisNum < axisNamesSize - 1; axisNum++)
    {
        axisName = orderedAxisNames[axisNum];

        for (axis2Num = axisNum + 1; axis2Num < axisNamesSize; axis2Num++ )
        {
            if (orderedAxisNames[axis2Num] == axisName)
                return false;
        }
    }
    
    return (shownVarAxisOrdinal < axisNamesSize);
}

bool
ParallelAxisAttributes::ChangesRequireRecalculation(
    const ParallelAxisAttributes &obj)
{
    return true;
}

void
ParallelAxisAttributes::SwitchToLeftAxis(const std::string &axisName_)
{
    std::string newAxisName = axisName_;

    int curAxisCount = orderedAxisNames.size();
    int leftShownAxisID, rightShownAxisID, leftSelectedAxisID, rightSelectedAxisID;
    int flagAxisID;
    int axisOrdinal, saveMinTimeOrd, saveMaxTimeOrd, saveInfoFlags;
    double saveAxisMin, saveAxisMax, saveExtentMin, saveExtentMax, saveXPosition;
    std::string orderedAxisName;
    std::string saveGroupName;

    DetermineShownAndSelectedAxisSequences(leftShownAxisID, rightShownAxisID,
        leftSelectedAxisID, rightSelectedAxisID);

    shownVarAxisOrdinal = 0;

    for (axisOrdinal = 0; axisOrdinal < curAxisCount; axisOrdinal++)
    {
        if (orderedAxisNames[axisOrdinal] == newAxisName) break;
    }

    if (axisOrdinal < curAxisCount) {
        if (axisOrdinal == 0)
        {
            Select(1, (void *)&shownVarAxisOrdinal);
            return;
        }

        saveAxisMin    = axisMinima[axisOrdinal];
        saveAxisMax    = axisMaxima[axisOrdinal];
        saveExtentMin  = extentMinima[axisOrdinal];
        saveExtentMax  = extentMaxima[axisOrdinal];
        saveMinTimeOrd = extMinTimeOrds[axisOrdinal];
        saveMaxTimeOrd = extMaxTimeOrds[axisOrdinal];
        saveGroupName  = axisGroupNames[axisOrdinal];
        saveInfoFlags  = axisInfoFlagSets[axisOrdinal];
        saveXPosition  = axisXPositions[axisOrdinal];

        orderedAxisNames.erase(orderedAxisNames.begin() + axisOrdinal);
        axisMinima.erase(axisMinima.begin() + axisOrdinal);
        axisMaxima.erase(axisMaxima.begin() + axisOrdinal);
        extentMinima.erase(extentMinima.begin() + axisOrdinal);
        extentMaxima.erase(extentMaxima.begin() + axisOrdinal);
        extMinTimeOrds.erase(extMinTimeOrds.begin() + axisOrdinal);
        extMaxTimeOrds.erase(extMaxTimeOrds.begin() + axisOrdinal);
        axisGroupNames.erase(axisGroupNames.begin() + axisOrdinal);
        axisInfoFlagSets.erase(axisInfoFlagSets.begin() + axisOrdinal);
        axisXPositions.erase(axisXPositions.begin() + axisOrdinal);
        
        AdjustAxisSequencesAfterDeletingAxis(leftShownAxisID, rightShownAxisID,
            leftSelectedAxisID, rightSelectedAxisID, axisOrdinal, curAxisCount);
    }
    else
    {
        saveAxisMin    = -1e+37;
        saveAxisMax    = +1e+37;
        saveExtentMin  = 0.0;
        saveExtentMax  = 1.0;
        saveMinTimeOrd = 0;
        saveMaxTimeOrd = 0;
        saveGroupName  = std::string("(not_in_a_group)");
        saveXPosition  = -1.0;
        
        saveInfoFlags = (axisInfoFlagSets[0] & EA_SHOW_ALL_AXIS_INFO_FLAGS) |
                        EA_AXIS_INFO_SHOWN_FLAG;
                         
        if (rightSelectedAxisID < curAxisCount-1)
            flagAxisID = curAxisCount - 1;
        else
            flagAxisID = 0;
            
        saveInfoFlags |=
            (axisInfoFlagSets[flagAxisID] & EA_THRESHOLD_BY_EXTENT_FLAG);
    }

    orderedAxisNames.insert(orderedAxisNames.begin(), newAxisName);
    axisMinima.insert(axisMinima.begin(), saveAxisMin);
    axisMaxima.insert(axisMaxima.begin(), saveAxisMax);
    extentMinima.insert(extentMinima.begin(), saveExtentMin);
    extentMaxima.insert(extentMaxima.begin(), saveExtentMax);
    extMinTimeOrds.insert(extMinTimeOrds.begin(), saveMinTimeOrd);
    extMaxTimeOrds.insert(extMaxTimeOrds.begin(), saveMaxTimeOrd);
    axisGroupNames.insert(axisGroupNames.begin(), saveGroupName);
    axisInfoFlagSets.insert(axisInfoFlagSets.begin(), saveInfoFlags);
    axisXPositions.insert(axisXPositions.begin(), saveXPosition);
    
    AdjustAxisSequencesAfterInsertingNewAxis(leftShownAxisID, rightShownAxisID,
        leftSelectedAxisID, rightSelectedAxisID, -1);
        
    MarkShownAndSelectedAxisSequences(leftShownAxisID, rightShownAxisID,
        leftSelectedAxisID, rightSelectedAxisID);

    plotToolModeFlags |= EA_PLOT_AXES_WERE_MODIFIED_FLAG;

    SelectAll();
}

void
ParallelAxisAttributes::ShowPreviousAxisVariableData()
{
    if (orderedAxisNames.size() < 2) return;

    shownVarAxisOrdinal = (shownVarAxisOrdinal + orderedAxisNames.size() - 1) %
                           orderedAxisNames.size();
    Select(1, (void *)&shownVarAxisOrdinal);
}

void
ParallelAxisAttributes::ShowNextAxisVariableData()
{
    if (orderedAxisNames.size() < 2) return;

    shownVarAxisOrdinal = (shownVarAxisOrdinal + 1) % orderedAxisNames.size();
    Select(1, (void *)&shownVarAxisOrdinal);
}

std::string &
ParallelAxisAttributes::GetShownVariableAxisName()
{
    return orderedAxisNames[shownVarAxisOrdinal];
}

int
ParallelAxisAttributes::GetShownVariableAxisNormalHumanOrdinal() const
{
    return (shownVarAxisOrdinal + 1);  // 1-origin for normal human beings
}

// ****************************************************************************
// Method: ParallelAxisAttributes::DetermineShownAndSelectedAxisSections
//
// Purpose: Finds ordinals of left and right shown axes and ordinals of left
//          and right selected axes.  If any of these are not found or not in
//          order, adjust them.  (The ParallelAxis plot wizard makes use of
//          this automatic adjustment.)
//
// Programmer: Mark Blair
// Creation:   Fri Jan 12 12:04:22 PST 2007
//
// Modifications:
//   
// ****************************************************************************

void
ParallelAxisAttributes::DetermineShownAndSelectedAxisSequences(int &leftShownAxisID,
    int &rightShownAxisID, int &leftSelectedAxisID, int &rightSelectedAxisID)
{
    leftShownAxisID    = -1; rightShownAxisID    = -1;
    leftSelectedAxisID = -1; rightSelectedAxisID = -1;

    int curAxisCount = axisInfoFlagSets.size();
    int axisID, axisInfoFlags;
    
    for (axisID = 0; axisID < curAxisCount; axisID++)
    {
        axisInfoFlags = axisInfoFlagSets[axisID];
        
        if ((axisInfoFlags & EA_LEFT_SHOWN_AXIS_FLAG) != 0)
            leftShownAxisID = axisID;
        if ((axisInfoFlags & EA_RIGHT_SHOWN_AXIS_FLAG) != 0)
            rightShownAxisID = axisID;
        
        if ((axisInfoFlags & EA_LEFT_SELECTED_AXIS_FLAG) != 0)
            leftSelectedAxisID = axisID;
        if ((axisInfoFlags & EA_RIGHT_SELECTED_AXIS_FLAG) != 0)
            rightSelectedAxisID = axisID;
    }
    
    if ((plotToolModeFlags & EA_SHOW_MARKED_AXES_ONLY_FLAG) == 0)
    {
        leftShownAxisID  = 0;
        rightShownAxisID = curAxisCount - 1;
    }
    else
    {
        if (leftShownAxisID ==  -1) leftShownAxisID  = 0;
        if (rightShownAxisID == -1) rightShownAxisID = curAxisCount - 1;
    }
    
    if (leftSelectedAxisID ==  -1) leftSelectedAxisID  = leftShownAxisID;
    if (rightSelectedAxisID == -1) rightSelectedAxisID = rightShownAxisID;
    
    if (rightShownAxisID < leftShownAxisID)
    {
        axisID           = leftShownAxisID;
        leftShownAxisID  = rightShownAxisID;
        rightShownAxisID = axisID;
    }
    
    if (rightSelectedAxisID < leftSelectedAxisID)
    {
        axisID              = leftSelectedAxisID;
        leftSelectedAxisID  = rightSelectedAxisID;
        rightSelectedAxisID = axisID;
    }
    
    if (leftSelectedAxisID < leftShownAxisID)
        leftSelectedAxisID = leftShownAxisID;
    
    if (rightSelectedAxisID > rightShownAxisID)
        rightSelectedAxisID = rightShownAxisID;
}

// ****************************************************************************
// Method: ParallelAxisAttributes::AdjustAxisSequencesAfterInsertingNewAxis
//
// Purpose: Adjusts ordinals of left and right shown axes, and ordinals of left
//          and right selected axes, if necessary, after inserting a new axis.
//
// Programmer: Mark Blair
// Creation:   Fri Jan 12 12:04:22 PST 2007
//
// Modifications:
//   
// ****************************************************************************

void
ParallelAxisAttributes::AdjustAxisSequencesAfterInsertingNewAxis(
    int &leftShownAxisID, int &rightShownAxisID,
    int &leftSelectedAxisID, int &rightSelectedAxisID, int insertedAxisID)
{
    if ((plotToolModeFlags & EA_SHOW_MARKED_AXES_ONLY_FLAG) == 0)
        rightShownAxisID++;
    else
    {
        if (insertedAxisID <  leftShownAxisID) leftShownAxisID++;
        if (insertedAxisID < rightShownAxisID) rightShownAxisID++;
    
        if (leftShownAxisID == rightShownAxisID)
        {
            if (leftShownAxisID > 0)
                leftShownAxisID--;
            else
                rightShownAxisID++;
        }
    }

    if (insertedAxisID <  leftSelectedAxisID) leftSelectedAxisID++;
    if (insertedAxisID < rightSelectedAxisID) rightSelectedAxisID++;
    
    if (leftSelectedAxisID == rightSelectedAxisID)
    {
        if (leftSelectedAxisID > leftShownAxisID)
            leftSelectedAxisID--;
        else
            rightSelectedAxisID++;
    }
}

// ****************************************************************************
// Method: ParallelAxisAttributes::AdjustAxisSequencesAfterDeletingAxis
//
// Purpose: Adjusts ordinals of left and right shown axes, and ordinals of left
//          and right selected axes, if necessary, after deleting an axis.
//
// Programmer: Mark Blair
// Creation:   Fri Jan 12 12:04:22 PST 2007
//
// Modifications:
//   
// ****************************************************************************

void
ParallelAxisAttributes::AdjustAxisSequencesAfterDeletingAxis(int &leftShownAxisID,
    int &rightShownAxisID, int &leftSelectedAxisID, int &rightSelectedAxisID,
    int deletedAxisID, int axisCountBeforeDelete)
{
    if (axisCountBeforeDelete < 2) return;

    if (deletedAxisID <   leftShownAxisID) leftShownAxisID--;
    if (deletedAxisID <= rightShownAxisID) rightShownAxisID--;
    
    if ((leftShownAxisID == rightShownAxisID) && (axisCountBeforeDelete > 2))
    {
        if (leftShownAxisID > 0)
            leftShownAxisID--;
        else
            rightShownAxisID++;
    }

    if (deletedAxisID <   leftSelectedAxisID) leftSelectedAxisID--;
    if (deletedAxisID <= rightSelectedAxisID) rightSelectedAxisID--;
    
    if ((leftSelectedAxisID == rightSelectedAxisID) && (axisCountBeforeDelete > 2))
    {
        if (leftSelectedAxisID > leftShownAxisID)
            leftSelectedAxisID--;
        else
            rightSelectedAxisID++;
    }
}

// ****************************************************************************
// Method: ParallelAxisAttributes::MarkShownAndSelectedAxisSequences
//
// Purpose: Set flags corresponding to left and right shown axes, and to left
//          and right selected axes.
//
// Programmer: Mark Blair
// Creation:   Fri Jan 12 12:04:22 PST 2007
//
// Modifications:
//   
// ****************************************************************************

void
ParallelAxisAttributes::MarkShownAndSelectedAxisSequences(int leftShownAxisID,
    int rightShownAxisID, int leftSelectedAxisID, int rightSelectedAxisID)
{
    int axisID, axisInfoFlags;

    for (axisID = 0; axisID < axisInfoFlagSets.size(); axisID++)
    {
        axisInfoFlags =
            axisInfoFlagSets[axisID] & (0xffffffff ^ EA_AXIS_SEQUENCE_FLAGS);
            
        if (axisID == leftShownAxisID)
            axisInfoFlags |= EA_LEFT_SHOWN_AXIS_FLAG;
        if (axisID == rightShownAxisID)
            axisInfoFlags |= EA_RIGHT_SHOWN_AXIS_FLAG;
            
        if (axisID == leftSelectedAxisID)
            axisInfoFlags |= EA_LEFT_SELECTED_AXIS_FLAG;
        if (axisID == rightSelectedAxisID)
            axisInfoFlags |= EA_RIGHT_SELECTED_AXIS_FLAG;
            
        axisInfoFlagSets[axisID] = axisInfoFlags;
    }
}

// ****************************************************************************
// Method: ParallelAxisAttributes::RecalculateAxisXPositions
//
// Purpose: This method calculates the X position of each axis in the plot,
//          based on current axis order, the total number of axes in the plot,
//          and the individual X spacings that may be associated with some axes
//          in the plot.
//
// Programmer: Mark Blair
// Creation:   Wed Dec 20 17:52:01 PST 2006
//
// Modifications:
//
//    Mark Blair, Fri Feb 23 12:19:33 PST 2007
//    Now supports all variable axis spacing and axis group conventions.
//   
//    Mark Blair, Tue Feb 27 19:33:19 PST 2007
//    Improved axis spacing conventions for multiple axis groups.
//
//    Mark Blair, Wed Mar 14 18:04:12 PDT 2007
//    Further improved axis spacing conventions for multiple axis groups.
//   
// ****************************************************************************

void
ParallelAxisAttributes::RecalculateAxisXPositions(
    int leftShownAxisID, int rightShownAxisID)
{
    intVector    groupIDList;
    intVector    groupShownIntCounts;
    doubleVector groupAxisSpacingSums;
    
    intVector    axisGroupIDNums;
    doubleVector axisSpacings;
    boolVector   axisNotInSpacingSums;
    
    int axisCount = orderedAxisNames.size();
    int attVarCount = axisAttributeVariables.size();
    int dummyGroupID = PCP_FIRST_DUMMY_AXIS_GROUP_ID;
    int axisID, axisGroupID, attVarID, attValueMap, groupIDNum;
    double axisSpacing, xRangeFraction, unscaledLeftX, unscaledRightX;
    double xScale, xTranslate;
    double unscaledXPosition = 0.0;
    double *axisAttData;
    std::string axisName;
    
    double defaultAxisSpacing = 1.0 / (double)(rightShownAxisID - leftShownAxisID);

    for (axisID = 0; axisID < axisCount; axisID++)
    {
        axisName = orderedAxisNames[axisID];
        
        for (attVarID = 0; attVarID < attVarCount; attVarID++)
        {
            if (axisAttributeVariables[attVarID] == axisName) break;
        }
        
        if (attVarID < attVarCount)
        {
            axisAttData = &axisAttributeData[attVarID*(attributesPerAxis+1)];
            attValueMap = (int)axisAttData[attributesPerAxis];
            
            if ((attValueMap & PCP_GROUP_ID_ATTRIBUTE_FLAG) != 0)
                axisGroupID = (int)axisAttData[PCP_GROUP_ID_ATTRIBUTE_OFFSET];
            else if ((attValueMap & PCP_AXIS_SPACING_ATTRIBUTE_FLAG) != 0)
                axisGroupID = PCP_IMPLICIT_AXIS_GROUP_ID;
            else
                axisGroupID = dummyGroupID++;
                
            for (groupIDNum = 0; groupIDNum < groupIDList.size(); groupIDNum++)
            {
                if (groupIDList[groupIDNum] == axisGroupID) break;
            }
            
            if (groupIDNum >= groupIDList.size())
            {
                groupIDNum = groupIDList.size();
                
                groupIDList.push_back(axisGroupID);
                groupShownIntCounts.push_back(0);
                groupAxisSpacingSums.push_back(0.0);
            }
            
            if ((attValueMap & PCP_AXIS_SPACING_ATTRIBUTE_FLAG) != 0)
                axisSpacing = axisAttData[PCP_AXIS_SPACING_ATTRIBUTE_OFFSET];
            else
                axisSpacing = defaultAxisSpacing;
        }
        else
        {
            groupIDNum = groupIDList.size();

            groupIDList.push_back(dummyGroupID); dummyGroupID++;
            groupShownIntCounts.push_back(0);
            groupAxisSpacingSums.push_back(0.0);
            
            axisSpacing = defaultAxisSpacing;
        }
        
        axisGroupIDNums.push_back(groupIDNum);
        axisSpacings.push_back(axisSpacing);
        axisNotInSpacingSums.push_back(false);
    }

    for (axisID = 1; axisID < axisCount; axisID++)
    {
        if (axisGroupIDNums[axisID] != axisGroupIDNums[axisID-1])
            axisNotInSpacingSums[axisID-1] = true;
    }
    
    for (axisID = 0; axisID < axisCount; axisID++)
    {
        if ((axisID < leftShownAxisID) || (axisID >= rightShownAxisID))
            axisNotInSpacingSums[axisID] = true;
        else if (!axisNotInSpacingSums[axisID])
        {
            groupIDNum = axisGroupIDNums[axisID];
            
            groupShownIntCounts[groupIDNum]++;
            groupAxisSpacingSums[groupIDNum] += axisSpacings[axisID];
        }
    }

    axisXPositions.clear();
    
    for (axisID = 0; axisID < axisCount; axisID++)
    {
        axisXPositions.push_back(unscaledXPosition);
        
        if (axisID == leftShownAxisID)
            unscaledLeftX = unscaledXPosition;
        else if (axisID == rightShownAxisID)
            unscaledRightX = unscaledXPosition;
        
        if (axisNotInSpacingSums[axisID])
            unscaledXPosition += 1.0;
        else
        {
            groupIDNum = axisGroupIDNums[axisID];
        
            xRangeFraction = axisSpacings[axisID] / groupAxisSpacingSums[groupIDNum];
            unscaledXPosition+=xRangeFraction*(double)groupShownIntCounts[groupIDNum];
        }
    }

    xScale = 1.0 / (unscaledRightX - unscaledLeftX);
    xTranslate = -unscaledLeftX * xScale;
    
    for (axisID = 0; axisID < axisCount; axisID++)
        axisXPositions[axisID] = axisXPositions[axisID]*xScale + xTranslate;
    
    axisXPositions[ leftShownAxisID] = 0.0;     // Must be exactly 0.0
    axisXPositions[rightShownAxisID] = 1.0;     // Must be exactly 1.0
    
    if (axisCount > PCP_MAX_HORIZONTAL_TEXT_INFO_AXES)
        plotToolModeFlags |= EA_VERTICAL_TEXT_AXIS_INFO_FLAG;
    else
    {
        for (axisID = leftShownAxisID+1; axisID <= rightShownAxisID; axisID++)
        {
            if (axisXPositions[axisID] - axisXPositions[axisID-1] <
                PCP_MIN_H_INFO_AXIS_INTERVAL_FRAC)
            {
                plotToolModeFlags |= EA_VERTICAL_TEXT_AXIS_INFO_FLAG;
            }
        }
    }
}

// ****************************************************************************
// Method: ParallelAxisAttributes::IdentifyReasonableAxesToLabel
//
// Purpose: This method marks a reasonable set of axes to be annotated with
//          axis titles, axis bound labels, potential Extents tool slider bound
//          labels, and potential Extents tool threshold sliders.  It attempts
//          to place the labelled axes as close together as possible such that
//          no two labels from different axes overlap.
//
// Programmer: Mark Blair
// Creation:   Thu Feb  8 19:50:58 PST 2007
//
// Modifications:
//   
// ****************************************************************************

void
ParallelAxisAttributes::IdentifyReasonableAxesToLabel()
{
    int axisID, axisInfoFlagSet;
    double prevLabelledXPos = axisXPositions[0] - 1.0;
    
    for (axisID = 0; axisID < axisXPositions.size(); axisID++)
    {
        axisInfoFlagSet =
            axisInfoFlagSets[axisID] & (0xffffffff ^ EA_AXIS_INFO_SHOWN_FLAG);
            
        if (axisXPositions[axisID] - prevLabelledXPos >=
            PCP_MIN_V_INFO_AXIS_INTERVAL_FRAC)
        {
            axisInfoFlagSet |= EA_AXIS_INFO_SHOWN_FLAG;
            prevLabelledXPos = axisXPositions[axisID];
        }
        
        axisInfoFlagSets[axisID] = axisInfoFlagSet;
    }
}


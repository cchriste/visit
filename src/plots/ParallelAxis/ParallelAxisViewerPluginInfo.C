/*****************************************************************************
*
* Copyright (c) 2000 - 2007, The Regents of the University of California
* Produced at the Lawrence Livermore National Laboratory
* All rights reserved.
*
* This file is part of VisIt. For details, see http://www.llnl.gov/visit/. The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or materials provided with the distribution.
*  - Neither the name of the UC/LLNL nor  the names of its contributors may be
*    used to  endorse or  promote products derived from  this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED.  IN  NO  EVENT  SHALL  THE  REGENTS  OF  THE  UNIVERSITY OF
* CALIFORNIA, THE U.S.  DEPARTMENT  OF  ENERGY OR CONTRIBUTORS BE  LIABLE  FOR
* ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                          ParallelAxisViewerPluginInfo.C                   //
// ************************************************************************* //

#include <ParallelAxisPluginInfo.h>
#include <avtParallelAxisPlot.h>

#include <ViewerPlot.h>
#include <ParsingExprList.h>
#include <Expression.h>
#include <ColorAttribute.h>

#include <InvalidVariableException.h>
#include <ImproperUseException.h>
#include <DebugStream.h>

#include <stdlib.h>
#include <string.h>

#if defined(__APPLE__)
#define GetViewerInfo ParallelAxis_GetViewerInfo
#endif

// ****************************************************************************
//  Function:  GetViewerInfo
//
//  Purpose:
//    Return a new ViewerPluginInfo for the ParallelAxis plot.
//
//  Programmer: mblair -- generated by xml2info
//  Creation:   Mon Jun 5 18:19:57 PST 2006
//
//  Modifications:
//
//      Mark Blair, Fri Aug 18 19:17:00 PDT 2006
//      Added fallback attributes (see InitializePlotAtts).
//
//      Mark Blair, Fri Jun 15 14:34:36 PDT 2007
//      Renamed "fallback" attributes as "array expression" attributes.
//
// ****************************************************************************

extern "C" ViewerPlotPluginInfo* GetViewerInfo()
{
    ParallelAxisViewerPluginInfo::InitializeGlobalObjects();
    return new ParallelAxisViewerPluginInfo;
}

//
// Storage for static data elements.
//
ParallelAxisAttributes *ParallelAxisViewerPluginInfo::clientAtts = NULL;
ParallelAxisAttributes *ParallelAxisViewerPluginInfo::defaultAtts = NULL;
ParallelAxisAttributes *ParallelAxisViewerPluginInfo::arrayExpAtts = NULL;

// ****************************************************************************
//  Method:  ParallelAxisViewerPluginInfo::InitializeGlobalObjects
//
//  Purpose:
//    Initialize the plot atts.
//
//  Programmer: mblair -- generated by xml2info
//  Creation:   Mon Jun 5 18:19:57 PST 2006
//
//  Modifications:
//
//      Mark Blair, Fri Aug 18 19:17:00 PDT 2006
//      Added fallback attributes (see InitializePlotAtts).
//
//      Mark Blair, Fri Jun 15 14:34:36 PDT 2007
//      Renamed "fallback" attributes as "array expression" attributes.
//
// ****************************************************************************

void
ParallelAxisViewerPluginInfo::InitializeGlobalObjects()
{
    ParallelAxisViewerPluginInfo::clientAtts   = new ParallelAxisAttributes;
    ParallelAxisViewerPluginInfo::defaultAtts  = new ParallelAxisAttributes;
    ParallelAxisViewerPluginInfo::arrayExpAtts = new ParallelAxisAttributes;
}

// ****************************************************************************
//  Method: ParallelAxisViewerPluginInfo::GetClientAtts
//
//  Purpose:
//    Return a pointer to the viewer client attributes.
//
//  Returns:    A pointer to the viewer client attributes.
//
//  Programmer: mblair -- generated by xml2info
//  Creation:   Mon Jun 5 18:19:57 PST 2006
//
// ****************************************************************************

AttributeSubject *
ParallelAxisViewerPluginInfo::GetClientAtts()
{
    return clientAtts;
}

// ****************************************************************************
//  Method: ParallelAxisViewerPluginInfo::GetDefaultAtts
//
//  Purpose:
//    Return a pointer to the viewer default attributes.
//
//  Returns:    A pointer to the viewer default attributes.
//
//  Programmer: mblair -- generated by xml2info
//  Creation:   Mon Jun 5 18:19:57 PST 2006
//
// ****************************************************************************

AttributeSubject *
ParallelAxisViewerPluginInfo::GetDefaultAtts()
{
    return defaultAtts;
}

// ****************************************************************************
//  Method: ParallelAxisViewerPluginInfo::SetClientAtts
//
//  Purpose:
//    Set the viewer client attributes.
//
//  Arguments:
//    atts      A pointer to the new client attributes.
//
//  Programmer: mblair -- generated by xml2info
//  Creation:   Mon Jun 5 18:19:57 PST 2006
//
// ****************************************************************************

void
ParallelAxisViewerPluginInfo::SetClientAtts(AttributeSubject *atts)
{
    *clientAtts = *(ParallelAxisAttributes *)atts;
    clientAtts->Notify();
}

// ****************************************************************************
//  Method: ParallelAxisViewerPluginInfo::GetClientAtts
//
//  Purpose:
//    Get the viewer client attributes.
//
//  Arguments:
//    atts      A pointer to return the client default attributes in.
//
//  Programmer: mblair -- generated by xml2info
//  Creation:   Mon Jun 5 18:19:57 PST 2006
//
// ****************************************************************************

void
ParallelAxisViewerPluginInfo::GetClientAtts(AttributeSubject *atts)
{
    *(ParallelAxisAttributes *)atts = *clientAtts;
}

// ****************************************************************************
//  Method: ParallelAxisViewerPluginInfo::AllocAvtPlot
//
//  Purpose:
//    Return a pointer to a newly allocated avt plot.
//
//  Returns:    A pointer to the newly allocated avt plot.
//
//  Programmer: mblair -- generated by xml2info
//  Creation:   Mon Jun 5 18:19:57 PST 2006
//
// ****************************************************************************

avtPlot *
ParallelAxisViewerPluginInfo::AllocAvtPlot()
{
    return new avtParallelAxisPlot;
}


// ****************************************************************************
//  Method: TokenizeExtendedArrayExpression
//
//  Purpose: Breaks an "extended" array expression into text tokens.  The
//           extended format of an array expression makes it possible to
//           associate one or more scalar attribute values with each component
//           scalar variable of the expression.
//
//  Returns:
//      tokenList  : A list of tokens
//      tokenTypes : A corresponding list of token types
//
//  Programmer: Mark Blair
//  Creation:   Wed Jan 31 12:05:19 PST 2007
//
// ****************************************************************************

void
TokenizeExtendedArrayExpression(
    stringVector &tokenList, intVector &tokenTypes, const char *arrayExpression)
{
    tokenList.clear(); tokenTypes.clear();

    if (strncmp(arrayExpression, "array_compose", 13) != 0) return;

    bool endOfExpression = false;
    bool badExpression = false;
    bool insideToken = false;
    bool storeToken = false;
    bool charIsDelimiter;
    int tokenLen, tokenType;
    char tokenChar;
    char *expCharPtr = (char *)arrayExpression + 13;
    char *tokenCharPtr;
    char *suffixPtr;
    char token[121];
    
    while (!endOfExpression)
    {
        tokenChar = *expCharPtr++;

        if (isspace(tokenChar) || (tokenChar == '\0'))
        {
            if (insideToken) storeToken = true;
            if (tokenChar == '\0') endOfExpression = true;
        }
        else
        {
            if (tokenChar == '(')
                charIsDelimiter = true;
            else if (tokenChar == ')')
                charIsDelimiter = true;
            else if (tokenChar == ',')
                charIsDelimiter = true;
            else
                charIsDelimiter = false;
                
            if (insideToken)
            {
                if (charIsDelimiter)
                {
                    expCharPtr--;
                    storeToken = true;
                }
                else if (tokenLen == 120)
                {
                    badExpression = true;
                }
                else
                {
                    *tokenCharPtr++ = tokenChar;
                    tokenLen++;
                }
            }
            else
            {
                tokenCharPtr = token;

                *tokenCharPtr++ = tokenChar;
                tokenLen = 1;
                
                insideToken = true;
                
                if (charIsDelimiter) storeToken = true;
            }
        }

        if (storeToken)
        {
            *tokenCharPtr = '\0';
            tokenList.push_back(std::string(token));
                
            if (strcmp(token, "(") == 0)
                tokenType = PCP_LEFT_PARENTHESIS_TOKEN;
            else if (strcmp(token, ")") == 0)
                tokenType = PCP_RIGHT_PARENTHESIS_TOKEN;
            else if (strcmp(token, ",") == 0)
                tokenType = PCP_COMMA_TOKEN;
            else
            {
                strtod(token, &suffixPtr);
                    
                if (*suffixPtr == '\0')
                {
                    if (strchr(token, '.') != NULL)
                        tokenType = PCP_FLOATING_POINT_NUMBER_TOKEN;
                    else if (strchr(token, 'e') != NULL)
                        tokenType = PCP_FLOATING_POINT_NUMBER_TOKEN;
                    else if (strchr(token, 'E') != NULL)
                        tokenType = PCP_FLOATING_POINT_NUMBER_TOKEN;
                    else
                        tokenType = PCP_INTEGER_TOKEN;
                }
                else
                {
                    tokenCharPtr = token;
                    
                    while ((tokenChar = *tokenCharPtr++) != '\0')
                    {
                        if (!isalpha(tokenChar) && !isdigit(tokenChar))
                        {
                            if (tokenChar != '_') badExpression = true;
                        }
                    }
                    
                    if (!isalpha(token[0])) badExpression = true;
                    
                    if (strcmp(token, "NO_VALUE") == 0)
                        tokenType = PCP_NO_VALUE_TOKEN;
                    else if (strcmp(token, "no_value") == 0)
                        tokenType = PCP_NO_VALUE_TOKEN;
                    else
                        tokenType = PCP_VARIABLE_NAME_TOKEN;
                }
            }
            
            tokenTypes.push_back(tokenType);
            
            storeToken = false; insideToken = false;
        }
        
        if (badExpression) break;
    }
    
    tokenList.push_back(std::string("<end_of_expression>"));
    tokenTypes.push_back(PCP_END_OF_EXPRESSION_TOKEN);
    
    if (badExpression)
    {
        tokenList.clear(); tokenTypes.clear();
    }
}


// ****************************************************************************
//  Method: ParseExtendedArrayExpression
//
//  Purpose: Parses an "extended" array expression.  The extended format of an
//           array expression makes it possible to associate one or more scalar
//           attribute values with each component scalar variable of the
//           expression.
//
//  Returns:
//      axisVariableList  : A list of the expression's component variables
//      axisAttributeList : A corresponding list of N attribute values per
//                          component variable
//
//  Programmer: Mark Blair
//  Creation:   Wed Jan 31 12:05:19 PST 2007
//
// ****************************************************************************

void
ParseExtendedArrayExpression(stringVector &axisVariableList,
    doubleVector &axisAttributeList, const char *arrayExpression)
{
    bool badExpression = false;
    bool needCommaOrParen;
    int valueMap, valueNum;
    int valueIndex = 0;
    int tokenIndex = 1;
    int tokenCount, tokenType;
    double numberValue;

    stringVector tokenList;
    intVector    tokenTypes;
    
    doubleVector numberValues;
    boolVector   numberExists;

    axisVariableList.clear(); axisAttributeList.clear();
    
    TokenizeExtendedArrayExpression(tokenList, tokenTypes, arrayExpression);
    
    if ((tokenCount = tokenList.size()) < 4) return;
    
    if (tokenTypes[0]            != PCP_LEFT_PARENTHESIS_TOKEN ) return;
    if (tokenTypes[1]            != PCP_VARIABLE_NAME_TOKEN    ) return;
    if (tokenTypes[tokenCount-2] != PCP_RIGHT_PARENTHESIS_TOKEN) return;
    if (tokenTypes[tokenCount-1] != PCP_END_OF_EXPRESSION_TOKEN) return;

    do
    {
        axisVariableList.push_back(tokenList[tokenIndex]);
        
        valueMap = 0;
        
        for (valueNum = 0; valueNum < PCP_ATTRIBUTES_PER_AXIS; valueNum++)
            axisAttributeList.push_back(0.0);
            
        if ((tokenType = tokenTypes[++tokenIndex]) == PCP_RIGHT_PARENTHESIS_TOKEN)
        {
            axisAttributeList.push_back((double)valueMap);
            break;
        }
        else if (tokenType != PCP_COMMA_TOKEN)
        {
            badExpression = true;
            break;
        }
        
        if ((tokenType = tokenTypes[++tokenIndex]) == PCP_VARIABLE_NAME_TOKEN)
        {
            axisAttributeList.push_back((double)valueMap);
            valueIndex += PCP_ATTRIBUTES_PER_AXIS + 1;

            continue;
        }
        else if (tokenType == PCP_INTEGER_TOKEN)
        {
            numberValue = strtod(tokenList[tokenIndex].c_str(), NULL);

            axisAttributeList[valueIndex+PCP_GROUP_ID_ATTRIBUTE_OFFSET] =
                numberValue;
            valueMap |= PCP_GROUP_ID_ATTRIBUTE_FLAG;
            
            needCommaOrParen = true;
        }
        else if (tokenType == PCP_NO_VALUE_TOKEN)
            needCommaOrParen = true;
        else if (tokenType == PCP_FLOATING_POINT_NUMBER_TOKEN)
            needCommaOrParen = false;
        else
        {
            badExpression = true;
            break;
        }

        if (needCommaOrParen)
        {
            if ((tokenType = tokenTypes[++tokenIndex]) == PCP_RIGHT_PARENTHESIS_TOKEN)
            {
                axisAttributeList.push_back((double)valueMap);
                break;
            }
            else if (tokenType != PCP_COMMA_TOKEN)
            {
                badExpression = true;
                break;
            }

            if ((tokenType = tokenTypes[++tokenIndex]) == PCP_VARIABLE_NAME_TOKEN)
            {
                axisAttributeList.push_back((double)valueMap);
                valueIndex += PCP_ATTRIBUTES_PER_AXIS + 1;

                continue;
            }
        }
        
        numberValues.clear(); numberExists.clear();

        do
        {
            if (tokenType == PCP_NO_VALUE_TOKEN)
            {
                numberValues.push_back(0.0);
                numberExists.push_back(false);
            }
            else
            {
                if (tokenType != PCP_FLOATING_POINT_NUMBER_TOKEN)
                {
                    if (tokenType != PCP_INTEGER_TOKEN)
                    {
                        badExpression = true;
                        break;
                    }
                }

                numberValue = strtod(tokenList[tokenIndex].c_str(), NULL);

                numberValues.push_back(numberValue);
                numberExists.push_back(true);
            }
            
            if ((tokenType = tokenTypes[++tokenIndex]) != PCP_COMMA_TOKEN)
            {
                if (tokenType != PCP_RIGHT_PARENTHESIS_TOKEN) badExpression = true;
                break;
            }
        } while ((tokenType = tokenTypes[++tokenIndex]) != PCP_VARIABLE_NAME_TOKEN);
        
        if (numberValues.size() > 3) badExpression = true;
        
        if (badExpression) break;
        
        if (numberValues.size() == 2)
        {
            axisAttributeList[valueIndex+PCP_LOWER_BOUND_ATTRIBUTE_OFFSET] =
                numberValues[0];
            axisAttributeList[valueIndex+PCP_UPPER_BOUND_ATTRIBUTE_OFFSET] =
                numberValues[1];
            
            if (numberExists[0] && numberExists[1])
            {
                if (numberValues[0] < numberValues[1])
                {
                    valueMap |= PCP_LOWER_BOUND_ATTRIBUTE_FLAG;
                    valueMap |= PCP_UPPER_BOUND_ATTRIBUTE_FLAG;
                }
            }
        }
        else
        {
            axisAttributeList[valueIndex+PCP_AXIS_SPACING_ATTRIBUTE_OFFSET] =
                numberValues[0];
            if (numberExists[0] && (numberValues[0] > 0.0))
                valueMap |= PCP_AXIS_SPACING_ATTRIBUTE_FLAG;
            
            if (numberValues.size() == 3)
            {
                axisAttributeList[valueIndex+PCP_LOWER_BOUND_ATTRIBUTE_OFFSET] =
                    numberValues[1];
                axisAttributeList[valueIndex+PCP_UPPER_BOUND_ATTRIBUTE_OFFSET] =
                    numberValues[2];
            
                if (numberExists[1] && numberExists[2])
                {
                    if (numberValues[1] < numberValues[2])
                    {
                        valueMap |= PCP_LOWER_BOUND_ATTRIBUTE_FLAG;
                        valueMap |= PCP_UPPER_BOUND_ATTRIBUTE_FLAG;
                    }
                }
            }
        }
        
        axisAttributeList.push_back((double)valueMap);
        valueIndex += PCP_ATTRIBUTES_PER_AXIS + 1;
        
        if (tokenType == PCP_RIGHT_PARENTHESIS_TOKEN) break;
    } while (tokenIndex < tokenCount-1);
    
    if (badExpression)
    {
        axisVariableList.clear(); axisAttributeList.clear();
    }
}


// ****************************************************************************
//  Method: ParallelAxisViewerPluginInfo::InitializePlotAtts
//
//  Purpose:
//    Initialize the plot attributes to (1) the default attributes already set
//    by the ParallelAxis plot wizard or to (2) a combination of the plot's
//    ordinary default attributes (or user's saved default attributes) and
//    those attributes which are a function of an array expression plot input
//    variable.
//
//  Arguments:
//    atts      The attribute subject to initialize.
//    md        The metadata used to initialize.
//    atts      The variable name used to initialize.
//
//  Programmer: mblair -- generated by xml2info
//  Creation:   Fri Mar 31 16:49:49 PST 2006
//
//  Modifications:
//
//      Mark Blair, Fri Aug 18 19:17:00 PDT 2006
//      Added support for fallback attributes if wizard or CLI has not provided
//      sufficient input attributes (see fuller explanation in code below).
//
//      Mark Blair, Wed Sep 20 10:59:41 PDT 2006
//      Added support for time ordinals.
// 
//      Brad Whitlock, Wed Feb 21 14:37:05 PST 2007
//      Changed API.
//
//      Mark Blair, Wed Jan 17 16:40:37 PST 2007
//      Added support for selective axis information and axis sequence expansion.
//
//      Mark Blair, Wed Jan 31 12:05:19 PST 2007
//      Added support for extended array expressions.
//
//      Mark Blair, Fri Feb 23 12:19:33 PST 2007
//      Records diagnostic information in debug log if user input is invalid.
//
//      Mark Blair, Mon Feb 26 17:57:42 PST 2007
//      Changed API to accommodate corresponding API change throughout VisIt.
//
//      Mark Blair, Mon May 14 10:36:16 PDT 2007
//      Added default "Context" attributes needed when plot variable is an
//      Array expression.
//
//      Mark Blair, Thu Jun  7 11:37:46 PDT 2007
//      Now checks explicit flag to determine if default attributes are from
//      plot wizard.
//
//      Mark Blair, Fri Jun 15 14:34:36 PDT 2007
//      Changed "fallback" attributes to "array expression" attributes.  If
//      plot input variable is an array expression, initialize plot attributes
//      as a combination of default attributes and those attributes which are
//      a function of the expression.
//   
//      Mark Blair, Mon Jul  2 17:34:26 PDT 2007
//      Now ensures that all attributes related to axis layout and labeling
//      are consistent before the engine runs.
//   
// ****************************************************************************

void
ParallelAxisViewerPluginInfo::InitializePlotAtts(AttributeSubject *atts,
    ViewerPlot *plot)
{
    ParallelAxisAttributes *initAtts = defaultAtts;

    if ((defaultAtts->GetPlotToolModeFlags() & EA_ATTRIBUTES_FROM_WIZARD_FLAG) == 0)
    {
        stringVector axisNames;
        doubleVector axisMins;
        doubleVector axisMaxs;
        doubleVector extMins;
        doubleVector extMaxs;
        intVector    minTimeOrds;
        intVector    maxTimeOrds;
        stringVector groupNames;
        intVector    infoFlagSets;
        doubleVector xPositions;
        doubleVector axisAttData;

        int axisCount, axisNum, infoFlags;
        Expression *exp;
        const char *expChars, *arrayExpression;
        const char *variableName = plot->GetVariableName().c_str();
        
        if ((exp = ParsingExprList::GetExpression(plot->GetVariableName())) == NULL)
        {
            debug1 << "PCP/PAVPI/IPA/1: ParallelAxis plot variable is "
                   << "neither a scalar nor an expression." << endl;
            EXCEPTION1(InvalidVariableException, plot->GetVariableName());
        }

        expChars = exp->GetDefinition().c_str();
        
        if ((arrayExpression = strstr(expChars,"array_compose")) == NULL)
        {
            debug1 << "PCP/PAVPI/IPA/2: ParallelAxis plot input expression "
                   << "is not an array expression." << endl;
            EXCEPTION1(ImproperUseException,
                "ParallelAxis plot input expressions must be array expressions.");
        }
        
        ParseExtendedArrayExpression(axisNames, axisAttData, arrayExpression);
            
        if ((axisCount = axisNames.size()) == 0)
        {
            debug1 << "PCP/PAVPI/IPA/3: ParallelAxis plot variable is "
                   << "an invalid array expression." << endl;
            EXCEPTION1(ImproperUseException, "Invalid array expression.");
        }
            
        if (axisCount < 2)
        {
            debug1 << "PCP/PAVPI/IPA/4: ParallelAxis plot input expression "
                   << "has only 1 scalar variable." << endl;
            EXCEPTION1(ImproperUseException,
            "ParallelAxis plot needs at least 2 input scalars for coordinate axes.");
        }
            
        for (axisNum = 0; axisNum < axisCount; axisNum++)
        {
            infoFlags = EA_THRESHOLD_BY_EXTENT_FLAG |
                EA_SHOW_ALL_AXIS_INFO_FLAGS | EA_AXIS_INFO_SHOWN_FLAG;

            if (axisNum == 0)
                infoFlags |= EA_LEFT_SHOWN_AXIS_FLAG | EA_LEFT_SELECTED_AXIS_FLAG;
            if (axisNum == axisCount-1)
                infoFlags |= EA_RIGHT_SHOWN_AXIS_FLAG | EA_RIGHT_SELECTED_AXIS_FLAG;

            axisMins.push_back(-1e+37);
            axisMaxs.push_back(+1e+37);
            extMins.push_back(0.0);
            extMaxs.push_back(1.0);
            minTimeOrds.push_back(0);
            maxTimeOrds.push_back(0);
            groupNames.push_back(std::string("(not_in_a_group)"));
            infoFlagSets.push_back(infoFlags);
            xPositions.push_back(-1.0);
        }

        arrayExpAtts->SetOrderedAxisNames(axisNames);
        arrayExpAtts->SetAxisMinima(axisMins);
        arrayExpAtts->SetAxisMaxima(axisMaxs);
        arrayExpAtts->SetExtentMinima(extMins);
        arrayExpAtts->SetExtentMaxima(extMaxs);
        arrayExpAtts->SetExtMinTimeOrds(minTimeOrds);
        arrayExpAtts->SetExtMaxTimeOrds(maxTimeOrds);
        arrayExpAtts->SetPlotToolModeFlags(EA_AXIS_INFO_AUTO_LAYOUT_FLAG);
        arrayExpAtts->SetAxisGroupNames(groupNames);
        arrayExpAtts->SetAxisInfoFlagSets(infoFlagSets);
        arrayExpAtts->SetAxisXPositions(xPositions);
        arrayExpAtts->SetAxisAttributeVariables(axisNames);
        arrayExpAtts->SetAttributesPerAxis(PCP_ATTRIBUTES_PER_AXIS);
        arrayExpAtts->SetAxisAttributeData(axisAttData);

        arrayExpAtts->SetDrawLines(defaultAtts->GetDrawLines());
        arrayExpAtts->SetLinesColor(defaultAtts->GetLinesColor());
        arrayExpAtts->SetDrawContext(defaultAtts->GetDrawContext());
        arrayExpAtts->SetContextGamma(defaultAtts->GetContextGamma());
        arrayExpAtts->SetContextNumPartitions(
            defaultAtts->GetContextNumPartitions());
        arrayExpAtts->SetContextColor(defaultAtts->GetContextColor());
        arrayExpAtts->SetDrawLinesOnlyIfExtentsOn(
            defaultAtts->GetDrawLinesOnlyIfExtentsOn());

        initAtts = arrayExpAtts;
    }

    defaultAtts->SetPlotToolModeFlags(defaultAtts->GetPlotToolModeFlags() &
        (0xffffffff ^ EA_ATTRIBUTES_FROM_WIZARD_FLAG));
    
    if (!initAtts->AttributesAreConsistent())
    {
        debug1 << "PCP/PAVPI/IPA/5: ParallelAxis plot internal data is "
               << "inconsistent." << endl;
        EXCEPTION1(ImproperUseException, 
                   "ParallelAxis plot is not set up correctly.");
    }

    initAtts->ReconfigureAxes(0, initAtts->GetOrderedAxisNames().size()-1);

    *(ParallelAxisAttributes *)atts = *initAtts;
}


// ****************************************************************************
// Method: ParallelAxisViewerPluginInfo::GetVariableTypes
//
// Purpose: 
//   Returns a flag indicating the types of variables that can be put in the
//   plot's variable list.
//
// Returns:    A flag indicating the types of variables that can be put in
//             the plot's variable list.
//
//  Programmer: mblair -- generated by xml2info
//  Creation:   Mon Jun 5 18:19:57 PST 2006
//
// Modifications:
//   
// ****************************************************************************

int
ParallelAxisViewerPluginInfo::GetVariableTypes() const
{
    return VAR_CATEGORY_SCALAR | VAR_CATEGORY_ARRAY;
}


// ****************************************************************************
//  Method: ParallelAxisViewerPluginInfo::XPMIconData
//
//  Purpose:
//    Return a pointer to the icon data.
//
//  Returns:    A pointer to the icon data.
//
//  Programmer: mblair -- generated by xml2info
//  Creation:   Mon Jun 5 18:19:57 PST 2006
//
// ****************************************************************************

#include <ParallelAxis.xpm>
const char **
ParallelAxisViewerPluginInfo::XPMIconData() const
{
    return ParallelAxis_xpm;
}

/*****************************************************************************
*
* Copyright (c) 2000 - 2008, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-400142
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtMirandaFileFormat.C                           //
// ************************************************************************* //

#include <avtMirandaFileFormat.h>


#include <string>
#ifdef _WIN32
#include <direct.h> /* for _getcwd */
#else
#include <inttypes.h>
#include <unistd.h>
#endif

#include <vtkFieldData.h>
#include <vtkFloatArray.h>
#include <vtkIntArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>

#include <avtDatabase.h>
#include <avtDatabaseMetaData.h>
#include <avtIntervalTree.h>
#include <avtStructuredDomainBoundaries.h>
#include <avtVariableCache.h>
#include <avtMaterial.h>

#include <Expression.h>

#include <InvalidFilesException.h>
#include <InvalidVariableException.h>
#include <InvalidDBTypeException.h>

using std::string;

#ifndef STREQUAL
#if defined(_WIN32) 
#  define STREQUAL(a,b)              stricmp(a,b)
#else
#  define STREQUAL(a,b)              strcasecmp(a,b)
#endif
#endif

#ifdef _WIN32
typedef int int32_t;
#endif



// ****************************************************************************
//  Method: avtMiranda constructor
//
//  Programmer: dbremer -- generated by xml2avt
//  Creation:   Tue Jan 23 17:00:13 PST 2007
//
//  Modifications:
//    Dave Bremer and Kathleen Bonnell, Mon Mar 19 19:04:11 PDT 2007
//    Fix fopen on windows.  Add error checking.
//
//    Dave Bremer, Wed Feb 20 15:25:12 PST 2008
//    Added support for version 1.2 of the .raw files, which specifies block
//    ordering using a tag of the form "fileorder: ZYX", rather than using a
//    separate grid file per process.  Also allow comments that use a full line.
// ****************************************************************************

avtMirandaFileFormat::avtMirandaFileFormat(const char *filename, DBOptionsAttributes *readOpts)
    : avtMTMDFileFormat(filename)
{
    string tag, buf1, buf2;
    char buf[512];
    ifstream  f(filename);
    int iGlobalDim[3];
    int ii, jj;

    dim = 3;
    flatDim = -1;
    iFileOrder[0] = -1;
    iFileOrder[1] = -1;
    iFileOrder[2] = -1;

    // Verify that the 'magic' and version number are right
    f >> buf1 >> buf2;
    if (buf1 != "VERSION")
    {
        EXCEPTION1(InvalidDBTypeException, "Not a raw miranda file." );
    }
    if (buf2 != "1.0" && buf2 != "1.1" && buf2 != "1.2")
    {
        EXCEPTION1(InvalidDBTypeException, 
                   "Only raw miranda version 1.0, 1.1, and 1.2 are supported." );
    }

    // Process a tag at a time until all lines have been read
    while (f.good())
    {
        f >> tag;
        if (f.eof()) {
            f.clear();
            break;
        }

        if (tag[0] == '#')
        {
            SkipToEndOfLine( f, false );
        }
        else if (STREQUAL("gridfiles:", tag.c_str())==0)
        {
            f >> gridTemplate;
            SkipToEndOfLine( f );
        }
        else if (STREQUAL("datafiles:", tag.c_str())==0)
        {
            f >> fileTemplate;
            SkipToEndOfLine( f );
        }
        else if (STREQUAL("domainsize:", tag.c_str())==0)
        {
            f >> iGlobalDim[0] >> iGlobalDim[1] >> iGlobalDim[2];
            SkipToEndOfLine( f );
        }
        else if (STREQUAL("blocksize:", tag.c_str())==0)
        {
            f >> iBlockSize[0] >> iBlockSize[1] >> iBlockSize[2];
            SkipToEndOfLine( f );
        }
        else if (STREQUAL("origin:", tag.c_str())==0)
        {
            fOrigin[0] = GetFortranDouble(f);
            fOrigin[1] = GetFortranDouble(f);
            fOrigin[2] = GetFortranDouble(f);
            SkipToEndOfLine( f );
        }
        else if (STREQUAL("spacing:", tag.c_str())==0)
        {
            fStride[0] = GetFortranDouble(f);
            fStride[1] = GetFortranDouble(f);
            fStride[2] = GetFortranDouble(f);
            SkipToEndOfLine( f );
        }
        else if (STREQUAL("variables:", tag.c_str())==0)
        {
            int nVars = 0;
            f >> nVars;
            SkipToEndOfLine( f );
        
            aVarNames.resize(nVars);
            aVarNumComps.resize(nVars);
            aVarMinMax.resize(nVars);
        
            for (ii = 0 ; ii < nVars ; ii++)
            {
                f >> aVarNames[ii] >> aVarNumComps[ii];
                aVarMinMax[ii].resize( 2*aVarNumComps[ii] );
                
                for (jj = 0 ; jj < aVarNumComps[ii] ; jj++)
                {
                    aVarMinMax[ii][jj*2] = GetFortranDouble(f);
                    aVarMinMax[ii][jj*2+1] = GetFortranDouble(f);
                }
                SkipToEndOfLine( f );
            }
        }
        else if (STREQUAL("materials:", tag.c_str())==0)
        {
            int nMats = 0;
            f >> nMats;
            SkipToEndOfLine( f );
            
            aMatNames.resize(nMats);
            for (ii = 0 ; ii < nMats ; ii++)
            {
                f >> aMatNames[ii];
                SkipToEndOfLine( f, false );
            }
        }
        else if (STREQUAL("timesteps:", tag.c_str())==0)
        {
            int nDumps = 0;
            f >> nDumps;
            SkipToEndOfLine( f );
            
            aCycles.resize(nDumps);
            aSimTimes.resize(nDumps);
            
            for (ii = 0 ; ii < nDumps ; ii++)
            {
                f >> aCycles[ii];
                aSimTimes[ii] = GetFortranDouble(f);
                SkipToEndOfLine( f );
            }
        }
        else if (STREQUAL("fileorder:", tag.c_str())==0)
        {
            //order will be some permutation of xyz or XYZ, or YZ, xy, etc.
            string  order;
            f >> order;
            if (order.size() != 2 && order.size() != 3)
                EXCEPTION1(InvalidDBTypeException, "Error parsing file.  "
                    "fileorder: should be followed by a permutation of XYZ");

            for (ii = 0 ; ii < order.size() ; ii++)
            {
                if ('x' <= order[ii] && order[ii] <= 'z')
                    iFileOrder[ii] = order[ii] - 'x';
                else if ('X' <= order[ii] && order[ii] <= 'Z')
                    iFileOrder[ii] = order[ii] - 'X';
                else
                    EXCEPTION1(InvalidDBTypeException, "Error parsing file.  "
                        "fileorder: should be followed by a permutation of XYZ");
            }
            if (order.size()==2)
                iFileOrder[2] = 3 - (iFileOrder[0]+iFileOrder[1]);
        }
        else
        {
            sprintf(buf, "Error parsing file.  Unknown tag %s", tag.c_str());
            EXCEPTION1(InvalidDBTypeException, buf);
        }
    }

    if (f.fail())
    {
        sprintf(buf, "Error parsing file at tag '%s'", tag.c_str());
        EXCEPTION1(InvalidDBTypeException, buf);
    }
    
    // make the file template into an absolute path
    for (ii = strlen(filename)-1 ; ii >= 0 ; ii--)
    {
        if (filename[ii] == '/' || filename[ii] == '\\')
        {
            fileTemplate.insert(0, filename, ii+1);
            gridTemplate.insert(0, filename, ii+1);
            break;
        }
    }
    if (ii == -1)
    {
#ifdef _WIN32
        _getcwd(buf, 512);
#else
        getcwd(buf, 512);
#endif
        strcat(buf, "/");
        fileTemplate.insert(0, buf, strlen(buf));
        gridTemplate.insert(0, buf, strlen(buf));
    }

#ifdef _WIN32
    for (ii = 0 ; ii < fileTemplate.size() ; ii++)
    {
        if (fileTemplate[ii] == '/')
            fileTemplate[ii] = '\\';
    }
    for (ii = 0 ; ii < gridTemplate.size() ; ii++)
    {
        if (gridTemplate[ii] == '/')
            gridTemplate[ii] = '\\';
    }
#endif

    iNumBlocks[0] = iGlobalDim[0] / iBlockSize[0];
    iNumBlocks[1] = iGlobalDim[1] / iBlockSize[1];
    iNumBlocks[2] = iGlobalDim[2] / iBlockSize[2];
    
    //domainMap is only used if the file order is unspecified
    if (iFileOrder[0] == -1)
        domainMap.resize( iNumBlocks[0]*iNumBlocks[1]*iNumBlocks[2]*3, -1 );

    // Rearrange data if it is flat in one dimension
    if (iGlobalDim[2] == 1)
    {
        dim = 2;
        flatDim = 2;
    }
    else if (iGlobalDim[1] == 1)
    {
        dim = 2;
        flatDim = 1;
        
        double tmpOrigin = fOrigin[1];
        double tmpStride = fStride[1];
    
        fOrigin[1] = fOrigin[2];
        fStride[1] = fStride[2];
        iNumBlocks[1] = iNumBlocks[2];
        iBlockSize[1] = iBlockSize[2];
    
        fOrigin[2] = tmpOrigin;
        fStride[2] = tmpStride;
        iNumBlocks[2] = 1;
        iBlockSize[2] = 1;

        if (iFileOrder[0] == 2)
            iFileOrder[0] = 1;
        else if (iFileOrder[1] == 2)
            iFileOrder[1] = 1;
    }
    else if (iGlobalDim[0] == 1)
    {
        dim = 2;
        flatDim = 0;
    
        double tmpOrigin = fOrigin[0];
        double tmpStride = fStride[0];
        
        fOrigin[0] = fOrigin[1];
        fStride[0] = fStride[1];
        iNumBlocks[0] = iNumBlocks[1];
        iBlockSize[0] = iBlockSize[1];
        
        fOrigin[1] = fOrigin[2];
        fStride[1] = fStride[2];
        iNumBlocks[1] = iNumBlocks[2];
        iBlockSize[1] = iBlockSize[2];
    
        fOrigin[2] = tmpOrigin;
        fStride[2] = tmpStride;
        iNumBlocks[2] = 1;
        iBlockSize[2] = 1;

        iFileOrder[0]--;
        iFileOrder[1]--;
    }

}


// ****************************************************************************
//  Method: avtMirandaFileFormat::SkipToEndOfLine
//
//  Purpose:
//      Used by the constructor to parse the file.  This just doublechecks 
//      that no extra tokens are found in the area where only white space
//      and comments should be.
//
//  Programmer: Dave Bremer
//  Creation:   Tue Jan 23 17:00:13 PST 2007
//
// ****************************************************************************

void 
avtMirandaFileFormat::SkipToEndOfLine( ifstream &f, bool bCheckForBadTokens )
{
    char buf[512];
    f.getline(buf, 512);

    int len = strlen(buf);
    if (len >= 511)
    {
        EXCEPTION1(InvalidDBTypeException, "Error parsing file." );
    }

    if (bCheckForBadTokens)
    {
        int ii;
        for (ii = 0 ; ii < len ; ii++)
        {
            if (buf[ii] == '#')
            {
                //The rest of the line is comments.  We're done
                break;
            }
            if ((buf[ii] != ' ') && (buf[ii] != '\t') && (buf[ii] != '\n'))
            {
                EXCEPTION1(InvalidDBTypeException, "Error parsing file." );
            }
        }
    }
}


// ****************************************************************************
//  Method: avtMirandaFileFormat::GetFortranDouble
//
//  Purpose:
//      This function extracts the next double from the stream.  It also 
//      handles a fortran convention of sometimes writing D or d instead 
//      of E or e, to denote the exponent in a float or double.
//
//  Programmer: Dave Bremer
//  Creation:   Tue Jan 23 17:00:13 PST 2007
//
// ****************************************************************************

double
avtMirandaFileFormat::GetFortranDouble( ifstream &f )
{
    std::string s;
    f >> s;

    int ii;
    for (ii = 0 ; ii < s.size() ; ii++)
    {
        if (s[ii] == 'd' || s[ii] == 'D')
        {
            s[ii] = 'e';
        }
    }
    double r = atof(s.c_str());
    return r;
}



// ****************************************************************************
//  Method: avtMirandaFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: dbremer -- generated by xml2avt
//  Creation:   Tue Jan 23 17:00:13 PST 2007
//
// ****************************************************************************

void
avtMirandaFileFormat::FreeUpResources(void)
{
}


// ****************************************************************************
//  Method: avtMirandaFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: dbremer -- generated by xml2avt
//  Creation:   Tue Jan 23 17:00:13 PST 2007
//
//  Modifications:
//    Dave Bremer, Wed Feb 21 17:54:33 PST 2007
//    All components of a material set are also added as scalars.
//    Those scalars are returned unmodified, whereas a material set
//    is cleaned first.
//    
// ****************************************************************************

void
avtMirandaFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, 
                                               int /*timeState*/)
{
    // Add the mesh
    std::string meshname("mesh");
    int nblocks = iNumBlocks[0] * iNumBlocks[1] * iNumBlocks[2];

    avtMeshMetaData *mesh = new avtMeshMetaData;
    mesh->name = meshname;
    mesh->meshType = AVT_RECTILINEAR_MESH;
    mesh->numBlocks = nblocks;
    mesh->cellOrigin = 1;
    mesh->spatialDimension = dim;
    mesh->topologicalDimension = dim;
    mesh->blockTitle = "blocks";
    mesh->blockPieceName = "p%06d";
    mesh->groupPieceName = "global_index";
    
    if (dim == 3)
    {
        double extents[6] = {fOrigin[0] - fStride[0]/2.0,
                             fOrigin[0] - fStride[0]/2.0 + (iNumBlocks[0]*iBlockSize[0])*fStride[0],
                             fOrigin[1] - fStride[1]/2.0,
                             fOrigin[1] - fStride[1]/2.0 + (iNumBlocks[1]*iBlockSize[1])*fStride[1],
                             fOrigin[2] - fStride[2]/2.0,
                             fOrigin[2] - fStride[2]/2.0 + (iNumBlocks[2]*iBlockSize[2])*fStride[2]
                        };
        mesh->SetExtents(extents);
    }
    else
    {
        double extents[4] = {fOrigin[0] - fStride[0]/2.0,
                             fOrigin[0] - fStride[0]/2.0 + (iNumBlocks[0]*iBlockSize[0])*fStride[0],
                             fOrigin[1] - fStride[1]/2.0,
                             fOrigin[1] - fStride[1]/2.0 + (iNumBlocks[1]*iBlockSize[1])*fStride[1]};
        mesh->SetExtents(extents);
        
        if (flatDim == 0)
        {
            mesh->xLabel = "Y";
            mesh->yLabel = "Z";
            mesh->zLabel = "";
        }
        if (flatDim == 1)
        {
            mesh->xLabel = "X";
            mesh->yLabel = "Z";
            mesh->zLabel = "";
        }
        
    }
    mesh->hasSpatialExtents = true;
    md->Add(mesh);

    // Add the variables    
    int ii;
    for (ii = 0 ; ii < aVarNames.size() ; ii++)
    {
        if (aVarNumComps[ii] == 1)
        {
            AddScalarVarToMetaData(md, aVarNames[ii], meshname, AVT_ZONECENT);
        }
        else
        {
            AddVectorVarToMetaData(md, aVarNames[ii], meshname, 
                                   AVT_ZONECENT, aVarNumComps[ii]);
        }
    }

    if (aMatNames.size() > 0)
    {
        // Add material set components as scalar vars as well as a material set
        for (ii = 0 ; ii < aMatNames.size() ; ii++)
        {
            AddScalarVarToMetaData(md, aMatNames[ii], meshname, AVT_ZONECENT);
        }
        avtMaterialMetaData *matmd = new avtMaterialMetaData;
        matmd->name = "materialset";
        matmd->meshName = meshname;
        matmd->numMaterials = aMatNames.size();
        matmd->materialNames = aMatNames;
        md->Add(matmd);
    }
    
    // Find domain boundaries
    if (!avtDatabase::OnlyServeUpMetaData() && nblocks > 1)
    {
        avtRectilinearDomainBoundaries *rdb =
                                      new avtRectilinearDomainBoundaries(true);
        rdb->SetNumDomains(nblocks);
        int bbox[6];
        for (ii = 0 ; ii < nblocks ; ii++)
        {
            int iBlockX, iBlockY, iBlockZ;
            DomainToIJK( ii, iBlockX, iBlockY, iBlockZ );
            bbox[0] = iBlockX * iBlockSize[0];
            bbox[1] = iBlockX * iBlockSize[0] + iBlockSize[0];
            bbox[2] = iBlockY * iBlockSize[1];
            bbox[3] = iBlockY * iBlockSize[1] + iBlockSize[1];
            bbox[4] = iBlockZ * iBlockSize[2];
            bbox[5] = iBlockZ * iBlockSize[2] + iBlockSize[2];

            rdb->SetIndicesForRectGrid(ii, bbox);
        }
        rdb->CalculateBoundaries();

        void_ref_ptr vr = void_ref_ptr(rdb,
                                   avtStructuredDomainBoundaries::Destruct);
        cache->CacheVoidRef("any_mesh",
                       AUXILIARY_DATA_DOMAIN_BOUNDARY_INFORMATION, -1, -1, vr);
    }
}


// ****************************************************************************
//  Method: avtMirandaFileFormat::DomainToIJK
//
//  Purpose:
//      Gets the location of a domain in block space, 
//      i.e. within 0 .. iNumBlocks-1.  
//
//  Programmer: Dave Bremer
//  Creation:   Feb 1, 2007
//
//  Modifications:
//    Dave Bremer, Wed Feb 20 15:25:12 PST 2008
//    Changed the computation of the mapping to use either iFileOrder, if set,
//    or the grid files.
// ****************************************************************************

void
avtMirandaFileFormat::DomainToIJK(int domain, int &i, int &j, int &k)
{

    if (iFileOrder[0] != -1)
    {
        int out[3];

        if (dim == 3)
        {
            out[iFileOrder[0]] = domain % iNumBlocks[iFileOrder[0]];
            out[iFileOrder[1]] = (domain / iNumBlocks[iFileOrder[0]]) % iNumBlocks[iFileOrder[1]];
            out[iFileOrder[2]] = domain / (iNumBlocks[iFileOrder[0]] * iNumBlocks[iFileOrder[1]]);
            i = out[0];
            j = out[1];
            k = out[2];
        }
        else
        {
            int lenInFastDir = iNumBlocks[iFileOrder[0]];

            out[iFileOrder[0]] = domain % lenInFastDir;
            out[iFileOrder[1]] = domain / lenInFastDir;
            i = out[0];
            j = out[1];
            k = 0;
        }
        /* This is only true if blocks come in ZYX order, which is normally
        true, but not guaranteed.
        k = domain % iNumBlocks[2];
        j = (domain / iNumBlocks[2]) % iNumBlocks[1];
        i = domain / (iNumBlocks[1] * iNumBlocks[2]);
        */
    }
    else
    {
        if (domainMap[domain*3] == -1)
        {
            char filename[512];
            string tok;
            double blockOrigin[3];
            int ii;
            
            sprintf(filename, gridTemplate.c_str(), domain);
            ifstream  f(filename);
            if (!f.good())
            {
                EXCEPTION1(InvalidFilesException, filename);
            }
            
            f >> tok;
            if (tok != "origin:")
            {
                EXCEPTION1(InvalidFilesException, filename);        
            }
            blockOrigin[0] = GetFortranDouble( f );
            blockOrigin[1] = GetFortranDouble( f );
            blockOrigin[2] = GetFortranDouble( f );
            f.close();
    
            if (dim == 3)
            {
                for (ii = 0 ; ii < 3 ; ii++)
                {
                    double dIndex = (blockOrigin[ii] - fOrigin[ii]) / 
                                    (fStride[ii]*iBlockSize[ii]);
                    domainMap[domain*3 + ii] = (int)floor(0.5 + dIndex);
                }
            }
            else
            {
                if (flatDim == 0)
                {
                    blockOrigin[0] = blockOrigin[1];
                    blockOrigin[1] = blockOrigin[2];
                }
                else if (flatDim == 1)
                {
                    blockOrigin[1] = blockOrigin[2];
                }
                for (ii = 0 ; ii < 2 ; ii++)
                {
                    double dIndex = (blockOrigin[ii] - fOrigin[ii]) / 
                                    (fStride[ii]*iBlockSize[ii]);
                    domainMap[domain*3 + ii] = (int)floor(0.5 + dIndex);
                }
                domainMap[domain*3 + 2] = 0;
            }
        }
        i = domainMap[domain*3 + 0];
        j = domainMap[domain*3 + 1];
        k = domainMap[domain*3 + 2];
    }
}


// ****************************************************************************
//  Method: avtMirandaFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: dbremer -- generated by xml2avt
//  Creation:   Tue Jan 23 17:00:13 PST 2007
//
// ****************************************************************************

vtkDataSet *
avtMirandaFileFormat::GetMesh(int /*timestate*/, int domain, const char * /*meshname*/)
{
    vtkRectilinearGrid *rgrid = vtkRectilinearGrid::New();
    if (dim == 3)
    {
        int tmp[3] = { iBlockSize[0]+1, iBlockSize[1]+1, iBlockSize[2]+1 };
        rgrid->SetDimensions(tmp);
    }
    else
    {
        int tmp[3] = { iBlockSize[0]+1, iBlockSize[1]+1, 1 };
        rgrid->SetDimensions(tmp);
    }
    
    int ii;    
    int iBlockX, iBlockY, iBlockZ;
    DomainToIJK( domain, iBlockX, iBlockY, iBlockZ );

    vtkFloatArray *x = vtkFloatArray::New();
    vtkFloatArray *y = vtkFloatArray::New();
    vtkFloatArray *z = vtkFloatArray::New();

    x->SetNumberOfTuples(iBlockSize[0]+1);
    y->SetNumberOfTuples(iBlockSize[1]+1);
    if (dim == 3)
        z->SetNumberOfTuples(iBlockSize[2]+1);
    else
        z->SetNumberOfTuples(1);

    for (ii = 0 ; ii < iBlockSize[0]+1 ; ii++)
        x->SetTuple1(ii, fOrigin[0] + (iBlockX*iBlockSize[0]+ii-0.5)*fStride[0]);

    for (ii = 0 ; ii < iBlockSize[1]+1 ; ii++)
        y->SetTuple1(ii, fOrigin[1] + (iBlockY*iBlockSize[1]+ii-0.5)*fStride[1]);

    if (dim == 3)
        for (ii = 0 ; ii < iBlockSize[2]+1 ; ii++)
            z->SetTuple1(ii, fOrigin[2] + (iBlockZ*iBlockSize[2]+ii-0.5)*fStride[2]);
    else
        z->SetTuple1(0, 0.);

    rgrid->SetXCoordinates(x);
    rgrid->SetYCoordinates(y);
    rgrid->SetZCoordinates(z);

    x->Delete();
    y->Delete();
    z->Delete();

    vtkIntArray *arr = vtkIntArray::New();
    arr->SetNumberOfTuples(3);
    arr->SetValue(0, iBlockX*iBlockSize[0]+1);
    arr->SetValue(1, iBlockY*iBlockSize[1]+1);
    arr->SetValue(2, iBlockZ*iBlockSize[2]+1);
    arr->SetName("base_index");
    rgrid->GetFieldData()->AddArray(arr);
    arr->Delete();

    return rgrid;
}



static void
ByteSwap32(void *val)
{
    char *v = (char *)val;
    char tmp;
    tmp = v[0]; v[0] = v[3]; v[3] = tmp;
    tmp = v[1]; v[1] = v[2]; v[2] = tmp;
}


// ****************************************************************************
//  Method: avtMirandaFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: dbremer -- generated by xml2avt
//  Creation:   Tue Jan 23 17:00:13 PST 2007
//
//  Modifications:
//    Dave Bremer, Wed Feb 21 17:54:33 PST 2007
//    The components of a material set can be queried here, just like other 
//    scalars.  Those scalars are returned unmodified, whereas a material set
//    is cleaned first.
//
//    Dave Bremer, Mon Mar 19 19:04:11 PDT 2007
//    Fix fopen on windows.  Add error checking.
// ****************************************************************************

vtkDataArray *
avtMirandaFileFormat::GetVar(int timestate, int domain, const char *varname)
{
    int ii, iVar = -1, nPrevComp = 0;
    
    for (ii = 0 ; ii < aVarNames.size() ; ii++) 
    {
        if (aVarNames[ii] == varname)
        {
            iVar = ii;
            break;
        }
        nPrevComp += aVarNumComps[ii];
    }
    // Search the materials if varname is not a regular variable
    if (iVar == -1)
    {
        for (ii = 0 ; ii < aMatNames.size() ; ii++) 
        {
            if (aMatNames[ii] == varname)
            {
                iVar = ii;
                break;
            }
            nPrevComp += 1;
        }
    }
    if (iVar == -1)
    {
        EXCEPTION1(InvalidVariableException, varname);
    }
    
    int nTuples = iBlockSize[0]*iBlockSize[1]*iBlockSize[2];
    vtkFloatArray *var = vtkFloatArray::New();
    var->SetNumberOfTuples( nTuples );

    char filename[512];
    sprintf(filename, fileTemplate.c_str(), aCycles[timestate], domain);

    FILE *fd = fopen(filename, "rb");
    if (fd == NULL)
        EXCEPTION1(InvalidFilesException, filename);

    int err = fseek(fd, nPrevComp*(nTuples*sizeof(float) + 2*sizeof(int32_t)), SEEK_SET);
    if (err)
        EXCEPTION1(InvalidFilesException, filename);

    int header, nItemsRead;
    fread(&header, sizeof(int32_t), 1, fd);
    nItemsRead = fread(var->GetVoidPointer(0), sizeof(float), nTuples, fd);
    if (nItemsRead != nTuples)
        EXCEPTION1(InvalidFilesException, filename);

    fclose(fd);
    
    if (header != nTuples*sizeof(float))
    {
        //If this is true, we need to swap endian
        ByteSwap32(&header);
        if (header != nTuples*sizeof(float))
            EXCEPTION1(InvalidFilesException, filename);
        
        float *f = (float *)var->GetVoidPointer(0);
        for (ii = 0 ; ii < nTuples ; ii++)
        {
            ByteSwap32(f + ii);
        }
    }
    return var;
}


// ****************************************************************************
//  Method: avtMirandaFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: dbremer -- generated by xml2avt
//  Creation:   Tue Jan 23 17:00:13 PST 2007
//
//  Modifications:
//    Dave Bremer, Wed Feb 21 19:54:33 PST 2007
//    Patched for data that is treated as 2D.  For 3-component vectors, 
//    the two non-zero components are placed in the first two output components.
//
//    Dave Bremer, Mon Mar 19 19:04:11 PDT 2007
//    Fix fopen on windows.  Add error checking.
// ****************************************************************************

vtkDataArray *
avtMirandaFileFormat::GetVectorVar(int timestate, int domain, const char *varname)
{
    int ii, jj, iVar = -1, nPrevComp = 0;
    
    for (ii = 0 ; ii < aVarNames.size() ; ii++) 
    {
        if (aVarNames[ii] == varname)
        {
            iVar = ii;
            break;
        }
        nPrevComp += aVarNumComps[ii];
    }
    if (iVar == -1 || aVarNumComps[ii] <= 1)
    {
        EXCEPTION1(InvalidVariableException, varname);
    }
    
    bool bFlattenVec = false;
    if (aVarNumComps[iVar] == 3 && dim == 2 && 
        aVarMinMax[iVar][flatDim*2] == 0.0f &&
        aVarMinMax[iVar][flatDim*2+1] == 0.0f)
    {
        bFlattenVec = true;
    }
    
    int nTuples = iBlockSize[0]*iBlockSize[1]*iBlockSize[2];
    vtkFloatArray *var = vtkFloatArray::New();
    var->SetNumberOfComponents( aVarNumComps[ii] );
    var->SetNumberOfTuples( nTuples );

    char filename[512];
    sprintf(filename, fileTemplate.c_str(), aCycles[timestate], domain);
    
    FILE *fd = fopen(filename, "rb");
    if (fd == NULL)
        EXCEPTION1(InvalidFilesException, filename);
    int err = fseek(fd, nPrevComp*(nTuples*sizeof(float) + 2*sizeof(int32_t)), SEEK_SET);
    if (err)
        EXCEPTION1(InvalidFilesException, filename);

    float *tmp = new float[nTuples];
    
    int nComps = aVarNumComps[ii];
    int iCurrComp = 0;
    for (ii = 0 ; ii < nComps ; ii++)
    {
        if (bFlattenVec && ii==flatDim)
        {
            fseek(fd, nTuples*sizeof(float) + 2*sizeof(int32_t), SEEK_CUR);
            continue;
        }
    
        int32_t header, footer, nItemsRead;
        fread(&header, sizeof(int32_t), 1, fd);
        nItemsRead = fread(tmp, sizeof(float), nTuples, fd);
        fread(&footer, sizeof(int32_t), 1, fd);
        if (nItemsRead != nTuples)
            EXCEPTION1(InvalidFilesException, filename);

        if (header != nTuples*sizeof(float))
        {
            //If this is true, we need to swap endian
            ByteSwap32(&header);
            if (header != nTuples*sizeof(float))
            {
                delete[] tmp;
                EXCEPTION1(InvalidFilesException, filename);
            }

            float *f = tmp;
            for (jj = 0 ; jj < nTuples ; jj++)
            {
                ByteSwap32(f + jj);
            }
        }
        for (jj = 0 ; jj < nTuples ; jj++)
        {
            var->SetComponent(jj, iCurrComp, tmp[jj]);
        }
        iCurrComp++;
    }
    fclose(fd);
    delete[] tmp;

    // I return a 3D vector here with the last component set to 0,
    // because code downstream prefers it this way.
    if (bFlattenVec)
    {
        for (jj = 0 ; jj < nTuples ; jj++)
        {
            var->SetComponent(jj, 2, 0.0f);
        }
    }
    
    return var;
}


// ****************************************************************************
//  Method: avtMirandaFileFormat::GetAuxiliaryData
//
//  Purpose:
//      Gets auxiliary data about the file format.
//
//  Programmer: Dave Bremer
//  Creation:   Jan 30, 2007
//
//  Modifications:
//    Dave Bremer, Wed Feb 21 19:54:33 PST 2007
//    Material data gets cleaned before it is returned.
//
//    Dave Bremer, Mon Mar 19 19:04:11 PDT 2007
//    Fix fopen on windows.  Add error checking.
//
// ****************************************************************************
void *
avtMirandaFileFormat::GetAuxiliaryData(const char *var, int timestate,  
                                       int domain, const char *type, void *args,
                                       DestructorFunction &df)
{
    void *rv = NULL;
    int   nbricks = iNumBlocks[0] * iNumBlocks[1] * iNumBlocks[2];
    int   ii, jj;
    
    if (strcmp(type, AUXILIARY_DATA_SPATIAL_EXTENTS) == 0)
    {
        if (strcmp(var, "mesh") != 0)
        {
            EXCEPTION1(InvalidVariableException, var);
        }
        avtIntervalTree *itree = new avtIntervalTree(nbricks, 3);
        for (ii = 0 ; ii < nbricks ; ii++)
        {
            int iBlockX, iBlockY, iBlockZ;
            DomainToIJK( ii, iBlockX, iBlockY, iBlockZ );

            //
            // Establish what the range is of this dataset.
            //
            double bounds[6];
            bounds[0] = fOrigin[0] - fStride[0]/2.0 + fStride[0]*iBlockSize[0]*iBlockX;
            bounds[1] = fOrigin[0] - fStride[0]/2.0 + fStride[0]*iBlockSize[0]*(iBlockX+1);
            bounds[2] = fOrigin[1] - fStride[1]/2.0 + fStride[1]*iBlockSize[1]*iBlockY;
            bounds[3] = fOrigin[1] - fStride[1]/2.0 + fStride[1]*iBlockSize[1]*(iBlockY+1);
            bounds[4] = fOrigin[2] - fStride[2]/2.0 + fStride[2]*iBlockSize[2]*iBlockZ;
            bounds[5] = fOrigin[2] - fStride[2]/2.0 + fStride[2]*iBlockSize[2]*(iBlockZ+1);
            itree->AddElement(ii, bounds);
        }
        itree->Calculate(true);

        rv = (void *) itree;
        df = avtIntervalTree::Destruct;
    }
    else if (strcmp(type, AUXILIARY_DATA_MATERIAL) == 0)
    {
        int     nMats    = aMatNames.size();
        int    *matNums  = new int[nMats];
        char  **matNames = new char*[nMats];
        float **volFracs = new float*[nMats];
        char    domainName[32];

        sprintf(domainName, "domain %d", domain);
        
        int iFirstComp = 0;
        for (ii = 0 ; ii < aVarNumComps.size() ; ii++)
            iFirstComp += aVarNumComps[ii];
    
        int nTuples = iBlockSize[0]*iBlockSize[1]*iBlockSize[2];
        char filename[512];
        sprintf(filename, fileTemplate.c_str(), aCycles[timestate], domain);
    
        FILE *fd = fopen(filename, "rb");
        if (fd == NULL)
            EXCEPTION1(InvalidFilesException, filename);
        int err = fseek(fd, iFirstComp*(nTuples*sizeof(float) + 2*sizeof(int32_t)), SEEK_SET);
        if (err)
            EXCEPTION1(InvalidFilesException, filename);

        for (ii = 0 ; ii < nMats ; ii++)
        {
            matNums[ii] = ii;
            matNames[ii] = strdup( aMatNames[ii].c_str() );
        
            volFracs[ii] = new float[nTuples];
            
            int32_t header, footer;
            fread(&header, sizeof(int32_t), 1, fd);
            int nItemsRead = fread(volFracs[ii], sizeof(float), nTuples, fd);
            fread(&footer, sizeof(int32_t), 1, fd);
            if (nItemsRead != nTuples)
                EXCEPTION1(InvalidFilesException, filename);

            if (header != nTuples*sizeof(float))
            {
                //If this is true, we need to swap endian
                ByteSwap32(&header);
                if (header != nTuples*sizeof(float))
                {
                    EXCEPTION1(InvalidFilesException, filename);
                }

                float *f = volFracs[ii];
                for (jj = 0 ; jj < nTuples ; jj++)
                {
                    ByteSwap32(f + jj);
                }
            }
        }
        
        /* For debugging, I'm going to clean up the data so that it
           can be processed.  I have zones with material fractions
           that range from -epsilon to 1+epsilon.  DJB */
        
        for (ii = 0 ; ii < nTuples ; ii++)
        {
            double sum = 0.00f;
            for (jj = 0 ; jj < nMats ; jj++)
            {
                if (volFracs[jj][ii] > 1.0 - 1e-5)
                    volFracs[jj][ii] = 1.0f;
                
                if (volFracs[jj][ii] < 1e-5)   
                    volFracs[jj][ii] = 0.0f;
                
                sum += volFracs[jj][ii];
            }
            for (jj = 0 ; jj < nMats ; jj++)
            {
                volFracs[jj][ii] /= sum;
            }
        }
        
        rv = (void *)new avtMaterial( nMats,
                                      matNums,
                                      matNames,
                                      dim, 
                                      iBlockSize,
                                      0 /*major_order*/,
                                      volFracs,
                                      domainName);
        df = avtMaterial::Destruct;
        
        fclose(fd);
        for (ii = 0 ; ii < nMats ; ii++)
        {
            free(matNames[ii]);
            delete[] volFracs[ii];
        }
        delete[] matNums;
        delete[] matNames;
        delete[] volFracs;
    }

    return rv;
}






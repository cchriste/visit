/*****************************************************************************
*
* Copyright (c) 2000 - 2011, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtGeqdskFileFormat.C                          //
// ************************************************************************* //

#include <avtGeqdskFileFormat.h>

#include <string>

#include <vtkFloatArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>
#include <vtkCellType.h>

#include <vtkPointData.h>
#include <vtkVisItUtility.h>

#include <avtDatabaseMetaData.h>
#include <avtCurveMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>
#include <InvalidFilesException.h>

using     std::string;


// ****************************************************************************
//  Method: avtGeqdskFileFormat constructor
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Thu Aug 11 15:17:56 PST 2011
//
// ****************************************************************************

avtGeqdskFileFormat::avtGeqdskFileFormat(const char *filename, DBOptionsAttributes *readOpts)
  : avtMTSDFileFormat(&filename, 1)
{
    if (filename == "")
        return;

    std::ifstream f;
    f.open(filename);

    char tmp[1024];
    
    // Read the first line: case information, dummy var, and nw, and nh
    char id[32], date[32], run[32], time[32];
    int idum;
    float xdum;

    f.getline(tmp, 1024);

    if(!f.good())
    {
      EXCEPTION1( InvalidFilesException, "Read past end of file" );
    }

    int n = sscanf( tmp, "%s %s %s %s  %d  %d %d",
                    id, date, run, time, &idum, &nw, &nh );

    if( n != 7 )
    {
      EXCEPTION1( InvalidVariableException,
                  "Can not read number of horizontal R and/or vertical Z grid points." );
    }

    int   curveCycle = atoi( time );
    float curveTime  = atof( time ) * 1.0e-3;

    // Read the second line ...
    f.getline(tmp, 1024);
    if(!f.good())
    {
      EXCEPTION1( InvalidFilesException, "Read past end of file" );
    }

    n = sscanf( tmp, "%f %f %f %f %f",
                &rdim, &zdim, &rcentr, &rleft, &zmid );

    if( n != 5 )
    {
      EXCEPTION1( InvalidVariableException,
                  "Can not read second line." );
    }

    // Read the third line ...
    f.getline(tmp, 1024);
    if(!f.good())
    {
      EXCEPTION1( InvalidFilesException, "Read past end of file" );
    }

    n = sscanf( tmp, "%f %f %f %f %f",
                &rmaxis, &zmaxis, &simag, &sibry, &bcentr );

    if( n != 5 )
    {
      EXCEPTION1( InvalidVariableException,
                  "Can not read third line." );
    }

    // Read the forth line ...
    f.getline(tmp, 1024);
    if(!f.good())
    {
      EXCEPTION1( InvalidFilesException, "Read past end of file" );
    }

    n = sscanf( tmp, "%f %f %f %f %f",
                &current, &simag, &xdum, &rmaxis, &xdum );

    if( n != 5 )
    {
      EXCEPTION1( InvalidVariableException,
                  "Can not read forth line." );
    }

    // Read the fifth line ...
    f.getline(tmp, 1024);
    if(!f.good())
    {
      EXCEPTION1( InvalidFilesException, "Read past end of file" );
    }

    n = sscanf( tmp, "%f %f %f %f %f",
                &zmaxis, &xdum, &sibry, &xdum, &xdum );

    if( n != 5 )
    {
      EXCEPTION1( InvalidVariableException,
                  "Can not read fifth line." );
    }

    // Read fpol - Poloidal current function in m-T, F = RBT on flux grid
    ReadData( f, &fpol, nw );

    // Read pres - Plasma pressure in nt/m2 on uniform flux grid
    ReadData( f, &pres, nw );

    // Read ffprim - FF’(ψ) in (mT)2 / (Weber/rad) on uniform flux grid
    ReadData( f, &ffprim, nw );

    // Read pprime - P’(ψ) in (nt /m2) / (Weber/rad) on uniform flux grid
    ReadData( f, &pprime, nw );

    // Read psizr - Poloidal flux in Weber/rad on the rectangular grid points
    ReadData( f, &psirz, nw*nh );

    // Read qpsi - q values on uniform flux grid from axis to boundary
    ReadData( f, &qpsi, nw );

    // Read the number of boundary and/or limiter points.
    f.getline(tmp, 1024);
    if(!f.good())
    {
      EXCEPTION1( InvalidFilesException, "Read past end of file" );
    }

    n = sscanf( tmp, "%d %d", &nbbbs, &limitr );

    if( n != 2 )
    {
      EXCEPTION1( InvalidVariableException,
                  "Can not read the number of boundary and/or limiter points." );
    }

    // Read RZ of boundary points in meter. Note the data is written
    // merged together so read together.
    ReadData( f, &rzbbbs, 2*nbbbs );

    // Read RZ of surrounding limiter contour in meter. Note the data
    // is written merged together so read together.
    ReadData( f, &rzlim, 2*limitr );
}

// ****************************************************************************
//  Method: avtEMSTDFileFormat::ReadData
//
//  Purpose:
//      Reads the data
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Thu Aug 11 15:17:56 PST 2011
//
// ****************************************************************************

void
avtGeqdskFileFormat::ReadData( std::ifstream &f, float **var, int nVar )
{
    // Read fpol - Poloidal current function in m-T, F = RBT on flux grid
  *var = new float[nVar];

  float *varPtr = *var;

  int cc = 0;

  while(f.good())
  {
    char tmp[1024];
    f.getline(tmp, 1024);
    if(!f.good())
    {
      EXCEPTION1( InvalidFilesException, "Read past end of file" );
    }

    float fdum[5];
    int n, count = (cc > nVar-5 ? nVar%5 : 5 );

    if( count == 5 )
      n = sscanf( tmp, "%f %f %f %f %f",
                  &fdum[0], &fdum[1], &fdum[2], &fdum[3], &fdum[4] );
    
    else if( count == 4 )
      n = sscanf( tmp, "%f %f %f %f",
                  &fdum[0], &fdum[1], &fdum[2], &fdum[3] );
    
    else if( count == 3 )
      n = sscanf( tmp, "%f %f %f",
                  &fdum[0], &fdum[1], &fdum[2] );
    
    else if( count == 2 )
      n = sscanf( tmp, "%f %f",
                  &fdum[0], &fdum[1] );
    
    else if( count == 1 )
      n = sscanf( tmp, "%f",
                  &fdum[0] );
    
    if( n != count )
    {
      EXCEPTION1( InvalidVariableException, "Can not read variable." );
    }

    for( int i=0; i<count; ++i )
      *varPtr++ = fdum[i];

    cc += count;

    if( cc == nVar )
    {
      return;
    }
  }

  EXCEPTION1( InvalidFilesException, "Read past end of file" );
}


// ****************************************************************************
//  Method: avtEMSTDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Thu Aug 11 15:17:56 PST 2011
//
// ****************************************************************************

int
avtGeqdskFileFormat::GetNTimesteps(void)
{
    return 1;
}


// ****************************************************************************
//  Method: avtGeqdskFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Thu Aug 11 15:17:56 PST 2011
//
// ****************************************************************************

void
avtGeqdskFileFormat::FreeUpResources(void)
{
}


// ****************************************************************************
//  Method: avtGeqdskFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Thu Aug 11 15:17:56 PST 2011
//
// ****************************************************************************

void
avtGeqdskFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{

    avtMeshMetaData *mmd;
    avtMeshType mt = AVT_RECTILINEAR_MESH;
    int nblocks = 1;
    int block_origin = 0;
    int cell_origin = 0;
    int group_origin = 0;
    int spatial_dimension = 3;
    int topological_dimension = 2;
    double *extents = NULL;
    int bounds[3];

    // Original meshes for the user to see.
    bounds[0] = nw;
    bounds[1] = nh;
    bounds[2] = 1;

    AddMeshToMetaData( md, "rectangular",
                       mt, extents, nblocks, block_origin,
                       spatial_dimension, topological_dimension, bounds );


    // Boundary mesh for the user to see.
    bounds[0] = nbbbs;
    bounds[1] = 1;
    bounds[2] = 1;

    mt = AVT_UNSTRUCTURED_MESH;
    topological_dimension = 1;

    AddMeshToMetaData( md, "boundary",
                       mt, extents, nblocks, block_origin,
                       spatial_dimension, topological_dimension, bounds );


    // Limiter mesh for the user to see.
    bounds[0] = limitr;
    bounds[1] = 1;
    bounds[2] = 1;

    mt = AVT_UNSTRUCTURED_MESH;
    topological_dimension = 1;

    AddMeshToMetaData( md, "limiter",
                       mt, extents, nblocks, block_origin,
                       spatial_dimension, topological_dimension, bounds );



    string varname = "psirz";
    string meshname = string("rectangular");
    AddScalarVarToMetaData( md, varname, meshname, AVT_NODECENT );


    avtCurveMetaData *curve = new avtCurveMetaData;
    curve->name = "fpol";
    curve->xLabel = string("Poloidal flux");
    curve->xUnits = std::string("weber/rad");
    curve->yLabel = string("Poloidal current");
    curve->yUnits = std::string("m-T");
//     curve->hasSpatialExtents = true;
//     curve->minSpatialExtents = spatialExtents[i*2];
//     curve->maxSpatialExtents = spatialExtents[i*2+1];
//     curve->hasDataExtents = true;
//     curve->minDataExtents = dataExtents[i*2];
//     curve->maxDataExtents = dataExtents[i*2+1];
    md->Add(curve);


    curve = new avtCurveMetaData;
    curve->name = "pres";
    curve->xLabel = string("Poloidal flux");
    curve->xUnits = std::string("weber/rad");
    curve->yLabel = string("Plasma pressure");
    curve->yUnits = std::string("nt/m^2");
//     curve->hasSpatialExtents = true;
//     curve->minSpatialExtents = spatialExtents[i*2];
//     curve->maxSpatialExtents = spatialExtents[i*2+1];
//     curve->hasDataExtents = true;
//     curve->minDataExtents = dataExtents[i*2];
//     curve->maxDataExtents = dataExtents[i*2+1];
    md->Add(curve);


    curve = new avtCurveMetaData;
    curve->name = "ffprim";
    curve->xLabel = string("Poloidal flux");
    curve->xUnits = std::string("weber/rad");
    curve->yLabel = string("FF'(ψ)");
    curve->yUnits = std::string("(mT)^2/(weber/rad)");
//     curve->hasSpatialExtents = true;
//     curve->minSpatialExtents = spatialExtents[i*2];
//     curve->maxSpatialExtents = spatialExtents[i*2+1];
//     curve->hasDataExtents = true;
//     curve->minDataExtents = dataExtents[i*2];
//     curve->maxDataExtents = dataExtents[i*2+1];
    md->Add(curve);


    curve = new avtCurveMetaData;
    curve->name = "pprime";
    curve->xLabel = string("Poloidal flux");
    curve->xUnits = std::string("weber/rad");
    curve->yLabel = string("P'(ψ)");
    curve->yUnits = std::string("(nt/m^2)/(weber/rad)");
//     curve->hasSpatialExtents = true;
//     curve->minSpatialExtents = spatialExtents[i*2];
//     curve->maxSpatialExtents = spatialExtents[i*2+1];
//     curve->hasDataExtents = true;
//     curve->minDataExtents = dataExtents[i*2];
//     curve->maxDataExtents = dataExtents[i*2+1];
    md->Add(curve);


    curve = new avtCurveMetaData;
    curve->name = "qpsi";
    curve->xLabel = string("Poloidal flux");
    curve->xUnits = std::string("weber/rad");
    curve->yLabel = string("Safety Factor");
    curve->yUnits = std::string("");
//     curve->hasSpatialExtents = true;
//     curve->minSpatialExtents = spatialExtents[i*2];
//     curve->maxSpatialExtents = spatialExtents[i*2+1];
//     curve->hasDataExtents = true;
//     curve->minDataExtents = dataExtents[i*2];
//     curve->maxDataExtents = dataExtents[i*2+1];
    md->Add(curve);
}


// ****************************************************************************
//  Method: avtGeqdskFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Thu Aug 11 15:17:56 PST 2011
//
// ****************************************************************************

vtkDataSet *
avtGeqdskFileFormat::GetMesh(int timestate, const char *meshname)
{
  if( string(meshname) == string("rectangular") )
  {
    float dr = rdim / (float) (nw-1);
    float dz = zdim / (float) (nh-1);

    float rmin = rleft;
    float zmin = zmid - zdim / 2.0;

    vtkPoints* vpoints = vtkPoints::New();
    vpoints->SetDataTypeToFloat();
    vpoints->SetNumberOfPoints(nw*nh);

    for( int i=0; i<nw; ++i )
    {
      float r = rmin + (float) i * dr;

      for( int j=0; j<nh; ++j )
      {
        float z = zmin + (float) j * dz;

        vpoints->SetPoint(i*nh+j, r, 0, z );
      }
    }

    int dims[3] = {nw,1,nh};

    vtkStructuredGrid* sgrid = vtkStructuredGrid::New();
    sgrid->SetDimensions(&(dims[0]));
    sgrid->SetPoints(vpoints);

    vpoints->Delete();

    return sgrid;
  }

  else if( string(meshname) == string("boundary") ||
           string(meshname) == string("limiter") )
  {
    float *rz;
    int numNodes;

    if( string(meshname) == string("boundary") )
    {
      rz = rzbbbs;
      numNodes = nbbbs;
    }
    else if( string(meshname) == string("limiter") )
    {
      rz = rzlim;
      numNodes = limitr;
    }

    vtkUnstructuredGrid* ugridPtr = vtkUnstructuredGrid::New();

    vtkPoints* vpoints = vtkPoints::New();
    vpoints->SetDataTypeToFloat();
    vpoints->SetNumberOfPoints(nw*nh);

    ugridPtr->SetPoints(vpoints);

    for (size_t i=0; i<numNodes; ++i)
      vpoints->SetPoint(i, rz[i*2], 0, rz[i*2+1] );

    ugridPtr->Allocate(numNodes-1);

    unsigned int cellVerts = 2; // cell's connected node indices
    std::vector<vtkIdType> verts(cellVerts);

    for (size_t i=0; i<numNodes-1; ++i)
    {
      verts[0] = i;
      verts[1] = i + 1;

      ugridPtr->InsertNextCell(VTK_LINE, cellVerts, &verts[0]);
    }

    return ugridPtr;
  }

  else if( string(meshname) == string("fpol") ||
           string(meshname) == string("pres") ||
           string(meshname) == string("ffprim") ||
           string(meshname) == string("pprime") ||
           string(meshname) == string("qpsi") )
  {
    float *var;

    if( string(meshname) == string("fpol") )
      var = fpol;
    else if( string(meshname) == string("pres") )
      var = pres;
    else if( string(meshname) == string("ffprim") )
      var = ffprim;
    else if( string(meshname) == string("pprime") )
      var = pprime;
    else if( string(meshname) == string("qpsi") )
      var = qpsi;

    // Create 1-D RectilinearGrid
    vtkFloatArray* vals = vtkFloatArray::New();
    vals->SetNumberOfComponents(1);
    vals->SetNumberOfTuples(nw);
    vals->SetName(meshname);

    vtkRectilinearGrid* rg = vtkVisItUtility::Create1DRGrid(nw, VTK_FLOAT);
    rg->GetPointData()->SetScalars(vals);

    vtkFloatArray* xc = vtkFloatArray::SafeDownCast(rg->GetXCoordinates());

    float xmin = simag;
    float xmax = sibry;
    float dx = (xmax - xmin) / (float) (nw-1);

    for (int i=0; i<nw; i++) {
      xc->SetValue(i, xmin + (float) i * dx);
      vals->SetValue(i, var[i]);
    }

    // Done, so clean up memory and return
    vals->Delete();

    return rg;

  }
  else
    return NULL;
}


// ****************************************************************************
//  Method: avtGeqdskFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Thu Aug 11 15:17:56 PST 2011
//
// ****************************************************************************

vtkDataArray *
avtGeqdskFileFormat::GetVar(int timestate, const char *varname)
{
  if( std::string( varname ) == std::string( "psirz" ) )
  {
    vtkDataArray *rv = vtkFloatArray::New();

    rv->SetNumberOfTuples(nw*nh);

    for (size_t i = 0; i<nw*nh; ++i)
      rv->SetTuple(i, &psirz[i]);

    return rv;
  }
  else
    return NULL;
}


// ****************************************************************************
//  Method: avtGeqdskFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Thu Aug 11 15:17:56 PST 2011
//
// ****************************************************************************

vtkDataArray *
avtGeqdskFileFormat::GetVectorVar(int timestate, const char *varname)
{
    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.
    //
    // EXCEPTION1(InvalidVariableException, varname);
    //

    //
    // If you do have a vector variable, here is some code that may be helpful.
    //
    // int ncomps = YYY;  // This is the rank of the vector - typically 2 or 3.
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // int ucomps = (ncomps == 2 ? 3 : ncomps);
    // rv->SetNumberOfComponents(ucomps);
    // rv->SetNumberOfTuples(ntuples);
    // float *one_entry = new float[ucomps];
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      int j;
    //      for (j = 0 ; j < ncomps ; j++)
    //           one_entry[j] = ...
    //      for (j = ncomps ; j < ucomps ; j++)
    //           one_entry[j] = 0.;
    //      rv->SetTuple(i, one_entry); 
    // }
    //
    // delete [] one_entry;
    // return rv;
    //
}

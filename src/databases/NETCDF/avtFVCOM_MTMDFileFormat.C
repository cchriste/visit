/*****************************************************************************
*
* Copyright (c) 2000 - 2006, The Regents of the University of California
* Produced at the Lawrence Livermore National Laboratory
* All rights reserved.
*
* This file is part of VisIt. For details, see http://www.llnl.gov/visit/. The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or materials provided with the distribution.
*  - Neither the name of the UC/LLNL nor  the names of its contributors may be
*    used to  endorse or  promote products derived from  this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED.  IN  NO  EVENT  SHALL  THE  REGENTS  OF  THE  UNIVERSITY OF
* CALIFORNIA, THE U.S.  DEPARTMENT  OF  ENERGY OR CONTRIBUTORS BE  LIABLE  FOR
* ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtFVCOMFileFormat.C                           //
// ************************************************************************* //

#include <avtFVCOM_MTMDFileFormat.h>

#include <string>

#include <vtkCellData.h>
#include <vtkFloatArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnsignedCharArray.h>
#include <vtkUnstructuredGrid.h>

#include <avtDatabaseMetaData.h>
#include <avtGhostData.h>
#include <avtIntervalTree.h>

#include <Expression.h>

#include <InvalidFilesException.h>
#include <InvalidVariableException.h>
#include <DebugStream.h>
#include <visit-config.h>
#include <snprintf.h>

#include <NETCDFFileObject.h>
#include <avtFVCOMReader.h>
#include <avtMaterial.h>
#include <netcdf.h>

using     std::string;


// ****************************************************************************
// Method: avtFVCOM_MTMDFileFormat::Identify
//
// Purpose:
//   This method checks to see if the file is an FVCOM Master file.
//
// Arguments:
//   fileObject : The file to check.
//
// Returns:    True if the file is a particle file; False otherwise.
//
// Note:
//
// Programmer: David Stuebe
// Creation:   Thu May 4 16:18:57 PST 2006
//
//     Edited for mtmd 
//
// Modifications:
//
// ****************************************************************************

bool
avtFVCOM_MTMDFileFormat::Identify(NETCDFFileObject *fileObject)
{
    bool isFVCOM = false;

    // Simple statement to identify FVCOM files:
    // Do not change source statement in mod_ncdio !!!

    std::string source;
    if(fileObject->ReadStringAttribute("source", source))
    {
        isFVCOM = strncmp("MDFVCOM",source.c_str(),7)==0;
    }

    return isFVCOM;
}



// ****************************************************************************
// Method: avtFVCOM_MTMDFileFormat::CreateInterface
//
// Purpose:
//   Creates the file format interface for this reader.
//
// Programmer: David Stuebe
// Creation:   Thu May 4 16:18:57 PST 2006
//
// Modifications:
//
// ****************************************************************************


avtFileFormatInterface *
avtFVCOM_MTMDFileFormat::CreateInterface(NETCDFFileObject *f,
    const char *const *list, int nList, int nBlock)
{
  
    return new avtMTMDFileFormatInterface(new avtFVCOM_MTMDFileFormat(list[0],f));
}


// ****************************************************************************
//  Method: avtFVCOM_MTMD constructor
//
//  Programmer: dstuebe -- generated by xml2avt
//  Creation:   Wed Aug 16 16:40:22 PST 2006
//
// ****************************************************************************


avtFVCOM_MTMDFileFormat::avtFVCOM_MTMDFileFormat(const char *filename)
  : avtMTMDFileFormat(filename)
{
    fileObject = new NETCDFFileObject(filename); 
    init = false;
}

avtFVCOM_MTMDFileFormat::avtFVCOM_MTMDFileFormat(const char *filename, 
                         NETCDFFileObject *f)
  : avtMTMDFileFormat(filename)
{
    init = false;
    fileObject = f; 
}

// ****************************************************************************
//  Method: avtFVCOM_MTMD destructor
//
//  Programmer: David Stuebe
//  Creation:   Wed May 31 15:50:52 PST 2006
//
// ****************************************************************************

avtFVCOM_MTMDFileFormat::~avtFVCOM_MTMDFileFormat()
{
    delete fileObject;
}

// ****************************************************************************
//  Method: avtFVCOM_MTMDFileFormat::Init()
//
//  Purpose:  Open files listed in the master file and put then in domainFiles
//
//  Programmer: dstuebe -- generated by xml2avt
//  Creation:   Wed Aug 16 16:40:22 PST 2006
//
//  Modifications:
//    Brad Whitlock, Tue Sep 5 11:59:21 PDT 2006
//    Added code to use the path to the master file to override the paths
//    stored in the master file to support moving the data to other machines.
//
// ****************************************************************************


void
avtFVCOM_MTMDFileFormat::Init()
{
    if(init) return;
    
    const char *mName = "avtFVCOM_MTMDFileFormat::Init(): ";
    debug4 << mName << endl;

    int ncid;
    int status;
    ncid=fileObject->GetFileHandle(); 

    int dom;
    int nfnames_id; 
    status = nc_inq_dimid(ncid, "nfnames", &nfnames_id);
    if (status != NC_NOERR) fileObject-> HandleError(status);
    
    status = nc_inq_dimlen(ncid, nfnames_id, &nfnames);
    if (status != NC_NOERR) fileObject-> HandleError(status);


    int ndoms_id;
    status = nc_inq_dimid(ncid, "ndoms", &ndoms_id);
    if (status != NC_NOERR) fileObject-> HandleError(status);
    
    status = nc_inq_dimlen(ncid, ndoms_id, &ndoms);
    if (status != NC_NOERR) fileObject-> HandleError(status);

    int ntwo_id;
    status = nc_inq_dimid(ncid, "ntwo", &ntwo_id);
    if (status != NC_NOERR) fileObject-> HandleError(status);
    
    status = nc_inq_dimlen(ncid, ntwo_id, &ntwo);
    if (status != NC_NOERR) fileObject-> HandleError(status);


    int ntime_id;
    status = nc_inq_dimid(ncid, "ntime", &ntime_id);
    if (status != NC_NOERR) fileObject-> HandleError(status);
    
    status = nc_inq_dimlen(ncid, ntime_id, &ntime);
    if (status != NC_NOERR) fileObject-> HandleError(status);



    char varname[NC_MAX_NAME+1];
    nc_type vartype;
    int  varndims;
    int  vardims[NC_MAX_VAR_DIMS];
    int  varnatts;
    int  fnamesID;
    status = nc_inq_varid (ncid, "fnames", &fnamesID);
    if (status != NC_NOERR) fileObject-> HandleError(status);
     
    // Now get variable type!
    status = nc_inq_var(ncid, fnamesID, varname, &vartype, &varndims, 
            vardims, &varnatts);
    if (status != NC_NOERR) fileObject-> HandleError(status);
    
    debug4 << mName << varname << endl;

    // Find a directory prefix based on the name of the master file.
    std::string prefix;
    std::string::size_type index = fileObject->GetName().rfind(SLASH_STRING);
    if(index != std::string::npos)
    {
        prefix = fileObject->GetName().substr(0, index+1);
    }
    debug4 << mName << "prefix = \"" << prefix << "\"" << endl;

    bool fatalError = false;
    char *domainfilename = new char[nfnames];
    debug4 << mName << "Reading " << ndoms << " filenames." << endl;
    for(dom=0; dom<ndoms; ++dom)
    {

        size_t start[]={dom,0};
        size_t count[]={1, nfnames};
        ptrdiff_t stride[]={1,1};

        status= nc_get_vars_text(ncid,fnamesID,start,count,stride,domainfilename);
        if (status != NC_NOERR) fileObject-> HandleError(status);

#ifdef MDSERVER
        // If we're in the mdserver then only be really picky about the 
        // 1st file since that's the file we use to get metadata.
        if(domainFiles.size() > 0)
        {
            debug4 << mName << "Added " << domainfilename << " to domainFiles."
                   << endl;
            domainFiles.push_back(new avtFVCOMReader(domainfilename));
            continue;
        }
#endif

        // If we can access the raw filename that was stored in the master
        // then we should use it. Unfortunately, a common problem with
        // masters is that they tend to contain the entire path to the domain
        // files
        NETCDFFileObject *fobj = new NETCDFFileObject(domainfilename);
        if(fobj->Open())
        {
            fobj->Close();
            domainFiles.push_back(new avtFVCOMReader(domainfilename, fobj));
            debug4 << mName << "Opened " << domainfilename << endl;
        }
        else
        {
            //
            // The file must have been bad so construct an alternate filename
            // that uses the path to the master file. If that file can't be
            // opened then we have a problem and should probably throw an
            // exception. All of this opening to check the validity of the
            // files in the master can be split among processors if needed
            // later.
            // 
            delete fobj;

            std::string filename(domainfilename);
            index = filename.rfind(SLASH_STRING);
            if(index != std::string::npos)
            {
                filename = filename.substr(index+1, filename.size()-1);
            }
            filename = prefix + filename;
            debug4 << mName << "New filename " << filename.c_str() << endl;

            fobj = new NETCDFFileObject(filename.c_str());
            if(fobj->Open())
            {
                fobj->Close();
                domainFiles.push_back(new avtFVCOMReader(filename.c_str(), fobj));
                debug4 << mName << "Opened " << filename.c_str() << endl;
            }
            else
            {
                delete fobj;

                debug4 << mName << "Cannot open " << filename.c_str() << endl;
                fatalError = true;
                break;
            }
        }
    }
    delete [] domainfilename;

    if(fatalError)
    {
        // Clean up the files that we've made sure exist.
        for(int i = 0; i < domainFiles.size(); ++i)
            delete domainFiles[i];
        domainFiles.clear();

        char msg[2000];
        SNPRINTF(msg, 2000,
                 "%s. One or more domain files in the master file cannot be accessed",
                 fileObject->GetName().c_str());
        EXCEPTION1(InvalidFilesException, msg);
    }

    // Set init equal to true so we don't do this again!
    init = true;
}

// ****************************************************************************
//  Method: avtFVCOM_MTMDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: dstuebe -- generated by xml2avt
//  Creation:   Wed Aug 16 16:40:22 PST 2006
//
// ****************************************************************************

int
avtFVCOM_MTMDFileFormat::GetNTimesteps(void)
{
    Init();
    return domainFiles[0]->GetNTimesteps();
}

// ****************************************************************************
// Method: avtFVCOM_MTMDFileFormat::GetCycles
//
// Purpose: 
//   Returns the time cycle a domain file from avtFVCOMReader.
//
// Arguments:
//   cyc : The times cycle to be returned.
//
// Programmer: David Stuebe
// Creation:   Thu May 18 08:39:01 PDT 2006
//
// Modifications:  Ref to FVCOM Reader class!
//   
// ****************************************************************************

void
avtFVCOM_MTMDFileFormat::GetCycles(std::vector<int> &cycles)
{
    Init();
    domainFiles[0]->GetCycles(cycles);
}


// ****************************************************************************
// Method: avtFVCOM_MTMDFileFormat::GetTimes
//
// Purpose: 
//   Returns the times from a domain file using avtFVCOMReader.
//
// Arguments:
//   t : The times to be returned.
//
// Programmer: David Stuebe
// Creation:   Thu May 18 08:39:01 PDT 2006
//
// Modifications:
//   
// ****************************************************************************


void
avtFVCOM_MTMDFileFormat::GetTimes(std::vector<double> &times)
{
    Init();
    domainFiles[0]->GetTimes(times);
}


// ****************************************************************************
//  Method: avtFVCOM_MTMDFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: dstuebe -- generated by xml2avt
//  Creation:   Wed Aug 16 16:40:22 PST 2006
//
// ****************************************************************************

void
avtFVCOM_MTMDFileFormat::FreeUpResources(void)
{    
    for (int dom=0; dom<ndoms; ++dom)
    {
        domainFiles[dom]->FreeUpResources();
    }
}


// ****************************************************************************
//  Method: avtFVCOM_MTMDFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: dstuebe -- generated by xml2avt
//  Creation:   Wed Aug 16 16:40:22 PST 2006
//
//  Modifications:
//    Brad Whitlock, Tue Sep 5 16:59:41 PST 2006
//    Added code to cache data extents.
//
// ****************************************************************************

void
avtFVCOM_MTMDFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
    const char *mName = "avtFVCOM_MTMDFileFormat::PopulateDatabaseMetaData: ";

    Init();
    // Let domain 0 provide the metadata.
    domainFiles[0]->PopulateDatabaseMetaData(md, timeState, GetType() );
    
    for(int i = 0; i < md->GetNumMeshes(); ++i)
    {
        avtMeshMetaData *mmd = const_cast<avtMeshMetaData*>(md->GetMesh(i));
        mmd->numBlocks = domainFiles.size();
    }

#ifndef MDSERVER
    //
    // Let's iterate through all of the scalars and try to cache data extents
    // for each time step's domains. We do this here as opposed to doing it
    // inside of the GetAuxiliaryData method because GetAuxiliaryData does not
    // get called for MTMD when requesting data for all domains.
    //
    int nts = GetNTimesteps();
    int ndoms = domainFiles.size();
    for(int i = 0; i < md->GetNumScalars(); ++i)
    {
        const avtScalarMetaData *smd = md->GetScalar(i);
        std::string extName(smd->name);
        extName += "_ext";

        TypeEnum t = NO_TYPE;
        int ndims = 0, *dims = 0;
        void *values = 0;
        if(fileObject->ReadVariable(extName.c_str(), &t, &ndims, &dims, &values))
        {
            if(t == FLOATARRAY_TYPE)
            {
                float *fptr = (float *)values;
                int thisSize = 1;
                debug4 << mName << extName.c_str() << " dims = {";
                for(int j = 0; j < ndims; ++j)
                {
                    thisSize *= dims[j];
                    debug4 << ", " << dims[j];
                }
                debug4 << "}\n";

                // We have time-varying extents.
                if(thisSize == nts * ndoms * 2)
                {
                    for(int t = 0; t < nts; ++t)
                    {
                        avtIntervalTree *itree = new avtIntervalTree(ndoms, 1);
                        debug5 << mName << "Data extents for " << smd->name.c_str()
                               << " at ts=" << t << ": " << endl;
                        for (int j = 0; j < ndoms; j++)
                        {
                            double range[2];
                            range[0] = fptr[j*2+1];
                            range[1] = fptr[j*2];
                            itree->AddElement(j, range);

                            debug5 << "\tdomain[" << j << "] = {"
                                   << range[0] << ", " << range[1] << "}" << endl;
                        }
                        itree->Calculate(true);

                        // Cache the extents for all doms in this ts.
                        void_ref_ptr vr = void_ref_ptr(itree, avtIntervalTree::Destruct);
                        cache->CacheVoidRef(smd->name.c_str(),
                            AUXILIARY_DATA_DATA_EXTENTS, t, -1, vr);
                        debug4 << mName << "Cache data extents for " << smd->name.c_str()
                               << " at ts=" << t << endl;

                        fptr += (ndoms * 2);
                    }
                }
                // We have extents that we should use for all time steps.
                else if(thisSize == ndoms * 2)
                {
                    avtIntervalTree *itree = new avtIntervalTree(ndoms, 1);
                    debug5 << mName << "Data extents for " << smd->name.c_str()
                           << ": " << endl;
                    for (int j = 0; j < ndoms; j++)
                    {
                        double range[2];
                        range[0] = fptr[j*2+1];
                        range[1] = fptr[j*2];
                        itree->AddElement(j, range);

                        debug5 << "\tdomain[" << j << "] = {"
                               << range[0] << ", " << range[1] << "}" << endl;
                    }
                    itree->Calculate(true);

                    // Cache the extents for all doms and all ts.
                    void_ref_ptr vr = void_ref_ptr(itree, avtIntervalTree::Destruct);
                    cache->CacheVoidRef(smd->name.c_str(),
                        AUXILIARY_DATA_DATA_EXTENTS, -1, -1, vr);
                    debug4 << mName << "Cache data extents for " << smd->name.c_str()
                           << " all times." << endl;
                }
            }

            delete [] dims;
            free_void_mem(values, t);
        }
    }

    // Figure out spatial extents for domains in each mesh and cache the metadata
    // on a per-mesh basis.
#endif
}


// ****************************************************************************
//  Method: avtFVCOM_MTMDFileFormat::GetAuxiliaryData
//
//  Purpose:
//      Gets auxiliary data, data and spatial extents.
//
//  Programmer: David Stuebe
//  Creation:   September 1, 2006
//
//  Modifications:
//
// ****************************************************************************

void *
avtFVCOM_MTMDFileFormat::GetAuxiliaryData(const char *var, int timestate,
                                   int domain, const char *type, void *args,
                                   DestructorFunction &df)
{
    const char *mName = "avtFVCOM_MTMD::GetAuxiliaryData: ";
    void *rv = NULL;
 
    debug4 << mName << endl;
    debug4 << "Type= " << type << endl;
    debug4 << "var= " << var << endl;
    debug4 << "Timestate= " << timestate << endl;
    debug4 << "Domain= " << domain << endl;

    // Data extents are already cached but we can still call GetAuxiliaryData
    // on the reader for materials.
    rv = domainFiles[domain]->GetAuxiliaryData(var, timestate, type, args, df);   

    debug4 << mName << "end" << endl;
    
    return rv;
}


// ****************************************************************************
//  Method: avtFVCOM_MTMDFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: dstuebe -- generated by xml2avt
//  Creation:   Wed Aug 16 16:40:22 PST 2006
//
// ****************************************************************************

vtkDataSet *
avtFVCOM_MTMDFileFormat::GetMesh(int timestate, int domain, const char *meshname)
{
    Init();
    
    // Let the avtFVCOMFileFormat object know which value to use for domain
    // when it needs to cache something.
    domainFiles[domain]->SetDomainIndexForCaching(domain);
    
    // Call the domain'th MTSD reader object to get its data for the desired
    // domain at the desired time step.
    vtkDataSet *retval = domainFiles[domain]->GetMesh(timestate, meshname, cache);

    // ADD GHOST ZONES!
    int nCells = retval->GetNumberOfCells();
    int *blanks = new int[nCells];

    debug4 << "nCells= " << nCells << endl;

    int *helems = new int[ndoms];
    int *telems = new int[ndoms];
    bool have_h, have_t;
    have_h=fileObject->ReadVariableInto("Halos_Elems", INTEGERARRAY_TYPE, helems);
    have_t=fileObject->ReadVariableInto("Total_Elems", INTEGERARRAY_TYPE, telems);
    
    if(have_h && have_t)
    {
        debug4 << "Got Here" << endl;
        debug4 << "domain= "<< domain << endl;
        debug4 << "helems(domain)= "<< helems[domain] << endl;

        if (nCells == telems[domain])
        {
            for (int i = 0 ; i < nCells ; i++)
            {
                blanks[i]=0;
                if ( i < (nCells - helems[domain]) ) 
                { 
                    blanks[i]=1;
                }
            }
        }
        else
        {
            int nl = nCells/telems[domain];
            debug4 << "nl=" << nl << endl;
    
            for (int j = 0 ; j < nl ; j++)
            {
                for (int i = 0 ; i < nCells ; i++)
                {
                    blanks[i]=0;
                    if ( i < (nCells - helems[domain]) ) 
                    { 
                        blanks[i]=1;
                    }
                }
            }
        }
        debug4 << "Got Here2" << endl;

        unsigned char RealVal=0, ghost=1;
    
        avtGhostData::AddGhostZoneType(ghost,DUPLICATED_ZONE_INTERNAL_TO_PROBLEM);
        vtkUnsignedCharArray *ghostCells= vtkUnsignedCharArray::New();

        debug4 << "Got Here3" << endl;

        ghostCells->SetName("avtGhostZones");
        ghostCells->Allocate(nCells);


        for (int i = 0 ; i < nCells ; i++)
        {
            if(blanks[i])
                ghostCells->InsertNextValue(RealVal);
            else
                ghostCells->InsertNextValue(ghost);
        }
    
        retval->GetCellData()->AddArray(ghostCells);
        retval->SetUpdateGhostLevel(0);
        ghostCells->Delete();
    }
    else
    {
        debug4 << "Reading Halos_Elems or reading Total_Elems failed "
                  "so no ghost zones will be added." << endl;
    }

    delete [] blanks;
    delete [] helems;
    delete [] telems;

    return  retval;
}


// ****************************************************************************
//  Method: avtFVCOM_MTMDFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: dstuebe -- generated by xml2avt
//  Creation:   Wed Aug 16 16:40:22 PST 2006
//
// ****************************************************************************

vtkDataArray *
avtFVCOM_MTMDFileFormat::GetVar(int timestate, int domain, const char *varname)
{
    Init();
    
    // Let the avtFVCOMFileFormat object know which value to use for domain
    // when it needs to cache something.
    domainFiles[domain]->SetDomainIndexForCaching(domain);
    
    // Call the domain'th MTSD reader object to get its data for the desired
    // domain at the desired time step.
    return domainFiles[domain]->GetVar(timestate, varname, cache);
}


// ****************************************************************************
//  Method: avtFVCOM_MTMDFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: dstuebe -- generated by xml2avt
//  Creation:   Wed Aug 16 16:40:22 PST 2006
//
// ****************************************************************************

vtkDataArray *
avtFVCOM_MTMDFileFormat::GetVectorVar(int timestate, int domain,const char *varname)
{
    Init();

    // No cache for vector variables yet? Don't really need it.

    return domainFiles[domain]->GetVectorVar(timestate, varname);

}

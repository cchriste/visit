/*****************************************************************************
*
* Copyright (c) 2000 - 2012, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* All rights reserved.
*
* This file is part of VisIt. For details, see http://www.llnl.gov/visit/. The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or materials provided with the distribution.
*  - Neither the name of the UC/LLNL nor  the names of its contributors may be
*    used to  endorse or  promote products derived from  this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED.  IN  NO  EVENT  SHALL  THE  REGENTS  OF  THE  UNIVERSITY OF
* CALIFORNIA, THE U.S.  DEPARTMENT  OF  ENERGY OR CONTRIBUTORS BE  LIABLE  FOR
* ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtparaDISFileFormat.C                           //
// ************************************************************************* //
#define NO_BOOST 1
#include <avtparaDISFileFormat.h>
#include <avtparaDISOptions.h>
#include <DBOptionsAttributes.h>
#include <DebugStream.h>
#include "stringutil.h"
#include "debugutil.h"
#include "pathutil.h"
#include "version.h"

#include <string>
#include <vector>

#ifdef PARALLEL
#include <avtParallel.h>
#endif

#include <avtDatabaseMetaData.h>
#include <avtMaterial.h>
#include <Expression.h>

#include <InvalidVariableException.h>

using     namespace std;
using     rclib::Point; 


// ****************************************************************************
//  Method: avtparaDIS constructor
//
//  Programmer: rcook -- generated by xml2avt
//  Creation:   Tue Jan 30 14:56:34 PST 2007
//  Note the presence of DBOptionsAttributes means there is an options dialog
//  and the user sets rdatts values through this dialog. 
//
// ****************************************************************************
 
avtparaDISFileFormat::avtparaDISFileFormat(const char *filename,
                                           DBOptionsAttributes *rdatts)
  : avtSTSDFileFormat(filename), 
    mFilename(filename), mFormat(PARADIS_NO_FORMAT), 
    mParallelData(filename), mDumpfile(filename, rdatts) {

  if (mParallelData.ParseMetaDataFile()) {  
     mFormat = PARADIS_PARALLEL_FORMAT;
  } else if (mDumpfile.FileIsValid()) {
    mFormat = PARADIS_DUMPFILE_FORMAT; 
  }
  debug1 << "avtparaDISFileFormat, filename="<<filename<<";  development code" << endl;
  return; 
}




// ****************************************************************************
//  Method: avtparaDISFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: rcook -- generated by xml2avt
//  Creation:   Tue Jan 30 14:56:34 PST 2007
//
// ****************************************************************************

void
avtparaDISFileFormat::FreeUpResources(void)
{
  return; 
}



// ****************************************************************************
//  Method: avtparaDISFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: rcook -- generated by xml2avt
//  Creation:   Tue Jan 30 14:56:34 PST 2007
//
// ****************************************************************************

void
avtparaDISFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md)
{
  debug1 << "starting populateDatabaseMetaData" << endl; 
  debug1 << "avtparaDISFileFormat version " << PARADIS_READER_VERSION_NUMBER << ", " << PARADIS_READER_VERSION_DATE << endl;
  md->SetMustRepopulateOnStateChange(true); 

  // Create a "segments" mesh and a "nodes" mesh
  int nblocks = 1; /* This is for multi-domain, we are single-domain self-decomposing */ 
  int block_origin = 0; 
  int spatial_dimension = 3; /* 3D space */ 
  double *extents = NULL; 

  string meshname = "segments"; 
  int topological_dimension = 1; /* lines */ 
  avtMeshType meshtype = AVT_UNSTRUCTURED_MESH; 
  AddMeshToMetaData(md, meshname, meshtype, NULL, nblocks, block_origin,
                    spatial_dimension, topological_dimension);

  meshname = "nodes"; 
  topological_dimension = 0; /* only points */ 
  meshtype = AVT_POINT_MESH; 
  AddMeshToMetaData(md, meshname, meshtype, NULL, nblocks, block_origin,
                    spatial_dimension, topological_dimension);
  
  if (mFormat == PARADIS_PARALLEL_FORMAT) {
    // mParallelData.ParseMetaDataFile()) {  
    debug1 << "populateDatabaseMetaData using the newer parallelizable data format... " << endl;
    /*!
      =======================================================
      populate the segments mesh
      =======================================================
    */ 
    int numvars = mParallelData.mSegmentFiles.mDataArrayNames.size(); 
    int varnum = 0; 
    for (varnum = 0; varnum < numvars; ++varnum) {
      string name =  mParallelData.mSegmentFiles.mDataArrayNames[varnum];
      int dim = mParallelData.mSegmentFiles.mComponentsPerVar[varnum];
      if (name == "StartPos" || name == "EndPos" || name == "NodePos") continue; 
      if (dim > 1) {
        AddVectorVarToMetaData(md, name, "segments", AVT_ZONECENT, dim); 
        debug2 << "AddVectorVarTo segments mesh: name=" << name << ", dim=" << dim << endl; 
      } else {      
        AddScalarVarToMetaData(md, name, "segments", AVT_ZONECENT); 
        debug2 << "AddScalarVarTo segments mesh: name=" << name  << endl; 
      }
    }
    
    // Add burgers vector scalars to the segments mesh
    AddMaterialToMetaData(md, "Burgers type", "segments", 
                          mParallelData.mBurgersTypes.size(), 
                          mDumpfile.mBurgersTypes);
    /*!
      avtScalarMetaData *el_smd =
      new avtScalarMetaData("Burgers type", "segments", AVT_ZONECENT);
    el_smd->SetEnumerationType(avtScalarMetaData::ByValue);
    int a=0;
    for (a=0; a<mParallelData.mBurgersTypes.size(); a++) {
      el_smd->AddEnumNameValue(mParallelData.mBurgersTypes[a], a);
    }
    md->Add(el_smd);
    */
   /*!
      =======================================================
      populate the nodes mesh
      =======================================================
    */ 
    
    numvars = mParallelData.mNodeFiles.mDataArrayNames.size(); 
    for (varnum = 0; varnum < numvars; ++varnum) { 
      string name =  mParallelData.mNodeFiles.mDataArrayNames[varnum];
      int dim = mParallelData.mNodeFiles.mComponentsPerVar[varnum];
      if (dim > 1) {
        AddVectorVarToMetaData(md, name, "nodes", AVT_NODECENT, dim); 
        debug2 << "AddVectorVarTo nodes mesh: name=" << name << ", dim=" << dim << endl; 
      } else {      
        AddScalarVarToMetaData(md, name, "nodes", AVT_NODECENT); 
        debug2 << "AddScalarVarTo nodes mesh: name=" << name  << endl; 
      }
    }
    
    
    md->SetFormatCanDoDomainDecomposition(true);  
  } // end of parallel data format mesh creation 
  else if (mFormat == PARADIS_DUMPFILE_FORMAT) { // mDumpfile.FileIsValid()) { 
    debug1 << " populateDatabaseMetaData detected dumpfile-based dataset" << endl;  

#ifdef PARALLEL
    EXCEPTION1(VisItException, "You cannot read old ParaDIS dump files in parallel.  Run VisIt in serial to do this, or create ParaDIS parallel vis files.  Contact Rich Cook at 423-9605 regarding this error.");     
#else
    
    /*!
      =======================================================
      populate the segments mesh
      =======================================================
    */ 
    AddScalarVarToMetaData(md, "segmentIndex", "segments", AVT_ZONECENT);
    AddScalarVarToMetaData(md, "burgersType", "segments", AVT_ZONECENT);
    if (mDumpfile.mVerbosity > 1) {
      AddScalarVarToMetaData(md, "segmentEngine", "segments", AVT_ZONECENT);
    }
    
    // VisIt only allows one material set, so we have to let the user choose one
    if (mDumpfile.mMaterialSetChoice == 0) {
      AddMaterialToMetaData(md, "Segment_Burgers_Type", "segments", 
                            mDumpfile.mBurgersTypes.size(), mDumpfile.mBurgersTypes);
    } else {
      AddMaterialToMetaData(md, "Segment_MN_Type", "segments", 
                            mDumpfile.mSegmentMNTypes.size(), mDumpfile.mSegmentMNTypes);
    }
    
    /*!
      =======================================================
      populate the nodes mesh
      =======================================================
    */ 
    
    //AddScalarVarToMetaData(md, "nodeType", "nodes", AVT_NODECENT);
    // use a material for the node types 
    AddMaterialToMetaData(md, "Node_Num_Neighbors", "nodes", mDumpfile.mNodeNeighborValues.size(), mDumpfile.mNodeNeighborValues);
    
    AddScalarVarToMetaData(md, "simulationDomain", "nodes", AVT_NODECENT); 
    AddScalarVarToMetaData(md, "simulationID", "nodes", AVT_NODECENT); 
    AddScalarVarToMetaData(md, "nodeIndex", "nodes", AVT_NODECENT); 
    AddScalarVarToMetaData(md, "nodeType", "nodes", AVT_NODECENT); 
    
    if (mDumpfile.mVerbosity > 1) {
      AddScalarVarToMetaData(md, "nodeEngine", "nodes", AVT_NODECENT);
    }
    
    md->SetFormatCanDoDomainDecomposition(true);  
    
#endif
  } // end DumpFile format 
  else {
    EXCEPTION1(VisItException, "Cannot get paraDIS metadata from the file."); 
  }

  debug3 << " populateDatabaseMetaData complete" << endl; 
  return;
  
  // NOTES FOR DOCUMENTATION
  // CODE TO ADD A MESH
  //
  // string meshname = ...
  //
  // AVT_RECTILINEAR_MESH, AVT_CURVILINEAR_MESH, AVT_UNSTRUCTURED_MESH,
  // AVT_POINT_MESH, AVT_SURFACE_MESH, AVT_UNKNOWN_MESH
  // avtMeshType mt = AVT_RECTILINEAR_MESH;
  //
  // int nblocks = 1;  <-- this must be 1 for STSD
  // int block_origin = 0;
  // int spatial_dimension = 2;
  // int topological_dimension = 2;
  // float *extents = NULL;
  //
  // Here's the call that tells the meta-data object that we have a mesh:
  //
  // AddMeshToMetaData(md, meshname, mt, extents, nblocks, block_origin,
  //                   spatial_dimension, topological_dimension);
  //
  
  //
  // CODE TO ADD A SCALAR VARIABLE
  //
  // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
  // string varname = ...
  //
  // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
  // avtCentering cent = AVT_NODECENT;
  //
  //
  // Here's the call that tells the meta-data object that we have a var:
  //
  //AddScalarVarToMetaData(md, varname, meshname, cent); 
  
  //
  // CODE TO ADD A VECTOR VARIABLE
  //
  // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
  // string varname = ...
  // int vector_dim = 2;
  //
  // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
  // avtCentering cent = AVT_NODECENT;
  //
  //
  // Here's the call that tells the meta-data object that we have a var:
  //
  // AddVectorVarToMetaData(md, varname, mesh_for_this_var, cent,vector_dim);
  //
  
  //
  // CODE TO ADD A TENSOR VARIABLE
  //
  // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
  // string varname = ...
  // int tensor_dim = 9;
  //
  // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
  // avtCentering cent = AVT_NODECENT;
  //
  //
  // Here's the call that tells the meta-data object that we have a var:
  //
  // AddTensorVarToMetaData(md, varname, mesh_for_this_var, cent,tensor_dim);
  //
  
  //
  // CODE TO ADD A MATERIAL
  //
  
  /* 
     string matname = "mymaterial";
     string mesh_for_mat = "segments"; 
     vector<string> mnames;
     mnames.push_back(string("100 arm type"));    
     mnames.push_back(string("010 arm type"));
     mnames.push_back(string("001 arm type"));
     mnames.push_back(string("+++ arm type"));
     mnames.push_back(string("++- arm type"));
     mnames.push_back(string("+-+ arm type"));
     mnames.push_back(string("-++ arm type"));
     mnames.push_back(string("unknown arm type"));
     
     int nmats = 8;
  */ 
  // 
  // Here's the call that tells the meta-data object that we have a mat:
  //
  //AddMaterialToMetaData(md, matname, mesh_for_mat, nmats, mnames);
  //
  //
  // Here's the way to add expressions:
  //Expression momentum_expr;
  //momentum_expr.SetName("momentum");
  //momentum_expr.SetDefinition("{u, v}");
  //momentum_expr.SetType(Expression::VectorMeshVar);
  //md->AddExpression(&momentum_expr);
  //Expression KineticEnergy_expr;
  //KineticEnergy_expr.SetName("KineticEnergy");
  //KineticEnergy_expr.SetDefinition("0.5*(momentum*momentum)/(rho*rho)");
  //KineticEnergy_expr.SetType(Expression::ScalarMeshVar);
  //md->AddExpression(&KineticEnergy_expr);
  
}

// ****************************************************************************
//  Method: avtparaDISFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: rcook -- generated by xml2avt
//  Creation:   Tue Jan 30 14:56:34 PST 2007
//
// ****************************************************************************

vtkDataSet *
avtparaDISFileFormat::GetMesh(const char *meshname)
{  
    
  debug2 << "avtparaDISFileFormat::GetMesh("<<meshname<<") from file "<<mFilename<<endl;
  vtkDataSet *mesh = NULL; 
    
  if (mFormat == PARADIS_DUMPFILE_FORMAT) {
    mesh = mDumpfile.GetMesh(meshname); 
  }  else {
    mesh = mParallelData.GetMesh(meshname); 
  }
  if (!mesh) {
    EXCEPTION1(VisItException, "Could not get mesh requested"); 
  }
  /* DEBUG CODE 
  int npts = mesh->GetNumberOfPoints();
  double pvals[3];
  double pvmax = -FLT_MAX;
  double pvmin =  FLT_MAX;
  for(int i=0;i<npts;i++)
    {
      mesh->GetPoint(i,pvals);
      if(pvals[0]>  pvmax) pvmax= pvals[0];
      if(pvals[1]>  pvmax) pvmax= pvals[1];
      if(pvals[2]>  pvmax) pvmax= pvals[2];
      if(pvals[0]<  pvmin) pvmin= pvals[0];
      if(pvals[1]<  pvmin) pvmin= pvals[1];
      if(pvals[2]<  pvmin) pvmin= pvals[2];
    }
  cout<<  "For " << mFilename << ", npts = " << npts << ", pv min&  max = "<<  pvmin<<  " "<<  pvmax<<endl;
  cout<<  "plast = "<<  pvals[0]<<  " "<<  pvals[1]<<  " "<<
    pvals[2]<<endl;
  */ 
  return mesh;
}

// ****************************************************************************
//  Method: avtparaDISFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      varname    The name of the variable requested.
//
//  Programmer: rcook -- generated by xml2avt
//  Creation:   Tue Jan 30 14:56:34 PST 2007
//
// ****************************************************************************

vtkDataArray *
avtparaDISFileFormat::GetVar(const char *varname) {
  vtkDataArray *array = NULL; 
  if (mFormat == PARADIS_DUMPFILE_FORMAT) {    
    array = mDumpfile.GetVar(varname); 
  }  else {
    array = mParallelData.GetVar(varname); 
  }
  if (!array) {
    EXCEPTION1(VisItException, "Could not get variable requested"); 
  }
  return array; 
}


// ****************************************************************************
//  Method: avtparaDISFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      varname    The name of the variable requested.
//
//  Programmer: rcook -- generated by xml2avt
//  Creation:   Tue Jan 30 14:56:34 PST 2007
//
// ****************************************************************************

vtkDataArray *
avtparaDISFileFormat::GetVectorVar(const char *varname)
{
  return GetVar(varname); 

  //YOU MUST IMPLEMENT THIS

    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.
    //
    // EXCEPTION1(InvalidVariableException, varname);
    //

    //
    // If you do have a vector variable, here is some code that may be helpful.
    //
    // int ncomps = YYY;  // This is the rank of the vector - typically 2 or 3.
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // int ucomps = (ncomps == 2 ? 3 : ncomps);
    // rv->SetNumberOfComponents(ucomps);
    // rv->SetNumberOfTuples(ntuples);
    // float *one_entry = new float[ucomps];
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      int j;
    //      for (j = 0 ; j < ncomps ; j++)
    //           one_entry[j] = ...
    //      for (j = ncomps ; j < ucomps ; j++)
    //           one_entry[j] = 0.;
    //      rv->SetTuple(i, one_entry); 
    // }
    //
    // delete [] one_entry;
    // return rv;
    //
}


// NEED METHOD COMMENT

void *
avtparaDISFileFormat::GetAuxiliaryData(const char *var, const char *type,
                                       void *, DestructorFunction &df) {
  
  if (mFormat == PARADIS_DUMPFILE_FORMAT) {
    return mDumpfile.GetAuxiliaryData(var, type, df); 
  } // else {
  return mParallelData.GetAuxiliaryData(var, type, df); 
}


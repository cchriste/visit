/*****************************************************************************
*
* Copyright (c) 2000 - 2017, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtHDFSFileFormat.C                           //
// ************************************************************************* //

#include <avtHDFSFileFormat.h>

#include <map>
#include <string>

#include <vtkCellData.h>
#include <vtkDoubleArray.h>
#include <vtkFloatArray.h>
#include <vtkPointData.h>
#include <vtkType.h>
#include <vtkUnsignedCharArray.h>
#include <vtkUnstructuredGrid.h>

#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <FileFunctions.h>
#include <InvalidVariableException.h>
#include <InvalidDBTypeException.h>
#include <InvalidTimeStepException.h>
#include <snprintf.h>

#include "visit_gzstream.h"

#include <dirent.h>
#include <stdarg.h>

using std::map;
using std::string;

// ****************************************************************************
//  Method: avtHDFSFileFormat constructor
//
//  Programmer: miller86 -- generated by xml2avt
//  Creation:   Tue Apr 25 16:33:45 PST 2017
//
// ****************************************************************************

avtHDFSFileFormat::avtHDFSFileFormat(const char *fn)
    : avtMTMDFileFormat(FileFunctions::Dirname(fn))
{
    int sval;
    FileFunctions::VisItStat_t sbuf;
    char tmp[512];
    string dBDirName, baseName;

    // Should have passed in the name of a states.txt.gz file
    dBDirName = FileFunctions::Dirname(string(fn));
    baseName = FileFunctions::Basename(string(fn));

    if (baseName != "states.txt.gz")
    {
        EXCEPTION1(InvalidDBTypeException, "HDFS must open a states.txt.gz file");
    }

    // confirm ../users.txt.gz is one dir above dBDirName
    SNPRINTF(tmp, sizeof(tmp), "%s/../../users.txt.gz", dBDirName.c_str());
    sval = FileFunctions::VisItStat(tmp, &sbuf);
    if (sval != 0 || !(sbuf.st_mode&S_IFREG))
    {
        SNPRINTF(tmp, sizeof(tmp), "Unable to stat %s/../users.txt.gz", dBDirName.c_str());
        EXCEPTION1(InvalidDBTypeException, tmp);
    }

    // confirm ./dbs.txt.gz is in same dir as dBDirName 
    SNPRINTF(tmp, sizeof(tmp), "%s/../dbs.txt.gz", dBDirName.c_str());
    sval = FileFunctions::VisItStat(tmp, &sbuf);
    if (sval != 0 || !(sbuf.st_mode&S_IFREG))
    {
        SNPRINTF(tmp, sizeof(tmp), "Unable to stat %s/./dbs.txt.gz", dBDirName.c_str());
        EXCEPTION1(InvalidDBTypeException, tmp);
    }

    // confirm states.txt.gz is one dir below dBDirName
    SNPRINTF(tmp, sizeof(tmp), "%s/states.txt.gz", dBDirName.c_str());
    sval = FileFunctions::VisItStat(tmp, &sbuf);
    if (sval != 0 || !(sbuf.st_mode&S_IFREG))
    {
        SNPRINTF(tmp, sizeof(tmp), "unable to stat %s/states.txt.gz", dBDirName.c_str());
        EXCEPTION1(InvalidDBTypeException, tmp);
    }

    // confirm meshes.txt.gz is two dirs below dBDirName
    SNPRINTF(tmp, sizeof(tmp), "%s/000000/meshes.txt.gz", dBDirName.c_str());
    sval = FileFunctions::VisItStat(tmp, &sbuf);
    if (sval != 0 || !(sbuf.st_mode&S_IFREG))
    {
        SNPRINTF(tmp, sizeof(tmp), "unable to stat %s/000000/meshes.txt.gz", dBDirName.c_str());
        EXCEPTION1(InvalidDBTypeException, tmp);
    }
    
}

// ****************************************************************************
//  Method: avtHDFSFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: miller86 -- generated by xml2avt
//  Creation:   Tue Apr 25 16:33:45 PST 2017
//
// ****************************************************************************

static int CountLinesInFile(char const *dirname, char const *fname)
{
    char tmp[256];
    int n = 0;

    SNPRINTF(tmp, sizeof(tmp), "%s/%s", dirname, fname);
    visit_ifstream ifile(tmp);
    while (!ifile().eof())
    {
        ifile().getline(tmp, sizeof(tmp));
        if (ifile().eof()) break;
        n++;
    }
    return n;
}

int
avtHDFSFileFormat::GetNTimesteps(void)
{
    return CountLinesInFile(filename, "states.txt.gz");
}


// ****************************************************************************
//  Method: avtHDFSFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: miller86 -- generated by xml2avt
//  Creation:   Tue Apr 25 16:33:45 PST 2017
//
// ****************************************************************************

void
avtHDFSFileFormat::FreeUpResources(void)
{
}


// ****************************************************************************
//  Method: avtHDFSFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: miller86 -- generated by xml2avt
//  Creation:   Tue Apr 25 16:33:45 PST 2017
//
// ****************************************************************************


static void
strrepl(char *s, char orig, char repl)
{
    int i, n;
    if (!s) return;
    n = strlen(s);
    for (i = 0; i < n; i++)
        if (s[i] == orig) s[i] = repl;
}

static int
sscanhdfs(char *s, char *fmt, ...)
{
    int n;
    va_list ap;

    va_start(ap, fmt);
    strrepl(s, ',', ' ');
    strrepl(fmt, ',', ' ');
    n = vsscanf(s, fmt, ap);
    va_end(ap);
    return n;
}

void
avtHDFSFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
    int nTimesteps = GetNTimesteps();

    if (timeState < 0 || timeState >= nTimesteps)
    {
        EXCEPTION2(InvalidTimeStepException, timeState, nTimesteps);
    }

    // users, dbs, states, meshes, blocks, leaf files

    // open the dir for the given timestate
    int sval;
    char tmp[512];
    FileFunctions::VisItStat_t sbuf;
    SNPRINTF(tmp, sizeof(tmp), "%s/%06d/meshes.txt.gz", filename, timeState);
    sval = FileFunctions::VisItStat(tmp, &sbuf);
    if (sval != 0 || !(sbuf.st_mode&S_IFREG))
    {
        SNPRINTF(tmp, sizeof(tmp), "Unable to stat %s/%06d/meshes.txt.gz", filename, timeState);
        EXCEPTION1(InvalidDBTypeException, tmp);
    }

    visit_ifstream ifile(tmp);
    while (!ifile().eof())
    {
        char line[256], mkey[32], mname[128];
        int nblocks, sdims, tdims;

        ifile().getline(line, sizeof(line));
        if (ifile().eof()) break;
        sscanhdfs(line, "%s %s %d %d %d", mkey, mname, &nblocks, &sdims, &tdims);

        AddMeshToMetaData(md, mname, AVT_UNSTRUCTURED_MESH, NULL, nblocks, 0, sdims, tdims);

        // Use block 0 to determine variables
        SNPRINTF(tmp, sizeof(tmp), "%s/%06d/%s/000000", filename, timeState, mname);
        DIR *dirp;
        struct dirent *dentp;
        dirp = opendir(tmp);
        while (dirp && (dentp = readdir(dirp)) != NULL)
        {
            char *dummy = "**dummy**";
            char vname[256];
            avtCentering cent = AVT_UNKNOWN_CENT;
            int len = strlen(dentp->d_name);
            char *p = len>13?&dentp->d_name[len-13]:dummy;

            if (!strncmp(p, "_nodal.txt.gz", 13))
            {
                *p = '\0';
                AddScalarVarToMetaData(md, vname, mname, AVT_NODECENT);
            }
            else if (!strncmp(&dentp->d_name[len-13], "_zonal.txt.gz", 13))
            {
                *p = '\0';
                AddScalarVarToMetaData(md, vname, mname, AVT_ZONECENT);
            }
            else if (!strncmp(dentp->d_name, "materials.txt.gz", 16))
            {
                int nmats = 0;
                char matline[512], *p = &matline[0];
                SNPRINTF(tmp, sizeof(tmp), "%s/%06d/materials.txt.gz", filename, timeState);
                visit_ifstream matfile(tmp);
                matfile().getline(matline, sizeof(matline));
                while ((p = strchr(p, ',')) != NULL)
                    nmats++;
                AddMaterialToMetaData(md, "material", mname, nmats);
            }
        }
        closedir(dirp);
    }
}


avtMaterial *
avtHDFSFileFormat::GetMaterial(int tim, int dom, char const *mat)
{
    return 0;
}

void *
avtHDFSFileFormat::GetAuxiliaryData(const char *var, int timestep, 
    int domain, const char *type, void *args, DestructorFunction &)
{

    void *rv = NULL;

    if (strcmp(type, AUXILIARY_DATA_MATERIAL) == 0)
    {
        rv = (void *) GetMaterial(timestep, domain, var);
        df = avtMaterial::Destruct;
    }

    return rv;
}


// ****************************************************************************
//  Method: avtHDFSFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: miller86 -- generated by xml2avt
//  Creation:   Tue Apr 25 16:33:45 PST 2017
//
// ****************************************************************************

vtkDataSet *
avtHDFSFileFormat::GetMesh(int timestate, int domain, const char *meshname)
{
#if defined(_WIN32)
    // Figure out gzcat via popen doesn't appear portable.
    return NULL;
#else
    // open the coords.txt.gz file and read it
    char key[32];
    double c[3];
    int ghost;
    bool hasGhostNodes = false;
    map<string, int> nodeKeyMap;
    vtkPoints *points = vtkPoints::New();
    vtkUnsignedCharArray *ghostNodes = vtkUnsignedCharArray::New();
    char gzcmd[512];
    SNPRINTF(gzcmd, sizeof(gzcmd), "gzcat %s/%06d/%s/%06d/coords.txt.gz",
        filename, timestate, meshname, domain);
    FILE *coords_file = popen(gzcmd, "r");
    int i = 0;
    while (fscanf(coords_file, "%18s,%d,%lg,%lg,%lg\n", key, &ghost, &c[0], &c[1], &c[2])==5)
    {
        points->InsertNextPoint(c[0],c[1],c[2]);
        nodeKeyMap[string(key)] = i++;
        ghostNodes->InsertNextTuple1((unsigned char) ghost);
        if (ghost) hasGhostNodes = true;
    }
    pclose(coords_file);

    vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::New();
    ugrid->SetPoints(points);
    points->Delete();

    if (hasGhostNodes)
    {
        ghostNodes->SetName("avtGhostNodes");
        ugrid->GetPointData()->AddArray(ghostNodes);
    }
    ghostNodes->Delete();

    bool hasGhostZones = false;
    vtkUnsignedCharArray *ghostZones = vtkUnsignedCharArray::New();
    SNPRINTF(gzcmd, sizeof(gzcmd), "gzcat %s/%06d/%s/%06d/topology.txt.gz",
        filename, timestate, meshname, domain);
    FILE *topo_file = popen(gzcmd, "r");
    int cnt, type;
    while (fscanf(topo_file, "%18s,%d,%d,%d", key, &ghost, &type, &cnt)==4)
    {
        vtkIdType ids[10];
        for (i = 0; i < cnt; i++)
        {
            if (i == cnt - 1)
                fscanf(topo_file, ",%18s", key);
            else
                fscanf(topo_file, ",%18s", key);
            ids[i] = (vtkIdType) nodeKeyMap[string(key)];
        }
        ugrid->InsertNextCell(type, cnt, ids);
        ghostZones->InsertNextTuple1((unsigned char) ghost);
        if (ghost) hasGhostZones = true;
    }
    pclose(topo_file);

    if (hasGhostZones)
    {
        ghostZones->SetName("avtGhostZones");
        ugrid->GetCellData()->AddArray(ghostZones);
    }
    ghostZones->Delete();

    return ugrid;
#endif
}


// ****************************************************************************
//  Method: avtHDFSFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: miller86 -- generated by xml2avt
//  Creation:   Tue Apr 25 16:33:45 PST 2017
//
// ****************************************************************************

vtkDataArray *
avtHDFSFileFormat::GetVar(int timestate, int domain, const char *varname)
{
    return 0;
}


// ****************************************************************************
//  Method: avtHDFSFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: miller86 -- generated by xml2avt
//  Creation:   Tue Apr 25 16:33:45 PST 2017
//
// ****************************************************************************

vtkDataArray *
avtHDFSFileFormat::GetVectorVar(int timestate, int domain,const char *varname)
{
    return 0;
}

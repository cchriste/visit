/*****************************************************************************
*
* Copyright (c) 2000 - 2014, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtRAGEFileFormat.C                           //
// ************************************************************************* //

#include <avtRAGEFileFormat.h>

#include <vtkFloatArray.h>
#include <vtkDoubleArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>

#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>
#include <InvalidFilesException.h>
#include <hdf.h>
#include <mfhdf.h>
#include <VisItStreamUtil.h>

using std::string;
using std::vector;
using std::map;
using std::pair;

template <class T> static void
swapXY(vtkDataArray *arr, int nx, int ny, T *vals);


// ****************************************************************************
//  Method: avtRAGEFileFormat constructor
//
//  Programmer: pugmire -- generated by xml2avt
//  Creation:   Mon Oct 20 14:11:41 PST 2014
//
// ****************************************************************************

avtRAGEFileFormat::avtRAGEFileFormat(const char *filename)
    : avtSTSDFileFormat(filename)
{
    hdfFile = -1;
}


// ****************************************************************************
//  Method: avtRAGEFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: pugmire -- generated by xml2avt
//  Creation:   Mon Oct 20 14:11:41 PST 2014
//
// ****************************************************************************

void
avtRAGEFileFormat::FreeUpResources()
{
    if (hdfFile != -1)
        SDend(hdfFile);
    hdfFile = -1;
}


//****************************************************************************
// Method:  avtRAGEFileFormat::Initialize()
//
// Purpose:
//   
//
// Programmer:  Dave Pugmire
// Creation:    October 20, 2014
//
// Modifications:
//
//****************************************************************************

void
avtRAGEFileFormat::Initialize()
{
    if (hdfFile != -1)
        return;

    hdfFile = SDstart(GetFilename(), DFACC_READ);
    if(hdfFile < 0)
        EXCEPTION1(InvalidFilesException, GetFilename());
    
    int32 numDS = 0, numAttrs = 0;
    if (SDfileinfo(hdfFile, &numDS, &numAttrs) == FAIL)
        EXCEPTION1(InvalidFilesException, GetFilename());

    meshInfo mi;
    for (int i = 0; i < numDS; i++)
    {
        int32 vi = SDselect(hdfFile, i);
        char dsName[H4_MAX_VAR_DIMS];
        int32 rank, dataType, numAttrs, dimSizes[H4_MAX_VAR_DIMS];
        if (SDgetinfo(vi, dsName, &rank, dimSizes, &dataType, &numAttrs) == FAIL)
            EXCEPTION1(InvalidFilesException, GetFilename());
        
        if (rank == 1)
        {
            int32 n, attrType;
            char nm[H4_MAX_VAR_DIMS], attr[1024];
            
            //Get the dimension attributes.
            for (int a = 0; a < numAttrs; a++)
            {
                if (SDattrinfo(vi, a, nm, &attrType, &n) == FAIL)
                    EXCEPTION1(InvalidFilesException, GetFilename());
                if (SDreadattr(vi, a, attr) == FAIL)
                    EXCEPTION1(InvalidFilesException, GetFilename());
                
                attr[n] = '\0';
                if (string(nm) == "units")
                    mi.units.push_back(attr);
                else if (string(nm) == "long_name")
                    mi.labels.push_back(attr);
            }

            //Add info on dimension to the mesh.
            mi.dimIDs.push_back(vi);
            mi.dimSz.push_back(dimSizes[0]);
            mi.dimType.push_back(dataType);
        }
        else if (rank > 1)
        {
            string meshNm = "mesh_" + string(dsName);
            
            // dims are reversed wrt to VTK.
            mi.reverse();
            meshes[meshNm] = mi;
            
            varInfo v;
            v.varID = vi;
            v.varIdx = i;
            v.meshNm = meshNm;
            v.dataType = dataType;
            vars[dsName] = v;
            
            mi.clear();
        }
    }
}


// ****************************************************************************
//  Method: avtRAGEFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: pugmire -- generated by xml2avt
//  Creation:   Mon Oct 20 14:11:41 PST 2014
//
// ****************************************************************************

void
avtRAGEFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md)
{
    Initialize();

    map<string, meshInfo>::iterator mit;
    for (mit = meshes.begin(); mit != meshes.end(); mit++)
    {
        int nDims = mit->second.dimIDs.size();
        avtMeshMetaData *mesh = new avtMeshMetaData;
        mesh->name = mit->first;
        mesh->meshType = AVT_RECTILINEAR_MESH;
        mesh->spatialDimension = nDims;
        mesh->topologicalDimension = nDims;

        int nU = mit->second.units.size();
        int nL = mit->second.labels.size();
        if (nU > 0) mesh->xUnits = mit->second.units[0];
        if (nL > 0) mesh->xLabel = mit->second.labels[0];
        if (nU > 1) mesh->yUnits = mit->second.units[1];
        if (nL > 1) mesh->yLabel = mit->second.labels[1];
        if (nU > 2) mesh->zUnits = mit->second.units[2];
        if (nL > 2) mesh->zLabel = mit->second.labels[2];

        md->Add(mesh);
    }

    map<string, varInfo>::iterator vit;
    for (vit = vars.begin(); vit != vars.end(); vit++)
        AddScalarVarToMetaData(md, vit->first, vit->second.meshNm, AVT_NODECENT);
}


// ****************************************************************************
//  Method: avtRAGEFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: pugmire -- generated by xml2avt
//  Creation:   Mon Oct 20 14:11:41 PST 2014
//
// ****************************************************************************

vtkDataSet *
avtRAGEFileFormat::GetMesh(const char *meshname)
{
    Initialize();
    map<string, meshInfo>::iterator mit = meshes.find(meshname);
    if (mit == meshes.end())
        return NULL;

    vtkFloatArray *coords[3] = {vtkFloatArray::New(),
                                vtkFloatArray::New(),
                                vtkFloatArray::New()};

    int dims[3] = {1,1,1};
    for (int i = 0; i < mit->second.dimIDs.size(); i++)
    {
        int dimID = mit->second.dimIDs[i];
        int sz = mit->second.dimSz[i];
        int dimType = mit->second.dimType[i];
        
        dims[i] = sz;
        coords[i]->SetNumberOfTuples(sz);

        int32 start[1] = {0}, end[1] = {sz};
        if (dimType == DFNT_FLOAT32)
        {
            float *vals = new float[sz];
            SDreaddata(dimID, start, NULL, end, vals);
            for (int j = 0; j < sz; j++)
                coords[i]->SetTuple1(j, vals[j]);
            delete [] vals;
        }
        else if (dimType == DFNT_FLOAT64)
        {
            double *vals = new double[sz];
            SDreaddata(dimID, start, NULL, end, vals);
            for (int j = 0; j < sz; j++)
                coords[i]->SetTuple1(j, vals[j]);
            delete [] vals;
        }
        else
            EXCEPTION1(InvalidVariableException, meshname);
    }
    
    if (mit->second.dimIDs.size() < 3)
    {
        coords[2]->SetNumberOfTuples(1);
        coords[2]->SetTuple1(0, 0.0f);
    }

    if (mit->second.dimIDs.size() < 2)
    {
        coords[1]->SetNumberOfTuples(1);
        coords[1]->SetTuple1(0, 0.0f);
    }

    vtkRectilinearGrid *rv = vtkRectilinearGrid::New();
    rv->SetDimensions(dims);
    rv->SetXCoordinates(coords[0]);
    rv->SetYCoordinates(coords[1]);
    rv->SetZCoordinates(coords[2]);
    coords[0]->Delete();
    coords[1]->Delete();
    coords[2]->Delete();

    return rv;
}


// ****************************************************************************
//  Method: avtRAGEFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      varname    The name of the variable requested.
//
//  Programmer: pugmire -- generated by xml2avt
//  Creation:   Mon Oct 20 14:11:41 PST 2014
//
// ****************************************************************************

vtkDataArray *
avtRAGEFileFormat::GetVar(const char *varname)
{
    Initialize();
    
    map<string, varInfo>::iterator vit = vars.find(varname);
    if (vit == vars.end())
        EXCEPTION1(InvalidVariableException, varname);
    
    map<string, meshInfo>::iterator mit = meshes.find(vit->second.meshNm);
    if (mit == meshes.end())
        EXCEPTION1(InvalidVariableException, varname);

    int nDims = mit->second.dimSz.size();
    int numTuples = 1;
    
    for (int i = 0; i < mit->second.dimSz.size(); i++)
        numTuples *= mit->second.dimSz[i];

    vtkDataArray *arr = NULL;
    if (vit->second.dataType == DFNT_FLOAT32)
        arr = vtkFloatArray::New();
    else if (vit->second.dataType == DFNT_FLOAT64)
        arr = vtkDoubleArray::New();
    else
        EXCEPTION1(InvalidVariableException, varname);
    
    arr->SetNumberOfTuples(numTuples);

    int varID = vit->second.varID;
    int32 start[3] = {0, 0, 0};
    int32 end[3] = {0, 0, 0};
    for (int i = 0; i < mit->second.dimSz.size(); i++)
        end[i] = mit->second.dimSz[i];

    if (vit->second.dataType == DFNT_FLOAT32)
    {
        float *vals = new float[numTuples];
        SDreaddata(varID, start, NULL, end, vals);
        
        //For 2D, we need to swap the data.
        if (nDims == 2)
            swapXY(arr, mit->second.dimSz[0], mit->second.dimSz[1], vals);
        else
        {
            for (int i = 0; i < numTuples; i++)
                arr->SetTuple1(i, vals[i]);
        }
        delete [] vals;
    }
    else if (vit->second.dataType == DFNT_FLOAT64)
    {
        double *vals = new double[numTuples];
        SDreaddata(varID, start, NULL, end, vals);
        
        //For 2D, we need to swap the data.
        if (nDims == 2)
            swapXY(arr, mit->second.dimSz[0], mit->second.dimSz[1], vals);
        else
        {
            for (int i = 0; i < numTuples; i++)
                arr->SetTuple1(i, vals[i]);
        }
        delete [] vals;
    }

    return arr;
}


// ****************************************************************************
//  Method: avtRAGEFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      varname    The name of the variable requested.
//
//  Programmer: pugmire -- generated by xml2avt
//  Creation:   Mon Oct 20 14:11:41 PST 2014
//
// ****************************************************************************

vtkDataArray *
avtRAGEFileFormat::GetVectorVar(const char *varname)
{
    Initialize();
    return NULL;
}

//****************************************************************************
// Method:  swapXY
//
// Purpose:
//   Swap the XY order of the data.
//
// Programmer:  Dave Pugmire
// Creation:    November  3, 2014
//
// Modifications:
//
//****************************************************************************

template <class T> static void
swapXY(vtkDataArray *arr, int nx, int ny, T *vals)
{
    int idx = 0;
    for (int i = 0; i < nx; i++)
        for (int j = 0; j < ny; j++)
            arr->SetTuple1(idx++, vals[i*ny+j]);
}


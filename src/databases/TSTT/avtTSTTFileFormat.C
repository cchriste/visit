/*****************************************************************************
*
* Copyright (c) 2000 - 2007, The Regents of the University of California
* Produced at the Lawrence Livermore National Laboratory
* All rights reserved.
*
* This file is part of VisIt. For details, see http://www.llnl.gov/visit/. The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or materials provided with the distribution.
*  - Neither the name of the UC/LLNL nor  the names of its contributors may be
*    used to  endorse or  promote products derived from  this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED.  IN  NO  EVENT  SHALL  THE  REGENTS  OF  THE  UNIVERSITY OF
* CALIFORNIA, THE U.S.  DEPARTMENT  OF  ENERGY OR CONTRIBUTORS BE  LIABLE  FOR
* ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtTSTTFileFormat.C                           //
// ************************************************************************* //

#include "TSTTB.hh"
#include "TSTTM.hh"

#include <snprintf.h>

#include <avtTSTTFileFormat.h>

#include <string>
#include <map>

#include <vtkCellType.h>
#include <vtkCharArray.h>
#include <vtkDoubleArray.h>
#include <vtkFloatArray.h>
#include <vtkIntArray.h>
#include <vtkPoints.h>
#include <vtkUnstructuredGrid.h>

#include <avtCallback.h>
#include <avtDatabaseMetaData.h>

#include <Expression.h>

#include <InvalidVariableException.h>

using     std::string;
using     std::map;

static char* entTypes[] = {
    "vertex", "edge", "face", "region", "all types"};
static char* entTopologies[] = {
    "point", "line segment", "polygon", "triangle",
    "quadrilateral", "polyhedron", "tetrahedron",
    "pyramid", "prism", "hexahedron", "septahedron",
    "all topologies"};

static char *dataTypes[] = {
    "integer", "double", "ehandle", "bytes" };

static int TSTTEntityTopologyToVTKZoneType(int ttype)
{
    switch (ttype)
    {
    case TSTTM::EntityTopology_POINT:         return VTK_VERTEX;
    case TSTTM::EntityTopology_LINE_SEGMENT:  return VTK_LINE;
    case TSTTM::EntityTopology_POLYGON:       return VTK_POLYGON;
    case TSTTM::EntityTopology_TRIANGLE:      return VTK_TRIANGLE;
    case TSTTM::EntityTopology_QUADRILATERAL: return VTK_QUAD;
    case TSTTM::EntityTopology_TETRAHEDRON:   return VTK_TETRA;
    case TSTTM::EntityTopology_HEXAHEDRON:    return VTK_HEXAHEDRON;
    case TSTTM::EntityTopology_PRISM:         return VTK_WEDGE;
    case TSTTM::EntityTopology_PYRAMID:       return VTK_PYRAMID;
    }
    return -1;
}

// ****************************************************************************
//  Method: avtTSTT constructor
//
//  Programmer: miller -- generated by xml2avt
//  Creation:   Wed Mar 7 17:15:33 PST 2007
//
// ****************************************************************************

avtTSTTFileFormat::avtTSTTFileFormat(const char *filename)
    : avtSTMDFileFormat(&filename, 1)
{
    vmeshFileName = filename;
    rootSet = vertEnts = edgeEnts = faceEnts = regEnts = 0;
    geomDim = topoDim = 0;
    numVerts = numEdges = numFaces = numRegs = 0;
    haveMixedElementMesh = false;
}


// ****************************************************************************
//  Method: avtTSTTFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: miller -- generated by xml2avt
//  Creation:   Wed Mar 7 17:15:33 PST 2007
//
// ****************************************************************************

void
avtTSTTFileFormat::FreeUpResources(void)
{
}


// ****************************************************************************
//  Method: avtTSTTFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: miller -- generated by xml2avt
//  Creation:   Wed Mar 7 17:15:33 PST 2007
//
// ****************************************************************************

void
avtTSTTFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md)
{
    int i, j;

    tsttMesh = TSTTM::Factory::newMesh("");
    rootSet = tsttMesh.getRootSet();

    // remove extension from filename
    string tmpFileName = vmeshFileName;
    int q = vmeshFileName.size();
    if (vmeshFileName[q-6] == '.' && vmeshFileName[q-5] == 'v' &&
        vmeshFileName[q-4] == 'm' && vmeshFileName[q-3] == 'e' &&
        vmeshFileName[q-2] == 's' && vmeshFileName[q-1] == 'h')
        tmpFileName = string(vmeshFileName, 0, q-6);
    else if (vmeshFileName[q-6] == '.' && vmeshFileName[q-5] == 'c' &&
             vmeshFileName[q-4] == 'u' && vmeshFileName[q-3] == 'b')
        tmpFileName = string(vmeshFileName, 0, q-4);

    // ok, try loading the mesh.
    try
    {
        tsttMesh.load(rootSet, tmpFileName);

        // determine spatial and topological dimensions of mesh
        geomDim = tsttMesh.getGeometricDim();
        topoDim = -1;
        numVerts = tsttMesh.getNumOfType(rootSet, TSTTM::EntityType_VERTEX);
        if (numVerts > 0)
            topoDim = 0;
        numEdges = tsttMesh.getNumOfType(rootSet, TSTTM::EntityType_EDGE);
        if (numEdges > 0)
            topoDim = 1;
        numFaces = tsttMesh.getNumOfType(rootSet, TSTTM::EntityType_FACE);
        if (numFaces > 0)
            topoDim = 2;
        numRegs = tsttMesh.getNumOfType(rootSet, TSTTM::EntityType_REGION);
        if (numRegs > 0)
            topoDim = 3;

        //
        // Decide if we've got a 'mixed element' mesh
        //
        if ((numEdges > 0 && numFaces > 0) ||
            (numEdges > 0 && numRegs > 0) ||
            (numFaces > 0 && numRegs > 0))
            haveMixedElementMesh = true;

        //
        // If we have a mixed element mesh, serve up the mesh to VisIt
        // such that each element type gets its own domain. Otherwise,
        // just serve up a single block mesh.
        //
        if (haveMixedElementMesh)
        {
            vector<string> blockPieceNames;
            if (numEdges)
            {
                domToEntType[blockPieceNames.size()] = TSTTM::EntityType_EDGE;
                blockPieceNames.push_back("EDGE");
            }
            if (numFaces)
            {
                domToEntType[blockPieceNames.size()] = TSTTM::EntityType_FACE;
                blockPieceNames.push_back("FACE");
            }
            if (numRegs)
            {
                domToEntType[blockPieceNames.size()] = TSTTM::EntityType_REGION;
                blockPieceNames.push_back("REGION");
            }
            avtMeshMetaData *mmd = new avtMeshMetaData("mesh", blockPieceNames.size(),
                0, 0, 0, geomDim, topoDim, AVT_UNSTRUCTURED_MESH);
            mmd->blockTitle = string("Entity Types");
            mmd->blockPieceName = string("etype");
            mmd->blockNames = blockPieceNames;
            md->Add(mmd);
        }
        else
        {
            if (numEdges > 0)
                domToEntType[0] = TSTTM::EntityType_EDGE;
            else if (numFaces > 0)
                domToEntType[0] = TSTTM::EntityType_FACE;
            else if (numRegs > 0)
                domToEntType[0] = TSTTM::EntityType_REGION;
            AddMeshToMetaData(md, "mesh", AVT_UNSTRUCTURED_MESH, 0, 1, 0,
                geomDim, topoDim);
        }
    }
    catch (TSTTB::Error TErr)
    {
        char msg[256];
        SNPRINTF(msg, sizeof(msg), "Encountered TSTT error (%d) \"%s\""
            "\nUnable to open file!", TErr.getDescription().c_str(),
            TErr.getErrorType());
        if (!avtCallback::IssueWarning(msg))
            cerr << msg << endl;
        return;
    }

    //
    // Because its so convenient, add the zonetype expression as a
    // variable on the mesh
    //
    Expression expr;
    expr.SetName("zonetype");
    expr.SetDefinition("zonetype(mesh)");
    expr.SetType(Expression::ScalarMeshVar);
    md->AddExpression(&expr);

    // create variants of the tsttMesh object handle ??
    TSTTB::EntSet tsttMeshes = tsttMesh;
    TSTTB::SetTag tsttMesht  = tsttMesh;
    TSTTM::Entity tsttMeshe  = tsttMesh;
    TSTTB::EntTag tsttMeshet = tsttMesh;
    TSTTB::ArrTag tsttMeshat = tsttMesh;

#if 0

    //
    // How to determine centering WITHOUT invoking problem sized
    // data work; e.g. an array of entity handles
    //
    for (int qq = 0; qq < 4; qq++)
    {
        void *entIt;
        tsttMeshe.initEntIter(rootSet, (TSTTM::EntityType) qq,
            TSTTM::EntityTopology_ALL_TOPOLOGIES, entIt);
        void *oneEntity;
        tsttMeshe.getNextEntIter(entIt, oneEntity);
        tsttMeshe.endEntIter(entIt);
        sidl::array<void*> tagsOnOneEntity;
        int tagsOnOneEntity_size;
        tsttMeshet.getAllTags(oneEntity, tagsOnOneEntity, tagsOnOneEntity_size);
        cerr << "Tags found on first " << qq << "d entity..." << endl;
        for (int kk = 0; kk < tagsOnOneEntity_size; kk++)
        {
            void *theTag = tagsOnOneEntity[kk];
            cerr << "    theTag = " << theTag << endl;
            cerr << "    name = \"" << tsttMesht.getTagName(theTag) << "\"" << endl;
            cerr << "    size values = " << tsttMesht.getTagSizeValues(theTag) << endl;
            cerr << "    size bytes = " << tsttMesht.getTagSizeBytes(theTag) << endl;
            int typeId = tsttMesht.getTagType(theTag);
            cerr << "    type = \"" <<
                (typeId < sizeof(dataTypes)/sizeof(dataTypes[0]) ? dataTypes[typeId] : "unknown")
                 << "\"" << endl; 
        }
        cerr << "DONE DONE DONE" << endl;
    }

    // look for variables stored in the form of 'tags' on entity sets
    sidl::array<void*> esets;
    int esets_size;
    tsttMeshes.getEntSets(rootSet, 0, esets, esets_size);

    cerr << "Found " << esets_size << " entity sets" << endl;

    // build a map of the tag names and handles
    std::map<string, void*> tagMap;
    for (i = 0; i < esets_size; i++)
    {
        sidl::array<void*> tags;
        int tags_size;
        tsttMesht.getAllEntSetTags(esets[i], tags, tags_size);
        cerr << "For entity set " << i << ", found " << tags_size << " tags" << endl;
    
        for (j = 0; j < tags_size; j++)
            tagMap[tsttMesht.getTagName(tags[j])] = tags[j];

        
        int eh_size;
        sidl::array<void*> eh;
        tsttMesh.getEntities(esets[i], TSTTM::EntityType_ALL_TYPES,
            TSTTM::EntityTopology_ALL_TOPOLOGIES, eh, eh_size);
        cerr << "    found " << eh_size << " entities for this entity set" << endl;

        for (int qq = 0; qq < eh_size; qq++)
        {
            sidl::array<void*> tagsOnOneEntity;
            int tagsOnOneEntity_size = 0;
            tsttMeshet.getAllTags(eh[qq], tagsOnOneEntity, tagsOnOneEntity_size);
            cerr << "    Tags found on entity " << qq << endl;
            for (int uu = 0; uu < tagsOnOneEntity_size; uu++)
            {
                void *theTag = tagsOnOneEntity[uu];
                cerr << "        theTag = " << theTag << endl;
                cerr << "        name = \"" << tsttMesht.getTagName(theTag) << "\"" << endl;
                cerr << "        size values = " << tsttMesht.getTagSizeValues(theTag) << endl;
                cerr << "        size bytes = " << tsttMesht.getTagSizeBytes(theTag) << endl;
                int typeId = tsttMesht.getTagType(theTag);
                cerr << "        type = \"" <<
                    (typeId < sizeof(dataTypes)/sizeof(dataTypes[0]) ? dataTypes[typeId] : "unknown")
                     << "\"" << endl; 
                if (typeId == 0)
                {
                    try
                    {
                        cerr << "        data = " << tsttMeshet.getIntData(eh[qq], theTag);
                    }
                    catch (TSTTB::Error TErr)
                    {
                        cerr << "Encountered TSTT error \"" << TErr.getDescription() << "\"" << endl;
                        cerr << "Encountered TSTT type " << TErr.getErrorType() << endl;
                    }
                }
                else
                    cerr << "        data = unknown" << endl;
            }
        }
    }
    
    // iterate through tags, defining mesh variables, handle
    // any specially named tags (e.g. 'UNIQUE_ID', 'MATERIAL')
    std::map<string, void*>::const_iterator mit;
    void *anIntTag;
    for (mit = tagMap.begin(); mit != tagMap.end(); mit++)
    {
        cerr << "Processing entry in map keyed at \"" << mit->first << "\"" << endl;
        void *theTag = mit->second;
        
        cerr << "    name = \"" << tsttMesht.getTagName(theTag) << "\"" << endl;
        cerr << "    size values = " << tsttMesht.getTagSizeValues(theTag) << endl;
        cerr << "    size bytes = " << tsttMesht.getTagSizeBytes(theTag) << endl;
        int typeId = tsttMesht.getTagType(theTag);
        cerr << "    type = \"" <<
            (typeId < sizeof(dataTypes)/sizeof(dataTypes[0]) ? dataTypes[typeId] : "unknown")
             << "\"" << endl; 

        if (string(tsttMesht.getTagName(theTag)) == "MATERIAL_SET")
        {
            anIntTag = theTag;
            cerr << "Setting anIntTag" << endl;
        }
        if (tsttMesht.getTagSizeValues(theTag) == 1)
            AddScalarVarToMetaData(md, tsttMesht.getTagName(theTag), "mesh", AVT_NODECENT);
        else if (tsttMesht.getTagSizeValues(theTag) == 3)
            AddVectorVarToMetaData(md, tsttMesht.getTagName(theTag), "mesh", AVT_NODECENT, 3);
        else if (tsttMesht.getTagSizeValues(theTag) == 9)
            AddTensorVarToMetaData(md, tsttMesht.getTagName(theTag), "mesh", AVT_NODECENT, 9);
    }

#if 0
    int eh_size;
    sidl::array<void*> eh;
    tsttMesh.getEntities(rootSet, TSTTM::EntityType_REGION,
        TSTTM::EntityTopology_ALL_TOPOLOGIES, eh, eh_size);
    cerr << "For VERTEX, got eh_size = " << eh_size << endl;
    sidl::array<int> intArray;
    int intArray_size;

    try
    {
        tsttMeshat.getIntArrData(eh, eh_size, anIntTag, intArray, intArray_size); 
    }
    catch (TSTTB::Error TErr)
    {
        cerr << "Encountered TSTT error \"" << TErr.getDescription() << "\"" << endl;
        cerr << "Encountered TSTT type " << TErr.getErrorType() << endl;
    }

    for (i = 0; i < intArray_size; i++)
        cerr << "intArray[" << i << "] = " << intArray[i] << endl;
#endif
#endif

}


// ****************************************************************************
//  Method: avtTSTTFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: miller -- generated by xml2avt
//  Creation:   Wed Mar 7 17:15:33 PST 2007
//
// ****************************************************************************

vtkDataSet *
avtTSTTFileFormat::GetMesh(int domain, const char *meshname)
{
    int i, j;

    try
    {

    //
    // The domain number indicates the entity type we're looking for
    //
    TSTTM::EntityType entType = domToEntType[domain]; 
    int numEnts = tsttMesh.getNumOfType(rootSet, entType);
    if (numEnts == 0)
        return 0;

    int coords2Size, mapSize;
    sidl::array<double> coords2;
    sidl::array<int> inEntSetMap;
    TSTTM::StorageOrder storageOrder2 = TSTTM::StorageOrder_UNDETERMINED;
    tsttMesh.getAllVtxCoords(rootSet, coords2, coords2Size,
        inEntSetMap, mapSize, storageOrder2);

    int vertCount = mapSize;
    if (vertCount == 0)
        return 0;

    //
    // If its a 1D or 2D mesh, the coords could be 3-tuples where
    // the 'extra' values are always zero or they could be reduced
    // dimensioned tuples. The TSTT interface doesn't specify.
    //
    int tupleSize = coords2Size / vertCount;

    //
    // Populate the coordinates.  Put in 3D points with z=0 if the mesh is 2D.
    //
    vtkPoints *points  = vtkPoints::New();
    points->SetNumberOfPoints(vertCount);
    float *pts = (float *) points->GetVoidPointer(0);
    for (i = 0; i < vertCount; i++)
    {
        if (storageOrder2 == TSTTM::StorageOrder_INTERLEAVED)
        {
            for (j = 0; j < tupleSize; j++)
                pts[i*3+j] = (float) coords2.get(i*tupleSize+j);
            for (j = tupleSize; j < 3; j++)
                pts[i*3+j] = 0.0;
        }
        else if (storageOrder2 == TSTTM::StorageOrder_BLOCKED)
        {
            for (j = 0; j < tupleSize; j++)
                pts[i*3+j] = (float) coords2.get(j*vertCount+i);
            for (j = tupleSize; j < 3; j++)
                pts[i*3+j] = 0.0;
        }
    }

    vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::New(); 
    ugrid->SetPoints(points);
    points->Delete();

    sidl::array<int> offset; int offsetSize;
    sidl::array<int> index; int indexSize;
    sidl::array<TSTTM::EntityTopology> topos; int32_t toposSize;
    tsttMesh.getVtxCoordIndex(rootSet, entType,
        TSTTM::EntityTopology_ALL_TOPOLOGIES, TSTTM::EntityType_VERTEX, 
        offset, offsetSize, index, indexSize, topos, toposSize);

    for (int off = 0; off < offsetSize; off++)
    {
        int vtkZoneType = TSTTEntityTopologyToVTKZoneType(topos[off]);
        vtkIdType vertIds[256];
        int jj = 0;
        for (int idx = offset[off];
             idx < ((off+1) < offsetSize ? offset[off+1] : indexSize); idx++)
            vertIds[jj++] = index[idx];
        ugrid->InsertNextCell(vtkZoneType, jj, vertIds);
    }

    return ugrid;

    }
    catch (TSTTB::Error TErr)
    {
        char msg[256];
        SNPRINTF(msg, sizeof(msg), "Encountered TSTT error (%d) \"%s\""
            "\nUnable to open file!", TErr.getDescription().c_str(),
            TErr.getErrorType());
        if (!avtCallback::IssueWarning(msg))
            cerr << msg << endl;
        return 0;
    }
}


// ****************************************************************************
//  Method: avtTSTTFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: miller -- generated by xml2avt
//  Creation:   Wed Mar 7 17:15:33 PST 2007
//
// ****************************************************************************

vtkDataArray *
avtTSTTFileFormat::GetVar(int domain, const char *varname)
{
    return 0;

    TSTTB::SetTag tsttMesht  = tsttMesh;
    void *tagHandle = tsttMesht.getTagHandle(varname);

    int numComps = tsttMesht.getTagSizeValues(tagHandle);

#if 0
    void *entHandles = 0;
    int ents_size;
    switch (entType)
    {
        case TSTTM::EntityType::VERTEX:
        {
            if (vertEnts == 0)
                tsttMesh.getEntities(rootSet, entType,
                    TSTTM::EntityTopology::ALL_TOPOLOGIES, vertEnts,
                    ents_size);
            if (ents_size != numVerts)
                cerr << "numVerts (" << numVerts << ") != ents_size (" << ents_size << ")" << endl;
            entHandles = vertEnts;
            break;
        }
        case TSTTM::EntityType::EDGE:
        {
            if (edgeEnts == 0)
                tsttMesh.getEntities(rootSet, entType,
                    TSTTM::EntityTopology::ALL_TOPOLOGIES, edgeEnts,
                    ents_size);
            if (ents_size != numEdges)
                cerr << "numEdges (" << numEdges << ") != ents_size (" << ents_size << ")" << endl;
            entHandles = edgeEnts;
            break;
        }
        case TSTTM::EntityType::FACE:
        {
            if (faceEnts == 0)
                tsttMesh.getEntities(rootSet, entType,
                    TSTTM::EntityTopology::ALL_TOPOLOGIES, faceEnts,
                    ents_size);
            if (ents_size != numFaces)
                cerr << "numFaces (" << numFaces << ") != ents_size (" << ents_size << ")" << endl;
            entHandles = faceEnts;
            break;
        }
        case TSTTM::EntityType::REGION:
        {
            if (regEnts == 0)
                tsttMesh.getEntities(rootSet, entType,
                    TSTTM::EntityTopology::ALL_TOPOLOGIES, regEnts,
                    ents_size);
            if (ents_size != numRegs)
                cerr << "numRegs (" << numRegs << ") != ents_size (" << ents_size << ")" << endl;
            entHandles = regEnts;
            break;
        }
    }
#endif

    int tag_value_size;

    vtkDataArray *result = 0;

    switch (tsttMesht.getTagType(tagHandle))
    {
        case TSTTB::TagValueType_INTEGER:
        {
            sidl::array<int> tag_value;
            //tsttMesht.getEntSetIntData(rootSet, tagHandle, tag_value, tag_value_size);
            vtkIntArray *ia = vtkIntArray::New();
            ia->SetNumberOfComponents(numComps);
            ia->SetNumberOfTuples(tag_value_size);
            cerr << "Processing integer data..." << endl;
            for (int i = 0; i < tag_value_size; i++)
            {
                ia->SetValue(i, tag_value[i]);
                cerr << "    value[" << i << "] = " << tag_value[i] << endl;
            }
            result = ia;
            break;
        }
        case TSTTB::TagValueType_DOUBLE:
        {
            sidl::array<double> tag_value;
            //tsttMesht.getEntSetDblData(rootSet, tagHandle, tag_value, tag_value_size);
            vtkDoubleArray *da = vtkDoubleArray::New();
            da->SetNumberOfComponents(numComps);
            da->SetNumberOfTuples(tag_value_size);
            cerr << "Processing double data..." << endl;
            for (int i = 0; i < tag_value_size; i++)
            {
                da->SetValue(i, tag_value[i]);
                cerr << "    value[" << i << "] = " << tag_value[i] << endl;
            }
            result = da;
            break;
        }
        case TSTTB::TagValueType_ENTITY_HANDLE:
        {
        }
        case TSTTB::TagValueType_BYTES:
        {
            sidl::array<char> tag_value;
            tsttMesht.getEntSetData(rootSet, tagHandle, tag_value, tag_value_size);
            vtkCharArray *ca = vtkCharArray::New();
            ca->SetNumberOfComponents(numComps);
            ca->SetNumberOfTuples(tag_value_size);
            cerr << "Processing double data..." << endl;
            for (int i = 0; i < tag_value_size; i++)
            {
                ca->SetValue(i, tag_value[i]);
                cerr << "    value[" << i << "] = " << tag_value[i] << endl;
            }
            result = ca;
            break;
        }
    }

    return result;
}


// ****************************************************************************
//  Method: avtTSTTFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: miller -- generated by xml2avt
//  Creation:   Wed Mar 7 17:15:33 PST 2007
//
// ****************************************************************************

vtkDataArray *
avtTSTTFileFormat::GetVectorVar(int domain, const char *varname)
{
    return 0;
}

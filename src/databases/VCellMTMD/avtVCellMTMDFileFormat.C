/*****************************************************************************
*
* Copyright (c) 2000 - 2014, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

/*
 * Virtual Cell (VCellMTMD) specific portions of this file are
 * Copyright (C) 1999-2011 University of Connecticut Health Center
 *
 * Licensed under the MIT License (the "License").
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *  http://www.opensource.org/licenses/mit-license.php
 */


// ************************************************************************* //
//                        avtVCellMTMDFileFormat.C                           //
// ************************************************************************* //

#include <avtVCellMTMDFileFormat.h>

#include <avtGenericDatabase.h>

#include <InvalidDBTypeException.h>
#include <DebugStream.h>

#include <vtkFloatArray.h>
#include <vtkDataArray.h>
#include <vtkRectilinearGrid.h>
//#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>
//#include "vtkPolyData.h"
#include "vtkCellArray.h"


#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <ExpressionParser/Expression.h>

#include <InvalidVariableException.h>

#include <sstream>
#include <stdio.h>
#include <sys/stat.h>
#include <algorithm>

#if ( defined(WIN32) || defined(WIN64) )
#include <windows.h>
#else
#include <unistd.h>
#endif

#define INTEL

using    namespace  std;//::stringstream;

int unzip32(char* zipfile, char* file, char* exdir);

extern "C"
{
    int uncompress(unsigned char*,unsigned long *,unsigned char*,unsigned long);
}

const int X_AXIS = 0;
const int Y_AXIS = 1;
const int Z_AXIS = 2;

const string REGIONPREFIX = "vcRegion";
const string REGIONVOLUME = REGIONPREFIX+"Volume";
const string REGIONAREA = REGIONPREFIX+"Area";



void Tokenize(const string& str,vector<string>& tokens,const string& delimiters)
{
    //http://www.oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html

    //clear tokens
    tokens.clear();
    // Skip delimiters at beginning.
    string::size_type lastPos = str.find_first_not_of(delimiters, 0);
    // Find first "non-delimiter".
    string::size_type pos     = str.find_first_of(delimiters, lastPos);

    while (string::npos != pos || string::npos != lastPos)
    {
        // Found a token, add it to the vector.
        tokens.push_back(str.substr(lastPos, pos - lastPos));
        // Skip delimiters.  Note the "not_of"
        lastPos = str.find_first_not_of(delimiters, pos);
        // Find next "non-delimiter"
        pos = str.find_first_of(delimiters, lastPos);
    }
}


// ****************************************************************************
//  Method: avtVCellMTMDFileFormat constructor
//
//  Programmer: frm -- generated by xml2avt
//  Creation:   Sat Oct 23 13:29:29 PST 2010
//
// ****************************************************************************

avtVCellMTMDFileFormat::avtVCellMTMDFileFormat(const char *filename)
    : avtMTMDFileFormat(filename)
{
    // INITIALIZE DATA MEMBERS
    string logFileNameString(filename);
    readLog(logFileNameString);

}

avtVCellMTMDFileFormat::~avtVCellMTMDFileFormat(){
    delete [] membrQuadNodes;
    delete [] ucdMeshNodes;
}


// ****************************************************************************
//  Method: avtEMSTDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: frm -- generated by xml2avt
//  Creation:   Sat Oct 23 13:29:29 PST 2010
//
// ****************************************************************************

int
avtVCellMTMDFileFormat::GetNTimesteps(void)
{
    return (int)vcellLogEntryList.size();
}

void avtVCellMTMDFileFormat::GetTimes(std::vector<double> & timeV)
{
    for (size_t i=0;i<vcellLogEntryList.size();i++)
    {
        timeV.push_back(vcellLogEntryList[i].time);
    }
}

// ****************************************************************************
//  Method: avtVCellMTMDFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: frm -- generated by xml2avt
//  Creation:   Sat Oct 23 13:29:29 PST 2010
//
// ****************************************************************************

void
avtVCellMTMDFileFormat::FreeUpResources(void)
{
}


const string ws_delim = " \t\r\n";
static void trimString(string& str)
{
     string::size_type pos = str.find_last_not_of(ws_delim);
     if(pos != string::npos) {
          str.erase(pos + 1);
          pos = str.find_first_not_of(ws_delim);
          if(pos != string::npos) {
              str.erase(0, pos);
          }
     }
     else {
          str.erase(str.begin(), str.end());
     }
}


string trimCopy(string str)
{
  string::size_type pos1 = str.find_first_not_of(ws_delim);
  string::size_type pos2 = str.find_last_not_of(ws_delim);
  str = str.substr(pos1 == string::npos ? 0 : pos1, 
    pos2 == string::npos ? str.length() - 1 : pos2 - pos1 + 1);

  return str;
}
#define MESH_FILE_EXT ".mesh"
//#define MESHMETRICS_FILE_EXT ".meshmetrics"
#define SIM_FILE_EXT ".sim"
//#define PARTICLE_FILE_EXT ".particle"
#define LOG_FILE_EXT ".log"
#define ZIP_FILE_EXT ".zip"
#define FUNCTIONS_FILE_EXT ".functions"
#define SUBDOMAIN_FILE_EXT ".subdomains"
#define SMOLDYN_FILE_EXT ".smoldynOutput"

void avtVCellMTMDFileFormat::readVCellMeshFile()
{
    
    if(vcellMeshInfo.bInit == true){
        return;
    }
    try{
    //Read VCell standard
        string meshFileName = baseFileName+MESH_FILE_EXT;

        ifstream ifs(meshFileName.c_str());

        stringstream ss;

        string line;
        string name;

        getline(ifs, line);
        if(trimCopy(line).find("Version",0) == 0/*!= string::npos*/){
            getline(ifs, line);
        }
        if(trimCopy(line).find("CartesianMesh",0) == 0/*!= string::npos*/){
            getline(ifs, line);
        }else{
            throw "Expected CartesianMesh";
        }
        if(trimCopy(line).find("//",0) == 0/*!= string::npos*/){
            getline(ifs, line);
        }
        if(trimCopy(line).find("Size",0) == 0/*!= string::npos*/){
            ss.clear();
            ss.str(line);
            ss >> name >> vcellMeshInfo.numElementsXYZ[0] >> vcellMeshInfo.numElementsXYZ[1] >> vcellMeshInfo.numElementsXYZ[2];
            getline(ifs, line);
        }else{
            throw "Expected Size";
        }
        if(trimCopy(line).find("Extent",0) == 0/*!= string::npos*/){
            ss.clear();
            ss.str(line);
            ss >> name >> vcellMeshInfo.extentXYZ[0] >> vcellMeshInfo.extentXYZ[1] >> vcellMeshInfo.extentXYZ[2];
            getline(ifs, line);
        }else{
            throw "Expected Extent";
        }
        if(trimCopy(line).find("Origin",0) == 0/*!= string::npos*/){
            ss.clear();
            ss.str(line);
            ss >> name >> vcellMeshInfo.originXYZ[0] >> vcellMeshInfo.originXYZ[1] >> vcellMeshInfo.originXYZ[2];
            getline(ifs, line);
        }else{
            throw "Expected Origin";
        }



        int numVolumeRegions;
        while(trimCopy(line).find("VolumeRegionsMapSubvolume",0) == string::npos){
            getline(ifs, line);
        }
        getline(ifs, line);//read count
        ss.clear();
        ss.str(line);
        ss >> numVolumeRegions;
        getline(ifs, line);//skip annot
        vcellMeshInfo.volumeRegionsMapSubvolume = new int[numVolumeRegions];
        int volregId;
        double volume;
        for(int i=0;i<numVolumeRegions;i++){
            getline(ifs, line);
            trimString(line);
            ss.clear();
            ss.str(line);
            ss >> volregId >> vcellMeshInfo.volumeRegionsMapSubvolume[i] >> volume;
        }

        int numMembraneRegions;
        while(trimCopy(line).find("MembraneRegionsMapVolumeRegion",0) == string::npos){
            getline(ifs, line);
        }
        getline(ifs, line);//read count
        ss.clear();
        ss.str(line);
        ss >> numMembraneRegions;
        getline(ifs, line);//skip annot
        vcellMeshInfo.membraneRegionsMapVolumeRegion = new MembraneRegionsMapVolumeRegion[numMembraneRegions];
        int membregId;
        double surface;
        for(int i=0;i<numMembraneRegions;i++){
            getline(ifs, line);
            trimString(line);
            ss.clear();
            ss.str(line);
            ss >>
                membregId >>
                vcellMeshInfo.membraneRegionsMapVolumeRegion[i].volReg1 >>
                vcellMeshInfo.membraneRegionsMapVolumeRegion[i].volReg2 >> surface;

            vcellMeshInfo.membraneRegionsMapVolumeRegion[i].membregid = membregId;
        }


        while(trimCopy(line).find("VolumeElementsMapVolumeRegion",0) == string::npos){
            getline(ifs, line);
        }
        getline(ifs, line);//numElements and "compressed"
        readVolumeSamples(ifs);



        while(trimCopy(line).find("MembraneElements",0) == string::npos){
            getline(ifs, line);
        }
        getline(ifs, line);//read numMembrelemetns
        ss.clear();
        ss.str(line);
        ss >> vcellMeshInfo.numMembraneElements;
        getline(ifs, line);//skip annot
        vcellMeshInfo.membraneElements = new MembraneElements[vcellMeshInfo.numMembraneElements];
        int throwAway;
        for(int i = 0;i<vcellMeshInfo.numMembraneElements;i++){
            getline(ifs, line);
            ss.clear();
            ss.str(line);
            ss >> throwAway //membraneIndex
                >> vcellMeshInfo.membraneElements[i].volIndex0 >> vcellMeshInfo.membraneElements[i].volIndex1
                >> throwAway >> throwAway >> throwAway >> throwAway //connections
                >> vcellMeshInfo.membraneElements[i].membregid;
        }

        ifs.close();

        calcUCDGridNodes();
        calcUCDMembraneQuads();

    //Find out if Smoldyn dataset
    vcellMeshInfo.isSmoldyn = false;
    string smoldynFileName = baseFileName+SMOLDYN_FILE_EXT;
    struct stat stFileInfo; 
    if(stat(smoldynFileName.c_str(),&stFileInfo) == 0){//file exist test
        vcellMeshInfo.isSmoldyn = true;
    }
        
        vcellMeshInfo.bInit = true;

    }catch(...){
        debug1 << "Error readVCellMeshFile" << endl;
        throw;
    }
    //cout << "spatial dimension =" << vcellMeshInfo.getSpatialdimension() << "test=" << (1+(2>1)) << endl;
}


void avtVCellMTMDFileFormat::readSubDomains(){

    string subdomainFileName = baseFileName+SUBDOMAIN_FILE_EXT;

    struct stat stFileInfo; 
    if( stat(subdomainFileName.c_str(),&stFileInfo) != 0){
        return;
    }

    ifstream ifs(subdomainFileName.c_str());
    string line;
    string name;
    vector<string> oResult;
    while(!getline(ifs, line).eof()){
        trimString(line);
        if(line[0] == '#'){
            continue;
        }
        string comma = ",";
        Tokenize(line,oResult,comma);
        for(size_t i=0;i<oResult.size();i++){
            trimString(oResult[i]);
        }
        istringstream convert;
        if(oResult[0].compare("CompartmentSubDomain") == 0){
            convert.str(oResult[2]);
            int subVolID;
            convert >> subVolID;
            vcellMeshInfo.compartmentSubdomainMap.insert(pair<string,int>(oResult[1],subVolID));
        }else if(oResult[0].compare("MembraneSubDomain") == 0){
            string volName1 = oResult[2];
            int volID1;
            string volName2 = oResult[4];
            int volID2;
            convert.str(oResult[3]);
            convert >> volID1;
            convert.clear();
            convert.str(oResult[5]);
            convert >> volID2;
            pair<string,map<string,int> > tempPair = pair<string,map<string,int> >(oResult[1],map<string,int>());
            vcellMeshInfo.membraneSubdomainMap.insert(tempPair);
            map<string,int> & tempMap = vcellMeshInfo.membraneSubdomainMap[oResult[1]];
            tempMap.insert(pair<string,int>(volName1,volID1));
            tempMap.insert(pair<string,int>(volName2,volID2));
        }else{
            throw "readSubDomains error: unknown subdomain type";
        }
    }

    ifs.close();

}


//Overrride avtMTSDFileFormat::GetAuxiliaryData(...)
void *avtVCellMTMDFileFormat::GetAuxiliaryData(const char *var, int timestep,int domain, const char *type, void *args,DestructorFunction &df)
{
    void *retval = 0;
    
    //if (strcmp(type, AUXILIARY_DATA_GLOBAL_NODE_IDS) == 0){
    //    vtkDataArray *gnid = vtkDataArray::CreateDataArray(VTK_INT);
    //    int totalNodes = calcNodeCount(X_AXIS)*calcNodeCount(Y_AXIS)*calcNodeCount(Z_AXIS);
    //    gnid->SetNumberOfComponents(totalNodes);
    //    gnid->SetNumberOfTuples(1);
    //    int *gnidArr = (int *)gnid->GetVoidPointer(0);
    //    for(int i=0;i<totalNodes;i++){
    //        gnidArr[i] = i;
    //    }
    //    df = avtVariableCache::DestructVTKObject;
    //    return (void *)gnid;
 //   }else 
    if(strcmp(type, AUXILIARY_DATA_MATERIAL) == 0){
        int dims[3] = {1,1,1};
        int ndims = 1;
        int nmats = 0;
        int *matnos = NULL;//new int[nmats];
        char **names = NULL;//new char *[nmats];
        int nzones = 0;
        int *matlist = NULL;//new int[nzones];

        if(string(var).compare(COMPARTMENTSUBDOMAIN_MATERIAL) == 0){
            //structured mesh
            ndims = vcellMeshInfo.getSpatialdimension();
            dims[0] = vcellMeshInfo.numElementsXYZ[0];
            dims[1] = vcellMeshInfo.numElementsXYZ[1];
            dims[2] = vcellMeshInfo.numElementsXYZ[2];
            nmats = (int)vcellMeshInfo.compartmentSubdomainMap.size();
            matnos = new int[nmats];
            for(int i=0;i<nmats;i++){
                matnos[i] =i+1;
            }
            names = new char *[nmats];
            map<string,int>::iterator it;
            //int count = 0;
            for ( it=vcellMeshInfo.compartmentSubdomainMap.begin() ; it != vcellMeshInfo.compartmentSubdomainMap.end(); it++ ){
                int compartmentIndex = it->second;
                names[compartmentIndex] = new char[it->first.size()+1];
                it->first.copy(names[compartmentIndex],it->first.size(),0);
                names[compartmentIndex][it->first.size()] = 0;//null terminate
                //count++;
            }
            nzones = dims[0] * dims[1] * dims[2];
            matlist = new int[nzones];
            for(int i=0;i<nzones;i++){
                matlist[i] = vcellMeshInfo.volumeRegionsMapSubvolume[vcellMeshInfo.volumeElementsMapVolumeRegion[i]] + 1;
                //if(matlist[i] >= nmats){
                //        cout << "wrong" << endl;
                //}
            }
            avtMaterial *mat = new avtMaterial(nmats,matnos,names,ndims,dims,0,matlist,0,NULL,NULL,NULL,NULL);
            retval = (void *)mat;

        }else if(string(var).compare(MEMBRANESUBDOMAIN_MATERIAL) == 0){
            //unstructured mesh
            ndims = 1;
            dims[0] = vcellMeshInfo.numMembraneElements;
            nmats = (int)vcellMeshInfo.membraneSubdomainMap.size();
            matnos = new int[nmats];
            for(int i=0;i<nmats;i++){
                matnos[i] =i/*+1*/;
            }
            names = new char *[nmats];
            int count = 0;
            map<string,map<string,int> >::iterator it;
            for ( it=vcellMeshInfo.membraneSubdomainMap.begin() ; it != vcellMeshInfo.membraneSubdomainMap.end(); it++ ){
                names[count] = new char[it->first.size()+1];
                it->first.copy(names[count],it->first.size(),0);
                names[count][it->first.size()] = 0;//null terminate
                count++;
            }
            nzones = vcellMeshInfo.numMembraneElements;
            matlist = new int[nzones];
            for(int i=0;i<nzones;i++){
                int volIndex0 = vcellMeshInfo.membraneElements[i].volIndex0;
                int volIndex1 = vcellMeshInfo.membraneElements[i].volIndex1;
                int volReg0 = vcellMeshInfo.volumeElementsMapVolumeRegion[volIndex0];
                int volReg1 = vcellMeshInfo.volumeElementsMapVolumeRegion[volIndex1];
                int subVolID0 = vcellMeshInfo.volumeRegionsMapSubvolume[volReg0];
                int subVolID1 = vcellMeshInfo.volumeRegionsMapSubvolume[volReg1];
                map<string,map<string,int> >::iterator it;
                int membraneSubVolume = 0;
                for ( it=vcellMeshInfo.membraneSubdomainMap.begin() ; it != vcellMeshInfo.membraneSubdomainMap.end(); it++ ){
                    map<string,int>::iterator it2 = it->second.begin();
                    int membrSubVol0 = it2++->second;
                    int membrSubVol1 = it2->second;
                    //for(it2=it->second.begin();it2 != it->second.end();it2++){
                        if((membrSubVol0 == subVolID0 && membrSubVol1 == subVolID1) ||
                            (membrSubVol0 == subVolID1 && membrSubVol1 == subVolID0)){

                            matlist[i] = membraneSubVolume/*+1*/;
                        }
                    //}
                    membraneSubVolume++;
                }
                //if(matlist[i] >= nmats){
                //    cout << "wrong" << endl;
                //}
            }

            vector<string> matNamesV;
            for(int i=0;i<nmats;i++){
                matNamesV.push_back(string(names[i]));
            }
            avtMaterial *mat = new avtMaterial(nmats,matNamesV,nzones,matlist,0,NULL,NULL,NULL,NULL);
            retval = (void *)mat;

        }else{
            return NULL;
        }

        // Clean up.
        delete [] matlist;
        delete [] matnos;
        for(int i = 0; i < nmats; ++i){
            delete [] names[i];
        }
        delete [] names;
        df = avtMaterial::Destruct;

        return retval;
    }

    return NULL;


//void *retval = 0;
//if(strcmp(type, AUXILIARY_DATA_MATERIAL) == 0)
//{
//int dims[3] = {1,1,1}, ndims = 1;
//// Structured mesh case
//ndims = MESH DIMENSION, 2 OR 3;
//dims[0] = NUMBER OF ZONES IN X DIMENSION;
//dims[1] = NUMBER OF ZONES IN Y DIMENSION;
//dims[2] = NUMBER OF ZONES IN Z DIMENSION, OR 1 IF 2D;
//// Unstructured mesh case
//dims[0] = NUMBER OF ZONES IN THE MESH
//ndims = 1;
//// Read the number of materials from the file. This
//Listing 4-39: matclean.C: C++ Language example for returning material data.
//Creating a database reader plugin
//Advanced topics 135
//// must have already been read from the file when
//// PopulateDatabaseMetaData was called.
//int nmats = NUMBER OF MATERIALS;
//// The matnos array contains the list of numbers that
//// are associated with particular materials. For example,
//// matnos[0] is the number that will be associated with
//// the first material and any time it is seen in the
//// matlist array, that number should be taken to mean
//// material 1. The numbers in the matnos array must
//// all be greater than or equal to 1.
//int *matnos = new int[nmats];
//READ nmats INTEGER VALUES INTO THE matnos ARRAY.
//// Read the material names from your file format or
//// make up names for the materials. Use the same
//// approach as when you created material names in
//// the PopulateDatabaseMetaData method.
//char **names = new char *[nmats];
//READ MATERIAL NAMES FROM YOUR FILE FORMAT UNTIL EACH
//ELEMENT OF THE names ARRAY POINTS TO ITS OWN STRING.
//// Read the matlist array, which tells what the material
//// is for each zone in the mesh.
//int nzones = dims[0] * dims[1] * dims[2];
//int *matlist = new int[nzones];
//READ nzones INTEGERS INTO THE matlist array.
//// Optionally create mix_mat, mix_next, mix_zone, mix_vf
//// arrays and read their contents from the file format.
//// Use the information to create an avtMaterial object.
//avtMaterial *mat = new avtMaterial(
//nmats,
//matnos,
//names,
//ndims,
//dims,
//0,
//matlist,
//0, // length of mix arrays
//0, // mix_mat array
//0, // mix_next array
//0, // mix_zone array
//0 // mix_vf array
//);
//// Clean up.
//delete [] matlist;
//delete [] matnos;
//for(int i = 0; i < nmats; ++i)
//delete [] names[i];
//delete [] names;
//Creating a database reader plugin
//136 Advanced topics
//// Set the return values.
//retval = (void *)mat;
//df = avtMaterial::Destruct;
//}
//return retval;
}

void avtVCellMTMDFileFormat::createSubDomainMaterials(avtDatabaseMetaData *md){

    string mesh_for_mat = VOLMESH;
    string matname = COMPARTMENTSUBDOMAIN_MATERIAL;
    int nmats = vcellMeshInfo.compartmentSubdomainMap.size();
    vector<string> mnames;
    map<string,int>::iterator it;
    if(nmats != 0){
        for ( it=vcellMeshInfo.compartmentSubdomainMap.begin() ; it != vcellMeshInfo.compartmentSubdomainMap.end(); it++ ){
            mnames.push_back(it->first);
        }
        AddMaterialToMetaData(md, matname, mesh_for_mat, nmats, mnames);
    }

    mesh_for_mat = MEMBRMESH;
    matname = MEMBRANESUBDOMAIN_MATERIAL;
    nmats = (int)vcellMeshInfo.membraneSubdomainMap.size();
    mnames.clear();
    map<string,map<string,int> >::iterator it2;
    if(nmats != 0){
        for ( it2=vcellMeshInfo.membraneSubdomainMap.begin() ; it2 != vcellMeshInfo.membraneSubdomainMap.end(); it2++ ){
            mnames.push_back(it2->first);
        }
        AddMaterialToMetaData(md, matname, mesh_for_mat, nmats, mnames);
    }

}

void avtVCellMTMDFileFormat::setMaterialRestricted(avtDatabaseMetaData *md,avtVarMetaData * varMetaData){
    string domainName = findDomainName(varMetaData->name);
    if(varMetaData->meshName.compare(VOLMESH) == 0){
        const avtMaterialMetaData *vol_mmd = md->GetMaterialOnMesh(VOLMESH);
        if(vol_mmd == NULL){
            return;
        }
        for(int j=0;j<vol_mmd->numMaterials;j++){
            if(domainName.compare(vol_mmd->materialNames[j]) == 0){
                varMetaData->matRestricted.push_back(j);
                break;
            }
        }
    }else if(varMetaData->meshName.compare(MEMBRMESH) == 0){
        const avtMaterialMetaData *membr_mmd = md->GetMaterialOnMesh(MEMBRMESH);
        if(membr_mmd == NULL){
            return;
        }
        for(int j=0;j<membr_mmd->numMaterials;j++){
            if(domainName.compare(membr_mmd->materialNames[j]) == 0){
                varMetaData->matRestricted.push_back(j);
                break;
            }
        }
    }
}


// ****************************************************************************
//  Method: avtVCellMTMDFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: frm -- generated by xml2avt
//  Creation:   Sat Oct 23 13:29:29 PST 2010
//
// ****************************************************************************

const string VARTYPENAME [] = {"unknown","volume","membrane","contour","vol_region","membr_region","contour_region"};
void
avtVCellMTMDFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{

    //const avtMaterialMetaData *mmd = md->GetMaterialOnMesh(meshname);
    //vector<int> restrictToMats;
//for (j = 0; j < mmd->numMaterials; j++){
//                // The 'materialNames' Silo plugin creates are either
//                // "%d (matno)" or "%d (matno) %s (matname)". Either way,
//                // strtol should convert the number part correctly.
//                errno = 0;
//                int matno = strtol(mmd->materialNames[j].c_str(), 0, 10);
//                if (errno == 0 && regno == matno)
//                    restrictToMats->push_back(j);
//}
//smd->matRestricted = restrictToMats;

    readVCellMeshFile();
    AddMeshToMetaData(md,VOLMESH,AVT_RECTILINEAR_MESH,vcellMeshInfo.getExtents(),1,0,/*spatial dim*/vcellMeshInfo.getSpatialdimension(),/*topo dim*/vcellMeshInfo.getSpatialdimension());
     AddMeshToMetaData(md,MEMBRMESH,AVT_UNSTRUCTURED_MESH,vcellMeshInfo.getExtents(),1,0,/*spatial dim*/vcellMeshInfo.getSpatialdimension(),/*topo dim*/vcellMeshInfo.getSpatialdimension()-1);
  
    if(vcellMeshInfo.isSmoldyn){
         AddMeshToMetaData(md,POINTMESH,AVT_UNSTRUCTURED_MESH,vcellMeshInfo.getExtents(),1,0,/*spatial dim*/vcellMeshInfo.getSpatialdimension(),/*topo dim*/1);
    }

    readSubDomains();
    createSubDomainMaterials(md);

    readStateVariables();
    readFunctions(md);

    //const avtMaterialMetaData *vol_mmd = md->GetMaterialOnMesh(VOLMESH);
    //const avtMaterialMetaData *membr_mmd = md->GetMaterialOnMesh(MEMBRMESH);
    //int volSize = vcellMeshInfo.numElementsXYZ[0]*vcellMeshInfo.numElementsXYZ[1]*vcellMeshInfo.numElementsXYZ[2];
    //int membrSize = vcellMeshInfo.numMembraneElements;
    for(size_t i = 0;i<variableNames.size();i++){
        //if(variableNames[i].size == volSize){
        if(variableNames[i].varType == VAR_VOLUME || variableNames[i].varType == VAR_VOLUME_REGION){
            avtScalarMetaData *smd = new avtScalarMetaData;
            smd->name = string(variableNames[i].varName)/*+"___"+VARTYPENAME[variableNames[i].varType]*/;
            smd->meshName = VOLMESH;
            smd->centering = AVT_ZONECENT;
            smd->hasUnits = true;
            smd->units = "Unknown";
            setMaterialRestricted(md,smd);
            //for(int j=0;j<vol_mmd->numMaterials;j++){
            //    if(variableNames[i].domainName.compare(vol_mmd->materialNames[j]) == 0){
            //        smd->matRestricted.push_back(j);
            //        break;
            //    }
            //}
            md->Add(smd);

            if(vcellMeshInfo.isSmoldyn){
                ostringstream oss;
                oss << i;
                string strDigit = string(oss.str());
                string pointDigit = (i < 100?string("0"):string(""))+(i<10?string("0"):string(""))+strDigit;
                
                avtScalarMetaData *smd2 = new avtScalarMetaData;
                smd2->name = string(variableNames[i].varName)+string("_points_")+pointDigit;
                smd2->meshName = POINTMESH;
                smd2->centering = AVT_ZONECENT;
                smd2->hasUnits = true;
                smd2->units = "Unknown";
                //smd2->matRestricted.push_back(smd->matRestricted[0]);
                //setMaterialRestricted(md,smd);
                md->Add(smd2);
            }

        //}else if(variableNames[i].size == membrSize){
        }else if(variableNames[i].varType == VAR_MEMBRANE || variableNames[i].varType == VAR_MEMBRANE_REGION){
            avtScalarMetaData *smd = new avtScalarMetaData;
            smd->name = string(variableNames[i].varName)/*+"___"+VARTYPENAME[variableNames[i].varType]*/;
            smd->meshName = MEMBRMESH;
            smd->centering = AVT_ZONECENT;
            smd->hasUnits = true;
            smd->units = "Unknown";
            setMaterialRestricted(md,smd);
            //for(int j=0;j<membr_mmd->numMaterials;j++){
            //    if(variableNames[i].domainName.compare(membr_mmd->materialNames[j]) == 0){
            //        smd->matRestricted.push_back(j);
            //        break;
            //    }
            //}
            md->Add(smd);
        }else{
            debug1 << "VariableName=" << variableNames[i].varName
                << " VariableSize=" << variableNames[i].size
                << " VariableDomain=" << variableNames[i].domainName
                << " VariableType=" << variableNames[i].varType << endl;
        }
    }

    for(size_t i=0;i<membrSubstVariables.size();i++){
        avtScalarMetaData *smd = new avtScalarMetaData;
        smd->name = membrSubstVariables[i].convertVolToMembrName;
        smd->meshName = MEMBRMESH;
        smd->centering = AVT_ZONECENT;
        smd->hasUnits = true;
        smd->units = "Unknown";
        setMaterialRestricted(md,smd);
        //for(int j=0;j<membr_mmd->numMaterials;j++){
        //    if(membrSubstVariables[i].membrFuncDomainName.compare(membr_mmd->materialNames[j]) == 0){
        //        smd->matRestricted.push_back(j);
        //        break;
        //    }
        //}
        md->Add(smd);
    }

    for(size_t i=0;i<regionSubstVariables.size();i++){
        avtScalarMetaData *smd = new avtScalarMetaData;
        smd->name = regionSubstVariables[i].regionSubstName;
        if(regionSubstVariables[i].varType == VAR_VOLUME_REGION){
            smd->meshName = VOLMESH;
        }else{
            smd->meshName = MEMBRMESH;
        }
        smd->centering = AVT_ZONECENT;
        smd->hasUnits = true;
        smd->units = "Unknown";
        setMaterialRestricted(md,smd);
        //for(int j=0;j<membr_mmd->numMaterials;j++){
        //    if(regionSubstVariables[i].membrFuncDomainName.compare(membr_mmd->materialNames[j]) == 0){
        //        smd->matRestricted.push_back(j);
        //        break;
        //    }
        //}
        md->Add(smd);
    }


    //
    // CODE TO ADD A MESH
    //
    // string meshname = ...
    //
    // AVT_RECTILINEAR_MESH, AVT_CURVILINEAR_MESH, AVT_UNSTRUCTURED_MESH,
    // AVT_POINT_MESH, AVT_SURFACE_MESH, AVT_UNKNOWN_MESH
    // avtMeshType mt = AVT_RECTILINEAR_MESH;
    //
    // int nblocks = YOU_MUST_DECIDE;
    // int block_origin = 0;
    // int spatial_dimension = 2;
    // int topological_dimension = 2;
    // double *extents = NULL;
    //
    // Here's the call that tells the meta-data object that we have a mesh:
    //
    // AddMeshToMetaData(md, meshname, mt, extents, nblocks, block_origin,
    //                   spatial_dimension, topological_dimension);
    //

    //
    // CODE TO ADD A SCALAR VARIABLE
    //
    // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    // string varname = ...
    //
    // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    // avtCentering cent = AVT_NODECENT;
    //
    //
    // Here's the call that tells the meta-data object that we have a var:
    //
    // AddScalarVarToMetaData(md, varname, mesh_for_this_var, cent);
    //

    //
    // CODE TO ADD A VECTOR VARIABLE
    //
    // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    // string varname = ...
    // int vector_dim = 2;
    //
    // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    // avtCentering cent = AVT_NODECENT;
    //
    //
    // Here's the call that tells the meta-data object that we have a var:
    //
    // AddVectorVarToMetaData(md, varname, mesh_for_this_var, cent,vector_dim);
    //

    //
    // CODE TO ADD A TENSOR VARIABLE
    //
    // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    // string varname = ...
    // int tensor_dim = 9;
    //
    // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    // avtCentering cent = AVT_NODECENT;
    //
    //
    // Here's the call that tells the meta-data object that we have a var:
    //
    // AddTensorVarToMetaData(md, varname, mesh_for_this_var, cent,tensor_dim);
    //

    //
    // CODE TO ADD A MATERIAL
    //
    // string mesh_for_mat = meshname; // ??? -- could be multiple meshes
    // string matname = ...
    // int nmats = ...;
    // vector<string> mnames;
    // for (int i = 0 ; i < nmats ; i++)
    // {
    //     char str[32];
    //     sprintf(str, "mat%d", i);
    //     -- or -- 
    //     strcpy(str, "Aluminum");
    //     mnames.push_back(str);
    // }
    // 
    // Here's the call that tells the meta-data object that we have a mat:
    //
    // AddMaterialToMetaData(md, matname, mesh_for_mat, nmats, mnames);
    //
    //
    // Here's the way to add expressions:
    //Expression momentum_expr;
    //momentum_expr.SetName("momentum");
    //momentum_expr.SetDefinition("{u, v}");
    //momentum_expr.SetType(Expression::VectorMeshVar);
    //md->AddExpression(&momentum_expr);
    //Expression KineticEnergy_expr;
    //KineticEnergy_expr.SetName("KineticEnergy");
    //KineticEnergy_expr.SetDefinition("0.5*(momentum*momentum)/(rho*rho)");
    //KineticEnergy_expr.SetType(Expression::ScalarMeshVar);
    //md->AddExpression(&KineticEnergy_expr);
    //
}


// ****************************************************************************
//  Method: avtVCellMTMDFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: frm -- generated by xml2avt
//  Creation:   Sat Oct 23 13:29:29 PST 2010
//
// ****************************************************************************

vtkDataSet *
avtVCellMTMDFileFormat::GetMesh(int timestate, int domain, const char *meshname)
{
       if(meshname[0] == 'v'){//volumeMesh
        // Read the ndims and number of X,Y,Z nodes from file.
        int ndims = vcellMeshInfo.getSpatialdimension();
        //int dims[3] = {vcellMeshInfo.numElementsXYZ[0],vcellMeshInfo.numElementsXYZ[1],vcellMeshInfo.numElementsXYZ[2]};
        int dims[3] = {calcNodeCount(X_AXIS),calcNodeCount(Y_AXIS),calcNodeCount(Z_AXIS)};
        int DZ = calcNodeCount(X_AXIS)*calcNodeCount(Y_AXIS);

        vtkFloatArray *coords[3] = {0,0,0};
        // Read the X coordinates from the file.
        coords[0] = vtkFloatArray::New();
        coords[0]->SetNumberOfTuples(dims[0]);
        float *xarray = (float *)coords[0]->GetVoidPointer(0);
        for(int n = 0;n<calcNodeCount(X_AXIS)/*dims[0]*/;n++){
            xarray[n] = ucdMeshNodes[n].x;

            //xarray[n] = vcellMeshInfo.originXYZ[0]+n*(vcellMeshInfo.extentXYZ[0]/(dims[0]-1));

            //xarray[n] = ((float)n/(dims[0]-1))*vcellMeshInfo.extentXYZ[0] + vcellMeshInfo.originXYZ[0];
            //if(n==0){
            //    xarray[n]-= vcellMeshInfo.extentXYZ[0]/((float)(dims[0]))/2.0;
            //}
            //if(n == dims[0]-1){
            //    xarray[n]+= vcellMeshInfo.extentXYZ[0]/((float)(dims[0]))/2.0;
            //}
        }
        //READ dims[0] FLOAT VALUES INTO xarray
        // Read the Y coordinates from the file.
        coords[1] = vtkFloatArray::New();
        coords[1]->SetNumberOfTuples(dims[1]);
        float *yarray = (float *)coords[1]->GetVoidPointer(0);
        for(int n = 0;n<calcNodeCount(Y_AXIS)/*(dims[1] > 1) && n<dims[1]*/;n++){
            yarray[n] = ucdMeshNodes[n*calcNodeCount(X_AXIS)].y;

            //yarray[n] = vcellMeshInfo.originXYZ[1]+n*(vcellMeshInfo.extentXYZ[1]/(dims[1]-1));
        }
        //READ dims[1] FLOAT VALUES INTO yarray
        // Read the Z coordinates from the file.
        coords[2] = vtkFloatArray::New();
        if(ndims > 2)
        {
        coords[2]->SetNumberOfTuples(dims[2]);
        float *zarray = (float *)coords[2]->GetVoidPointer(0);
        for(int n = 0;n<calcNodeCount(Z_AXIS)/*(dims[2] > 1) && n<dims[2]*/;n++){
            zarray[n] = ucdMeshNodes[n*DZ].z;

            //zarray[n] = vcellMeshInfo.originXYZ[2]+n*(vcellMeshInfo.extentXYZ[2]/(dims[2]-1));
        }
        //READ dims[2] FLOAT VALUES INTO zarray
        }
        else
        {
        coords[2]->SetNumberOfTuples(1);
        coords[2]->SetComponent(0, 0, 0.);
        }
        //
        // Create the vtkRectilinearGrid object and set its dimensions
        // and coordinates.
        //
        vtkRectilinearGrid *rgrid = vtkRectilinearGrid::New();
        rgrid->SetDimensions(dims);
        rgrid->SetXCoordinates(coords[0]);
        coords[0]->Delete();
        rgrid->SetYCoordinates(coords[1]);
        coords[1]->Delete();
        rgrid->SetZCoordinates(coords[2]);
        coords[2]->Delete();
        return rgrid;
    }else if (meshname[0] == 'm'){//membraneMesh

        int ndims = vcellMeshInfo.getSpatialdimension();
        vtkPoints *points = vtkPoints::New();
        points->SetDataTypeToFloat();
        int totalNodes = calcNodeCount(X_AXIS)*calcNodeCount(Y_AXIS)*calcNodeCount(Z_AXIS);
        points->SetNumberOfPoints(totalNodes);
        for (int i=0; i<totalNodes; i++){
            float x = (float)ucdMeshNodes[i].x;
            float y = (ndims > 1?(float)ucdMeshNodes[i].y:0);
            float z = (ndims > 2?(float)ucdMeshNodes[i].z:0);
            points->SetPoint(i,x,y,z);
        }

        vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::New();
        ugrid->SetPoints(points);
        points->Delete();
        ugrid->Allocate(vcellMeshInfo.numMembraneElements);
        
        if(vcellMeshInfo.getSpatialdimension() == 3){
            for (int i=0; i<vcellMeshInfo.numMembraneElements; i++){
                vtkIdType ids[4];
                int *iptr = membrQuadNodes+i*4;
                ids[0] = (vtkIdType)iptr[0];
                ids[1] = (vtkIdType)iptr[1];
                ids[2] = (vtkIdType)iptr[2];
                ids[3] = (vtkIdType)iptr[3];
                ugrid->InsertNextCell(VTK_QUAD,4,ids);
            }
        }else{
            for (int i=0; i<vcellMeshInfo.numMembraneElements; i++){
                vtkIdType ids[2];
                int *iptr = membrQuadNodes+i*4;
                ids[0] = (vtkIdType)iptr[0];
                ids[1] = (vtkIdType)iptr[1];
                ugrid->InsertNextCell(VTK_LINE,2,ids);
            }
        }

        return ugrid;

        //int i;

        //vtkPoints *points = vtkPoints::New();
        //vtkCellArray *polys = vtkCellArray::New();

        //int totalNodes = calcNodeCount(X_AXIS)*calcNodeCount(Y_AXIS)*calcNodeCount(Z_AXIS);
        //for (i=0; i<totalNodes; i++){
        //    points->InsertPoint(i,ucdMeshNodes[i].x,ucdMeshNodes[i].y,ucdMeshNodes[i].z);
        //}

        //for (i=0; i<vcellMeshInfo.numMembraneElements; i++){
        //    polys->InsertNextCell(4,(membrQuadNodes+i*4));
        //}

        //vtkPolyData *membranePolyData = vtkPolyData::New();
        //membranePolyData->SetPoints(points);
        //points->Delete();
        //membranePolyData->SetPolys(polys);
        //polys->Delete();
        //return membranePolyData;
    }else if (meshname[0] == 'p'){//pointMesh for smoldyn
        int smoldynTimeIndex = timestate+1;
        ostringstream oss;
        oss << smoldynTimeIndex;//smoldyn really starts file numbering at 1 (not 0)
        string strDigit = string(oss.str());

        string timeDigit = (smoldynTimeIndex < 100?string("0"):string(""))+(smoldynTimeIndex<10?string("0"):string(""))+strDigit;
        string meshFileName = baseFileName+"_"+timeDigit+SMOLDYN_FILE_EXT;
        ifstream ifs(meshFileName.c_str());
        stringstream ss;
        string line;
        string name;

        smoldynDataValues = vtkDoubleArray::New();
        
        vtkPoints *p = vtkPoints::New();
        float x=0.0,y=0.0,z=0.0;
        string lastFoundVarName("");
        double lastFoundVal = 0; //TODO: check on fix for uninitialized vars
        while(ifs.eof() == 0){
            getline(ifs,line);
            trimString(line);
            if(line.size() > 0){
                ss.clear();
                ss.str(line);
                if(vcellMeshInfo.getSpatialdimension() == 3){
                    ss >> name >> x >> y >> z;
                }else{
                    ss >> name >> x >> y;
                }
                p->InsertNextPoint(x,y,z);
            
                //save data values for this timepoint
                string varName = name.substr(0,name.find("(",0));
                if(lastFoundVarName.compare(varName) != 0){
                    for(size_t i = 0;i<variableNames.size();i++){
                        string datablockVarName(variableNames[i].varName);
                        if(datablockVarName.compare(varName) == 0){
                            lastFoundVarName = datablockVarName;
                            lastFoundVal = i;
                            break;
                        }
                    }
                }
                smoldynDataValues->InsertNextValue(lastFoundVal);
            }
        }

        ifs.close();

        vtkUnstructuredGrid *pMesh = vtkUnstructuredGrid::New();
        pMesh->SetPoints(p);
        p->Delete();

        pMesh->Allocate(pMesh->GetNumberOfPoints());
        vtkIdType onevertex[1];
        for(int i=0;i<pMesh->GetNumberOfPoints();i++){
            onevertex[0] = i;
            pMesh->InsertNextCell(VTK_VERTEX,1,onevertex);
        }
        return pMesh;
    }else{
        throw "VCellMTMD plugin GetMesh(...) error: Unknown mesh type";
    }

}
/*
#ifndef DIRECTORY_SEPARATOR
#if ( defined(WIN32) || defined(WIN64) )
#define DIRECTORY_SEPARATOR '\\'
#else
#define DIRECTORY_SEPARATOR '/'
#endif
#endif
*/
// ****************************************************************************
//  Method: avtVCellMTMDFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: frm -- generated by xml2avt
//  Creation:   Sat Oct 23 13:29:29 PST 2010
//
// ****************************************************************************

vtkDataArray *
avtVCellMTMDFileFormat::GetVar(int timestate, int domain, const char *varname)
{
    if(vcellMeshInfo.isSmoldyn &&
        string(varname).size() > (8 + 3) &&
        string(varname).find(string("_points_"),string(varname).size()-(8 + 3)) != string::npos){
        //values already read during getMesh(...) for each timepoint
/*
        int dataVal
        for(int i = 0;i<variableNames.size();i++){
            if(variableNames[i].compare(varName){
                lastFoundVarName = variableNames[i];
                lastFoundVal = i;
                break;
            }
        }
*/
        return smoldynDataValues;
    }

    string zipfilename = vcellLogEntryList[timestate].zipFileName;
    string simFileName = vcellLogEntryList[timestate].simFileName;
    struct stat buf;
    if (bSimZip) {
        // check if zip file exists
        //char zipfileabsolutename[512];
        stripToBaseName(zipfilename);
/*
        string::size_type pos = zipfilename.rfind('\\');
        if (pos != string::npos) {
            zipfilename.erase(0,pos + 1);
        }
        pos = zipfilename.rfind('/');
        if (pos != string::npos) {
            zipfilename.erase(0,pos + 1);
        }
*/
        zipfilename = baseDirName+zipfilename;
        if (stat(zipfilename.c_str(), &buf)) {
            string temp = "readVariable(), unable to open zip file "+zipfilename;
            throw temp;
            //EXCEPTION1(InvalidDBTypeException,temp.c_str());
        } else {
            // unzip the file (without directory) into exdir, currently we
            // unzip the file to the current working directory
            char errmsg[128];
            zipUnzipWithRetry(zipfilename.c_str(), simFileName.c_str(), errmsg);
        }
    }            
    
    // otherwise check if sim file exists
    if (stat(simFileName.c_str(), &buf)) {
        string temp = "readVariable(), unable to open zip file "+simFileName;
        throw temp;
        //EXCEPTION1(InvalidDBTypeException,temp.c_str());
    } 
    //else {
        //try {
            //readSimFileHeader((char*)simFileName.c_str());
            vtkDoubleArray *rv = vtkDoubleArray::New();
            readVariableValues(simFileName.c_str(),string(varname),rv);
            if (bSimZip) {
                remove(simFileName.c_str());
            }
            return rv;
            //DataSet::read(dataFileName, simulation);
            //simulation->setCurrIteration(tempIteration);
            //simFileCount = tempFileCount;

            //if (bSimZip) {
            //    remove(dataFileName);
            //    zipFileCount = getZipCount(zipFileName);
            //    // wrong zip file Name
            //    if (zipFileCount < 0) { // should never happen
            //    }  else {
            //        // check if this zip file is already big enough
            //        if (stat(zipFileName, &buf) == 0) {
            //            if (buf.st_size > ZIP_FILE_LIMIT) {
            //                zipFileCount ++;
            //            }
            //        }
            //    }
            //} 
            
        //} catch (const char* msg) {
        //    cout << "SimTool::loadFinal() : dataSet.read(" << simFileName << " failed : " << msg << endl;
        //} catch (...) {
        //    cout << "SimTool::loadFinal() : dataSet.read(" << simFileName << " failed : unexpected error" << endl;
        //}
    //}            



    //YOU MUST IMPLEMENT THIS

    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.
    //
    // EXCEPTION1(InvalidVariableException, varname);
    //

    //
    // If you do have a scalar variable, here is some code that may be helpful.
    //
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // rv->SetNumberOfTuples(ntuples);
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      rv->SetTuple1(i, VAL);  // you must determine value for ith entry.
    // }
    //
    // return rv;
    //
}

const int VCREGTYPE_NORMAL = 0;
const int VCREGTYPE_SPECIAL = 1;
const int VCREGTYPE_SUBST = 2;

void avtVCellMTMDFileFormat::readVariableValues(const char * simFileName,string varnameIN,vtkDoubleArray * dataHolder){

    string varname = varnameIN;

    size_t substPosition = varname.find(string("_subst"));
    bool bSubstitute = substPosition != string::npos;
    if(bSubstitute){
        varname = varname.substr(0,varname.size()-string("_subst").size());
    }
    int regionVarType = -1;
    if(varname.find(REGIONPREFIX) != string::npos){
        if(varname.find("__") != string::npos){
            regionVarType = VCREGTYPE_SUBST;
            varname = varnameIN.substr(0,varname.find("__"));
        }else if(varname.find("_") != string::npos){
            regionVarType = VCREGTYPE_SPECIAL;
            varname = varnameIN.substr(0,varname.find("_"));
        }else{
            regionVarType = VCREGTYPE_NORMAL;
        }
    }



    FILE *fp=NULL;

    DataBlock * varDataBlock = NULL;
    for(size_t i=0;i<variableNames.size();i++){
        if(varname.compare(string(variableNames[i].varName)) == 0){
            varDataBlock = &(variableNames[i]);
            break;
        }
    }
    if(varDataBlock == NULL){
        throw "readVariableValues: error - couldn't find varname";
    }

    if ((fp=fopen(simFileName, "rb"))==NULL){
        char errmsg[512];
        sprintf(errmsg, "DataSet::read() - could not open file '%s'.", simFileName); 
        throw errmsg;
    }

    if (fseek(fp, varDataBlock->dataOffset, SEEK_SET)){
            char errmsg[512];
            sprintf(errmsg, "DataSet::read() - could not find data offset ( %d ).", varDataBlock->dataOffset); 
            throw errmsg;
        }


    if(bSubstitute){
        //read volume
        double * tempValues = new double[varDataBlock->size];
        readDoubles(fp, tempValues, varDataBlock->size);
        //read membrane
        vector<int> * volIndexes = NULL; //TODO: check on fix for uninitialized vars //fakeVariables[varnameIN];
        for(size_t i=0;i<membrSubstVariables.size();i++){
            if(membrSubstVariables[i].convertVolToMembrName.compare(varnameIN) == 0){
                volIndexes = &(membrSubstVariables[i].volumeIndexes);
                break;
            }
        }
        dataHolder->SetNumberOfTuples(vcellMeshInfo.numMembraneElements);
        double *values = (double *)dataHolder->GetVoidPointer(0);
        for(int i=0;i<vcellMeshInfo.numMembraneElements;i++){
            values[i] = tempValues[(*volIndexes)[i]];
        }
        delete [] tempValues;
    }else{
        if(regionVarType != -1){
            int NUMVOLELEMENTS = vcellMeshInfo.numElementsXYZ[0]*vcellMeshInfo.numElementsXYZ[1]*vcellMeshInfo.numElementsXYZ[2];
            //read region values (position in list imply region index)
            double * regionValues = new double[varDataBlock->size];
            readDoubles(fp, regionValues, varDataBlock->size);
            if(regionVarType == VCREGTYPE_NORMAL || regionVarType == VCREGTYPE_SUBST){
                if(varname.find(REGIONVOLUME) != string::npos){
                    dataHolder->SetNumberOfTuples(NUMVOLELEMENTS);
                    double *values = (double *)dataHolder->GetVoidPointer(0);
                    for (int i=0;i<NUMVOLELEMENTS;i++){
                        values[i] = regionValues[vcellMeshInfo.volumeElementsMapVolumeRegion[i]];
                    }
                }else{
                    dataHolder->SetNumberOfTuples(vcellMeshInfo.numMembraneElements);
                    double *values = (double *)dataHolder->GetVoidPointer(0);
                    for (int i=0;i<vcellMeshInfo.numMembraneElements;i++){
                        values[i] = regionValues[vcellMeshInfo.membraneElements[i].membregid];
                    }
                }
            }/*else if(regionVarType == VCREGTYPE_SUBST){
                if(varname.find(REGIONVOLUME) != string::npos){
                    dataHolder->SetNumberOfTuples(NUMVOLELEMENTS);
                    double *values = (double *)dataHolder->GetVoidPointer(0);
                    for (int i=0;i<NUMVOLELEMENTS;i++){
                        values[i] = -1;
                    }
                }else{
                    dataHolder->SetNumberOfTuples(vcellMeshInfo.numMembraneElements);
                    double *values = (double *)dataHolder->GetVoidPointer(0);
                    for (int i=0;i<vcellMeshInfo.numMembraneElements;i++){
                        values[i] = -1;
                    }
                }
            }*/else if(regionVarType == VCREGTYPE_SPECIAL){
                if(varname.find(REGIONVOLUME) != string::npos){
                    dataHolder->SetNumberOfTuples(NUMVOLELEMENTS);
                    double *values = (double *)dataHolder->GetVoidPointer(0);
                    for (int i=0;i<NUMVOLELEMENTS;i++){
                        values[i] = -1;
                    }
                }else{
                    dataHolder->SetNumberOfTuples(vcellMeshInfo.numMembraneElements);
                    double *values = (double *)dataHolder->GetVoidPointer(0);
                    for (int i=0;i<vcellMeshInfo.numMembraneElements;i++){
                        values[i] = -1;
                    }
                }
            }
            delete [] regionValues;
        }else{
            dataHolder->SetNumberOfTuples(varDataBlock->size);
            double *values = (double *)dataHolder->GetVoidPointer(0);
            readDoubles(fp, values, varDataBlock->size);
        }
    }

    fclose(fp);
}


// ****************************************************************************
//  Method: avtVCellMTMDFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: frm -- generated by xml2avt
//  Creation:   Sat Oct 23 13:29:29 PST 2010
//
// ****************************************************************************

vtkDataArray *
avtVCellMTMDFileFormat::GetVectorVar(int timestate, int domain,const char *varname)
{
    return NULL;
    //YOU MUST IMPLEMENT THIS
    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.
    //
    // EXCEPTION1(InvalidVariableException, varname);
    //

    //
    // If you do have a vector variable, here is some code that may be helpful.
    //
    // int ncomps = YYY;  // This is the rank of the vector - typically 2 or 3.
    // int ntuples = XXX; // this is the number of entries in the variable.
    // vtkFloatArray *rv = vtkFloatArray::New();
    // int ucomps = (ncomps == 2 ? 3 : ncomps);
    // rv->SetNumberOfComponents(ucomps);
    // rv->SetNumberOfTuples(ntuples);
    // float *one_entry = new float[ucomps];
    // for (int i = 0 ; i < ntuples ; i++)
    // {
    //      int j;
    //      for (j = 0 ; j < ncomps ; j++)
    //           one_entry[j] = ...
    //      for (j = ncomps ; j < ucomps ; j++)
    //           one_entry[j] = 0.;
    //      rv->SetTuple(i, one_entry); 
    // }
    //
    // delete [] one_entry;
    // return rv;
    //
}

void avtVCellMTMDFileFormat::readLog(string& logFileName)
{
    vcellLogEntryList.clear();
    //
    // read '.log' file to determine simulation time and iteration
    //
    if (logFileName.length() == 0) {
        EXCEPTION1(InvalidDBTypeException,"log file name is invalid");
    }    

    baseFileName = logFileName;
    string::size_type pos = baseFileName.rfind(LOG_FILE_EXT);
    if (pos != string::npos) {
        baseFileName.erase(pos);
    }

    // extract directory
    baseDirName = baseFileName;
    pos = baseDirName.rfind('\\');
    if (pos != string::npos) {
        baseDirName.erase(pos + 1);
    }
    pos = baseDirName.rfind('/');
    if (pos != string::npos) {
        baseDirName.erase(pos + 1);
    }
    string baseSimName = baseFileName;
    stripToBaseName(baseSimName);
/*
    pos = baseSimName.rfind(DIRECTORY_SEPARATOR);
    if (pos != string::npos) {
        baseSimName.erase(0, pos + 1);
    }
*/
debug1 << "logFileName = " << logFileName << endl;
debug1 << "baseFileName = " << baseFileName << endl;
debug1 << "baseDirName = " << baseDirName << endl;
debug1 << "baseSimName = " << baseSimName << endl;

    //int NUM_TOKENS_PER_LINE = 0;

//    vector<VCellLogEntry> vcellLogEntryList;
    ifstream ifs(logFileName.c_str());
    if(!ifs.is_open()){
        EXCEPTION1(InvalidDBTypeException,"The file could not be opened");
    }

        struct stat buf;
        char zipFileName[128];
        sprintf(zipFileName,"%s00%s", baseFileName.c_str(), ZIP_FILE_EXT);
        if (stat(zipFileName, &buf)) {
            bSimZip = false;
            //NUM_TOKENS_PER_LINE = 3;
        } else {
            bSimZip = true;
            //NUM_TOKENS_PER_LINE = 4;
        }
//debug1 << "NUM_TOKENS_PER_LINE = " << NUM_TOKENS_PER_LINE << endl;
        //int tempIteration = -1, tempFileCount = 0, tempZipCount = 0;

        int lineCount = 0;
        string line;
        while (!ifs.eof()){
            getline(ifs,line);
//debug1 << "Log line = " << line << endl;
            //
            // look for line with a valid filename (includes basename)
            //
            if (line.find(baseSimName) != string::npos){
                //
                // parse iteration number and time
                //
                trimString(line);
                //int numTokens = 0;
                VCellLogEntry vcellLogEntry;
                stringstream ss(line);
                if (bSimZip) {
                    ss >> vcellLogEntry.iteration >> vcellLogEntry.simFileName >> vcellLogEntry.zipFileName >> vcellLogEntry.time;
                    //numTokens = sscanf(logBuffer, "%d %s %s %lg",
                    //    &vcellLogEntry.iteration, vcellLogEntry.simFileName, vcellLogEntry.zipFileName, &vcellLogEntry.time);
                } else {
                    ss >> vcellLogEntry.iteration >> vcellLogEntry.simFileName >> vcellLogEntry.time;
                    vcellLogEntry.zipFileName.clear();
                    //numTokens = sscanf(logBuffer, "%d %s %lg",
                    //    &vcellLogEntry.iteration, vcellLogEntry.simFileName, &vcellLogEntry.time);
                }
                if(ss.fail() || ss.bad() || !ss.eof()){
                    EXCEPTION1(InvalidDBTypeException,"The file could not be opened, num tokens wrong");
                }

                if (vcellLogEntry.iteration < 0  || vcellLogEntry.time < 0) {
                    EXCEPTION1(InvalidDBTypeException,"The file could not be opened");
                }

                vcellLogEntryList.push_back(vcellLogEntry);

            }
            lineCount ++;
        } // while (!feof(logFP))

        // close log file
        ifs.close();
        if(vcellLogEntryList.size() == 0){
            EXCEPTION1(InvalidDBTypeException,"No valid log lines were read.");
        }

}







uint32 reverseLong(uint32 along)
{
    uint32 newLong = ((along>>24)&0x000000ff)|((along>>8)&0x0000ff00)|((along<<8)&0x00ff0000)|((along<<24)&0xff000000);
    return newLong;
}

unsigned char *reverseDouble(double adouble)
{
    static union {
        double dbl;
        unsigned char array[8];
    } longDoubleUnion;

    longDoubleUnion.dbl = adouble;

    for (int i=0;i<4;i++){
        unsigned char temp = longDoubleUnion.array[i];
        longDoubleUnion.array[i] = longDoubleUnion.array[7-i];
        longDoubleUnion.array[7-i] = temp;
    }
    return longDoubleUnion.array;
}

double reverseDouble(unsigned char array[8])
{
    static union {
        double dbl;
        unsigned char array[8];
    } longDoubleUnion;

    memcpy(longDoubleUnion.array,array,8);

    for (int i=0;i<4;i++){
        unsigned char temp = longDoubleUnion.array[i];
        longDoubleUnion.array[i] = longDoubleUnion.array[7-i];
        longDoubleUnion.array[7-i] = temp;
    }
    return longDoubleUnion.dbl;
}

//
// we must read and write in the unix style (endian ... can't remember whether big or small???)
//
//struct FileHeader {
//   char   magicString[16];
//   char   versionString[8];
//   long   numBlocks;
//   long   firstBlockOffset;
//   long   sizeX;
//   long   sizeY;
//   long   sizeZ;
//};
//
void readHeader(FILE *fp, FileHeader *header)
{
#ifndef INTEL
    if (fread(header, sizeof(FileHeader), 1, fp)!=1){
        throw "DataSet::readHeader() - could not read header (UNIX)";
    }
#else
    if (fread(header->magicString, sizeof(char), 16, fp)!=16){
        throw "DataSet::readHeader() - could not read header->magicString (INTEL)";
    }
    if (fread(header->versionString, sizeof(char), 8, fp)!=8){
        throw "DataSet::readHeader() - could not read header->versionString (INTEL)";
    }
    uint32 newLongs[5];
    if (fread(&newLongs, sizeof(int32), 5, fp)!=5){
        throw "DataSet::readHeader() - could not read header->offsets.. (INTEL)";
    }
    header->numBlocks = reverseLong(newLongs[0]);
    header->firstBlockOffset = reverseLong(newLongs[1]);
    header->sizeX = reverseLong(newLongs[2]);
    header->sizeY = reverseLong(newLongs[3]);
    header->sizeZ = reverseLong(newLongs[4]);
#endif
}

//
// we must read and write in the unix style (endian ... can't remember whether big or small???)
//
//struct DataBlock {
//   char   varName[DATABLOCK_STRING_SIZE];
//   long   size;
//   long   dataOffset;
//};
//
void readDataBlock(FILE *fp, DataBlock *block)
{
#ifndef INTEL
    if (fread(block, sizeof(DataBlock), 1, fp)!=1){
        throw "DataSet::read() - could not read dataBlock (UNIX)";
    }
#else
    vector<string> oResult;
    char   fullVarName[DATABLOCK_STRING_SIZE];
    if (fread(fullVarName, sizeof(char), DATABLOCK_STRING_SIZE, fp)!=DATABLOCK_STRING_SIZE){
        throw "DataSet::readDataBlock() - could not read block->varName (INTEL)";
    }
    string colon = ":";
    string fullVarNameStr = fullVarName;
    Tokenize(fullVarNameStr,oResult,colon);
    if(oResult.size() == 1){
        block->domainName = "";
        fill(&(block->varName[0]),&(block->varName[DATABLOCK_STRING_SIZE]),0);
        memcpy(block->varName,oResult[0].c_str(),oResult[0].size());
    }else{
        block->domainName = oResult[0];
        fill(&(block->varName[0]),&(block->varName[DATABLOCK_STRING_SIZE]),0);
        memcpy(block->varName,oResult[1].c_str(),oResult[1].size());
    }
    uint32 newLongs[3];
    if (fread(&newLongs, sizeof(int32), 3, fp)!=3){
        throw "DataSet::read() - could not read dataBlock longs... (INTEL)";
    }
    block->varType = reverseLong(newLongs[0]);
    block->size = reverseLong(newLongs[1]);
    block->dataOffset = reverseLong(newLongs[2]);
#endif
}

//
// we must read and write in the unix style (endian ... can't remember whether big or small???)
//
void avtVCellMTMDFileFormat::readDoubles(FILE *fp, double *data, int length)
{
#ifndef INTEL
    if (fread(data, sizeof(double), length, fp)!=length){
        throw "DataSet::readDoubles() - error reading data (UNIX)";
    }

#else
    unsigned char tempArray[8];
    for (int i=0;i<length;i++){
        if (fread(tempArray, sizeof(char), 8, fp)!=8){
            throw "DataSet::readDoubles() - could not read double value (INTEL)";
        }
        data[i] = reverseDouble(tempArray);
    }
#endif
}

void avtVCellMTMDFileFormat::readSimFileHeader(char *filename)
{
    debug1 << "readSimFileHeader: enter readsimFileHeader " << filename << endl;
    FILE *fp=NULL;
    FileHeader fileHeader;

    if ((fp=fopen(filename, "rb"))==NULL){
        char errmsg[512];
        sprintf(errmsg, "DataSet::read() - could not open file '%s'.", filename); 
        throw errmsg;
    }
    debug1 << "readSimFileHeader: opened " << filename << endl;
    readHeader(fp,&fileHeader);

    if (strcmp(fileHeader.magicString, MAGIC_STRING)){
        throw "DataSet::read() - file is not a VCellDump file";
    }

    if (fileHeader.numBlocks <= 0){
        char errmsg[512];
        sprintf(errmsg, "DataSet::read() - number of blocks ( %d ) less than 1.", fileHeader.numBlocks); 
        throw errmsg;
    }

    if (fseek(fp, fileHeader.firstBlockOffset, SEEK_SET)){
        char errmsg[512];
        sprintf(errmsg, "DataSet::read() - could not find first block at offset %d.", fileHeader.firstBlockOffset); 
        throw errmsg;
    }
    //Read state variables
    for (int i=0;i<fileHeader.numBlocks;i++){
        DataBlock dataBlock;
        readDataBlock(fp,&dataBlock);
        variableNames.push_back(dataBlock);
        if(string(dataBlock.varName).find("vcRegion") == 0){
            debug1 <<"ok" <<endl;
        }
    }

    //for (int i=0;i<fileHeader.numBlocks;i++){
    //    Variable *var = sim->getVariableFromName(dataBlock[i].varName);
    //    if (var==NULL){
    //        cout << "DataSet::read() - variable '" << dataBlock[i].varName << "' not found in Simulation" << endl;
    //        continue;
    //    }
    //    if (var->getSize()!=dataBlock[i].size){
    //        char errmsg[512];
    //        sprintf(errmsg, "DataSet::read() - size mismatch for var '%s', file=%d, var=%d.", dataBlock[i].varName, dataBlock[i].size, var->getSize()); 
    //        throw errmsg;
    //    }
    //      
    //    if (fseek(fp, dataBlock[i].dataOffset, SEEK_SET)){
    //        char errmsg[512];
    //        sprintf(errmsg, "DataSet::read() - could not find data offset ( %d ).", dataBlock[i].dataOffset); 
    //        throw errmsg;
    //    }
    //    readDoubles(fp, var->getCurr(), var->getSize());
    //    var->update();   
    //    cout << "read data for variable '" << var->getName() << "'" << endl;
    //}
    
    
    //delete[] dataBlock;
       
    fclose(fp);
}

static void retryWait(int seconds) {
#if ( defined(WIN32) || defined(WIN64) )
    Sleep(seconds * 1000);
#else
    sleep(seconds);
#endif
}

bool avtVCellMTMDFileFormat::zipUnzipWithRetry(const char* zipFileName,const char* simFileName, char* errmsg) {
    bool bSuccess = true;
    int retcode = 0;
    int numRetries = 2;
    int retryWaitSeconds = 5;
    for (int retry = 0; retry < numRetries; retry ++) {
        try {
            retcode = unzip32((char*)zipFileName, (char*)simFileName, NULL);
            break;
        } catch (const char* ziperr) {
            sprintf(errmsg, "%s", ziperr);
        } catch (...) {
            sprintf(errmsg, "SimTool::updateLog(), adding .sim to .zip failed.");                        
        }
        bSuccess = false;
        if (retry < numRetries - 1) {
            retryWait(retryWaitSeconds);
            cout << "SimTool::updateLog(), adding .sim to .zip failed, trying again" << endl;
        }
    }
    if (bSuccess && retcode != 0) {
        sprintf(errmsg, "Writing zip file <%s> failed, return code is %d", zipFileName, retcode);
        bSuccess = false;
    }
    return bSuccess;
}

void avtVCellMTMDFileFormat::readStateVariables()
{
    string zipfilename = vcellLogEntryList[0].zipFileName;
    string simFileName = vcellLogEntryList[0].simFileName;
    struct stat buf;
    if (bSimZip) {
        // check if zip file exists
        //char zipfileabsolutename[512];
        stripToBaseName(zipfilename);
/*
        string::size_type pos = zipfilename.rfind('\\');
        if (pos != string::npos) {
            zipfilename.erase(0,pos + 1);
        }
        pos = zipfilename.rfind('/');
        if (pos != string::npos) {
            zipfilename.erase(0,pos + 1);
        }
*/
        zipfilename = baseDirName+zipfilename;
        if (stat(zipfilename.c_str(), &buf)) {
            string temp = "readVariable(), unable to open zip file "+zipfilename;
            EXCEPTION1(InvalidDBTypeException,temp.c_str());
        } else {
            // unzip the file (without directory) into exdir, currently we
            // unzip the file to the current working directory
            char errmsg[128];
            zipUnzipWithRetry(zipfilename.c_str(), simFileName.c_str(), errmsg);
        }
    }            
    
    // otherwise check if sim file exists
    if (stat(simFileName.c_str(), &buf)) {
        string temp = "readVariable(), unable to open zip file "+simFileName;
        EXCEPTION1(InvalidDBTypeException,temp.c_str());
    } else {
        try {
            readSimFileHeader((char*)simFileName.c_str());
            if (bSimZip) {
                remove(simFileName.c_str());
            }
            //DataSet::read(dataFileName, simulation);
            //simulation->setCurrIteration(tempIteration);
            //simFileCount = tempFileCount;

            //if (bSimZip) {
            //    remove(dataFileName);
            //    zipFileCount = getZipCount(zipFileName);
            //    // wrong zip file Name
            //    if (zipFileCount < 0) { // should never happen
            //    }  else {
            //        // check if this zip file is already big enough
            //        if (stat(zipFileName, &buf) == 0) {
            //            if (buf.st_size > ZIP_FILE_LIMIT) {
            //                zipFileCount ++;
            //            }
            //        }
            //    }
            //} 
            
        } catch (const char* msg) {
            cout << "SimTool::loadFinal() : dataSet.read(" << simFileName << " failed : " << msg << endl;
        } catch (...) {
            cout << "SimTool::loadFinal() : dataSet.read(" << simFileName << " failed : unexpected error" << endl;
        }
    }            
}


int avtVCellMTMDFileFormat::calcNodeCount(int axis){
            if(axis == X_AXIS){
                return 1+vcellMeshInfo.numElementsXYZ[X_AXIS];
            }else if(axis == Y_AXIS){
                return 1+(vcellMeshInfo.getSpatialdimension() > 1?vcellMeshInfo.numElementsXYZ[Y_AXIS]:0);
            }else if(axis == Z_AXIS){
                return 1+(vcellMeshInfo.getSpatialdimension() > 2?vcellMeshInfo.numElementsXYZ[Z_AXIS]:0);
            }
            throw "calcNodeCount(...) error: Uknown Axis";
            //throw new RuntimeException("Axis value "+axis+" unknown");
        }

void avtVCellMTMDFileFormat::getCoordinateIndexFromVolumeIndex(CoordinateIndex& holder,int volIndex) {
    holder.z = volIndex / (vcellMeshInfo.numElementsXYZ[X_AXIS] * vcellMeshInfo.numElementsXYZ[Y_AXIS]);
    volIndex -= holder.z * (vcellMeshInfo.numElementsXYZ[X_AXIS] * vcellMeshInfo.numElementsXYZ[Y_AXIS]);
    holder.y = volIndex / vcellMeshInfo.numElementsXYZ[X_AXIS];
    volIndex -= holder.y * vcellMeshInfo.numElementsXYZ[X_AXIS];
    holder.x = volIndex;
}
void avtVCellMTMDFileFormat::calcUCDMembraneQuads(){
    membrQuadNodes = new int[vcellMeshInfo.numMembraneElements*4];
    int xNodeCount = calcNodeCount(X_AXIS);
    int yNodeCount = calcNodeCount(Y_AXIS);
    int xyNodeCount = xNodeCount*yNodeCount;
    CoordinateIndex coordIndex0;
    CoordinateIndex coordIndex1;
    for (int i = 0; i < vcellMeshInfo.numMembraneElements; i++) {
        getCoordinateIndexFromVolumeIndex(coordIndex0,vcellMeshInfo.membraneElements[i].volIndex0);
        getCoordinateIndexFromVolumeIndex(coordIndex1,vcellMeshInfo.membraneElements[i].volIndex1);
        if(coordIndex0.y == coordIndex1.y && coordIndex0.z == coordIndex1.z){//perpendicular x-axis
            int xBase = max(coordIndex0.x, coordIndex1.x);
            membrQuadNodes[i*4+0] = xBase +(coordIndex0.y*xNodeCount) +(coordIndex0.z*xyNodeCount);
            membrQuadNodes[i*4+1] = xBase +((coordIndex0.y+1)*xNodeCount) +(coordIndex0.z*xyNodeCount);
            membrQuadNodes[i*4+2] = xBase +((coordIndex0.y+1)*xNodeCount) +((coordIndex0.z+1)*xyNodeCount);
            membrQuadNodes[i*4+3] = xBase +((coordIndex0.y)*xNodeCount) +((coordIndex0.z+1)*xyNodeCount);
        }else if(coordIndex0.x == coordIndex1.x && coordIndex0.z == coordIndex1.z){//perpendicular y-axis
            int yBase = max(coordIndex0.y, coordIndex1.y);
            membrQuadNodes[i*4+0] = coordIndex0.x +(yBase*xNodeCount) +(coordIndex0.z*xyNodeCount);
            membrQuadNodes[i*4+1] = coordIndex0.x+1 +(yBase*xNodeCount) +(coordIndex0.z*xyNodeCount);
            membrQuadNodes[i*4+2] = coordIndex0.x+1 +(yBase*xNodeCount) +((coordIndex0.z+1)*xyNodeCount);
            membrQuadNodes[i*4+3] = coordIndex0.x +(yBase*xNodeCount) +((coordIndex0.z+1)*xyNodeCount);

        }else if(coordIndex0.x == coordIndex1.x && coordIndex0.y == coordIndex1.y){//perpendicular z-axis
            int zBase = max(coordIndex0.z, coordIndex1.z);
            membrQuadNodes[i*4+0] = coordIndex0.x +(coordIndex0.y*xNodeCount) +(zBase*xyNodeCount);
            membrQuadNodes[i*4+1] = coordIndex0.x +((coordIndex0.y+1)*xNodeCount) +(zBase*xyNodeCount);
            membrQuadNodes[i*4+2] = coordIndex0.x+1 +((coordIndex0.y+1)*xNodeCount) +(zBase*xyNodeCount);
            membrQuadNodes[i*4+3] = coordIndex0.x+1 +((coordIndex0.y)*xNodeCount) +(zBase*xyNodeCount);

        }else{
            ostringstream oss;
            oss << "No boundary found for MembraneElement " << i;
            throw oss.str().c_str();
        }
    }
}


double avtVCellMTMDFileFormat::coordComponentFromSinglePlanePolicy(int argAxisFlag) {
    if(argAxisFlag == X_AXIS){
        return vcellMeshInfo.extentXYZ[0] /2.0 + vcellMeshInfo.originXYZ[0];
    }else if(argAxisFlag == Y_AXIS){
        return vcellMeshInfo.extentXYZ[1] /2.0 + vcellMeshInfo.originXYZ[1];
    }else if(argAxisFlag == Z_AXIS){
        return vcellMeshInfo.extentXYZ[1] /2.0 + vcellMeshInfo.originXYZ[1];
    }

    throw "coordComponentFromSinglePlanePolicy error: Unknown Axis Flag";
}
void avtVCellMTMDFileFormat::getCoordinate(Coordinate& holder,CoordinateIndex coordIndex) {
    //
    //
    // calculate coordinates based on element coordinates 
    //     
    //     1--------2--------3-------4--------N
    //
    // so spacing is divided into (N-1) regions.
    //
    //
    // if N is 1, then take middle of that dimension
    //
    //
    holder.x = coordComponentFromSinglePlanePolicy(X_AXIS);//extent.getX()/2.0 + origin.getX();
    if (vcellMeshInfo.numElementsXYZ[X_AXIS]>1){
        holder.x = (((float)coordIndex.x)/(vcellMeshInfo.numElementsXYZ[X_AXIS]-1))*vcellMeshInfo.extentXYZ[0]+vcellMeshInfo.originXYZ[0];
    }
    holder.y = coordComponentFromSinglePlanePolicy(Y_AXIS);//extent.getY()/2.0 + origin.getY();
    if (vcellMeshInfo.numElementsXYZ[Y_AXIS]>1){
        holder.y = (((double)coordIndex.y)/(vcellMeshInfo.numElementsXYZ[Y_AXIS]-1))*vcellMeshInfo.extentXYZ[1]+vcellMeshInfo.originXYZ[1];
    }
    holder.z = coordComponentFromSinglePlanePolicy(Z_AXIS);//extent.getZ()/2.0 + origin.getZ();
    if (vcellMeshInfo.numElementsXYZ[Z_AXIS]>1){
        holder.z = (((double)coordIndex.z)/(vcellMeshInfo.numElementsXYZ[Z_AXIS]-1))*vcellMeshInfo.extentXYZ[2]+vcellMeshInfo.originXYZ[2];
    }
}

void avtVCellMTMDFileFormat::calcUCDGridNodes(){
    int totalNodes = calcNodeCount(X_AXIS)*calcNodeCount(Y_AXIS)*calcNodeCount(Z_AXIS);
    ucdMeshNodes = new Coordinate[totalNodes];
    //Coordinate[][][] ucdMeshNodes =
    //    new Coordinate[calcNodeCount(Coordinate.Z_AXIS)]
    //                  [calcNodeCount(Coordinate.Y_AXIS)]
    //                  [calcNodeCount(Coordinate.X_AXIS)];
    double dx = vcellMeshInfo.extentXYZ[0]/(vcellMeshInfo.numElementsXYZ[X_AXIS]-1);//getExtent().getX()/(getSizeX()-1);
    double dy = (vcellMeshInfo.getSpatialdimension() > 1?vcellMeshInfo.extentXYZ[1]/(vcellMeshInfo.numElementsXYZ[Y_AXIS]-1):0);//(getGeometryDimension() > 1?getExtent().getY()/(getSizeY()-1):0);
    double dz = (vcellMeshInfo.getSpatialdimension() > 2?vcellMeshInfo.extentXYZ[2]/(vcellMeshInfo.numElementsXYZ[Z_AXIS]-1):0);//(getGeometryDimension() > 2?getExtent().getZ()/(getSizeZ()-1):0);
    CoordinateIndex coordIndex;
    Coordinate volCenterCoord;
    int volIndex = 0;
    const int DX = 1;
    const int DY = calcNodeCount(X_AXIS);//vcellMeshInfo.numElementsXYZ[X_AXIS];
    const int DZ = calcNodeCount(X_AXIS)*calcNodeCount(Y_AXIS);//vcellMeshInfo.numElementsXYZ[X_AXIS] * vcellMeshInfo.numElementsXYZ[Y_AXIS];
    for (int z = 0; z < vcellMeshInfo.numElementsXYZ[Z_AXIS]; z++) {
        coordIndex.z = z;
        bool bZEnd = (z+1 == vcellMeshInfo.numElementsXYZ[Z_AXIS]) && vcellMeshInfo.numElementsXYZ[Z_AXIS] > 1;
        for (int y = 0; y < vcellMeshInfo.numElementsXYZ[Y_AXIS]; y++) {
            coordIndex.y = y;
            bool bYEnd = y+1 == vcellMeshInfo.numElementsXYZ[Y_AXIS];
            for (int x = 0; x < vcellMeshInfo.numElementsXYZ[X_AXIS]; x++) {
                try{
                volIndex = z*DZ + y*DY + x;
                coordIndex.x = x;
                bool bXEnd = x+1 == vcellMeshInfo.numElementsXYZ[X_AXIS];
                
                //Get mesh volume element center coordinate.
                getCoordinate(volCenterCoord,coordIndex);
                
                //convert volume center coord to UCD grid "cell" node
                double nodeX = volCenterCoord.x-(x==0?0:dx/2);
                double nodeY = volCenterCoord.y-(y==0?0:dy/2);
                double nodeZ = volCenterCoord.z-(z==0?0:dz/2);
                ucdMeshNodes[volIndex]/*[z][y][x]*/ = Coordinate(nodeX,nodeY,nodeZ);//local or new????????
                
                //Add "end" nodes when necessary
                if(bXEnd){
                    ucdMeshNodes[volIndex+DX]/*[z][y][x+1]*/ = Coordinate(volCenterCoord.x,nodeY,nodeZ);
                }
                if(bYEnd){
                    ucdMeshNodes[volIndex+DY]/*[z][y+1][x]*/ = Coordinate(nodeX,volCenterCoord.y,nodeZ);
                }
                if(bZEnd){
                    ucdMeshNodes[volIndex+DZ]/*[z+1][y][x]*/ = Coordinate(nodeX,nodeY,volCenterCoord.z);
                }
                
                if(bXEnd && bYEnd){
                    ucdMeshNodes[volIndex+DY+DX]/*[z][y+1][x+1]*/ = Coordinate(volCenterCoord.x,volCenterCoord.y,nodeZ);
                }
                if(bYEnd && bZEnd){
                    ucdMeshNodes[volIndex+DZ+DY]/*[z+1][y+1][x]*/ = Coordinate(nodeX,volCenterCoord.y,volCenterCoord.z);
                }
                if(bZEnd && bXEnd){
                    ucdMeshNodes[volIndex+DZ+DX]/*[z+1][y][x+1]*/ = Coordinate(volCenterCoord.x,nodeY,volCenterCoord.z);
                }

                if(bXEnd && bYEnd && bZEnd){
                    ucdMeshNodes[volIndex+DZ+DY+DX]/*[z+1][y+1][x+1]*/ = Coordinate(volCenterCoord.x,volCenterCoord.y,volCenterCoord.z);
                }

                //volIndex++;
                }catch(...){
                    debug1 << "Error calcUCDGridNodes" << endl;
                    throw;
                }
            }
        }
    }
}

void avtVCellMTMDFileFormat::stripToBaseName(string & filePath){
    string::size_type pos = filePath.rfind('\\');
    if (pos != string::npos) {
        filePath.erase(0,pos + 1);
    }
    pos = filePath.rfind('/');
    if (pos != string::npos) {
        filePath.erase(0,pos + 1);
    }
}

string avtVCellMTMDFileFormat::findDomainName(string & varOrFuncName){

    for(size_t i=0;i<variableNames.size();i++){
        if(string(variableNames[i].varName).compare(varOrFuncName) == 0){
            return variableNames[i].domainName;
        }
    }

    map<string,string>::iterator it;
    for ( it=funcMapDomain.begin() ; it != funcMapDomain.end(); it++ ){
        if(it->first.compare(varOrFuncName) == 0){
            return it->second;
        }
    }

    for(size_t i=0;i<membrSubstVariables.size();i++){
        if(membrSubstVariables[i].convertVolToMembrName.compare(varOrFuncName) == 0){
            return membrSubstVariables[i].membrFuncDomainName;
        }
    }

    for(size_t i=0;i<regionSubstVariables.size();i++){
        if(regionSubstVariables[i].regionSubstName.compare(varOrFuncName) == 0){
            return regionSubstVariables[i].domainName;
        }
    }

    return NULL;
}


void avtVCellMTMDFileFormat::substituteMembraneFunctions(avtDatabaseMetaData *md){
    
    //If membrane functions have volume function variables
    //replace volume function variables until only volume state variables remain
    ExpressionList & exprList = md->GetExprList();
    bool bReplaced;
    for(int k=0;k<exprList.GetNumExpressions();k++){
        Expression & visitExpr = exprList.GetExpressions(k);
        if(visitExpr.GetMeshName().compare(MEMBRMESH) == 0){
            do{
                bReplaced = false;
                    VCell::Expression * vcellExpr = new VCell::Expression(visitExpr.GetDefinition());
                    vector<string> vcellExprSymbols;
                    vcellExpr->getSymbols(vcellExprSymbols);
                    for(int i=0;i<exprList.GetNumExpressions();i++){
                        if(exprList.GetExpressions(i).GetMeshName().compare(VOLMESH) == 0){
                            for(size_t j=0;j<vcellExprSymbols.size();j++){
                                if(exprList.GetExpressions(i).GetName().compare(vcellExprSymbols[j]) == 0){
                                    VCell::Expression * replaceThisFragment = new VCell::Expression(vcellExprSymbols[j]);
                                    VCell::Expression * newReplacement = new VCell::Expression(exprList.GetExpressions(i).GetDefinition());
                                    vcellExpr->substituteInPlace(replaceThisFragment,newReplacement);
                                    visitExpr.SetDefinition(vcellExpr->infix());
                                    bReplaced = true;
                                    break;
                                }
                            }
                        }
                        if(bReplaced){
                            break;
                        }
                    }
                    delete vcellExpr;
            }while(bReplaced);
        }
    }
    

    //Within membrane functions replace all volume state variables with a "fake" membrane variable reference
    //int substCounter = 0;
    for(int k=0;k<exprList.GetNumExpressions();k++){
        Expression & visitExpr = exprList.GetExpressions(k);
        if(visitExpr.GetMeshName().compare(MEMBRMESH) == 0){
            do{
                bReplaced = false;
                VCell::Expression * vcellExpr = new VCell::Expression(visitExpr.GetDefinition());
                vector<string> vcellExprSymbols;
                vcellExpr->getSymbols(vcellExprSymbols);
                for(size_t i=0;i<vcellExprSymbols.size();i++){
                    for(size_t j=0;j<variableNames.size();j++){
                        if(variableNames[j].varType == VAR_VOLUME){
                            if(string(variableNames[j].varName).compare(vcellExprSymbols[i]) == 0){
                                VCell::Expression * replaceThisFragment = new VCell::Expression(vcellExprSymbols[i]);
                                stringstream ss;
                                ss << vcellExprSymbols[i] << "_subst";
                                string substName = ss.str();
                                bool bFound = false;
                                for (size_t k=0;k<membrSubstVariables.size();k++){
                                    if(membrSubstVariables[k].convertVolToMembrName.compare(substName) == 0){
                                        bFound = true;
                                        break;
                                    }
                                }
                                if(!bFound){
                                    string substDomain = findDomainName(vcellExprSymbols[i]);
                                    string functionDomain = findDomainName(visitExpr.GetName());

                                    MembraneSubstVariables membrSubtVars;
                                    membrSubtVars.convertVolToMembrName = substName;
                                    membrSubtVars.membrFuncDomainName = functionDomain;
                                    membrSubstVariables.push_back(membrSubtVars);


                                    int volID1 = -1;
                                    int volID2 = -1;
                                    string volName1;
                                    string volName2;

                                    map<string,map<string,int> >::iterator it;
                                    
                                    for ( it=vcellMeshInfo.membraneSubdomainMap.begin() ; it != vcellMeshInfo.membraneSubdomainMap.end(); it++ ){
                                        if(it->first.compare(functionDomain) == 0){
                                            map<string,int> volName_IDMap = it->second;
                                            map<string,int>::iterator it2;
                                            for(it2=volName_IDMap.begin();it2 != volName_IDMap.end();it2++){
                                                if(volID1 == -1){
                                                    volName1 = it2->first;
                                                    volID1 = it2->second;
                                                }else{
                                                    volName2 = it2->first;
                                                    volID2 = it2->second;
                                                }
                                            }
                                            break;
                                        }
                                    }
                                    int finalVolID = -1;
                                    if(volName1.compare(substDomain) == 0){
                                        finalVolID = volID1;
                                    }else if(volName2.compare(substDomain) == 0){
                                        finalVolID = volID2;
                                    }else{
                                        throw "unknown volume name";
                                    }
                                    //create vector<int>
                                    vector<int> & membraneIndexesV = membrSubstVariables.back().volumeIndexes;
                                    for(int l=0;l<vcellMeshInfo.numMembraneElements;l++){
                                        int volumeIndex0 = vcellMeshInfo.membraneElements[l].volIndex0;
                                        int volumeIndex1 = vcellMeshInfo.membraneElements[l].volIndex1;
                                        int volRegID1 = vcellMeshInfo.volumeElementsMapVolumeRegion[volumeIndex0];
                                        int volRegID2 = vcellMeshInfo.volumeElementsMapVolumeRegion[volumeIndex1];
                                        int subVolID1 = vcellMeshInfo.volumeRegionsMapSubvolume[volRegID1];
                                        int subVolID2 = vcellMeshInfo.volumeRegionsMapSubvolume[volRegID2];
                                        if(subVolID1 == finalVolID){
                                            membraneIndexesV.push_back(volumeIndex0);
                                        }else if(subVolID2 == finalVolID){
                                            membraneIndexesV.push_back(volumeIndex1);
                                        }else{
                                            membraneIndexesV.push_back(-1);
                                        }
                                    }

                                }
                                VCell::Expression * newReplacement = new VCell::Expression(substName);
                                vcellExpr->substituteInPlace(replaceThisFragment,newReplacement);
                                visitExpr.SetDefinition(vcellExpr->infix());
                                bReplaced = true;
                                break;
                            }
                        }
                    }
                    if(bReplaced){
                        break;
                    }
                }
                delete vcellExpr;
            }while(bReplaced);
        }
    }
}

//const string RESERVED_X = "x";
//const string RESERVED_Y = "y";
//const string RESERVED_Z = "z";
const string RESERVE_XYZT [] = {"x","y","z","t"};

void avtVCellMTMDFileFormat::substituteVisitFunctionSyntax(avtDatabaseMetaData *md){
    stringstream ss;

    ExpressionList & exprList = md->GetExprList();
    for(int k=0;k<exprList.GetNumExpressions();k++){
        Expression & visitExpr = exprList.GetExpressions(k);
        VCell::Expression * vcellExpr = new VCell::Expression(visitExpr.GetDefinition());
        string vcellSyntax = vcellExpr->infix();
        string SPECIAL_XYZT [] = {"_X_","_Y_","_Z_","_T_"};
        //replace xyz with "special symbols" for later replacement VisIt syntax
        for(int i=0;i<4;i++){
            while(vcellSyntax.find(SPECIAL_XYZT[i]) != string::npos){
                ss.clear();
                ss.str("");
                ss << "_" << SPECIAL_XYZT[i] << "_";
                SPECIAL_XYZT[i] = ss.str();
            }
        VCell::Expression reserveExp(RESERVE_XYZT[i]);
        VCell::Expression specialExp(SPECIAL_XYZT[i]);
        vcellExpr->substituteInPlace(& reserveExp,& specialExp);
        }

        //Convert VCell function syntax to Visit
        string convertedToVisitSyntax = vcellExpr->infix_Visit();

        //replace xyz "special symbols" with Visit "coord" syntax
        size_t index;
        do{
            bool bFound = false;
            for(int i=0;i<4;i++){
                index = convertedToVisitSyntax.find(SPECIAL_XYZT[i]);
                if(index != string::npos){
                    bFound = true;
                    ss.clear();
                    ss.str("");
                    if(i == 3){
                        ss << "time(" << VOLMESH/*visitExpr.GetMeshName()*/ << ")";
                        convertedToVisitSyntax.replace(index, SPECIAL_XYZT[i].size(), ss.str());
                    }else{
                        ss << "coord(" << VOLMESH/*visitExpr.GetMeshName()*/ << ")[" << i << "]";
                        convertedToVisitSyntax.replace(index, SPECIAL_XYZT[i].size(), ss.str());
                    }
                }
            }
            if(!bFound){
                break;
            }
        }while(true);

        visitExpr.SetDefinition(convertedToVisitSyntax);
    }
}

void avtVCellMTMDFileFormat::addRegionSubstVar(string & regionSubstVarName,int substVarType,string & domainName){
    for(size_t i=0;i<regionSubstVariables.size();i++){
        if(regionSubstVarName.compare(regionSubstVariables[i].regionSubstName) == 0){
            return;
        }
    }
    RegionSubstVariables regionSubstVariable;
    regionSubstVariable.regionSubstName = regionSubstVarName;
    regionSubstVariable.varType = substVarType;
    regionSubstVariable.domainName = domainName;
    regionSubstVariables.push_back(regionSubstVariable);
}

void avtVCellMTMDFileFormat::convertRegionToTempVar(string & vcellFuncStr,string & domainName){
    while(true){
        bool bFound = false;
        string::size_type pos = vcellFuncStr.find(REGIONVOLUME+"('");
        if(pos != string::npos){
            bFound = true;
            vcellFuncStr.replace(pos+REGIONVOLUME.length(),2,"__");
            string::size_type pos2 = vcellFuncStr.find("')",pos);
            vcellFuncStr.erase(pos2,2);
            string temp(vcellFuncStr.substr(pos,pos2-pos));
            addRegionSubstVar(temp,VAR_VOLUME_REGION,domainName);
        }
        pos = vcellFuncStr.find(REGIONAREA+"('");
        if(pos != string::npos){
            bFound = true;
            vcellFuncStr.replace(pos+REGIONAREA.length(),2,"__");
            string::size_type pos2 = vcellFuncStr.find("')",pos);
            vcellFuncStr.erase(pos2,2);
            string temp(vcellFuncStr.substr(pos,pos2-pos));
            addRegionSubstVar(temp,VAR_MEMBRANE_REGION,domainName);
        }
        if(!bFound){
            break;
        }
    }
}

void avtVCellMTMDFileFormat::readFunctions(avtDatabaseMetaData *md){

     vector<string> oResult;

    struct stat buf;
    char functionsFileName[128];
    sprintf(functionsFileName,"%s%s", baseFileName.c_str(), FUNCTIONS_FILE_EXT);
    if (stat(functionsFileName, &buf)) {
        throw "functions file not found";
    }

    ifstream ifs(functionsFileName);
    if(!ifs.is_open()){
        throw "functions file failed to open for reading";;
    }

    int lineCount = 0;
    string line;
    vector<string> fNameResult;
    while (!ifs.eof()){
        getline(ifs,line);
        //
        // look for line with a ";"
        //
        if (line.find("##") == string::npos && line.find(";") != string::npos){
            //
            // parse iteration number and time
            //
            trimString(line);
            string semicolon = ";";
            Tokenize(line,oResult,semicolon);
            //oResult[0] = functionName
            //oResult[1] = function expression
            //oResult[2] = "" unkown
            //oResult[3] = variableType "Membrane_VariableType","Volume_VariableType","Volume_Region_VariableType","Membrane_Region_VariableType"
            //oResult[4] = "true","false"

    //CTokenizer<CIsFromString>::Tokenize(oResult, fullVarName, CIsFromString("::"));
    //if(oResult.size() == 1){
    //    block->domainName = "";
    //    fill(&(block->varName[0]),&(block->varName[DATABLOCK_STRING_SIZE]),0);
    //    memcpy(block->varName,oResult[0].c_str(),oResult[0].size());
    //}else{
    //    block->domainName = oResult[0];
    //    fill(&(block->varName[0]),&(block->varName[DATABLOCK_STRING_SIZE]),0);
    //    memcpy(block->varName,oResult[1].c_str(),oResult[1].size());
    //}
            string colon = ":";
            Tokenize(oResult[0],fNameResult,colon);
            if(fNameResult.size() == 2){
                funcMapDomain.insert(pair<string,string>(fNameResult[1],fNameResult[0]));
            }
            trimString(oResult[3]);
            if(oResult[3].compare("Volume_VariableType") == 0){
                Expression *e1 = new Expression;
                e1->SetName((fNameResult.size() == 1?fNameResult[0]:fNameResult[1]));
                e1->SetDefinition(oResult[1]);
                e1->SetType(Expression::ScalarMeshVar);
                e1->SetHidden(false);
                e1->SetMeshName(VOLMESH);
                md->AddExpression(e1);
            }else if(oResult[3].compare("Membrane_VariableType") == 0){
                Expression *e1 = new Expression;
                e1->SetName((fNameResult.size() == 1?fNameResult[0]:fNameResult[1]));
                e1->SetDefinition(oResult[1]);
                e1->SetType(Expression::ScalarMeshVar);
                e1->SetHidden(false);
                e1->SetMeshName(MEMBRMESH);
                md->AddExpression(e1);
            }else if(oResult[3].compare("Volume_Region_VariableType") == 0){
                string tempStr = oResult[1];
                string tempStr2 = (fNameResult.size() == 1?NULL:fNameResult[0]);
                convertRegionToTempVar(tempStr,tempStr2);
                Expression *e1 = new Expression;
                e1->SetName((fNameResult.size() == 1?fNameResult[0]:fNameResult[1]));
                e1->SetDefinition(tempStr);
                e1->SetType(Expression::ScalarMeshVar);
                e1->SetHidden(false);
                e1->SetMeshName(VOLMESH);
                md->AddExpression(e1);
            }else if(oResult[3].compare("Membrane_Region_VariableType") == 0){
                string tempStr = oResult[1];
                string tempStr2 = (fNameResult.size() == 1?NULL:fNameResult[0]);
                convertRegionToTempVar(tempStr,tempStr2);
                Expression *e1 = new Expression;
                e1->SetName((fNameResult.size() == 1?fNameResult[0]:fNameResult[1]));
                e1->SetDefinition(tempStr);
                e1->SetType(Expression::ScalarMeshVar);
                e1->SetHidden(false);
                e1->SetMeshName(MEMBRMESH);
                md->AddExpression(e1);
            }else if(oResult[3].compare("Nonspatial_VariableType") == 0){
                Expression *e1 = new Expression;
                e1->SetName((fNameResult.size() == 1?fNameResult[0]:fNameResult[1]));
                e1->SetDefinition(oResult[1]);
                e1->SetType(Expression::ScalarMeshVar);
                e1->SetHidden(false);
                e1->SetMeshName(VOLMESH);
                md->AddExpression(e1);
            }
            //int numTokens = 0;
            //VCellLogEntry vcellLogEntry;
            //stringstream ss(line);
            //if (bSimZip) {
            //    ss >> vcellLogEntry.iteration >> vcellLogEntry.simFileName >> vcellLogEntry.zipFileName >> vcellLogEntry.time;
            //    //numTokens = sscanf(logBuffer, "%d %s %s %lg",
            //    //    &vcellLogEntry.iteration, vcellLogEntry.simFileName, vcellLogEntry.zipFileName, &vcellLogEntry.time);
            //} else {
            //    ss >> vcellLogEntry.iteration >> vcellLogEntry.simFileName >> vcellLogEntry.time;
            //    vcellLogEntry.zipFileName.clear();
            //    //numTokens = sscanf(logBuffer, "%d %s %lg",
            //    //    &vcellLogEntry.iteration, vcellLogEntry.simFileName, &vcellLogEntry.time);
            //}
            //if(ss.fail() || ss.bad() || !ss.eof()){
            //    EXCEPTION1(InvalidDBTypeException,"The file could not be opened, num tokens wrong");
            //}

            //if (vcellLogEntry.iteration < 0  || vcellLogEntry.time < 0) {
            //    EXCEPTION1(InvalidDBTypeException,"The file could not be opened");
            //}

            //vcellLogEntryList.push_back(vcellLogEntry);

        }
        lineCount ++;
    } // while (!feof(logFP))

    // close log file
    ifs.close();

    substituteMembraneFunctions(md);

    substituteVisitFunctionSyntax(md);
}

unsigned char avtVCellMTMDFileFormat::fromHex(unsigned char* src) {
    char chs[5];
    chs[0] = '0';
    chs[1] = 'x';
    chs[2] = src[0];
    chs[3] = src[1];
    chs[4] = 0;
    int v;
    sscanf(chs, "%x", &v);
    return (unsigned char)v;
}

void avtVCellMTMDFileFormat::readVolumeSamples(ifstream & ifs){

    int numXY = vcellMeshInfo.numElementsXYZ[0] * vcellMeshInfo.numElementsXYZ[1];
    int numVolume = numXY * vcellMeshInfo.numElementsXYZ[2];

    //volumeSamples compressed, changed from byte to short
    int twiceNumVolume = 2 * numVolume;
    unsigned char* bytes_from_compressed = new unsigned char[twiceNumVolume + 1000];
    memset(bytes_from_compressed, 0, (twiceNumVolume + 1000) * sizeof(unsigned char));

    unsigned char* compressed_hex = new unsigned char[twiceNumVolume + 1000];
    memset(compressed_hex, 0, (twiceNumVolume + 1000) * sizeof(unsigned char));

    int compressed_len = 0;
    string line;
    while(!ifs.eof()){
        //ifs.getline((char*)(compressed_hex+compressed_len), twiceNumVolume + 1000);
        getline(ifs,line);
        trimString(line);
        if(line.compare("}") == 0){
            break;
        }
        memcpy(compressed_hex+compressed_len,line.c_str(),line.size());
        compressed_len += line.size();
    }


//    int compressed_len = ifs.gcount();

    if (compressed_len <= 1) {
        throw "CartesianMesh::readGeometryFile() : invalid compressed volume";
    }
    
    for (int i = 0, j = 0; i < compressed_len; i += 2, j ++) {
        bytes_from_compressed[j] = fromHex(compressed_hex + i);
    }

    unsigned char* inflated_bytes = new unsigned char[twiceNumVolume + 1];
    memset(inflated_bytes, 0, (twiceNumVolume + 1) * sizeof(unsigned char));

    unsigned long inflated_len = twiceNumVolume;
    int retVal = uncompress(inflated_bytes, &inflated_len, bytes_from_compressed, compressed_len/2); (void) retVal;

    vcellMeshInfo.volumeElementsMapVolumeRegion = new unsigned short[numVolume];
    if (inflated_len == (unsigned long)numVolume) {
        for (unsigned long i = 0; i < inflated_len; i ++) {        
            vcellMeshInfo.volumeElementsMapVolumeRegion[i] = inflated_bytes[i];
        }
    } else if (inflated_len == (unsigned long)twiceNumVolume) {
        // convert two bytes to short
        for (unsigned long i = 0, j = 0; i < inflated_len; i += 2, j ++) {
            vcellMeshInfo.volumeElementsMapVolumeRegion[j] = inflated_bytes[i] | (inflated_bytes[i + 1] << 8);
        }
    } else {
        throw "CartesianMesh : unexpected number of volume samples";
    }

}

/*****************************************************************************
*
* Copyright (c) 2000 - 2011, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtWPPImageFileFormat.C                           //
// ************************************************************************* //

#include <avtWPPImageFileFormat.h>

#include <string>

#include <vtkFloatArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>

#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>
#include <InvalidDBTypeException.h>

#include <DebugStream.h>

#include <fcntl.h>
#include <unistd.h>

#ifndef WIN32
#define O_BINARY 0
#endif

using     std::string;


// ****************************************************************************
//  Method: avtWPPImageFileFormat constructor
//
//  Programmer: bjorn -- generated by xml2avt
//  Creation:   Fri Jan 13 16:02:12 PST 2012
//
// ****************************************************************************

avtWPPImageFileFormat::avtWPPImageFileFormat(const char *filename)
    : avtSTMDFileFormat(&filename, 1)
{
   m_filename    = filename;
   m_initialized = false;

    // INITIALIZE DATA MEMBERS
}


// ****************************************************************************
//  Method: avtWPPImageFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: bjorn -- generated by xml2avt
//  Creation:   Fri Jan 13 16:02:12 PST 2012
//
// ****************************************************************************

void
avtWPPImageFileFormat::FreeUpResources(void)
{
}


// ****************************************************************************
//  Method: avtWPPImageFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: bjorn -- generated by xml2avt
//  Creation:   Fri Jan 13 16:02:12 PST 2012
//
// ****************************************************************************

void
avtWPPImageFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md)
{
    debug5 << "Populatedatabase begins" << endl;

    if( !m_initialized )
        Initialize();

    // Mesh information
    avtMeshMetaData *mmd = new avtMeshMetaData;

    mmd->name = "Cartesian slice";

    mmd->spatialDimension = 3;
    mmd->topologicalDimension = 3;
    mmd->numBlocks = m_nblocks;
    //   mmd->hasUnits = true;
    //   mmd->units = "meters";
    mmd->meshType = AVT_RECTILINEAR_MESH;

    debug5 << "before b-loop " << endl;

    mmd->blockNames.resize(m_nblocks);
    for( int b=0 ; b < m_nblocks ; b++ )
    {
        debug5 << "Block = " << b << endl;
        debug5 << "grid size = " << m_gridsize[b] << endl;
        debug5 << "no of pts = " << m_ni[b] << " " << m_nj[b] << " " << m_nk[b] << endl;
        char buf[50];
        SNPRINTF(buf,50,"h=%f",m_gridsize[b]);
        string bname= buf;
        mmd->blockNames[b] = bname;
    }
    md->Add(mmd);
    debug5 << "after b-loop " << endl;

    // Scalar variable information
    avtScalarMetaData *smd1 = new avtScalarMetaData;
    smd1->name = m_mode;
// copy the mesh name from above
    smd1->meshName = mmd->name;
    smd1->centering = AVT_NODECENT;
    smd1->hasUnits = false;
    md->Add(smd1);
    debug5 << "Populatedatabase done " << endl;
}
    //
    // CODE TO ADD A MESH
    //
    // string meshname = ...
    //
    // AVT_RECTILINEAR_MESH, AVT_CURVILINEAR_MESH, AVT_UNSTRUCTURED_MESH,
    // AVT_POINT_MESH, AVT_SURFACE_MESH, AVT_UNKNOWN_MESH
    // avtMeshType mt = AVT_RECTILINEAR_MESH;
    //
    // int nblocks = YOU_MUST_DECIDE;
    // int block_origin = 0;
    // int spatial_dimension = 2;
    // int topological_dimension = 2;
    // double *extents = NULL;
    //
    // Here's the call that tells the meta-data object that we have a mesh:
    //
    // AddMeshToMetaData(md, meshname, mt, extents, nblocks, block_origin,
    //                   spatial_dimension, topological_dimension);
    //

    //
    // CODE TO ADD A SCALAR VARIABLE
    //
    // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    // string varname = ...
    //
    // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    // avtCentering cent = AVT_NODECENT;
    //
    //
    // Here's the call that tells the meta-data object that we have a var:
    //
    // AddScalarVarToMetaData(md, varname, mesh_for_this_var, cent);
    //

    //
    // CODE TO ADD A VECTOR VARIABLE
    //
    // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    // string varname = ...
    // int vector_dim = 2;
    //
    // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    // avtCentering cent = AVT_NODECENT;
    //
    //
    // Here's the call that tells the meta-data object that we have a var:
    //
    // AddVectorVarToMetaData(md, varname, mesh_for_this_var, cent,vector_dim);
    //

    //
    // CODE TO ADD A TENSOR VARIABLE
    //
    // string mesh_for_this_var = meshname; // ??? -- could be multiple meshes
    // string varname = ...
    // int tensor_dim = 9;
    //
    // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    // avtCentering cent = AVT_NODECENT;
    //
    //
    // Here's the call that tells the meta-data object that we have a var:
    //
    // AddTensorVarToMetaData(md, varname, mesh_for_this_var, cent,tensor_dim);
    //

    //
    // CODE TO ADD A MATERIAL
    //
    // string mesh_for_mat = meshname; // ??? -- could be multiple meshes
    // string matname = ...
    // int nmats = ...;
    // vector<string> mnames;
    // for (int i = 0 ; i < nmats ; i++)
    // {
    //     char str[32];
    //     sprintf(str, "mat%d", i);
    //     -- or -- 
    //     strcpy(str, "Aluminum");
    //     mnames.push_back(str);
    // }
    // 
    // Here's the call that tells the meta-data object that we have a mat:
    //
    // AddMaterialToMetaData(md, matname, mesh_for_mat, nmats, mnames);
    //
    //
    // Here's the way to add expressions:
    //Expression momentum_expr;
    //momentum_expr.SetName("momentum");
    //momentum_expr.SetDefinition("{u, v}");
    //momentum_expr.SetType(Expression::VectorMeshVar);
    //md->AddExpression(&momentum_expr);
    //Expression KineticEnergy_expr;
    //KineticEnergy_expr.SetName("KineticEnergy");
    //KineticEnergy_expr.SetDefinition("0.5*(momentum*momentum)/(rho*rho)");
    //KineticEnergy_expr.SetType(Expression::ScalarMeshVar);
    //md->AddExpression(&KineticEnergy_expr);
    //
//}


// ****************************************************************************
//  Method: avtWPPImageFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: bjorn -- generated by xml2avt
//  Creation:   Fri Jan 13 16:02:12 PST 2012
//
// ****************************************************************************

vtkDataSet *
avtWPPImageFileFormat::GetMesh(int domain, const char *meshname)
{
  debug5 << "constructing a Cartesian grid" << endl;

   if( !m_initialized )
      Initialize();

   vtkFloatArray *coords[3]= {0,0,0};
   coords[0] = vtkFloatArray::New();
   coords[0]->SetNumberOfTuples(m_ni[domain]);
   coords[1] = vtkFloatArray::New();
   coords[1]->SetNumberOfTuples(m_nj[domain]);
   coords[2] = vtkFloatArray::New();
   coords[2]->SetNumberOfTuples(m_nk[domain]);
   float* x = (float *)coords[0]->GetVoidPointer(0);
   float* y = (float *)coords[1]->GetVoidPointer(0);
   float* z = (float *)coords[2]->GetVoidPointer(0);
   for( int i=0 ; i < m_ni[domain] ; i++ )
      x[i] = i*m_gridsize[domain]+m_xmin[domain];
   for( int i=0 ; i < m_nj[domain] ; i++ )
      y[i] = i*m_gridsize[domain]+m_ymin[domain];
   for( int i=0 ; i < m_nk[domain] ; i++ )
      z[i] = i*m_gridsize[domain]+m_zmin[domain];
   vtkRectilinearGrid *rgrid= vtkRectilinearGrid::New();
   int dims[3];
   dims[0] = m_ni[domain];
   dims[1] = m_nj[domain];
   dims[2] = m_nk[domain];
   rgrid->SetDimensions(dims);
   rgrid->SetXCoordinates(coords[0]);
   rgrid->SetYCoordinates(coords[1]);
   rgrid->SetZCoordinates(coords[2]);
   coords[0]->Delete();
   coords[1]->Delete();
   coords[2]->Delete();
   debug5 << "done get mesh " << endl;
   return rgrid;
}


// ****************************************************************************
//  Method: avtWPPImageFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: bjorn -- generated by xml2avt
//  Creation:   Fri Jan 13 16:02:12 PST 2012
//
// ****************************************************************************

vtkDataArray *
avtWPPImageFileFormat::GetVar(int domain, const char *varname)
{
   debug5 << "avtWPPImageFileFormat::GetVar" << endl;
   if( !m_initialized )
      Initialize();

   vtkFloatArray* arr = vtkFloatArray::New();
   size_t npts = ((size_t) m_ni[domain])*m_nj[domain]*m_nk[domain];
   arr->SetNumberOfTuples(npts);
   float* data = (float *)arr->GetVoidPointer(0);
   int fd = open(m_filename.c_str(), O_RDONLY | O_BINARY );
   char errmsg[500];
   if( fd == -1 )
   {
      snprintf(errmsg,500,"Error opening file %s",m_filename.c_str());
      EXCEPTION1( InvalidDBTypeException, errmsg );
   }
   off_t nr = lseek(fd,m_offset[domain],SEEK_CUR);
   if( nr != m_offset[domain] )
   {
      close(fd);
      snprintf(errmsg,500,"Error accessing array in %s",m_filename.c_str());
      EXCEPTION1( InvalidDBTypeException, errmsg );
   }
   if( m_prec == 4 )
   {
      nr = read(fd,data,sizeof(float)*npts);
      if( nr != sizeof(float)*npts )
      {
     close(fd);
     snprintf(errmsg,500,"Error reading array in %s" , m_filename.c_str());
     EXCEPTION1( InvalidDBTypeException, errmsg );
      }
   }
   else
   {
      double* tmp=new double[npts];
      nr = read(fd,tmp,sizeof(double)*npts);
      if( nr != sizeof(double)*npts )
      {
     close(fd); 
     delete [] tmp;
     snprintf(errmsg,500,"Error reading array in %s" , m_filename.c_str());
     EXCEPTION1( InvalidDBTypeException, errmsg );
      }
      for( size_t i = 0 ; i < npts ; i++ )
     data[i] = tmp[i];
      delete[] tmp;
   }
   close(fd);
   debug5 << "done get var " << endl;
   return arr;
}


// ****************************************************************************
//  Method: avtWPPImageFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: bjorn -- generated by xml2avt
//  Creation:   Fri Jan 13 16:02:12 PST 2012
//
// ****************************************************************************

vtkDataArray *
avtWPPImageFileFormat::GetVectorVar(int domain, const char *varname)
{
   // There are no vector variables 
   return 0;
}

// ****************************************************************************
//  Method: avtvolimageFileFormat::Initialize
//
//  Purpose:
//      Read the file.
//
//
// ****************************************************************************

void avtWPPImageFileFormat::Initialize()
{
    char errmsg[500];
    debug5 << "Initialize begins" << endl;

    size_t k=m_filename.rfind('.');

    if( k != string::npos )
        m_mode = m_filename.substr(k+1);
    else
        m_mode = " ";
    if( !(m_mode == "ux" || m_mode == "uy" || m_mode == "uz" || m_mode == "rho" ||
          m_mode == "lambda" || m_mode == "mu" || m_mode == "p" || m_mode == "s" ||
          m_mode == "div" || m_mode == "curl" || m_mode == "veldiv" || m_mode == "velcurl" ||
          m_mode == "lat" || m_mode == "lon" || m_mode == "hvelmax" || m_mode == "vvelmax" ||
          m_mode == "topo" || m_mode == "grid" || m_mode == "uxerr" || m_mode == "uyerr" ||
          m_mode == "uzerr" || m_mode == "fx" || m_mode == "fy" || m_mode == "fz" ||
          m_mode == "velmag" || m_mode == "qs" || m_mode == "qp" || m_mode == "hvel" ) ) 
    {
        snprintf(errmsg,500,"Error: Unknown volimage mode %s" , m_mode.c_str() );
        EXCEPTION1( InvalidDBTypeException, errmsg );
    }
    debug5 << "mode = " << m_mode << endl;

    int fd = open( m_filename.c_str(), O_RDONLY|O_BINARY );
    if( fd == -1 )
    {
        snprintf(errmsg,500,"Error opening file %s",m_filename.c_str());
        EXCEPTION1( InvalidDBTypeException, errmsg );
    }
    debug5 << "file opened " << endl;
    size_t nr = read(fd,&m_prec,sizeof(int) );
    if( nr != sizeof(int) )
    {
        snprintf(errmsg,500,"Error reading precision in %s",m_filename.c_str());
        EXCEPTION1( InvalidDBTypeException, errmsg );
    }
    if( (m_prec != 4) && (m_prec != 8 ) )
    {
       snprintf(errmsg,500,"Error, precision is %i, should be 4 or 8\n",m_prec);
       EXCEPTION1( InvalidDBTypeException, errmsg );
    }
    nr = read(fd,&m_nblocks,sizeof(int) );
    if( nr != sizeof(int) )
    {
        snprintf(errmsg,500,"Error reading nblocks in %s",m_filename.c_str());
        EXCEPTION1( InvalidDBTypeException, errmsg );
    }
    debug5 << "prec = " << m_prec << " " << " nblocks = " << m_nblocks << endl;

// was there a grid file?
    m_CartGrid = true;
    debug5 << "No grid file, assuming Cartesian grid" << endl;

    double plane_value = 0;
    int slice_plane;
    char *ptr = 0;
    if((ptr = strstr( m_filename.c_str(), "x=")) != NULL)
       slice_plane = 0;
    else if((ptr = strstr(m_filename.c_str(), "y=")) != NULL)
       slice_plane = 1;
    else if((ptr = strstr(m_filename.c_str(), "z=")) != NULL)
       slice_plane = 2;
    if(ptr != 0)
       sscanf(ptr+2, "%lf", &plane_value );

    m_gridsize.resize(m_nblocks);
    m_xmin.resize(m_nblocks);
    m_ymin.resize(m_nblocks);
    m_zmin.resize(m_nblocks);
    m_ni.resize(m_nblocks);
    m_nj.resize(m_nblocks);
    m_nk.resize(m_nblocks);
    m_offset.resize(m_nblocks);

    size_t header_offset = 2*sizeof(int)+m_nblocks*(sizeof(double)+4*sizeof(int));
    int dims[4];
    debug5 << "reading block headers " << endl;
    for( int b=0 ; b < m_nblocks ; b++ )
    {
        debug5 << "b = " << b << endl;
        nr = read(fd,&m_gridsize[b],sizeof(double));
        if( nr != sizeof(double) )
        {
            snprintf(errmsg,500,"Error reading gridsizes in %s",m_filename.c_str());
            EXCEPTION1( InvalidDBTypeException, errmsg );
        }
        nr = read(fd,dims,sizeof(int)*4);
        if( nr != sizeof(int)*4 )
        {
            snprintf(errmsg,500,"Error reading dimensions in %s",m_filename.c_str());
            EXCEPTION1( InvalidDBTypeException, errmsg );
        }
        if( slice_plane == 0 )
    {
       m_ni[b] = 1;
       m_nj[b] = dims[1]-dims[0]+1;
       m_nk[b] = dims[3]-dims[2]+1;
           m_xmin[b] = plane_value;
       m_ymin[b] = (dims[0]-1)*m_gridsize[b];
       m_zmin[b] = (dims[2]-1)*m_gridsize[b];
    }
    else if( slice_plane == 1 )
    {
       m_ni[b] = dims[1]-dims[0]+1;
       m_nj[b] = 1;
       m_nk[b] = dims[3]-dims[2]+1;
           m_xmin[b] = (dims[0]-1)*m_gridsize[b];
       m_ymin[b] = plane_value;
       m_zmin[b] = (dims[2]-1)*m_gridsize[b];
    }
        else
    {
       m_ni[b] = dims[1]-dims[0]+1;
       m_nj[b] = dims[3]-dims[2]+1;
       m_nk[b] = 1;
           m_xmin[b] = (dims[0]-1)*m_gridsize[b];
       m_ymin[b] = (dims[2]-1)*m_gridsize[b];
       m_zmin[b] = plane_value;
    }
        debug5 << "b = " << b << " dims[0] = " << dims[0] << " dims[1] = " << dims[1] << " dims[2] = " 
       << dims[2] << " dims[3] = " << dims[3] << endl;
        debug5 << "x_min = " << m_xmin[b] << " y_min = " << m_ymin[b] << " z_min = " << m_zmin[b] << endl;
    }
    m_offset[0] = header_offset;
    int datasize;
    if( m_prec == 4 )
        datasize = sizeof(float);
    else
        datasize = sizeof(double);

// calculate offsets for accessing data
    for( int b=1 ; b < m_nblocks ; b++ )
        m_offset[b] = m_offset[b-1] + ((size_t) m_ni[b-1])*m_nj[b-1]*m_nk[b-1]*datasize;

// z-offset for x- or y- slices
    if( slice_plane == 0 || slice_plane == 1 )
       for( int b=m_nblocks-1 ; b > 0 ; b-- )
      m_zmin[b-1] = m_zmin[b] + (m_nk[b]-1)*m_gridsize[b];

    close(fd); // closing the solution file

    m_initialized = true;
    debug5 << "Initialize done " << endl;
}

/*****************************************************************************
*
* Copyright (c) 2000 - 2018, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtGTCFileFormat.C                           //
// ************************************************************************* //

#include <avtMTSDFileFormatInterface.h>
#include <avtGTCFileFormat.h>

#include <string>
#include <map>

#include <vtkFloatArray.h>
#include <vtkDoubleArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>
#include <vtkGenericCell.h>
#include <vtkPolyData.h>
#include <vtkDelaunay3D.h>
#include <vtkDelaunay2D.h>
#include <vtkGenericCell.h>

#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>
#include <Utility.h>
#include <VisItStreamUtil.h>

#include <InvalidVariableException.h>

using namespace std;

static std::vector<int> CSVToVectorInt(const std::string csv) noexcept
{
    std::vector<int> numbers;
    if (csv.empty())
    {
        return numbers;
    }

    if (csv.find(",") == csv.npos) // if no commas, one int
    {
        numbers.push_back(std::stoi(csv)); // might need to be checked
    }
    else
    {
        numbers.reserve(std::count(csv.begin(), csv.end(), ','));

        std::istringstream csvSS(csv);
        std::string value;
        while (std::getline(csvSS, value, ','))
        {
            numbers.push_back(std::stoi(csv));
        }
    }

    return numbers;
}

bool
avtGTCFileFormat::Identify(const char *fname)
{
    return false;
    //return true;
}

avtFileFormatInterface *
avtGTCFileFormat::CreateInterface(const char *const *list,
                                  int nList,
                                  int nBlock)
{
    int nTimestepGroups = nList / nBlock;
    avtMTSDFileFormat ***ffl = new avtMTSDFileFormat**[nTimestepGroups];    
    for (int i = 0; i < nTimestepGroups; i++)
    {
        ffl[i] =  new avtMTSDFileFormat*[nBlock];
        for (int j = 0; j < nBlock; j++)
            ffl[i][j] =  new avtGTCFileFormat(list[i*nBlock +j]);
    }
    return new avtMTSDFileFormatInterface(ffl, nTimestepGroups, nBlock);
}

// ****************************************************************************
//  Method: avtGTCFileFormat constructor
//
//  Programmer: pugmire -- generated by xml2avt
//  Creation:   Thu Apr 12 08:39:47 PDT 2018
//
// ****************************************************************************

avtGTCFileFormat::avtGTCFileFormat(const char *filename)
    : adios(std::make_shared<adios2::ADIOS>(adios2::DebugON)), io(adios->DeclareIO("ReadBP")), numTimeSteps(1), avtMTSDFileFormat(&filename, 1)
{
    reader = io.Open(filename, adios2::Mode::Read);
    if (!reader)
        EXCEPTION1(ImproperUseException, "Invalid file");

    variables = io.AvailableVariables();
    attributes = io.AvailableAttributes();

    //Determine how many steps we have.
    if (variables.find("potential") != variables.end())
        numTimeSteps = std::stoi(variables["potential"]["AvailableStepsCount"]);
    
    cout<<"Attrs: "<<endl;
    for (auto ai = attributes.begin(); ai != attributes.end(); ai++)
        cout<<ai->first<<" "<<ai->second<<endl;
    cout<<"Vars:"<<endl;
    for (auto vi = variables.begin(); vi != variables.end(); vi++)
        cout<<vi->first<<" "<<vi->second<<endl;
}


// ****************************************************************************
//  Method: avtGTCFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: pugmire -- generated by xml2avt
//  Creation:   Thu Apr 12 08:39:47 PDT 2018
//
// ****************************************************************************

int
avtGTCFileFormat::GetNTimesteps()
{
    cout<<"Num timesteps= "<<numTimeSteps<<endl;
    return numTimeSteps;
}

void
avtGTCFileFormat::GetCycles(std::vector<int> &c)
{
    c.resize(numTimeSteps);
    for (int i = 0; i < numTimeSteps; i++)
        c[i] = i;
    cout<<"CYCLES= "<<c<<endl;
}

void
avtGTCFileFormat::GetTimes(std::vector<double> &t)
{
    t.resize(numTimeSteps);
    for (int i = 0; i < numTimeSteps; i++)
        t[i] = (double)i;
    cout<<"TIMES= "<<t<<endl;
}

// ****************************************************************************
//  Method: avtGTCFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: pugmire -- generated by xml2avt
//  Creation:   Thu Apr 12 08:39:47 PDT 2018
//
// ****************************************************************************

void
avtGTCFileFormat::FreeUpResources(void)
{
}


// ****************************************************************************
//  Method: avtGTCFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: pugmire -- generated by xml2avt
//  Creation:   Thu Apr 12 08:39:47 PDT 2018
//
// ****************************************************************************

void
avtGTCFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
    vector<pair<string,string>> vars;

    //first,second: (variableName, map<string,string> {'shape', '10,10,10' : 'name', 'varname'
    for (const auto &varInfo : variables)
    {
        auto params = varInfo.second;
        string shape = params["Shape"];
        auto vecShape = CSVToVectorInt(shape);
        if (meshInfo.find(shape) == meshInfo.end())
        {
            string meshNm;
            int dim = 0;
            if (vecShape.size() == 2)
            {
                meshNm = "mesh" + std::to_string(vecShape[0])+"x"+std::to_string(vecShape[1]);
                dim = 2;
            }
            else if (vecShape.size() == 3)
            {
                meshNm = "mesh" + std::to_string(vecShape[0])+"x"+std::to_string(vecShape[1])+"x"+std::to_string(vecShape[2]);
                dim = 3;
            }
            cout<<shape<<endl;
            meshInfo[shape] = std::make_pair(dim, meshNm);
        }
        vars.push_back(std::make_pair(varInfo.first, meshInfo[shape].second));
    }
    
    AddMeshToMetaData(md, "ptmesh", AVT_POINT_MESH, NULL, 1, 0, 3, 3);
    AddMeshToMetaData(md, "mesh", AVT_UNSTRUCTURED_MESH, NULL, 1, 0, 3, 3);    
    AddScalarVarToMetaData(md, "potential", "mesh", AVT_NODECENT);


    /*
    vector<pair<string,string>> vars;

    for (const auto &varInfo : variables)
    {
        auto params = varInfo.second;
        string shape = params["Shape"];
        auto vecShape = CSVToVectorInt(shape);
        if (meshInfo.find(shape) == meshInfo.end())
        {
            string meshNm;
            int dim = 0;
            if (vecShape.size() == 2)
            {
                meshNm = "mesh" + std::to_string(vecShape[0])+"x"+std::to_string(vecShape[1]);
                dim = 2;
            }
            else if (vecShape.size() == 3)
            {
                meshNm = "mesh" + std::to_string(vecShape[0])+"x"+std::to_string(vecShape[1])+"x"+std::to_string(vecShape[2]);
                dim = 3;
            }
            meshInfo[shape] = std::make_pair(dim, meshNm);
        }
        vars.push_back(std::make_pair(varInfo.first, meshInfo[shape].second));
    }

    for (auto &m : meshInfo)
    {
        string nm = m.second.second;
        int dim = m.second.first;
        AddMeshToMetaData(md, nm, AVT_RECTILINEAR_MESH, NULL, 1, 0, dim, dim);
        cout<<"MESH: "<<nm<<endl;
    }

    for (auto &v : vars)
    {
        AddScalarVarToMetaData(md, v.first, v.second, AVT_NODECENT);
        cout<<"VAR: "<<v.first<<endl;
    }
    */
}


// ****************************************************************************
//  Method: avtGTCFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: pugmire -- generated by xml2avt
//  Creation:   Thu Apr 12 08:39:47 PDT 2018
//
// ****************************************************************************

vtkDataSet *
avtGTCFileFormat::GetPtMesh(int timestate, const char *meshname)
{
    adios2::Variable<float> c = io.InquireVariable<float>("coordinates");
    if (!c)
        return NULL;

    //dims: nPlanes, 3, nPts
    auto dims = c.Shape();

    cout<<"DIMS: "<<dims<<endl;
    vector<float> buff(dims[0]*dims[1]*dims[2]);

    c.SetStepSelection({timestate, 1});
    c.SetSelection(adios2::Box<adios2::Dims>({0,0,0}, dims));
    reader.Get(c, buff.data(), adios2::Mode::Sync);

    vtkPoints *pts = vtkPoints::New();
    pts->SetNumberOfPoints(dims[0]*dims[2]);
    vtkUnstructuredGrid *grid = vtkUnstructuredGrid::New();
    grid->SetPoints(pts);
    pts->Delete();

    int numPlanes = dims[0];
    int ptsPerPlane = dims[2];

    //Fortran to C order.
    std::swap(dims[0], dims[2]);
/*    
    vtkIdType idx = 0;
    for (int i = 0; i < dims[0]; i++)
        for (int k = 0; k < dims[2]; k++)
        {
            double pt[3] = {buff[(k*dims[0]*dims[1]) + 0*dims[0] + i],
                            buff[(k*dims[0]*dims[1]) + 1*dims[0] + i],
                            buff[(k*dims[0]*dims[1]) + 2*dims[0] + i]};

            pts->SetPoint(idx, pt);
            grid->InsertNextCell(VTK_VERTEX, 1, &idx);
            idx++;
        }
*/

    //reverse the loop dims to get it into per-plane points.
    vtkIdType idx = 0;
    for (int k = 0; k < dims[2]; k++)    
    {
        for (int i = 0; i < dims[0]; i++)
        {
            double pt[3] = {buff[(k*dims[0]*dims[1]) + 0*dims[0] + i],
                            buff[(k*dims[0]*dims[1]) + 1*dims[0] + i],
                            buff[(k*dims[0]*dims[1]) + 2*dims[0] + i]};

            pts->SetPoint(idx, pt);
            grid->InsertNextCell(VTK_VERTEX, 1, &idx);
            idx++;
        }
    }


    
    return grid;
}

vtkDataSet *
avtGTCFileFormat::GetMesh(int timestate, const char *meshname)
{
    if (!strcmp(meshname, "ptmesh"))
        return GetPtMesh(timestate, meshname);
    
    adios2::Variable<float> c = io.InquireVariable<float>("coordinates");
    if (!c)
        return NULL;

    //dims: nPlanes, 3, nPts
    auto dims = c.Shape();
    cout<<"DIMS: "<<dims<<endl;
    vector<float> buff(dims[0]*dims[1]*dims[2]);

    c.SetStepSelection({timestate, 1});
    c.SetSelection(adios2::Box<adios2::Dims>({0,0,0}, dims));
    reader.Get(c, buff.data(), adios2::Mode::Sync);

    vtkPoints *pts = vtkPoints::New();
    pts->SetNumberOfPoints(dims[0]*dims[2]);
    vtkUnstructuredGrid *grid = vtkUnstructuredGrid::New();
    grid->SetPoints(pts);
    pts->Delete();

    //Fortran to C order.
    std::swap(dims[0], dims[2]);
    
    vtkIdType idx = 0;
    for (int k = 0; k < dims[2]; k++)    
        for (int i = 0; i < dims[0]; i++)
        {
            double pt[3] = {buff[(k*dims[0]*dims[1]) + 0*dims[0] + i],
                            buff[(k*dims[0]*dims[1]) + 1*dims[0] + i],
                            buff[(k*dims[0]*dims[1]) + 2*dims[0] + i]};
            pts->SetPoint(idx, pt);
            idx++;
        }


    //Get the connectivity...

    //triangulate plane 0.
    vtkPoints *pts0 = vtkPoints::New();
    pts0->SetNumberOfPoints(dims[0]);
    cout<<"pts0 : "<<dims[0]<<endl;
    for (int i = 0; i < dims[0]; i++)
    {
        double pt[3];
        pts->GetPoint(i, pt);
        pt[1] = pt[2];
        pt[2] = 0;
        pts0->SetPoint(i, pt);
    }
    vtkPolyData *pd = vtkPolyData::New();
    pd->SetPoints(pts0);
    vtkDelaunay2D *del = vtkDelaunay2D::New();
    del->SetInputData(pd);
    del->Update();
    vtkDataSet *ds0 = del->GetOutput();
    //del3d->Delete();

    int numTris = ds0->GetNumberOfCells();
    cout<<"numTris= "<<numTris<<endl;

    //Now, add the wedge elements from the triangulation...
    int numPlanes = dims[0];
    int ptsPerPlane = dims[2];
    vtkIdType wedge[6];

    numPlanes = 31;
    ptsPerPlane = 2145;
    ptsPerPlane = 38315;

    numPlanes = 12;
    //vtkGenericCell *cell = vtkGenericCell::New();
    for (int i = 0; i < numPlanes; i++)
        for (int j = 0; j < numTris; j++)
        {
            vtkCell *cell = ds0->GetCell(j);
            vtkIdList *ids = cell->GetPointIds();
            int offset = i*ptsPerPlane;
            wedge[0] = offset + ids->GetId(0);
            wedge[1] = offset + ids->GetId(1);
            wedge[2] = offset + ids->GetId(2);

            offset = (i+1)*ptsPerPlane;
            
            wedge[3] = offset + ids->GetId(0);
            wedge[4] = offset + ids->GetId(1);
            wedge[5] = offset + ids->GetId(2);
            grid->InsertNextCell(VTK_WEDGE, 6, wedge);            
        }

    return grid;
}

// ****************************************************************************
//  Method: avtGTCFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: pugmire -- generated by xml2avt
//  Creation:   Thu Apr 12 08:39:47 PDT 2018
//
// ****************************************************************************

vtkDataArray *
avtGTCFileFormat::GetVar(int timestate, const char *varname)
{
    cout<<"GetVar: "<<timestate<<" "<<varname<<endl;
    
    adios2::Variable<float> var = io.InquireVariable<float>(varname);
    if (!var)
        return NULL;
    
    auto dims = var.Shape();
    cout<<"DIMS: "<<dims<<endl;
    
    var.SetStepSelection({timestate, 1});    
    var.SetSelection(adios2::Box<adios2::Dims>({0,0}, dims));

    vector<float> buff(dims[0]*dims[1]);    
    reader.Get(var, buff.data(), adios2::Mode::Sync);

    vtkFloatArray *arr = vtkFloatArray::New();

    int nPts = 2145;
    nPts = 38315;
    int nPlanes = 32;
    arr->SetNumberOfTuples(nPts * nPlanes);

    int idx = 0;
    for (int i = 0; i < nPlanes; i++)    
        for (int j = 0; j < nPts; j++)
        {
            //arr->SetTuple1(idx, buff[j*nPlanes+i]);
            arr->SetTuple1(idx, buff[i*nPts+j]);
            //arr->SetTuple1(idx, i);
            idx++;
        }

#if 0
    arr->SetNumberOfTuples(dims[0]*dims[1]);
    int idx = 0;
    for (int i = 0; i < dims[0]; i++)    
        for (int j = 0; j < dims[1]; j++)    
        {
            //arr->SetTuple1(j*dims[0]+i, buff[i*dims[1]+j]);
            arr->SetTuple1(idx, buff[i*dims[1]+j]);
            idx++;
        }
#endif
    
    return arr;
}


// ****************************************************************************
//  Method: avtGTCFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: pugmire -- generated by xml2avt
//  Creation:   Thu Apr 12 08:39:47 PDT 2018
//
// ****************************************************************************

vtkDataArray *
avtGTCFileFormat::GetVectorVar(int timestate, const char *varname)
{
    return NULL;
}

/*****************************************************************************
*
* Copyright (c) 2000 - 2008, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-400142
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtPFLOTRANFileFormat.C                           //
// ************************************************************************* //

#include <avtPFLOTRANFileFormat.h>

#include <algorithm>
#include <string>
#include <DebugStream.h>
#include <snprintf.h>

#include <vtkDoubleArray.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>

#include <avtDatabaseMetaData.h>

#include <InvalidDBTypeException.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>

using std::string;

static std::string coordNames[3] = { "X [m]", "Y [m]", "Z [m]" };

// ****************************************************************************
//  Method: avtPFLOTRANFileFormat constructor
//
//  Programmer: ahern -- generated by xml2avt
//  Creation:   Thu Apr 24 14:00:58 PST 2008
//
// ****************************************************************************

avtPFLOTRANFileFormat::avtPFLOTRANFileFormat(const char *fname):
    avtMTMDFileFormat(fname)
{
    filename = strdup(fname);
    opened = false;
    nTime = 0;

    // Turn off HDF5 error messages to the terminal.
    H5Eset_auto(NULL, NULL);
}

// ****************************************************************************
//  Method: avtPFLOTRANFileFormat destructor
//
//  Programmer: ahern -- generated by xml2avt
//  Creation:   Thu Apr 24 14:00:58 PST 2008
//
// ****************************************************************************

avtPFLOTRANFileFormat::~avtPFLOTRANFileFormat()
{
    free(filename);
    filename = NULL;
}

// ****************************************************************************
//  Method: avtEMSTDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: ahern -- generated by xml2avt
//  Creation:   Thu Apr 24 14:00:58 PST 2008
//
// ****************************************************************************

int
avtPFLOTRANFileFormat::GetNTimesteps(void)
{
    LoadFile();

    return nTime;
}

// ****************************************************************************
//  Method: avtPFLOTRANFileFormat::LoadFile
//
//  Purpose:
//      Loads the basics of the file into memory.
//
//  Programmer: ahern
//  Creation:   Thu Apr 24 14:00:58 PST 2008
//
// ****************************************************************************

void
avtPFLOTRANFileFormat::LoadFile(void)
{
    if (opened == true)
        return;

    // Initialize HDF5.
    H5open();

    // Grab the file and begin.
    fileID = H5Fopen(filename, H5F_ACC_RDONLY, H5P_DEFAULT);
    if (fileID < 0)
    {
        debug4 << "avtPFLOTRANFileFormat::LoadFile: " << "Could not open <" << filename << ">" << endl;
        char error[1024];
        SNPRINTF(error, 1024, "Cannot be a PFLOTRAN file (%s) since it is not even an HDF5 file:",filename);
        EXCEPTION1(InvalidDBTypeException, error);
    }

    // Check the coordinates and pull out the mesh dimensions
    // while we're at it.
    hid_t coordsGID = H5Gopen(fileID, "Coordinates");
    if (coordsGID < 0)
    {
        debug4 << "avtPFLOTRANFileFormat::LoadFile: " << "Could not open the Coordinates group in file " << filename << endl;
        EXCEPTION1(InvalidDBTypeException, "Cannot be a PFLOTRAN file since it does not have a Coordinates group.");
    }
    for (int dim=0;dim<3;dim++)
    {
        dimID[dim] = H5Dopen(coordsGID, coordNames[dim].c_str());
        if (dimID[dim] < 0)
        {
            debug4 << "avtPFLOTRANFileFormat::LoadFile: " << "Could not open the " << coordNames[dim] << "dataset in file " << filename << endl;
            EXCEPTION1(InvalidDBTypeException, "Cannot be a PFLOTRAN file since it does not have valid coordinates data.");
        }
        hid_t dimSpaceID = H5Dget_space(dimID[dim]);
        if (dimSpaceID < 0)
        {
            debug4 << "avtPFLOTRANFileFormat::LoadFile: " << "Could not get the space information for the " << coordNames[dim] << " coordinate in file " << filename << endl;
            EXCEPTION1(InvalidDBTypeException, "Cannot be a PFLOTRAN file since it does not have valid coordinates data.");
        }
        int ndims = H5Sget_simple_extent_ndims(dimSpaceID);
        if (ndims != 1)
        {
            debug4 << "avtPFLOTRANFileFormat::LoadFile: " << "The " << coordNames[dim] << " coordinate is not one dimensional" << endl;
            EXCEPTION1(InvalidDBTypeException, "Cannot be a PFLOTRAN file since some coordinate data is not one dimensional.");
        }
        hsize_t dims, maxdims;
        H5Sget_simple_extent_dims(dimSpaceID, &dims, &maxdims);

        meshDims[dim] = dims;
    }

    // Look for groups starting with "Time:".  They're our timesteps.
    hsize_t nObjs;
    H5Gget_num_objs(fileID, &nObjs);
    nTime = 0;
    times.clear();
    for(int i=0;i<nObjs;i++)
    {
        char name[256];
        H5Gget_objname_by_idx(fileID, i, name, 256);
        if (strncmp(name, "Coordinates", 11) == 0)
            continue;
        if (strncmp(name, "Time: ", 6) == 0)
        {
            nTime++;
            double time;
            sscanf(name, "Time: %lf h", &time);
            times.push_back(std::make_pair(time,name));
        }
        else
        {
            // Unknown name.
            debug2 << "avtPFLOTRANFileFormat::LoadFile: Unknown object in file: " << name << endl;
        }
    }
    std::sort(times.begin(), times.end());

    opened = true;
}

// ****************************************************************************
//  Method: avtPFLOTRANFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: ahern -- generated by xml2avt
//  Creation:   Thu Apr 24 14:00:58 PST 2008
//
// ****************************************************************************

void
avtPFLOTRANFileFormat::FreeUpResources(void)
{
    if (fileID > 0)
        H5Fclose(fileID);
    opened = false;
}

// ****************************************************************************
//  Method: avtPFLOTRANFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: ahern -- generated by xml2avt
//  Creation:   Thu Apr 24 14:00:58 PST 2008
//
// ****************************************************************************

void
avtPFLOTRANFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData * md,
                                                 int timeState)
{
    LoadFile();

    // Mesh
    avtMeshMetaData *mesh = new avtMeshMetaData;
    mesh->name = "mesh";
    mesh->meshType = AVT_RECTILINEAR_MESH;
    mesh->numBlocks = 1 * 1 * 1;
    mesh->blockOrigin = 1;
    mesh->cellOrigin = 0;
    mesh->spatialDimension = 3;
    mesh->topologicalDimension = 3;
    mesh->blockTitle = "blocks";
    mesh->blockPieceName = "block";
    mesh->hasSpatialExtents = false;
    //mesh->xUnits = "mm";
    //mesh->yUnits = "mm";
    //mesh->zUnits = "mm";
    md->Add(mesh);

    // Look in the timestep for the list of variables.
    hid_t g = H5Gopen(fileID, times[timeState].second.c_str());
    hsize_t nObjs;
    H5Gget_num_objs(g, &nObjs);
    for(int i=0;i<nObjs;i++)
    {
        char name[512];
        H5Gget_objname_by_idx(g, i, name, 512);
        avtScalarMetaData *scalar = new avtScalarMetaData();
        scalar->name = name;
        scalar->meshName = "mesh";
        scalar->centering = AVT_NODECENT;
        md->Add(scalar);
    }

    // Set the time information.
    std::vector<double> t;
    for(int i=0;i<nTime;i++)
        t.push_back(times[i].first);
    md->SetTimes(t);
    md->SetTimesAreAccurate(true);
    md->SetTemporalExtents(times[0].first, times[nTime-1].first);
}

// ****************************************************************************
//  Method: avtPFLOTRANFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: ahern -- generated by xml2avt
//  Creation:   Thu Apr 24 14:00:58 PST 2008
//
// ****************************************************************************

vtkDataSet *
avtPFLOTRANFileFormat::GetMesh(int, int domain, const char *)
{
    // Make sure the file is opened and ready.
    LoadFile();

    // Read the coordinates arrays.
    vtkDoubleArray *globalCoords[3];
    for (int dim=0;dim<3;dim++)
    {
        globalCoords[dim] = vtkDoubleArray::New();
        globalCoords[dim]->SetNumberOfTuples(meshDims[dim]);
        double *axis = (double*)globalCoords[dim]->GetVoidPointer(0);
        //hid_t space = H5Dget_space(dimID[dim]);
        herr_t err = H5Dread(dimID[dim], H5T_NATIVE_DOUBLE, H5S_ALL,
                             H5S_ALL, H5P_DEFAULT, axis);
    }
    vtkRectilinearGrid *mesh = vtkRectilinearGrid::New();
    mesh->SetDimensions(meshDims);
    mesh->SetXCoordinates(globalCoords[0]);
    mesh->SetYCoordinates(globalCoords[1]);
    mesh->SetZCoordinates(globalCoords[2]);
    globalCoords[0]->Delete();
    globalCoords[1]->Delete();
    globalCoords[2]->Delete();

    return mesh;
}

// ****************************************************************************
// opened = false;
//  Method: avtPFLOTRANFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: ahern -- generated by xml2avt
//  Creation:   Thu Apr 24 14:00:58 PST 2008
//
// ****************************************************************************

vtkDataArray *
avtPFLOTRANFileFormat::GetVar(int timestate, int, const char *varname)
{
    // Make sure the file is opened and ready.
    LoadFile();

    // Read the dataset from the file.
    hid_t ts = H5Gopen(fileID, times[timestate].second.c_str());
    hid_t ds = H5Dopen(ts, varname);
    hid_t dsSpace = H5Dget_space(ds);
    int ndims = H5Sget_simple_extent_ndims(dsSpace);
    if (ndims != 3)
    {
        debug1 << "The variable " << varname << " had only " << ndims << " dimensions" << endl;
        EXCEPTION1(InvalidVariableException, varname);
    }
    hsize_t dims[3], maxdims[3];
    H5Sget_simple_extent_dims(dsSpace, dims, maxdims);
    double *in = new double[dims[0] * dims[1] * dims[2]];
    herr_t err = H5Dread(ds, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL,
                         H5P_DEFAULT, in);

    // Set up the VTK object.
    vtkDoubleArray *array = vtkDoubleArray::New();
    array->SetNumberOfTuples(dims[0] * dims[1] * dims[2]);
    double *out = (double*)array->GetVoidPointer(0);

    // Input is in a different ordering (Fortran) than VTK wants (C).
    // Reshuffle.
    int nx = meshDims[0];
    int ny = meshDims[1];
    int nz = meshDims[2];
    for (int k=0;k<nz;k++)
        for (int j=0;j<ny;j++)
            for (int i=0;i<nx;i++)
                out[k*nx*ny + j*nx + i] = in[k + j*nz + i*nz*ny];

    delete [] in;
    return array;
}

// ****************************************************************************
//  Method: avtPFLOTRANFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: ahern -- generated by xml2avt
//  Creation:   Thu Apr 24 14:00:58 PST 2008
//
// ****************************************************************************

vtkDataArray *
avtPFLOTRANFileFormat::GetVectorVar(int timestate, int domain,
                                     const char *varname)
{
    // We don't have any vectors, so we should never get here.
    EXCEPTION1(InvalidVariableException, varname);
}

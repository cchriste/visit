/*****************************************************************************
*
* Copyright (c) 2000 - 2015, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtNektarPPFileFormat.C                        //
// ************************************************************************* //

#include <avtNektarPPFileFormat.h>

#include <string>
#include <sys/stat.h>

#include <vtkIntArray.h>
#include <vtkLongArray.h>
#include <vtkFloatArray.h>
#include <vtkDoubleArray.h>
#include <vtkPointData.h>
#include <vtkUnstructuredGrid.h>
#include <vtkVertex.h>
#include <vtkTriangle.h>
#include <vtkQuad.h>
#include <vtkTetra.h>
#include <vtkWedge.h>
#include <vtkPyramid.h>
#include <vtkHexahedron.h>
#include <vtkSmartPointer.h>
#include <vtkXMLUnstructuredGridReader.h>

#include <avtVariableCache.h>
#include <avtDatabaseMetaData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <NonCompliantException.h>
#include <InvalidFilesException.h>
#include <InvalidVariableException.h>

//#include <vtkNektar++.h>

#include <MultiRegions/ExpList.h>
#include <MultiRegions/ExpList1D.h>
#include <MultiRegions/ExpList2D.h>
#include <MultiRegions/ExpList3D.h>
#include <MultiRegions/ExpList2DHomogeneous1D.h>
#include <MultiRegions/ExpList3DHomogeneous1D.h>
#include <MultiRegions/ExpList3DHomogeneous2D.h>

#define ACCELERATE_FRAMEWORK_LINK_FLAGS 1

using namespace Nektar;

// extern vtkInformationUnsignedLongKey *NEKTAR_RT_U_FIELD;
// extern vtkInformationUnsignedLongKey *NEKTAR_RT_V_FIELD;
// extern vtkInformationUnsignedLongKey *NEKTAR_RT_W_FIELD;


// ****************************************************************************
//  Method: avtNektarPPFileFormat constructor
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Fri Nov 7 13:51:33 PST 2014
//
// ****************************************************************************

avtNektarPPFileFormat::avtNektarPPFileFormat(const char *filename, DBOptionsAttributes *readOpts)
  : avtMTSDFileFormat(&filename, 1), refinedDataSet(0)
{
  //std::cerr << __FUNCTION__ << "  " << filenames[0] << std::endl;

  vectorVarComponents[0] = std::string("u");
  vectorVarComponents[1] = std::string("v");
  vectorVarComponents[2] = std::string("w");

  // if( NEKTAR_RT_U_FIELD == 0 )
  //   NEKTAR_RT_U_FIELD = new vtkInformationUnsignedLongKey( "U field", "Not used");
  // if( NEKTAR_RT_V_FIELD == 0 )
  //   NEKTAR_RT_V_FIELD = new vtkInformationUnsignedLongKey( "V field", "Not used");
  // if( NEKTAR_RT_W_FIELD == 0 )
  //   NEKTAR_RT_W_FIELD = new vtkInformationUnsignedLongKey( "W field", "Not used");

  // If *.xml just a mesh no field data.

  // If *.chk field data with a pointer to the mesh.
  // If *.fld field data with a pointer to the mesh.

  int cycle = GuessCycle( filename );

  //----------------------------------------------
  // Get the mesh file name.
  m_meshFile = std::string(filename);

  int fdot = m_meshFile.find_last_of('.');

  if (fdot != std::string::npos)
  {
    std::string ending = m_meshFile.substr(fdot);

    // If a valid cycle and .chk or .fld exchange the cycle number and
    // extension with .xml to get the mesh file name.
    if (cycle != INVALID_CYCLE && ending == ".chk" )
    {
      // Remove the .chk extension.
      m_meshFile = m_meshFile.substr(0, fdot);

      int funderscore = m_meshFile.find_last_of('_');

      if (funderscore != std::string::npos)
      {
        int cycle;
        istringstream ( m_meshFile.substr(funderscore+1) ) >> cycle;

        // Remove the cycle value.
        m_meshFile = m_meshFile.substr(0, funderscore);

        if( cycle >= 0 )
        {
          m_cycles.push_back( cycle );

          // Add the .xml extension
          m_meshFile += std::string(".xml");
        }

        // This should never happen as that would mean a check file
        // without a cycle number. BUt try to salvage something.
        else
        {
          m_meshFile += std::string(".xml");

          int cycle = 0;
          m_cycles.push_back( cycle );
        }
      }

      // No underscore
      else
      {
        ostringstream cycleStr;
        cycleStr << cycle;

        int fcycle = m_meshFile.find_last_of( cycleStr.str() );

        if( fcycle != std::string::npos)
        {
          // Remove the cycle value.
          m_meshFile = m_meshFile.substr(0, fcycle);
          
          // Remove any trailing zeros.
          int fzero;

          while( (fzero = m_meshFile.find_last_of( "0" )) != std::string::npos)
          {
            // Remove the zero.
            m_meshFile = m_meshFile.substr(0, fzero);
          }

          m_meshFile += std::string(".xml");
        }
      }
    }

    // If no cycle and .chk or .fld exchange the extension with .xml
    else if( ending == ".fld" )
    {
      // Remove the .fld extension and add the .xml extension
      m_meshFile = m_meshFile.substr(0, fdot);
      m_meshFile += std::string(".xml");

      // No cycle 
      int cycle = 0;
      m_cycles.push_back( cycle );
    }

    // Only .chk and .fld fies should be passed to the database reader.
    else
    {
      EXCEPTION1( InvalidFilesException, filename );
    }
  }
  // No dot found thus no extension.
  else
  {
    EXCEPTION1( InvalidFilesException, filename );
  }

  // Check for the mesh file to exist.
  struct stat buffer;
  if( stat( m_meshFile.c_str(), &buffer ) )
  {
    EXCEPTION1( InvalidFilesException, m_meshFile );
  }

  // Get the Nektar++ field file for the time slice and number of
  // elements.
  std::string fieldFile(filename);

  LibUtilities::FieldMetaDataMap fieldMetaDataMap;

  vector<LibUtilities::FieldDefinitionsSharedPtr> fieldDef;
  vector<vector<NekDouble> > fieldData;
  LibUtilities::Import(fieldFile,fieldDef,fieldData,fieldMetaDataMap);

  double time;
  LibUtilities::FieldMetaDataMap::iterator it;

  it = fieldMetaDataMap.find("Time");
  if( it != fieldMetaDataMap.end() )
    std::stringstream( it->second ) >> time;
  else
    time = 0;

  m_times.push_back( time );

  if( fieldDef.size() )
  {
    //----------------------------------------------
    // Get the field variable names from the first set of elements.
    int nfields = fieldDef[0]->m_fields.size();

    for(int i = 0; i < nfields; ++i)
    {
      m_scalarVarNames.push_back( fieldDef[0]->m_fields[i] );
    }

    //----------------------------------------------
    // The meshes can have mixed elements so get the total from each field.
    m_nElements = 0;

    for(int i = 0; i < fieldDef.size(); ++i)
      m_nElements += fieldDef[i]->m_elementIDs.size();
  }
  else
  {
    EXCEPTION1( InvalidFilesException, filename );
  }
}


// ****************************************************************************
//  Method: avtEMSTDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Fri Nov 7 13:51:33 PST 2014
//
// ****************************************************************************

int
avtNektarPPFileFormat::GetNTimesteps(void)
{
  //std::cerr << __FUNCTION__ << "  " << filenames[0] << std::endl;

    return (int) m_times.size();
}


// ****************************************************************************
//  Method: avtNektarPPFileFormat::GetCycles
//
//  Purpose:
//      Returns the cycles
//
//  Arguments:
//      c          the cycles
//
//  Programmer: allen
//  Creation:   
//
// ****************************************************************************

void avtNektarPPFileFormat::GetCycles(std::vector<int> &cycles)
{
    cycles = m_cycles;
}


// ****************************************************************************
//  Method: avtNektarPPFileFormat::GetTimes
//
//  Purpose:
//      Returns the times
//
//  Arguments:
//      t          the times
//
//  Programmer: allen
//  Creation:   
//
// ****************************************************************************

void avtNektarPPFileFormat::GetTimes(std::vector<double> &times)
{
    times = m_times;
}


// ****************************************************************************
// Method: avtNektarPPFileFormat::Initialize
//
// Purpose:
//   Initializes the file format by reading the file and the contents, etc.
//
//  Programmer: allen
//  Creation:   Fri Nov 7 13:51:33 PST 2014
//
// ****************************************************************************

void
avtNektarPPFileFormat::Initialize()
{
  //std::cerr << __FUNCTION__ << "  " << filenames[0] << std::endl;

  if( refinedDataSet == NULL )
  {
    std::string xmlstr = GetNektarFileAsXMLString("");

    vtkSmartPointer<vtkXMLUnstructuredGridReader> reader =
      vtkSmartPointer<vtkXMLUnstructuredGridReader>::New();
    
#if (6 <= VTK_MAJOR_VERSION && 2 <= VTK_MINOR_VERSION )
    reader->ReadFromInputStringOn();
    reader->SetInputString(xmlstr);
#else
    ofstream outstream("/tmp/visit_tmp.vtu");
    outstream << xmlstr;
    outstream.close();

    reader->SetFileName("/tmp/visit_tmp.vtu");
#endif

    reader->Update();
    reader->GetOutput()->Register(reader);
    
    refinedDataSet = vtkDataSet::SafeDownCast(reader->GetOutput());
  }
}

// ****************************************************************************
//  Method: avtNektarPPFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Fri Nov 7 13:51:33 PST 2014
//
// ****************************************************************************

void
avtNektarPPFileFormat::FreeUpResources(void)
{
  //std::cerr << __FUNCTION__ << "  " << filenames[0] << std::endl;

  if( refinedDataSet )
  {
    refinedDataSet->Delete();
    refinedDataSet = NULL;
  }
}

// ****************************************************************************
// Method: avtNektarPPFileFormat::ActivateTimestep
//
// Purpose:
//   This method is called each time we change to a new time state. Make
//   sure that the file has been initialized.
//
//  Programmer: allen
//  Creation:   Fri Nov 7 13:51:33 PST 2014
//
// ****************************************************************************

void
avtNektarPPFileFormat::ActivateTimestep(int ts)
{
  //std::cerr << __FUNCTION__ << "  " << filenames[0] << std::endl;

    //
    // Initialize the file if it has not been initialized.
    //
    Initialize();
}

// ****************************************************************************
//  Method: avtNektarPPFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Fri Nov 7 13:51:33 PST 2014
//
// ****************************************************************************

void
avtNektarPPFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
  //std::cerr << __FUNCTION__ << "  " << filenames[0] << std::endl;

    md->SetDatabaseComment(std::string("Read using the Nektar++ reader") +
                           md->GetDatabaseComment());

    //----------------------------------------------
    // Read in mesh from input file
    SpatialDomains::MeshGraphSharedPtr graphShPt =
      SpatialDomains::MeshGraph::Read(m_meshFile);
    //----------------------------------------------

    // Add in the refined mesh.
    avtMeshMetaData *mmd;
    avtMeshType meshType = AVT_UNSTRUCTURED_MESH;
    std::string meshName("mesh");
    int nblocks = 1;
    int block_origin = 0;
    int cell_origin = 0;
    int group_origin = 0;
    int spatial_dimension = 3; //graphShPt->GetSpaceDimension();
    int topological_dimension = graphShPt->GetMeshDimension();

    // Original mesh for the user to see.
    mmd = new avtMeshMetaData(meshName,
                              nblocks, block_origin,
                              cell_origin, group_origin,
                              spatial_dimension, topological_dimension,
                              meshType);

    // Note: the number of elements is the original number of
    // elements. It should be number of elements based on the
    // refinement - but is not known at this time.
    mmd->SetNumberCells( m_nElements );

    int bounds[3] = {m_nElements, 0, 0};
    mmd->SetBounds( bounds );

    // Get the Mesh extents
    double extents[6] = { DBL_MAX, -DBL_MAX, 
                          DBL_MAX, -DBL_MAX, 
                          DBL_MAX, -DBL_MAX };

    if( graphShPt->GetSpaceDimension() == 2 )
      extents[4] = extents[5] = 0;

    int nVerts = graphShPt->GetNvertices();

    for( int i=0; i<nVerts; ++i )
    {
      NekDouble x, y, z;
      graphShPt->GetVertex(i)->GetCoords(x, y, z);

      if( extents[0] > x ) extents[0] = x;
      if( extents[1] < x ) extents[1] = x;

      if( extents[2] > y ) extents[2] = y;
      if( extents[3] < y ) extents[3] = y;

      if( graphShPt->GetSpaceDimension() == 3 )
      {
        if( extents[4] > z ) extents[4] = z;
        if( extents[5] < z ) extents[5] = z;
      }
    }

    mmd->SetExtents( extents );

    md->Add(mmd);


    // Original mesh for the spectral element evaluation.
    mmd = new avtMeshMetaData(std::string("SE_") + meshName,
                              nblocks, block_origin,
                              cell_origin, group_origin,
                              spatial_dimension, topological_dimension,
                              meshType);

    mmd->SetBounds( bounds );
    mmd->SetNumberCells( m_nElements );
    mmd->SetExtents( extents );
    md->Add(mmd);

    // Add in the scalar vars while checking for a potential vector var.
    int vector_dim = 0;

    for ( size_t i = 0; i < m_scalarVarNames.size(); ++i )
    {
      avtScalarMetaData *smd =
        new avtScalarMetaData( m_scalarVarNames[i],
                              meshName, AVT_NODECENT);
      
      md->Add(smd);
      
      // Is the var is a potential coordinate for the velocity?
      for(int j = 0; j < 3; ++j)
      {
        if( m_scalarVarNames[i] == vectorVarComponents[j] )
        {
          ++vector_dim;
          break;
        }
      }
    }

    // If at least two values (u,v) or (uv,w) are found then
    // create a velocity variable for the refined and spectral mesh.
    if( 2 <= vector_dim )
    {
      std::string varname, definition;

      // The refined mesh velocity will be an expression.
      if( vector_dim == 2 )
      {
        varname = std::string("velocity_uv");
        definition = std::string("{u, v, 0}");
      }
      else //if( vector_dim == 3 )
      {
        varname = std::string("velocity_uvw");
        definition = std::string("{u, v, w}");
      }

      Expression velocity_expr;
      velocity_expr.SetName(varname);
      velocity_expr.SetDefinition(definition);
      velocity_expr.SetType(Expression::VectorMeshVar);
      md->AddExpression(&velocity_expr);

      // Create a velocity var for the spectral evaluation prefix it
      // with SE_ to differentiate from the refined vector var
      // expression.
      if( vector_dim == 2 )
        varname = std::string("SE_velocity_uv");
      else //if( vector_dim == 3 )
        varname = std::string("SE_velocity_uvw");

      // Note for the PICS code the vector must be 3D if only two
      // components we will add the third and make it zero.
      vector_dim = 3;
      
      avtCentering cent = AVT_NODECENT;
      
      AddVectorVarToMetaData(md, varname, std::string("SE_")+meshName,
                             cent, vector_dim);
    }
}


// ****************************************************************************
//  Method: avtNektarPPFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Fri Nov 7 13:51:33 PST 2014
//
// ****************************************************************************

vtkDataSet *
avtNektarPPFileFormat::GetMesh(int timestate, const char *meshname)
{
  //std::cerr << __FUNCTION__ << "  " << filenames[0] << std::endl;
  vtkUnstructuredGrid* ugrid = NULL;

  // Request for the refined mesh.  At this point the original
  // nektar++ field has been refined and converted into a VTK grid so
  // just grab the grid.
  if( std::string(meshname) == std::string("mesh") )
  {
    ugrid = vtkUnstructuredGrid::New();

    // Make a copy of the refined grid array as VisIt might munch on it. 
    ugrid->ShallowCopy( refinedDataSet );
    ugrid->Register(NULL);
  }

  // Request for the original spectral element mesh. Create a VTK grid
  // for the original spectral mesh.
  else if( strncmp(meshname, "SE_mesh", 7 ) == 0 )
  {
    //----------------------------------------------
    // Read in the vertrices from input mesh file
    SpatialDomains::MeshGraphSharedPtr graphShPt =
      SpatialDomains::MeshGraph::Read(m_meshFile);

    int nVerts = graphShPt->GetNvertices();


    // VTK structure for holding the mesh points. 
    vtkPoints *vtkPts = vtkPoints::New();
    vtkPts->SetDataTypeToDouble();
    vtkPts->SetNumberOfPoints( nVerts );

    for( int i=0; i<nVerts; ++i )
    {
      NekDouble x, y, z;
      graphShPt->GetVertex(i)->GetCoords(x, y, z);

      if( graphShPt->GetSpaceDimension() == 2 )
        z = 0;

      vtkPts->SetPoint (i, x, y, z);
    }

    // Add the points to the VTK grid.
    ugrid = vtkUnstructuredGrid::New();
    ugrid->SetPoints( vtkPts );
    vtkPts->Delete();

    // for a 2D mesh read in the trianagle and quad elements.
    if( graphShPt->GetMeshDimension() == 2 )
    {
      // Add in all of the triangle elements
      vtkTriangle *tri = vtkTriangle::New();
      SpatialDomains::TriGeomMap triGeomMap = graphShPt->GetAllTriGeoms();
      SpatialDomains::TriGeomMapIter triGeomMapIter = triGeomMap.begin();
        
      while( triGeomMapIter != triGeomMap.end() )
      {       
        SpatialDomains::TriGeomSharedPtr triGeom = triGeomMapIter->second;
        
        for( int i=0; i<triGeom->GetNumVerts(); ++i )
          tri->GetPointIds()->SetId( i, triGeom->GetVertex(i)->GetVid() );
        
        ugrid->InsertNextCell( tri->GetCellType(), tri->GetPointIds() );
        
        ++triGeomMapIter;
      }
        
      tri->Delete();
      
      // Add in all of the quad elements
      vtkQuad *quad = vtkQuad::New();
      SpatialDomains::QuadGeomMap quadGeomMap = graphShPt->GetAllQuadGeoms();
      SpatialDomains::QuadGeomMapIter quadGeomMapIter = quadGeomMap.begin();
        
      while( quadGeomMapIter != quadGeomMap.end() )
      {       
        SpatialDomains::QuadGeomSharedPtr quadGeom = quadGeomMapIter->second;
        
        for( int i=0; i<quadGeom->GetNumVerts(); ++i )
          quad->GetPointIds()->SetId( i, quadGeom->GetVertex(i)->GetVid() );
        
        ugrid->InsertNextCell( quad->GetCellType(), quad->GetPointIds() );
        
        ++quadGeomMapIter;
      }
        
      quad->Delete();
    }

    // for a 3D mesh read in the tet, pyramid, prism, and hex elements.
    else if( graphShPt->GetMeshDimension() == 3 )
    {
      // Add in all of the tet elements
      vtkTetra *tet = vtkTetra::New();
      SpatialDomains::TetGeomMap tetGeomMap = graphShPt->GetAllTetGeoms();
      SpatialDomains::TetGeomMapIter tetGeomMapIter = tetGeomMap.begin();
        
      while( tetGeomMapIter != tetGeomMap.end() )
      {       
        SpatialDomains::TetGeomSharedPtr tetGeom = tetGeomMapIter->second;
        
        for( int i=0; i<tetGeom->GetNumVerts(); ++i )
          tet->GetPointIds()->SetId( i, tetGeom->GetVertex(i)->GetVid() );
        
        ugrid->InsertNextCell( tet->GetCellType(), tet->GetPointIds() );
        
        ++tetGeomMapIter;
      }
        
      tet->Delete();

      // Add in all of the pyramid elements
      vtkPyramid *pyramid = vtkPyramid::New();
      SpatialDomains::PyrGeomMap pyramidGeomMap = graphShPt->GetAllPyrGeoms();
      SpatialDomains::PyrGeomMapIter pyramidGeomMapIter = pyramidGeomMap.begin();
      
      while( pyramidGeomMapIter != pyramidGeomMap.end() )
      {       
        SpatialDomains::PyrGeomSharedPtr pyramidGeom = pyramidGeomMapIter->second;
        
        for( int i=0; i<pyramidGeom->GetNumVerts(); ++i )
          pyramid->GetPointIds()->SetId( i, pyramidGeom->GetVertex(i)->GetVid() );
          
        ugrid->InsertNextCell( pyramid->GetCellType(), pyramid->GetPointIds() );

        ++pyramidGeomMapIter;
      }
        
      pyramid->Delete();

      // Add in all of the prism elements
      vtkWedge *wedge = vtkWedge::New();
      SpatialDomains::PrismGeomMap prismGeomMap = graphShPt->GetAllPrismGeoms();
      SpatialDomains::PrismGeomMapIter prismGeomMapIter = prismGeomMap.begin();
        
      while( prismGeomMapIter != prismGeomMap.end() )
      {       
        SpatialDomains::PrismGeomSharedPtr prismGeom = prismGeomMapIter->second;        
        // for( int i=0; i<prismGeom->GetNumVerts(); ++i )
        //   wedge->GetPointIds()->SetId( i, prismGeom->GetVertex(i)->GetVid() );

        // Nektar++ uses a prism whereas VTK uses a wedge which have
        // a slightly different ordering. A prism would be decribed
        // via a quad and two points. Whereas a wedge would be
        // described via two triangles.
        wedge->GetPointIds()->SetId( 0, prismGeom->GetVertex(0)->GetVid() );
        wedge->GetPointIds()->SetId( 1, prismGeom->GetVertex(1)->GetVid() );
        wedge->GetPointIds()->SetId( 2, prismGeom->GetVertex(4)->GetVid() );
        wedge->GetPointIds()->SetId( 3, prismGeom->GetVertex(3)->GetVid() );
        wedge->GetPointIds()->SetId( 4, prismGeom->GetVertex(2)->GetVid() );
        wedge->GetPointIds()->SetId( 5, prismGeom->GetVertex(5)->GetVid() );
        
        ugrid->InsertNextCell( wedge->GetCellType(), wedge->GetPointIds() );
        
        ++prismGeomMapIter;
      }
        
      wedge->Delete();

      // Add in all of the hex elements
      vtkHexahedron *hex = vtkHexahedron::New();
      SpatialDomains::HexGeomMap hexGeomMap = graphShPt->GetAllHexGeoms();
      SpatialDomains::HexGeomMapIter hexGeomMapIter = hexGeomMap.begin();

      while( hexGeomMapIter != hexGeomMap.end() )
      {       
        SpatialDomains::HexGeomSharedPtr hexGeom = hexGeomMapIter->second;
        
        for( int i=0; i<8; ++i )
          hex->GetPointIds()->SetId( i, hexGeom->GetVertex(i)->GetVid() );
        
        ugrid->InsertNextCell( hex->GetCellType(), hex->GetPointIds() );
        
        ++hexGeomMapIter;
      }
    
      hex->Delete();
    }

    // Save the pointer to the nektar++ field data for use in the
    // avtIVPNektar++Field.
    vtkLongArray *fp = vtkLongArray::New();
    fp->SetName("Nektar++FieldPointers");

    // Set the number of components before setting the number of tuples
    // for proper memory allocation.
    fp->SetNumberOfComponents( 1 );
    fp->SetNumberOfTuples(3);

    for (int i = 0; i < 3; ++i)
    {
      // Store the shared pointer address. 
      if( nektar_field[i] )
        fp->SetTuple1(i, (intptr_t) &(nektar_field[i]));
      else
        fp->SetTuple1(i, (intptr_t) 0);
    }

    ugrid->GetFieldData()->AddArray(fp);
    fp->Delete();

    // At some point we might want to pass a look up table.
//     int numElements = nektar_field[0]->GetExpSize();
    
//     vtkIntArray *lu = vtkIntArray::New();
    // Set the number of components before setting the number of tuples
    // for proper memory allocation.
//     lu->SetNumberOfComponents( 1 );
//     lu->SetNumberOfTuples(3);
    
//     lu->SetName("Nektar++ElementLookup");
// //    grid->GetFieldData()->AddArray(lu);
//     lu->Delete();
    ugrid->Register(NULL);
  }

  return ugrid;
}


// ****************************************************************************
//  Method: avtNektarPPFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Fri Nov 7 13:51:33 PST 2014
//
// ****************************************************************************

vtkDataArray *
avtNektarPPFileFormat::GetVar(int timestate, const char *varname)
{
  //std::cerr << __FUNCTION__ << "  " << filenames[0] << std::endl;

  // At this point the original nektar++ field has been refined and
  // converted into a vtkDataArray so just grab the variable needed.
  vtkDataArray *dataArray =
      refinedDataSet->GetPointData()->GetArray(varname);

  // Make a copy of the data array as VisIt might munch on it. 
  if( dataArray )
  {
    vtkDataArray *copyArray;

    if( dataArray->GetDataType() == VTK_FLOAT )
      copyArray = vtkFloatArray::New();
    else if( dataArray->GetDataType() == VTK_DOUBLE )
      copyArray = vtkDoubleArray::New();
    else
      return NULL;

    copyArray->DeepCopy( dataArray );

    return copyArray;
  }
  else
    return NULL;
}


// ****************************************************************************
//  Method: avtNektarPPFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      varname    The name of the variable requested.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Fri Nov 7 13:51:33 PST 2014
//
// ****************************************************************************

vtkDataArray *
avtNektarPPFileFormat::GetVectorVar(int timestate, const char *varname)
{
  if( std::string(varname) != std::string("SE_velocity_uv") &&
      std::string(varname) != std::string("SE_velocity_uvw") )
    return 0;

    //----------------------------------------------
    // Read in mesh from input file
    SpatialDomains::MeshGraphSharedPtr graphShPt =
      SpatialDomains::MeshGraph::Read(m_meshFile);

    // For each vertex evluate the velocity at that location using the
    // previously stored Nektar++ fields.
    int nVerts = graphShPt->GetNvertices();

    // Vertices may be used multiple times in the mesh. As such,
    // evaluate each vertex once using a counter.
    std::vector< int > vertexCheck(nVerts);

    for( int i=0; i<nVerts; ++i )
      vertexCheck[i] = 0;

    // VTK array for the vector values.
    vtkDoubleArray *rv = vtkDoubleArray::New();
    // vtkNektarDoubleArray *rv = vtkNektarDoubleArray::New();

    // Set the number of components before setting the number of tuples
    // for proper memory allocation.
    rv->SetNumberOfComponents(3);
    rv->SetNumberOfTuples(nVerts);

    Nektar::Array<OneD, NekDouble> coords(3);
    double vec[3];

    // for a 2D mesh read in the trianagle and quad elements.
    if( graphShPt->GetMeshDimension() == 2 )
    {
      // Add in all of the triangle elements
      SpatialDomains::TriGeomMap triGeomMap = graphShPt->GetAllTriGeoms();
      SpatialDomains::TriGeomMapIter triGeomMapIter = triGeomMap.begin();
        
      while( triGeomMapIter != triGeomMap.end() )
      {       
        int nt_el = triGeomMapIter->first;
        SpatialDomains::TriGeomSharedPtr triGeom = triGeomMapIter->second;

        for( int i=0; i<triGeom->GetNumVerts(); ++i )
        {
          int vertex_id = triGeom->GetVertex(i)->GetVid();
          
          if( vertexCheck[vertex_id]++ == 0 )
          {
            graphShPt->GetVertex(vertex_id)->GetCoords(coords);
            GetNektarVectorVar( coords, nt_el, vec );
            rv->SetTuple(vertex_id, vec); 
          }
        }
        
        ++triGeomMapIter;
      }
      
      // Add in all of the quad elements
      SpatialDomains::QuadGeomMap quadGeomMap = graphShPt->GetAllQuadGeoms();
      SpatialDomains::QuadGeomMapIter quadGeomMapIter = quadGeomMap.begin();
        
      while( quadGeomMapIter != quadGeomMap.end() )
      {       
        int nt_el = quadGeomMapIter->first;
        SpatialDomains::QuadGeomSharedPtr quadGeom = quadGeomMapIter->second;
        
        for( int i=0; i<quadGeom->GetNumVerts(); ++i )
        {
          int vertex_id = quadGeom->GetVertex(i)->GetVid();
          
          if( vertexCheck[vertex_id]++ == 0 )
          {
            graphShPt->GetVertex(vertex_id)->GetCoords(coords);
            GetNektarVectorVar( coords, nt_el, vec );
            rv->SetTuple(vertex_id, vec); 
          }
        }
          
        ++quadGeomMapIter;
      }
    }

    // for a 3D mesh read in the tet, pyramid, prism, and hex elements.
    else if( graphShPt->GetMeshDimension() == 3 )
    {
      // Add in all of the tet elements
      SpatialDomains::TetGeomMap tetGeomMap = graphShPt->GetAllTetGeoms();
      SpatialDomains::TetGeomMapIter tetGeomMapIter = tetGeomMap.begin();
        
      while( tetGeomMapIter != tetGeomMap.end() )
      {       
        int nt_el = tetGeomMapIter->first;
        SpatialDomains::TetGeomSharedPtr tetGeom = tetGeomMapIter->second;

        for( int i=0; i<tetGeom->GetNumVerts(); ++i )
        {
          int vertex_id = tetGeom->GetVertex(i)->GetVid();
          
          if( vertexCheck[vertex_id]++ == 0 )
          {
            graphShPt->GetVertex(vertex_id)->GetCoords(coords);
            GetNektarVectorVar( coords, nt_el, vec );
            rv->SetTuple(vertex_id, vec); 
          }
        }
        
        ++tetGeomMapIter;
      }
        
      // Add in all of the pyramid elements
      SpatialDomains::PyrGeomMap pyramidGeomMap = graphShPt->GetAllPyrGeoms();
      SpatialDomains::PyrGeomMapIter pyramidGeomMapIter = pyramidGeomMap.begin();
      
      while( pyramidGeomMapIter != pyramidGeomMap.end() )
      {       
        int nt_el = pyramidGeomMapIter->first;
        SpatialDomains::PyrGeomSharedPtr pyramidGeom = pyramidGeomMapIter->second;

        for( int i=0; i<pyramidGeom->GetNumVerts(); ++i )
        {
          int vertex_id = pyramidGeom->GetVertex(i)->GetVid();
          
          if( vertexCheck[vertex_id]++ == 0 )
          {
            graphShPt->GetVertex(vertex_id)->GetCoords(coords);
            GetNektarVectorVar( coords, nt_el, vec );
            rv->SetTuple(vertex_id, vec); 
          }
        }

        ++pyramidGeomMapIter;
      }
        
      // Add in all of the prism elements
      SpatialDomains::PrismGeomMap prismGeomMap = graphShPt->GetAllPrismGeoms();
      SpatialDomains::PrismGeomMapIter prismGeomMapIter = prismGeomMap.begin();
        
      while( prismGeomMapIter != prismGeomMap.end() )
      {       
        int nt_el = prismGeomMapIter->first;
        SpatialDomains::PrismGeomSharedPtr prismGeom = prismGeomMapIter->second;

        for( int i=0; i<prismGeom->GetNumVerts(); ++i )
        {
          int vertex_id = prismGeom->GetVertex(i)->GetVid();
          
          if( vertexCheck[vertex_id]++ == 0 )
          {
            graphShPt->GetVertex(vertex_id)->GetCoords(coords);
            GetNektarVectorVar( coords, nt_el, vec );
            rv->SetTuple(vertex_id, vec); 
          }
        }
        
        ++prismGeomMapIter;
      }
        
      // Add in all of the hex elements
      SpatialDomains::HexGeomMap hexGeomMap = graphShPt->GetAllHexGeoms();
      SpatialDomains::HexGeomMapIter hexGeomMapIter = hexGeomMap.begin();

      while( hexGeomMapIter != hexGeomMap.end() )
      {       
        int nt_el = hexGeomMapIter->first;
        SpatialDomains::HexGeomSharedPtr hexGeom = hexGeomMapIter->second;

        for( int i=0; i<hexGeom->GetNumVerts(); ++i )
        {
          int vertex_id = hexGeom->GetVertex(i)->GetVid();
          
          if( vertexCheck[vertex_id]++ == 0 )
          {
            graphShPt->GetVertex(vertex_id)->GetCoords(coords);
            GetNektarVectorVar( coords, nt_el, vec );
            rv->SetTuple(vertex_id, vec); 
          }
        }
        
        ++hexGeomMapIter;
      }
    }
    
    // // Store the shared pointer address. 
    // if( nektar_field[0] )
    //   rv->SetNektarUField( (intptr_t) &(nektar_field[0]) );
    // else
    //   rv->SetNektarUField( 0 );

    // if( nektar_field[1] )
    //   rv->SetNektarVField( (intptr_t) &(nektar_field[1]) );
    // else
    //   rv->SetNektarVField( 0 );

    // if( nektar_field[2] )
    //   rv->SetNektarWField( (intptr_t) &(nektar_field[2]) );
    // else
    //   rv->SetNektarWField( 0 );

    
    // Store the shared pointer address. 
    // if( nektar_field[0] )
    //   NEKTAR_RT_U_FIELD->Set( rv->GetInformation(), (intptr_t) &(nektar_field[0]) );
    // else
    //   NEKTAR_RT_U_FIELD->Set( rv->GetInformation(), 0 );

    // if( nektar_field[1] )
    //   NEKTAR_RT_V_FIELD->Set( rv->GetInformation(), (intptr_t) &(nektar_field[1]) );
    // else
    //   NEKTAR_RT_V_FIELD->Set( rv->GetInformation(), 0 );

    // if( nektar_field[2] )
    //   NEKTAR_RT_W_FIELD->Set( rv->GetInformation(), (intptr_t) &(nektar_field[2]) );
    // else
    //   NEKTAR_RT_W_FIELD->Set( rv->GetInformation(), 0 );

    // std::cerr << "Set info " << m_times[0] << "  "
    //        << (intptr_t) &(nektar_field[0]) << "  " 
    //        << (intptr_t) &(nektar_field[1]) << "  " 
    //        << (intptr_t) &(nektar_field[2]) << "  " 
    //        << std::endl;

    return rv;
}

// ****************************************************************************
//  Method: avtNektarPPFileFormat::GetNektarFileAsXMLString
//
//  Purpose:
//      Reads Nektar++ file and creates a refined mesh with all values
//      on the mesh for display using linear interpolation. Returns an
//      XML string that VTK can convert into a vtkDataSet.
//
//      Code is from the Nektar++ postporcessing utility FldToVtk
//
//  Arguments:
//      var  The variable name - NOT USED AT THIS TIME.
//
//  Programmer: Allen Sanderson
//  Creation:   Fri Nov 7 13:51:33 PST 2014
//
// ****************************************************************************

std::string avtNektarPPFileFormat::GetNektarFileAsXMLString( std::string var )
{
  //std::cerr << __FUNCTION__ << "  " << filenames[0] << std::endl;

  std::string fieldfile(filenames[0]);

  //----------------------------------------------
  // Create a dummy set of args to create a session.
  int argc = 3;
  char **argv;

  argv = (char **) malloc( sizeof(char*) * argc );
  argv[0] = (char *) malloc( sizeof(char) * 8 );
  argv[1] = (char *) malloc( sizeof(char) * m_meshFile.size()+1 );
  argv[2] = (char *) malloc( sizeof(char) * fieldfile.size()+1 );
  strcpy( argv[0], "VisIt" );
  strcpy( argv[1], m_meshFile.c_str() );
  strcpy( argv[2], fieldfile.c_str() );

  int nExtraPoints;
  LibUtilities::SessionReaderSharedPtr vSession =
    LibUtilities::SessionReader::CreateInstance(argc, argv);

  vSession->LoadParameter("OutputExtraPoints", nExtraPoints,0);
  
  //----------------------------------------------
  // Read in mesh from input file
  SpatialDomains::MeshGraphSharedPtr graphShPt
    = SpatialDomains::MeshGraph::Read(vSession);
  //----------------------------------------------
    
  //----------------------------------------------
  // Import field file.
  vector<LibUtilities::FieldDefinitionsSharedPtr> fielddef;
  vector<vector<NekDouble> > fielddata;
  LibUtilities::Import(fieldfile,fielddef,fielddata);

  // std::cerr << "nVerts = " << graphShPt->GetNvertices() << std::endl;

  // std::cerr << "nfields = " << fielddef[0]->m_fields.size() << std::endl;

  // std::cerr << fielddata.size() << std::endl;

  // for(int i = 0; i < fielddata.size(); ++i)
  //   std::cerr << fielddata[i].size()<< std::endl;

  bool useFFT = false;
  bool dealiasing = false;
  //----------------------------------------------

  //----------------------------------------------
  // Set up Expansion information
  for(int i = 0; i < fielddef.size(); ++i)
  {
    vector<LibUtilities::PointsType> ptype;
    for(int j = 0; j < 3; ++j)
    {
      ptype.push_back(LibUtilities::ePolyEvenlySpaced);
    }
    
    fielddef[i]->m_pointsDef = true;
    fielddef[i]->m_points    = ptype; 
    
    vector<unsigned int> porder;
    if(fielddef[i]->m_numPointsDef == false)
    {
      for(int j = 0; j < fielddef[i]->m_numModes.size(); ++j)
      {
        porder.push_back(fielddef[i]->m_numModes[j]+nExtraPoints);
      }
      
      fielddef[i]->m_numPointsDef = true;
    }
    else
    {
      for(int j = 0; j < fielddef[i]->m_numPoints.size(); ++j)
      {
        porder.push_back(fielddef[i]->m_numPoints[j]+nExtraPoints);
      }
    }

    fielddef[i]->m_numPoints = porder;      
  }

  graphShPt->SetExpansions(fielddef);
  //----------------------------------------------

  //----------------------------------------------
  // Define Expansion
  int expdim  = graphShPt->GetMeshDimension();
  int nfields = fielddef[0]->m_fields.size();

  int fieldIndex = 0;

  for(int i = 0; i < nfields; ++i)
  {
    if( var == std::string( fielddef[0]->m_fields[i]) )
    {
      fieldIndex = i;
      break;
    }
  }

  Array<OneD, MultiRegions::ExpListSharedPtr> Exp(nfields);
    
  switch(expdim)
  {
    case 1:
    {
      ASSERTL0(fielddef[0]->m_numHomogeneousDir <= 2,"NumHomogeneousDir is only set up for 1 or 2");
      
      if(fielddef[0]->m_numHomogeneousDir == 1)
      {
        MultiRegions::ExpList2DHomogeneous1DSharedPtr Exp2DH1;
        
        // Define Homogeneous expansion
        //int nplanes = fielddef[0]->m_numModes[1];
        int nplanes; 
        vSession->LoadParameter("HomModesZ",nplanes,fielddef[0]->m_numModes[1]);

        // choose points to be at evenly spaced points at
        const LibUtilities::PointsKey Pkey(nplanes+1,LibUtilities::ePolyEvenlySpaced);
        const LibUtilities::BasisKey  Bkey(fielddef[0]->m_basis[1],nplanes,Pkey);
        NekDouble ly = fielddef[0]->m_homogeneousLengths[0];
        
        Exp2DH1 = MemoryManager<MultiRegions::ExpList2DHomogeneous1D>::AllocateSharedPtr(vSession,Bkey,ly,useFFT,dealiasing,graphShPt);

        for( int i= 1; i < nfields; ++i)
        {
          Exp[i] = MemoryManager<MultiRegions::ExpList2DHomogeneous1D>::AllocateSharedPtr(*Exp2DH1);
        }
      }
      else if(fielddef[0]->m_numHomogeneousDir == 2)
      {
        MultiRegions::ExpList3DHomogeneous2DSharedPtr Exp3DH2;
        
        // Define Homogeneous expansion
        //int nylines = fielddef[0]->m_numModes[1];
        //int nzlines = fielddef[0]->m_numModes[2];
                                        
        int nylines;
        int nzlines;
        vSession->LoadParameter("HomModesY",nylines,fielddef[0]->m_numModes[1]);
        vSession->LoadParameter("HomModesZ",nzlines,fielddef[0]->m_numModes[2]);
                                        
                                        
        // choose points to be at evenly spaced points at
        const LibUtilities::PointsKey PkeyY(nylines+1,LibUtilities::ePolyEvenlySpaced);
        const LibUtilities::BasisKey  BkeyY(fielddef[0]->m_basis[1],nylines,PkeyY);
                                        
        const LibUtilities::PointsKey PkeyZ(nzlines+1,LibUtilities::ePolyEvenlySpaced);
        const LibUtilities::BasisKey  BkeyZ(fielddef[0]->m_basis[2],nzlines,PkeyZ);
                                        
        NekDouble ly = fielddef[0]->m_homogeneousLengths[0];
        NekDouble lz = fielddef[0]->m_homogeneousLengths[1];
                                        
        Exp3DH2 = MemoryManager<MultiRegions::ExpList3DHomogeneous2D>::AllocateSharedPtr(vSession,BkeyY,BkeyZ,ly,lz,useFFT,dealiasing,graphShPt);
        Exp[0] = Exp3DH2;
                                        
        for(int i = 1; i < nfields; ++i)
        {
          Exp[i] = MemoryManager<MultiRegions::ExpList3DHomogeneous2D>::AllocateSharedPtr(*Exp3DH2);
        }
      }
      else
      {
        MultiRegions::ExpList1DSharedPtr Exp1D;
        Exp1D = MemoryManager<MultiRegions::ExpList1D>
          ::AllocateSharedPtr(vSession,graphShPt);
        Exp[0] = Exp1D;
        for(int i = 1; i < nfields; ++i)
          {
            Exp[i] = MemoryManager<MultiRegions::ExpList1D>
              ::AllocateSharedPtr(*Exp1D);
          }
      }
    }
    break;

  case 2:
  {
    ASSERTL0(fielddef[0]->m_numHomogeneousDir <= 1,"NumHomogeneousDir is only set up for 1");

    if(fielddef[0]->m_numHomogeneousDir == 1)
    {
      MultiRegions::ExpList3DHomogeneous1DSharedPtr Exp3DH1;

      // Define Homogeneous expansion
      //int nplanes = fielddef[0]->m_numModes[2];
                                        
      int nplanes; 
      vSession->LoadParameter("HomModesZ",nplanes,fielddef[0]->m_numModes[2]);

      // choose points to be at evenly spaced points at
      // nplanes + 1 points
      const LibUtilities::PointsKey Pkey(nplanes+1,LibUtilities::ePolyEvenlySpaced);
      const LibUtilities::BasisKey  Bkey(fielddef[0]->m_basis[2],nplanes,Pkey);
      NekDouble lz = fielddef[0]->m_homogeneousLengths[0];

      Exp3DH1 = MemoryManager<MultiRegions::ExpList3DHomogeneous1D>::AllocateSharedPtr(vSession,Bkey,lz,useFFT,dealiasing,graphShPt);
      Exp[0] = Exp3DH1;

      for(int i = 1; i < nfields; ++i)
      {
        Exp[i] = MemoryManager<MultiRegions::ExpList3DHomogeneous1D>::AllocateSharedPtr(*Exp3DH1);
      }
    }
    else
    {
      MultiRegions::ExpList2DSharedPtr Exp2D;
      Exp2D = MemoryManager<MultiRegions::ExpList2D>
        ::AllocateSharedPtr(vSession,graphShPt);
      Exp[0] =  Exp2D;

      for(int i = 1; i < nfields; ++i)
      {
        Exp[i] = MemoryManager<MultiRegions::ExpList2D>
          ::AllocateSharedPtr(*Exp2D);
      }
    }
  }
  break;

  case 3:
  {
    MultiRegions::ExpList3DSharedPtr Exp3D;
    Exp3D = MemoryManager<MultiRegions::ExpList3D>::AllocateSharedPtr(vSession,graphShPt);

    Exp[0] =  Exp3D;
    
    for(int i = 1; i < nfields; ++i)
    {
      Exp[i] = MemoryManager<MultiRegions::ExpList3D>
        ::AllocateSharedPtr(*Exp3D);
    }
  }
  break;

  default:
    ASSERTL0(false,"Expansion dimension not recognised");
    break;
  }
  
  //----------------------------------------------

  //----------------------------------------------
  // Copy data from field file
  for( int j= 0; j < nfields; ++j)
  {
    for(int i = 0; i < fielddata.size(); ++i)
    {
      Exp[j]->ExtractDataToCoeffs(fielddef [i],
                                  fielddata[i],
                                  fielddef [i]->m_fields[j],
                                  Exp[j]->UpdateCoeffs());
    }
    
    Exp[j]->BwdTrans(Exp[j]->GetCoeffs(),Exp[j]->UpdatePhys());
  }
  //----------------------------------------------

  //----------------------------------------------
  // Write solution

  ostringstream outstream;

  Exp[0]->WriteVtkHeader(outstream);
    
  // For each field write out field data for each expansion.
  for(int i = 0; i < Exp[0]->GetNumElmts(); ++i)
  {
    Exp[0]->WriteVtkPieceHeader(outstream,i);

    // For this expansion, write out each field.
    for(int j = 0; j < Exp.num_elements(); ++j)
    {
      Exp[j]->WriteVtkPieceData(outstream, i, fielddef[0]->m_fields[j]);
    }
    
    Exp[0]->WriteVtkPieceFooter(outstream,i);
  }
  
  Exp[0]->WriteVtkFooter(outstream);

  //----------------------------------------------

  //----------------------------------------------
  // Save data from field file
  // for(int i = 0; i < 3; ++i)
  //   nektar_field[i] = 0;

  for(int i = 0; i < fielddata.size(); ++i)
  {
    for(int j = 0; j < 3; ++j)
      if( fielddef[0]->m_fields[i] == vectorVarComponents[j] )
        nektar_field[j] = Exp[i];
  }

  outstream.flush();

  //----------------------------------------------
  return outstream.str();
}


// ****************************************************************************
//  Method: avtNektarPPFileFormat::GetNektarVar
//
//  Purpose:
//      Returns the vector component value at an arbitrary location
//      using the spectral interpolation.
//
//  Arguments:
//      coords     the point
//      nt_el      index of the nektar++ element
//      index      index of the vector component
//
//  Programmer: allen
//  Creation:   
//
// ****************************************************************************

double avtNektarPPFileFormat::GetNektarVar( const Nektar::Array<OneD, NekDouble> &coords,
                                            const int nt_el,
                                            const int index ) const
{
    if( 3 <= index || !nektar_field[index] )
      return 0.0;

    Nektar::Array<Nektar::OneD, Nektar::NekDouble> physVals =
      nektar_field[index]->GetPhys() + nektar_field[index]->GetPhys_Offset(nt_el);
    return nektar_field[index]->GetExp(nt_el)->PhysEvaluate(coords, physVals);
}

// ****************************************************************************
//  Method: avtNektarPPFileFormat::GetNektarVectorVar
//
//  Purpose:
//      Returns the vector value at an arbitrary location
//      using the spectral interpolation.
//
//  Arguments:
//      coords     the point
//      nt_el      index of the nektar++ element
//      vec        vector value
//
//  Programmer: Allen Sanderson
//  Creation:   Fri Nov 7 13:51:33 PST 2014
//
// ****************************************************************************

void avtNektarPPFileFormat::GetNektarVectorVar( const Nektar::Array<OneD, NekDouble> &coords,
                                                const int nt_el,
                                                double *vec ) const
{
  for( int i=0; i<3; ++i )
    vec[i] = GetNektarVar( coords, nt_el, i );
}

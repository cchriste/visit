// ************************************************************************* //
//  File: avtThresholdFilter.C
// ************************************************************************* //

#include <avtThresholdFilter.h>

#include <vtkCellData.h>
#include <vtkPointData.h>
#include <vtkPolyData.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkThreshold.h>
#include <vtkUnstructuredGrid.h>

#include <avtIntervalTree.h>
#include <avtMetaData.h>
#include <avtStructuredMeshChunker.h>

#include <DebugStream.h>
#include <ImproperUseException.h>
#include <NoDefaultVariableException.h>


// ****************************************************************************
//  Method: avtThreshold constructor
//
//  Programmer: Hank Childs
//  Creation:   March 19, 2005
//     
// ****************************************************************************

avtThresholdFilter::avtThresholdFilter()
{
    downstreamRectilinearMeshOptimizations = false;
    downstreamCurvilinearMeshOptimizations = false;
    downstreamGhostType = NO_GHOST_DATA;
}


// ****************************************************************************
//  Method:  avtThresholdFilter::Create
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Tue Oct 23 16:38:18 PST 2001
//
// ****************************************************************************

avtFilter *
avtThresholdFilter::Create()
{
    return new avtThresholdFilter();
}


// ****************************************************************************
//  Method:      avtThresholdFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Tue Oct 23 16:38:18 PST 2001
//
//  Modifications:
//
//    Hank Childs, Thu Oct 25 09:17:54 PDT 2001
//    Register the active variable.
//
// ****************************************************************************

void
avtThresholdFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const ThresholdAttributes*)a;

    // We need to specify that we want a secondary variable as soon as 
    // possible.
    if (strcmp(atts.GetVariable().c_str(), "default") != 0)
    {
        SetActiveVariable(atts.GetVariable().c_str());
    }
}


// ****************************************************************************
//  Method: avtThresholdFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtThresholdFilter with the given
//      parameters would result in an equivalent avtThresholdFilter.
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Tue Oct 23 16:38:18 PST 2001
//
// ****************************************************************************

bool
avtThresholdFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(ThresholdAttributes*)a);
}


// ****************************************************************************
//  Function: UpdateNeighborCells
//
//  Purpose:
//      Updates cells that are neighbors to a point with a value.
//
//  Programmer: Hank Childs
//  Creation:   March 19, 2005
//
// ****************************************************************************

static void UpdateNeighborCells(int pt, const int *pt_dims,
           avtStructuredMeshChunker::ZoneDesignation d,
           std::vector<avtStructuredMeshChunker::ZoneDesignation> &designation)
{
    int I = pt % pt_dims[0];
    int J = (pt / pt_dims[0]) % pt_dims[1];
    int K = pt / (pt_dims[0]*pt_dims[1]);

    for (int i = 0 ; i < 8 ; i++)
    {
        int sI = I - (i & 1 ? 1 : 0);
        int sJ = J - (i & 2 ? 1 : 0);
        int sK = K - (i & 4 ? 1 : 0);
        if (sI < 0)
            continue;
        if (sI >= (pt_dims[0]-1))
            continue;
        if (sJ < 0)
            continue;
        if (sJ >= (pt_dims[1]-1))
            continue;
        if (sK < 0)
            continue;
        if (sK >= (pt_dims[2]-1))
            continue;

        int cell = sK*(pt_dims[0]-1)*(pt_dims[1]-1) + sJ*(pt_dims[0]-1) + sI;
        designation[cell] = d;
    }
}


// ****************************************************************************
//  Method: avtThresholdFilter::ExecuteData
//
//  Purpose:
//      Sends the specified input and output through the Threshold filter.
//
//  Arguments:
//      in_ds      The input dataset.
//      <unused>   The domain number.
//      <unused>   The label.
//
//  Returns:       The output dataset.
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Tue Oct 23 16:38:18 PST 2001
//
//  Modifications:
//
//    Hank Childs, Thu Oct 25 09:17:54 PDT 2001
//    Removed references to active variables.
//
//    Hank Childs, Tue Oct 30 09:29:13 PST 2001
//    Account for cases when we are not switching active variables.
//
//    Kathleen Bonnell, Fri Feb  8 11:03:49 PST 2002
//    vtkScalars has been deprecated in VTK 4.0, use vtkDataArray instead.
//
//    Hank Childs, Tue Sep 10 18:29:14 PDT 2002
//    Make memory management be self-contained in this routine.
//
//    Hank Childs, Sat Jun 21 09:25:34 PDT 2003
//    If we have poly data input, then we should have poly data output.
//
//    Hank Childs, Fri May  7 08:33:17 PDT 2004
//    If the variable is not a scalar, then issue a warning.
//
//    Hank Childs, Thu Jul 29 09:43:58 PDT 2004
//    Do not convert output to poly-data, since the base class will now
//    take care of this (when appropriate).
//
//    Hank Childs, Sat Mar 19 10:34:08 PST 2005
//    Use a structured mesh chunker if appropriate.
//
// ****************************************************************************

avtDataTree_p
avtThresholdFilter::ExecuteDataTree(vtkDataSet *in_ds, int domain,
                                    std::string label)
{
    avtDataTree_p rv = NULL;

    //
    // Confirm that we got a variable that we can threshold by.
    //
    string v1 = atts.GetVariable();
    string thres_var;
    if (v1 == "default")
        thres_var = pipelineVariable;
    else
        thres_var = v1;
    bool isPoint = true;
    vtkDataArray *arr = in_ds->GetPointData()->GetArray(thres_var.c_str());
    if (arr == NULL)
    {
        arr = in_ds->GetCellData()->GetArray(thres_var.c_str());
        isPoint = false;
    }
    if (arr == NULL)
    {
        char str[1024];
        sprintf(str, "The threshold operator was not applied because the "
                "variable \"%s\" could not be located.", thres_var.c_str());
        EXCEPTION1(VisItException, str);
    }
    if (arr->GetNumberOfComponents() != 1)
    {
        char str[1024];
        sprintf(str, "The threshold operator was not applied because the "
                "variable \"%s\" is not a scalar.", thres_var.c_str());
        EXCEPTION1(VisItException, str);
    }

    //
    // Now determine if we can do structured mesh chunking.
    //
    int ds_type = in_ds->GetDataObjectType();
    bool haveStructured = (ds_type == VTK_RECTILINEAR_GRID || 
                           ds_type == VTK_STRUCTURED_GRID);
    //bool canChunk = haveStructured;
    bool canChunk = false;

    if (canChunk)
    {
        int dims[3];
        bool downstreamOptimizations;
        if (ds_type == VTK_RECTILINEAR_GRID)
        {
            vtkRectilinearGrid *rgrid = (vtkRectilinearGrid *) in_ds;
            rgrid->GetDimensions(dims);
            downstreamOptimizations = downstreamRectilinearMeshOptimizations;
        }
        else
        {
            vtkStructuredGrid *sgrid = (vtkStructuredGrid *) in_ds;
            sgrid->GetDimensions(dims);
            downstreamOptimizations = downstreamCurvilinearMeshOptimizations;
        }

        //
        // Determine which zones we want to retain and which we want to
        // discard.
        //
        int ncells = in_ds->GetNumberOfCells();
        int npts = in_ds->GetNumberOfPoints();
        vector<avtStructuredMeshChunker::ZoneDesignation> designation(ncells);
        float *p = (float *) arr->GetVoidPointer(0);
        if (isPoint)
        {
            int  i;
            float lbound = atts.GetLbound();
            float ubound = atts.GetUbound();

            if (atts.GetAmount() == ThresholdAttributes::Some)
            {
                for (i = 0 ; i < ncells ; i++)
                    designation[i] = avtStructuredMeshChunker::DISCARD;
                for (i = 0 ; i < npts ; i++)
                {
                    bool pointInThreshold = (p[i] >= lbound && p[i] <= ubound);
                    if (pointInThreshold)
                        UpdateNeighborCells(i, dims, 
                                avtStructuredMeshChunker::RETAIN, designation);
                }
            }
            else
            {
                for (i = 0 ; i < ncells ; i++)
                    designation[i] = avtStructuredMeshChunker::RETAIN;
                for (i = 0 ; i < npts ; i++)
                {
                    bool pointOutsideThreshold = (p[i]<lbound || p[i]>ubound);
                    if (pointOutsideThreshold)
                        UpdateNeighborCells(i, dims, 
                               avtStructuredMeshChunker::DISCARD, designation);
                }
            }
        }
        else
        {
            float lbound = atts.GetLbound();
            float ubound = atts.GetUbound();
            for (int i = 0 ; i < ncells ; i++)
            {
                designation[i] = (p[i] >= lbound && p[i] <= ubound 
                                  ? avtStructuredMeshChunker::RETAIN 
                                  : avtStructuredMeshChunker::DISCARD);
            }
        }

        //
        // Have the structured mesh chunker create the sub-meshes.
        //
        vtkUnstructuredGrid *ugrid = NULL;
        vector<vtkDataSet *> grids;
        avtStructuredMeshChunker::ChunkStructuredMesh(in_ds, designation, 
                   grids, ugrid, downstreamGhostType, downstreamOptimizations);
    
        // 
        // Create a data tree that has all of the structured meshes, as well
        // as the single unstructured mesh.
        //
        vtkDataSet **out_ds = new vtkDataSet*[grids.size()+1];
        for (int i = 0 ; i < grids.size() ; i++)
            out_ds[i] = grids[i];
        out_ds[grids.size()] = ugrid;
        rv = new avtDataTree(grids.size()+1, out_ds,
                                           domain, label);
        delete [] out_ds;
    }
    else
    {
        vtkThreshold *threshold = vtkThreshold::New();
    
        //
        // Set up the threshold filter from the attributes.
        //
        threshold->SetInput(in_ds);
        threshold->SetAttributeModeToDefault();
        if (atts.GetAmount() == ThresholdAttributes::Some)
        {
            threshold->AllScalarsOff();
        }
        else if (atts.GetAmount() == ThresholdAttributes::All)
        {
            threshold->AllScalarsOn();
        }
        else
        {
            debug1 << "No good option for threshold attributes for what amount"
                   << " to restrict by." << endl;
            threshold->AllScalarsOff();
        }
        threshold->ThresholdBetween(atts.GetLbound(), atts.GetUbound());
    
        bool usePointData = false;
        if (switchVariables)
        {
            usePointData = activeVariableIsPointData;
        }
        else
        {
            vtkDataArray *s = in_ds->GetPointData()->GetScalars();
            usePointData = (s != NULL ? true : false);
        }
        if (usePointData)
        {
            threshold->SetAttributeModeToUsePointData();
        }
        else
        {
            threshold->SetAttributeModeToUseCellData();
        }
        
        vtkDataSet *out_ds = threshold->GetOutput();
        out_ds->Update();

        if (out_ds->GetNumberOfCells() <= 0)
        {
            out_ds = NULL;
        }

        rv = new avtDataTree(1, &out_ds, domain, label);
        threshold->Delete();
    }

    return rv;
}


// ****************************************************************************
//  Method: avtThresholdFilter::RefashionDataObjectInfo
//
//  Purpose:
//      Indicates the zones no longer correspond to the original problem.
//
//  Programmer: Hank Childs
//  Creation:   October 23, 2001
//
// ****************************************************************************

void
avtThresholdFilter::RefashionDataObjectInfo(void)
{
    GetOutput()->GetInfo().GetValidity().InvalidateZones();
}


// ****************************************************************************
//  Method: avtThresholdFilter::PreExecute
//
//  Purpose:
//      Determine if there is a "default" variable to work with.
//
//  Programmer: Hank Childs
//  Creation:   August 28, 2002
//
//  Modifications:
//
//    Hank Childs, Thu Aug 29 08:12:22 PDT 2002
//    If the variable was not the 'default' variable, the test was sometimes
//    wrong.
//
//    Hank Childs, Sat Mar 19 10:29:37 PST 2005
//    Initialize chunkedStructuredMesh.
//
// ****************************************************************************

void
avtThresholdFilter::PreExecute(void)
{
    avtPluginDataTreeStreamer::PreExecute();

    if (atts.GetVariable() == "default" &&
        GetInput()->GetInfo().GetAttributes().GetVariableName() == "<unknown>")
    {
        //
        // Somehow the variable we asked for didn't make it down far enough.
        // This often happens when we are doing a plot that doesn't have a
        // variable (say a material plot) and then we apply the threshold
        // operator.
        //
        EXCEPTION1(NoDefaultVariableException, "Threshold");
    }

    chunkedStructuredMeshes = false;
}


// ****************************************************************************
//  Method: avtThresholdFilter::PostExecute
//
//  Purpose:
//      If we chunked a structured mesh, indicate that we may now have ghost
//      data.
//
//  Programmer: Hank Childs
//  Creation:   March 19, 2005
//
// ****************************************************************************

void
avtThresholdFilter::PostExecute(void)
{
    avtPluginDataTreeStreamer::PostExecute();

    if (chunkedStructuredMeshes && downstreamGhostType != NO_GHOST_DATA)
    {
        GetOutput()->GetInfo().GetAttributes().
                                     SetContainsGhostZones(AVT_CREATED_GHOSTS);
    }
}

// ****************************************************************************
//  Method: avtThresholdFilter::PerformRestriction
//
//  Purpose:
//      Restrict the data processed by looking at the data extents.
//
//  Programmer: Hank Childs
//  Creation:   May 14, 2003
//
//  Modifications:
//
//    Mark C. Miller, Mon Oct 18 13:02:37 PDT 2004
//    Added code to pass variable name in call to GetDataExtents
//
//    Hank Childs, Sat Mar 19 10:34:08 PST 2005
//    Initialize data members for structured mesh chunking.
//
// ****************************************************************************

avtPipelineSpecification_p
avtThresholdFilter::PerformRestriction(avtPipelineSpecification_p in_spec)
{
    downstreamRectilinearMeshOptimizations = 
                                in_spec->GetHaveRectilinearMeshOptimizations();
    downstreamCurvilinearMeshOptimizations =
                                in_spec->GetHaveCurvilinearMeshOptimizations();
    downstreamGhostType = 
                    in_spec->GetDataSpecification()->GetDesiredGhostDataType();

    string thres_var = atts.GetVariable();;
    if (thres_var == "default")
        thres_var = in_spec->GetDataSpecification()->GetVariable();

    avtIntervalTree *it = GetMetaData()->GetDataExtents(thres_var.c_str());
    if (it == NULL)
    {
        return in_spec;
    }

    avtPipelineSpecification_p spec = new avtPipelineSpecification(in_spec);
    float min = atts.GetLbound();
    float max = atts.GetUbound();
    vector<int> dl;
    it->GetDomainsListFromRange(&min, &max, dl);
    spec->GetDataSpecification()->GetRestriction()->RestrictDomains(dl);

    return spec;
}



/*****************************************************************************
*
* Copyright (c) 2000 - 2006, The Regents of the University of California
* Produced at the Lawrence Livermore National Laboratory
* All rights reserved.
*
* This file is part of VisIt. For details, see http://www.llnl.gov/visit/. The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or materials provided with the distribution.
*  - Neither the name of the UC/LLNL nor  the names of its contributors may be
*    used to  endorse or  promote products derived from  this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED.  IN  NO  EVENT  SHALL  THE  REGENTS  OF  THE  UNIVERSITY OF
* CALIFORNIA, THE U.S.  DEPARTMENT  OF  ENERGY OR CONTRIBUTORS BE  LIABLE  FOR
* ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//  File: avtThresholdFilter.C
// ************************************************************************* //

#include <avtThresholdFilter.h>

#include <vtkDataSet.h>
#include <vtkCellData.h>
#include <vtkPointData.h>
#include <vtkPolyData.h>
#include <vtkDataArray.h>
#include <vtkDataObject.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkThreshold.h>
#include <vtkUnstructuredGrid.h>

#include <avtIntervalTree.h>
#include <avtMetaData.h>
#include <avtStructuredMeshChunker.h>

#include <DebugStream.h>
#include <ImproperUseException.h>
#include <NoDefaultVariableException.h>


// ****************************************************************************
//  Method: avtThreshold constructor
//
//  Programmer: Hank Childs
//  Creation:   March 19, 2005
//     
//  Modifications:
//
//    Hank Childs, Sun Mar 27 11:36:49 PST 2005
//    Don't initialize data members that have now been pushed into the base
//    class.
//
// ****************************************************************************

avtThresholdFilter::avtThresholdFilter()
{
    ;
}


// ****************************************************************************
//  Method:  avtThresholdFilter::Create
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Tue Oct 23 16:38:18 PST 2001
//
// ****************************************************************************

avtFilter *
avtThresholdFilter::Create()
{
    return new avtThresholdFilter();
}


// ****************************************************************************
//  Method:      avtThresholdFilter::SetAtts
//
//  Purpose: Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Tue Oct 23 16:38:18 PST 2001
//
//  Modifications:
//
//    Hank Childs, Thu Oct 25 09:17:54 PDT 2001
//    Register the active variable.
//
//    Mark Blair, Tue Mar  7 13:25:00 PST 2006
//    No longer recognizes the "default" variable.
//
//    Mark Blair, Tue Aug  8 17:47:00 PDT 2006
//    Now accommodates an empty list of threshold variables; does pass-through.
//
// ****************************************************************************

void
avtThresholdFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const ThresholdAttributes*)a;
    
    if (!atts.AttributesAreConsistent()) return;
    
    std::string shownVariable = atts.GetShownVariable();
    
    if (shownVariable != std::string("(no variables in list)"))
    {
        if (shownVariable != std::string("default"))
        {
            SetActiveVariable(shownVariable.c_str());
        }
    }
}


// ****************************************************************************
//  Method: avtThresholdFilter::Equivalent
//
//  Purpose: Returns true if creating a new avtThresholdFilter with the given
//           parameters would result in an equivalent avtThresholdFilter.
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Tue Oct 23 16:38:18 PST 2001
//
// ****************************************************************************

bool
avtThresholdFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(ThresholdAttributes*)a);
}


// ****************************************************************************
//  Function: UpdateNeighborCells
//
//  Purpose: Updates cells that are neighbors to a point with a value.
//
//  Programmer: Hank Childs
//  Creation:   March 19, 2005
//
// ****************************************************************************

static void UpdateNeighborCells(int pt, const int *pt_dims,
           avtStructuredMeshChunker::ZoneDesignation d,
           std::vector<avtStructuredMeshChunker::ZoneDesignation> &designation)
{
    int I = pt % pt_dims[0];
    int J = (pt / pt_dims[0]) % pt_dims[1];
    int K = pt / (pt_dims[0]*pt_dims[1]);

    for (int i = 0 ; i < 8 ; i++)
    {
        int sI = I - (i & 1 ? 1 : 0);
        int sJ = J - (i & 2 ? 1 : 0);
        int sK = K - (i & 4 ? 1 : 0);
        if (sI < 0)
            continue;
        if (sI >= (pt_dims[0]-1))
            continue;
        if (sJ < 0)
            continue;
        if (sJ >= (pt_dims[1]-1))
            continue;
        if (sK < 0)
            continue;
        if (sK >= (pt_dims[2]-1))
            continue;

        int cell = sK*(pt_dims[0]-1)*(pt_dims[1]-1) + sJ*(pt_dims[0]-1) + sI;
        designation[cell] = d;
    }
}


// ****************************************************************************
//  Method: avtThresholdFilter::ProcessOneChunk
//
//  Purpose: Sends the specified input and output through the Threshold filter.
//
//  Arguments:
//      in_ds      The input dataset.
//      <unused>   The domain number.
//      <unused>   The label.
//
//  Returns:       The output dataset.
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Tue Oct 23 16:38:18 PST 2001
//
//  Modifications:
//
//    Hank Childs, Thu Oct 25 09:17:54 PDT 2001
//    Removed references to active variables.
//
//    Hank Childs, Tue Oct 30 09:29:13 PST 2001
//    Account for cases when we are not switching active variables.
//
//    Kathleen Bonnell, Fri Feb  8 11:03:49 PST 2002
//    vtkScalars has been deprecated in VTK 4.0, use vtkDataArray instead.
//
//    Hank Childs, Tue Sep 10 18:29:14 PDT 2002
//    Make memory management be self-contained in this routine.
//
//    Hank Childs, Sat Jun 21 09:25:34 PDT 2003
//    If we have poly data input, then we should have poly data output.
//
//    Hank Childs, Fri May  7 08:33:17 PDT 2004
//    If the variable is not a scalar, then issue a warning.
//
//    Hank Childs, Thu Jul 29 09:43:58 PDT 2004
//    Do not convert output to poly-data, since the base class will now
//    take care of this (when appropriate).
//
//    Hank Childs, Sat Mar 19 10:34:08 PST 2005
//    Use a structured mesh chunker if appropriate.
//
//    Hank Childs, Sun Mar 27 11:36:49 PST 2005
//    Renamed to ProcessOneChunk.  Modified to assume structured chunking.
//
//    Hank Childs, Sun Apr  3 13:06:01 PDT 2005
//    Fix bug with structured chunking.
//
//    Hank Childs, Tue Sep 13 09:03:12 PDT 2005
//    Add support for "PointsOnly".
//
//    Mark Blair, Tue Mar  7 13:25:00 PST 2006
//    Rewrote to support multi-variable thresholding.
//
//    Kathleen Bonnell, Tue May 16 15:49:24 PDT 2006
//    SetAttributeModeTo* deprecated, now use SetInputArrayToProcess.
//    Pass FieldData, as it is no longer done internally by vtkThreshold.
//
//    Mark Blair, Wed May 31 18:17:00 PDT 2006
//    SetInputScalars deprecated, now use SetInputArrayToProcess.
//
//    Mark Blair, Tue Aug  8 17:47:00 PDT 2006
//    Now accommodates an empty list of threshold variables; does pass-through.
//
// ****************************************************************************

vtkDataSet *
avtThresholdFilter::ProcessOneChunk(
    vtkDataSet *in_ds, int domain, std::string label, bool fromChunker)
{
    if (!atts.AttributesAreConsistent())
    {
        debug1 << "Threshold operator attributes are inconsistent." << endl;

        in_ds->Register(NULL);
        return in_ds;
    }

    if (atts.GetShownVariable() == std::string("(no variables in list)"))
    {
        in_ds->Register(NULL);
        return in_ds;
    }

    if (atts.GetOutputMeshType() == ThresholdAttributes::PointMesh)
    {
        return ThresholdToPointMesh(in_ds);
    }

    if (fromChunker) {
        //
        // If in_ds is from the chunker, then the zones in in_ds are all
        // ones we identified that we wanted.  So just return them.
        //
        in_ds->Register(NULL);
        return in_ds;
    }

    vtkThreshold *threshold;

    vtkDataSet *curOutDataSet = in_ds;

    const stringVector curVariables    = atts.GetListedVariables();
    const intVector    curZonePortions = atts.GetZonePortions();
    const doubleVector curLowerBounds  = atts.GetLowerBounds();
    const doubleVector curUpperBounds  = atts.GetUpperBounds();

    const char *curVarName;
    char errMsg[1024];
    
    for (int curVarNum = 0; curVarNum < curVariables.size(); curVarNum++)
    {
        threshold = vtkThreshold::New();

        curVarName = curVariables[curVarNum].c_str();

        threshold->SetInput(curOutDataSet);

        threshold->SetInputArrayToProcess(
            0, 0, 0, vtkDataObject::FIELD_ASSOCIATION_POINTS_THEN_CELLS,
            vtkDataSetAttributes::SCALARS);

        if (curZonePortions[curVarNum] == (int)ThresholdAttributes::PartOfZone)
        {
            threshold->AllScalarsOff();
        }
        else if (curZonePortions[curVarNum] == (int)ThresholdAttributes::EntireZone)
        {
            threshold->AllScalarsOn();
        }
        else
        {
            debug1 << "Invalid zone inclusion option encountered "
                   << "in Threshold operator attributes." << endl;
            threshold->AllScalarsOff();
        }

        threshold->ThresholdBetween(
            curLowerBounds[curVarNum], curUpperBounds[curVarNum]);
    
        if (curOutDataSet->GetPointData()->GetArray(curVarName) != NULL)
        {
            threshold->SetInputArrayToProcess(
                0, 0, 0, vtkDataObject::FIELD_ASSOCIATION_POINTS, curVarName);
        }
        else if (curOutDataSet->GetCellData()->GetArray(curVarName) != NULL)
        {
            threshold->SetInputArrayToProcess(
                0, 0, 0, vtkDataObject::FIELD_ASSOCIATION_CELLS, curVarName);
        }
        else
        {
            curOutDataSet->Register(NULL);
            threshold->Delete();
    
            sprintf (errMsg, "Data for variable \"%s\" is not currently available.",
                     curVarName);
            debug1 << errMsg << endl;
            EXCEPTION1(VisItException, errMsg);
        }

        curOutDataSet = threshold->GetOutput();
        curOutDataSet->Update();

        if (curOutDataSet->GetNumberOfCells() <= 0)
        {
            curOutDataSet = NULL;
            threshold->Delete();

            break;
        }

        curOutDataSet->Register(NULL);

        threshold->Delete();
    }

    if (curOutDataSet != NULL)
    {
        curOutDataSet->GetFieldData()->PassData(in_ds->GetFieldData());
    }

    return curOutDataSet;
}


// ****************************************************************************
//  Method: avtThresholdFilter::GetAssignments
//
//  Purpose: Gets the assignments for each zone.
//
//  Programmer: Hank Childs
//  Creation:   March 27, 2005
//
//  Modifications:
//
//    Mark Blair, Tue Mar  7 13:25:00 PST 2006
//    Reworked to support multi-variable thresholding.
//
// ****************************************************************************

void
avtThresholdFilter::GetAssignments(vtkDataSet *in_ds, const int *dims,
    std::vector<avtStructuredMeshChunker::ZoneDesignation> &d)
{
    const stringVector curVariables    = atts.GetListedVariables();
    const intVector    curZonePortions = atts.GetZonePortions();
    const doubleVector curLowerBounds  = atts.GetLowerBounds();
    const doubleVector curUpperBounds  = atts.GetUpperBounds();

    int zoneCount = in_ds->GetNumberOfCells();
    int pointCount = in_ds->GetNumberOfPoints();
    int curVarNum, zoneNum, pointNum;

    bool varIsPointData;
    const char *curVarName;
    vtkDataArray *dataArray;
    float *varValues;
    double lowerBound, upperBound, varValue;
    char errMsg[1024];

    std::vector<avtStructuredMeshChunker::ZoneDesignation> curVarZDs(zoneCount);

    for (zoneNum = 0; zoneNum < zoneCount; zoneNum++)
        d[zoneNum] = avtStructuredMeshChunker::RETAIN;

    for (curVarNum = 0; curVarNum < curVariables.size(); curVarNum++)
    {
        curVarName = curVariables[curVarNum].c_str();

        if ((dataArray = in_ds->GetPointData()->GetArray(curVarName)) != NULL)
        {
            varIsPointData = true;
        }
        else if ((dataArray = in_ds->GetCellData()->GetArray(curVarName)) != NULL)
        {
            varIsPointData = false;
        }
        else
        {
            sprintf (errMsg,
                "Data for variable \"%s\" is not currently available.",
                curVarName);
            EXCEPTION1(VisItException, errMsg);
        }

        varValues = (float *)dataArray->GetVoidPointer(0);

        lowerBound = curLowerBounds[curVarNum];
        upperBound = curUpperBounds[curVarNum];

        if (varIsPointData)
        {
            if (curZonePortions[curVarNum] == ThresholdAttributes::PartOfZone)
            {
                for (zoneNum = 0; zoneNum < zoneCount; zoneNum++)
                    curVarZDs[zoneNum] = avtStructuredMeshChunker::DISCARD;

                for (pointNum = 0; pointNum < pointCount; pointNum++)
                {
                    varValue = (double)varValues[pointNum];

                    if ((varValue >= lowerBound) && (varValue <= upperBound))
                    {
                        UpdateNeighborCells(pointNum, dims,
                        avtStructuredMeshChunker::RETAIN, curVarZDs);
                    }
                }
            }
            else
            {
                for (zoneNum = 0; zoneNum < zoneCount; zoneNum++)
                    curVarZDs[zoneNum] = avtStructuredMeshChunker::RETAIN;

                for (pointNum = 0; pointNum < pointCount; pointNum++)
                {
                    varValue = (double)varValues[pointNum];

                    if ((varValue < lowerBound) || (varValue > upperBound))
                    {
                        UpdateNeighborCells(pointNum, dims,
                        avtStructuredMeshChunker::DISCARD, curVarZDs);
                    }
                }
            }
        }
        else
        {
            for (zoneNum = 0; zoneNum < zoneCount; zoneNum++)
            {
                varValue = (double)varValues[zoneNum];

                if ((varValue >= lowerBound) && (varValue <= upperBound))
                    curVarZDs[zoneNum] = avtStructuredMeshChunker::RETAIN;
                else
                    curVarZDs[zoneNum] = avtStructuredMeshChunker::DISCARD;
            }
        }

        for (zoneNum = 0; zoneNum < zoneCount; zoneNum++)
        {
            if (curVarZDs[zoneNum] == avtStructuredMeshChunker::DISCARD)
                d[zoneNum] = avtStructuredMeshChunker::DISCARD;
        }
    }
}


// ****************************************************************************
//  Method: avtThresholdFilter::ThresholdToPointMesh
//
//  Purpose:
//      Does a threshold on a nodal quantity and then creates a point mesh.
//
//  Programmer: Hank Childs
//  Creation:   September 13, 2005
//
//  Modifications:
//
//    Mark Blair, Tue Mar  7 13:25:00 PST 2006
//    Rewrote to support multi-variable thresholding.
//
// ****************************************************************************

vtkDataSet *
avtThresholdFilter::ThresholdToPointMesh(vtkDataSet *in_ds)
{
    const stringVector curVariables = atts.GetListedVariables();
    int curVarCount = curVariables.size();
    int curVarNum;
    vtkDataArray *dataArray;
    float *valueArray;

    std::vector<float *> valueArrays;

    for (curVarNum = 0; curVarNum < curVarCount; curVarNum++)
    {
        dataArray =
            in_ds->GetPointData()->GetArray(curVariables[curVarNum].c_str());

        if (dataArray == NULL)
        {
            EXCEPTION1(VisItException,
                "All threshold variables must be nodal quantities "
                "when point mesh output is requested.");
        }

        valueArray = (float *)dataArray->GetVoidPointer(0);
        valueArrays.push_back(valueArray);
    }

    const intVector    curZonePortions = atts.GetZonePortions();
    const doubleVector curLowerBounds  = atts.GetLowerBounds();
    const doubleVector curUpperBounds  = atts.GetUpperBounds();
    int inPointCount = in_ds->GetNumberOfPoints();
    int plotPointCount = 0;
    int inPointID;
    double doubleValue;

    for (inPointID = 0; inPointID < inPointCount; inPointID++)
    {
        for (curVarNum = 0; curVarNum < curVarCount; curVarNum++)
        {
            doubleValue = (double)valueArrays[curVarNum][inPointID];

            if (doubleValue < curLowerBounds[curVarNum]) break;
            if (doubleValue > curUpperBounds[curVarNum]) break;
        }

        if (curVarNum >= curVarCount) plotPointCount++;
    }

    if (plotPointCount == 0) return NULL;

    vtkUnstructuredGrid *outputMesh = vtkUnstructuredGrid::New();
    vtkPoints *outMeshPoints = vtkPoints::New();
    vtkPointData *inPointData = in_ds->GetPointData();
    vtkPointData *outPointData = outputMesh->GetPointData();
    int outPointID = 0;
    vtkIdType vertexIDs[1];
    double pointXYZ[3];

    outMeshPoints->SetNumberOfPoints(plotPointCount);
    outputMesh->SetPoints(outMeshPoints);
    outputMesh->Allocate(plotPointCount*(curVarCount+1));
    outPointData->CopyAllocate(inPointData, plotPointCount*curVarCount);
    outMeshPoints->Delete();

    for (inPointID = 0; inPointID < inPointCount; inPointID++)
    {
        for (curVarNum = 0; curVarNum < curVarCount; curVarNum++)
        {
            doubleValue = (double)valueArrays[curVarNum][inPointID];

            if (doubleValue < curLowerBounds[curVarNum]) break;
            if (doubleValue > curUpperBounds[curVarNum]) break;
        }

        if (curVarNum >= curVarCount)
        {
            outPointData->CopyData(inPointData, inPointID, outPointID);
            in_ds->GetPoint(inPointID, pointXYZ);
            outMeshPoints->SetPoint(outPointID, pointXYZ);
            vertexIDs[0] = outPointID++;
            outputMesh->InsertNextCell(VTK_VERTEX, 1, vertexIDs);
        }
    }

    return outputMesh;
}


// ****************************************************************************
//  Method: avtThresholdFilter::RefashionDataObjectInfo
//
//  Purpose: Indicates the zones no longer correspond to the original problem.
//
//  Programmer: Hank Childs
//  Creation:   October 23, 2001
//
//  Modifications:
//
//    Hank Childs, Tue Sep 13 09:07:05 PDT 2005
//    Add support for "PointsOnly".
//
//    Mark Blair, Tue Mar  7 13:25:00 PST 2006
//    Rewrote to support multi-variable thresholding.
//
//    Kathleen Bonnell, Mon May  1 08:50:46 PDT 2006 
//    Set OrigElementsRequiredForPick. 
//
// ****************************************************************************

void
avtThresholdFilter::RefashionDataObjectInfo(void)
{
    GetOutput()->GetInfo().GetValidity().InvalidateZones();

    if (atts.GetOutputMeshType() == ThresholdAttributes::PointMesh)
    {
        GetOutput()->GetInfo().GetAttributes().SetTopologicalDimension(0);
    }

    GetOutput()->GetInfo().GetAttributes().SetOrigElementsRequiredForPick(true);
}


// ****************************************************************************
//  Method: avtThresholdFilter::PreExecute
//
//  Purpose: Determine if there is a "default" variable to work with.
//
//  Programmer: Hank Childs
//  Creation:   August 28, 2002
//
//  Modifications:
//
//    Hank Childs, Thu Aug 29 08:12:22 PDT 2002
//    If the variable was not the 'default' variable, the test was sometimes
//    wrong.
//
//    Hank Childs, Sat Mar 19 10:29:37 PST 2005
//    Initialize chunkedStructuredMesh.
//
//    Hank Childs, Sun Mar 27 11:49:20 PST 2005
//    Moved chunkedStructuredMesh to base class.
//
//    Mark Blair, Tue Mar  7 13:25:00 PST 2006
//    No longer recognizes the "default" variable.
//
//    Mark Blair, Tue Aug  8 17:47:00 PDT 2006
//    Now accommodates an empty list of threshold variables; does pass-through.
//
// ****************************************************************************

void
avtThresholdFilter::PreExecute(void)
{
    avtPluginStructuredChunkStreamer::PreExecute();

/*  Since the list of threshold variables can now be empty, this check is no
    longer necessary.  If a plot has no scalar default variable, like in the
    case of a Material or Vector plot, and if no other scalar variable has been
    selected for thresholding, the threshold variable list will be empty and
    the input data to the Threshold operator will simply be passed through as
    its output.  (mb)

    if (GetInput()->GetInfo().GetAttributes().GetVariableName() == "<unknown>")
    {
        //
        // Somehow the variable we asked for didn't make it down far enough.
        // This often happens when we are doing a plot that doesn't have a
        // variable (say a material plot) and then we apply the threshold
        // operator.
        //
        EXCEPTION1(NoDefaultVariableException, "Threshold");
    }
*/
}


// ****************************************************************************
//  Method: avtThresholdFilter::PerformRestriction
//
//  Purpose: Restrict the data processed by looking at the data extents.
//
//  Programmer: Hank Childs
//  Creation:   May 14, 2003
//
//  Modifications:
//
//    Mark C. Miller, Mon Oct 18 13:02:37 PDT 2004
//    Added code to pass variable name in call to GetDataExtents
//
//    Hank Childs, Sat Mar 19 10:34:08 PST 2005
//    Initialize data members for structured mesh chunking.
//
//    Hank Childs, Sun Mar 27 11:49:20 PST 2005
//    Moved data members for structured mesh chunking to base class.
//
//    Mark Blair, Tue Mar  7 13:25:00 PST 2006
//    Rewrote to support multi-variable thresholding.
//
//    Kathleen Bonnell, Mon May  1 08:50:46 PDT 2006 
//    Turn on Node & Zone numbers when appropriate. 
//
//    Mark Blair, Tue Aug  8 17:47:00 PDT 2006
//    Now accommodates an empty list of threshold variables; does pass-through.
//
//   Kathleen Bonnell, Mon Aug 14 16:40:30 PDT 2006
//   API change for avtIntervalTree.
//
// ****************************************************************************

avtPipelineSpecification_p
avtThresholdFilter::PerformRestriction(avtPipelineSpecification_p in_spec)
{
    if (!atts.AttributesAreConsistent())
        return in_spec;
        
    std::string shownVariable = atts.GetShownVariable();
    
    if (shownVariable == std::string("(no variables in list)"))
        return in_spec;

    const char *pipelineVar = in_spec->GetDataSpecification()->GetVariable();

    const char *activeVar = pipelineVar;

    if (atts.GetShownVariable() != std::string("default"))
        activeVar = atts.GetShownVariable().c_str();

    atts.SwitchToPipelineVariable(std::string(pipelineVar));
    
    avtPipelineSpecification_p outSpec = new avtPipelineSpecification(in_spec);

    const std::vector<CharStrRef> curSecondaryVars =
        outSpec->GetDataSpecification()->GetSecondaryVariables();
    const stringVector curListedVars = atts.GetListedVariables();
    const char *curListedVar;
    int listedVarNum, secVarNum;

    for (listedVarNum = 0; listedVarNum < curListedVars.size(); listedVarNum++)
    {
        curListedVar = curListedVars[listedVarNum].c_str();
        
        if ((strcmp(curListedVar, pipelineVar) != 0) &&
            (strcmp(curListedVar, activeVar  ) != 0))
        {
            for (secVarNum = 0; secVarNum < curSecondaryVars.size(); secVarNum++)
            {
                if (strcmp(*curSecondaryVars[secVarNum],curListedVar) == 0)
                {
                    break;
                }
            }

            if (secVarNum >= curSecondaryVars.size())
            {
                outSpec->GetDataSpecification()->AddSecondaryVariable(curListedVar);
            }
        }
    }

    bool atLeastOneTree = false;
    avtIntervalTree *it;
    int varDomNum, curDomNum, curDomain;
    intVector varDomains;
    intVector curDomains;
    intVector outDomains;

    doubleVector curLowerBounds = atts.GetLowerBounds();
    doubleVector curUpperBounds = atts.GetUpperBounds();
    double lowerBound, upperBound;

    for (listedVarNum = 0; listedVarNum < curListedVars.size(); listedVarNum++)
    {
        curListedVar = curListedVars[listedVarNum].c_str();
        
        if ((it = GetMetaData()->GetDataExtents(curListedVar)) != NULL)
        {
            lowerBound = curLowerBounds[listedVarNum];
            upperBound = curUpperBounds[listedVarNum];

            if (atLeastOneTree)
            {
                it->GetElementsListFromRange(&lowerBound, &upperBound, varDomains);

                for (curDomNum = 0; curDomNum < curDomains.size(); curDomNum++)
                {
                    if ((curDomain = curDomains[curDomNum]) != -1)
                    {
                        for (varDomNum=0; varDomNum<varDomains.size(); varDomNum++)
                        {
                            if (varDomains[varDomNum] == curDomain) break;
                        }

                        if (varDomNum >= varDomains.size())
                        {
                            curDomains[curDomNum] = -1;
                        }
                    }
                }
            }
            else
            {
                it->GetElementsListFromRange(&lowerBound, &upperBound, curDomains);
                atLeastOneTree = true;
            }
        }
    }

    if (atLeastOneTree)
    {
        for (curDomNum = 0; curDomNum < curDomains.size(); curDomNum++)
        {
            if (curDomains[curDomNum] != -1)
            {
                outDomains.push_back(curDomains[curDomNum]);
            }
        }

        outSpec->GetDataSpecification()->GetRestriction()->RestrictDomains(outDomains);
    }

    if (outSpec->GetDataSpecification()->MayRequireZones() ||
        outSpec->GetDataSpecification()->MayRequireNodes())
    {
        // Turn on both Nodes and Zones, to prevent another re-execution if
        // user switches between zone and node pick.
        outSpec->GetDataSpecification()->TurnZoneNumbersOn();
        outSpec->GetDataSpecification()->TurnNodeNumbersOn();
    }

    return outSpec;
}

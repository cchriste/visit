// ************************************************************************* //
//  File: avtIsovolumeFilter.C
// ************************************************************************* //

#include <avtIsovolumeFilter.h>
#include <vtkVisItClipper3D.h>
#include <vtkDataSet.h>
#include <vtkDataArray.h>
#include <vtkPointData.h>
#include <vtkCellData.h>
#include <vtkPolyData.h>
#include <vtkUnstructuredGrid.h>
#include <vtkCellDataToPointData.h>
#include <DebugStream.h>
#include <VisItException.h>

// ****************************************************************************
//  Method: avtIsovolumeFilter constructor
//
//  Programmer: meredith -- generated by xml2info
//  Creation:   Fri Jan 30 14:50:21 PST 2004
//
// ****************************************************************************

avtIsovolumeFilter::avtIsovolumeFilter()
{
}


// ****************************************************************************
//  Method: avtIsovolumeFilter destructor
//
//  Programmer: meredith -- generated by xml2info
//  Creation:   Fri Jan 30 14:50:21 PST 2004
//
//  Modifications:
//
// ****************************************************************************

avtIsovolumeFilter::~avtIsovolumeFilter()
{
}


// ****************************************************************************
//  Method:  avtIsovolumeFilter::Create
//
//  Programmer: meredith -- generated by xml2info
//  Creation:   Fri Jan 30 14:50:21 PST 2004
//
// ****************************************************************************

avtFilter *
avtIsovolumeFilter::Create()
{
    return new avtIsovolumeFilter();
}


// ****************************************************************************
//  Method:      avtIsovolumeFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: Jeremy Meredith
//  Creation:   January 30, 2004
//
// ****************************************************************************

void
avtIsovolumeFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const IsovolumeAttributes*)a;

    // We need to specify that we want a secondary variable as soon as 
    // possible.
    if (strcmp(atts.GetVariable().c_str(), "default") != 0)
    {
        SetActiveVariable(atts.GetVariable().c_str());
    }
}


// ****************************************************************************
//  Method: avtIsovolumeFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtIsovolumeFilter with the given
//      parameters would result in an equivalent avtIsovolumeFilter.
//
//  Programmer: meredith -- generated by xml2info
//  Creation:   Fri Jan 30 14:50:21 PST 2004
//
// ****************************************************************************

bool
avtIsovolumeFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(IsovolumeAttributes*)a);
}


// ****************************************************************************
//  Method: avtIsovolumeFilter::ExecuteData
//
//  Purpose:
//      Sends the specified input and output through the Isovolume filter.
//
//  Arguments:
//      in_ds      The input dataset.
//      <unused>   The domain number.
//      <unused>   The label.
//
//  Returns:       The output dataset.
//
//  Programmer: Jeremy Meredith
//  Creation:   January 30, 2004
//
//  Modifications:
//    Jeremy Meredith, Mon Feb  2 13:13:05 PST 2004
//    Fixed memory leak.
//
// ****************************************************************************

vtkDataSet *
avtIsovolumeFilter::ExecuteData(vtkDataSet *in_ds, int, std::string)
{
    vtkVisItClipper3D *clipper = vtkVisItClipper3D::New();
    clipper->SetInput(in_ds);

    //
    // Get the scalar array we'll use for clipping; it must be nodal
    //
    vtkCellDataToPointData *cd2pd = NULL;
    if (in_ds->GetPointData()->GetScalars())
    {
        vtkDataArray *s = in_ds->GetPointData()->GetScalars();
        clipper->SetClipScalars((float*)(s->GetVoidPointer(0)),
                                atts.GetLbound(), atts.GetUbound());
    }
    else if (in_ds->GetCellData()->GetScalars())
    {
        //
        // Okay, our active variable was cell-centered.  Recenter it....
        //
        vtkDataSet *temp_ds = (vtkDataSet *) in_ds->NewInstance();
        temp_ds->CopyStructure(in_ds);
        temp_ds->GetCellData()->SetScalars(in_ds->GetCellData()->GetScalars());

        cd2pd = vtkCellDataToPointData::New();
        cd2pd->SetInput(temp_ds);
        cd2pd->Update();

        vtkDataSet *temporary = cd2pd->GetOutput();

        // Now tell the clipper about it....
        vtkDataArray *s = temporary->GetPointData()->GetScalars();
        clipper->SetClipScalars((float*)(s->GetVoidPointer(0)),
                                atts.GetLbound(), atts.GetUbound());

        // Wait until after the clipping is done to delete 'cd2pd' (which
        // will take 'temporary' with it)
        temp_ds->Delete();
    }
    else
    {
        debug1 << "Could not find any data for isovolume operation\n";
        EXCEPTION1(VisItException, "No variable was present for the Isovolume");
    }

    //
    // Do the clipping!
    //
    vtkDataSet *out_ds = clipper->GetOutput();
    out_ds->Update();

    if (out_ds->GetNumberOfCells() <= 0)
    {
        out_ds = NULL;
    }

    //
    // If we had poly data input, we want poly data output.  The VTK filter
    // only returns unstructured grids, so convert that now.
    //
    bool shouldDelete = false;
    if (in_ds->GetDataObjectType() == VTK_POLY_DATA && out_ds != NULL)
    {
        vtkUnstructuredGrid *ugrid = (vtkUnstructuredGrid *) out_ds;
        vtkPolyData *out_pd = vtkPolyData::New();
        out_pd->SetPoints(ugrid->GetPoints());
        out_pd->GetPointData()->ShallowCopy(ugrid->GetPointData());
        out_pd->GetCellData()->ShallowCopy(ugrid->GetCellData());
        int ncells = ugrid->GetNumberOfCells();
        out_pd->Allocate(ncells);
        for (int i = 0 ; i < ncells ; i++)
        {
            int celltype = ugrid->GetCellType(i);
            vtkIdType *pts;
            int npts;
            ugrid->GetCellPoints(i, npts, pts);
            out_pd->InsertNextCell(celltype, npts, pts);
        }
        out_ds = out_pd;
        shouldDelete = true;
    }

    ManageMemory(out_ds);
    clipper->Delete();
    if (shouldDelete)
        out_ds->Delete();

    //
    // Free the temporary filter used to convert to point data
    //
    if (cd2pd)
        cd2pd->Delete();

    return out_ds;
}


// ****************************************************************************
//  Method: avtIsovolumeFilter::RefashionDataObjectInfo
//
//  Purpose:
//      Indicates the zones no longer correspond to the original problem.
//
//  Programmer: Jeremy Meredith
//  Creation:   February 16, 2004
//
// ****************************************************************************

void
avtIsovolumeFilter::RefashionDataObjectInfo(void)
{
    GetOutput()->GetInfo().GetValidity().InvalidateZones();
}



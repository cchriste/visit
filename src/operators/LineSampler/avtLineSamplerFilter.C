/*****************************************************************************
*
* Copyright (c) 2000 - 2010, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//  File: avtLineSamplerFilter.C
// ************************************************************************* //

#include <avtLineSamplerFilter.h>

#include <avtIntervalTree.h>
#include <avtVector.h>

#include <vtkAppendPolyData.h>
#include <vtkCellArray.h>
#include <vtkCellData.h>
#include <vtkCleanPolyData.h>
#include <vtkDataSet.h>
#include <vtkFloatArray.h>
#include <vtkPointData.h>
#include <vtkPolyData.h>
#include <vtkPolyLine.h>
#include <vtkTransform.h>

#include <vtkVisitProbeFilter.h>

// ****************************************************************************
//  Method: avtLineSamplerFilter constructor
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

avtLineSamplerFilter::avtLineSamplerFilter()
{
}


// ****************************************************************************
//  Method: avtLineSamplerFilter destructor
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
//  Modifications:
//
// ****************************************************************************

avtLineSamplerFilter::~avtLineSamplerFilter()
{
}


// ****************************************************************************
//  Method:  avtLineSamplerFilter::Create
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

avtFilter *
avtLineSamplerFilter::Create()
{
    return new avtLineSamplerFilter();
}


// ****************************************************************************
//  Method:      avtLineSamplerFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

void
avtLineSamplerFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const LineSamplerAttributes*)a;
}


// ****************************************************************************
//  Method: avtLineSamplerFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtLineSamplerFilter with the given
//      parameters would result in an equivalent avtLineSamplerFilter.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

bool
avtLineSamplerFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(LineSamplerAttributes*)a);
}


// ****************************************************************************
//  Method: avtLineSamplerFilter::ExecuteData
//
//  Purpose:
//      Sends the specified input and output through the LineSampler filter.
//
//  Arguments:
//      in_ds      The input dataset.
//      <unused>   The domain number.
//      <unused>   The label.
//
//  Returns:       The output dataset.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

vtkDataSet *
avtLineSamplerFilter::ExecuteData(vtkDataSet *in_ds, int, std::string)
{
    vtkDataSet *out_ds = NULL;
    vtkAppendPolyData *append = vtkAppendPolyData::New();


    bool parallel = (atts.GetBeamType() == LineSamplerAttributes::Parallel );

    double beamSpacing = atts.GetSpacing();
    double beamAngle = atts.GetAngle();
    int nBeams = atts.GetNBeams();
    double *origin = atts.GetOrigin();
    double poloidalAngle = atts.GetPoloialAngle();
    double tilt = atts.GetPoloialTilt();
    double toroidalAngle = atts.GetToroialAngle();

    avtVector beamDirection;
    avtVector beamSpacingDirection;

    int nLinearSamples = atts.GetNLinearSamples();

    if( atts.GetBeamAxis() == LineSamplerAttributes::R )
    {
      beamDirection = avtVector(-1, 0, 0 );
      beamSpacingDirection = avtVector( 0, 0, beamSpacing );
    }
    else // if( atts.GetBeamAxis() == LineSamplerAttributes::Z )
    {
      beamDirection = avtVector(0, 0, -1);
      beamSpacingDirection = avtVector( beamSpacing, 0, 0 );
    }

    bool showBeamAsLine = true;

    avtVector beamOrigin( origin[0], origin[1], origin[2] );

    avtVector startBeamOrigin;
    double startBeamAngle;


    if( atts.GetViewDimension() == LineSamplerAttributes::Three )
    {
      // Odd number of beams so the origin is the middle beam.
      if( nBeams % 2 == 1 )
      {
        if( parallel )
          startBeamOrigin =
            beamOrigin - (int) (nBeams/2) * beamSpacingDirection;
        else //if( fan )
        {
          startBeamOrigin = beamOrigin;

          if( nBeams )
          {
            double dAngle = beamAngle / (double) (nBeams-1);
            startBeamAngle = (int) (nBeams/2) * dAngle;
          }
          else
            startBeamAngle = 0;
        }
      }

      // Even number of beams so the origin is between the middle two
      // beams.
      else // if( nBeams % 2 == 0 )
      {
        if( parallel )
          startBeamOrigin =
            beamOrigin - (nBeams/2.0) * beamSpacingDirection;
        else //if( fan )
        {
          startBeamOrigin = beamOrigin;

          if( nBeams )
          {
            double dAngle = beamAngle / (double) (nBeams-1);
            startBeamAngle = nBeams / 2.0 * dAngle;
          }
          else
            startBeamAngle = 0;
        }
      }

      // Loop through each beam.
      for( int b=0; b<nBeams; ++b ) 
      {
        //Create groups that represent each beam.
        vtkPoints *points = vtkPoints::New();
        vtkCellArray *cells = vtkCellArray::New();
        vtkFloatArray *scalars = vtkFloatArray::New();
            
        cells->InsertNextCell(nLinearSamples);
        scalars->Allocate    (nLinearSamples);

        avtVector startPoint;
        avtVector stopPoint;

        if( parallel )
        {
          startPoint = startBeamOrigin + (double) b * beamSpacingDirection;
          stopPoint  = startBeamOrigin + (double) b * beamSpacingDirection;

          avtDataset_p avtData = GetTypedInput();
          avtIntervalTree * avtIntTree =
            avtData->CalculateSpatialIntervalTree();

          double extents[6];
          avtIntTree->GetExtents( extents );

          if( atts.GetBeamAxis() == LineSamplerAttributes::R )
          {
            startPoint.x = 0;
            stopPoint.x = extents[1]; // Need to get Rmax;
          }

          else //if( atts.GetBeamAxis() == LineSamplerAttributes::Z )
          {
            startPoint.z = extents[4];  // Need to get Zmin;
            stopPoint.z  = extents[5];  // Need to get Zmax;
          }
        }
        else //if( fan )
        {
          double angle =
            2.0 * M_PI * (startBeamAngle -
                          (double) b * beamAngle / (double) nBeams) / 360.0 ;

          startPoint = startBeamOrigin;

          if( atts.GetBeamAxis() == LineSamplerAttributes::R )
          {
            // Get the inital stop point based on the angle
            stopPoint = startBeamOrigin +
              avtVector( -cos( angle ), 0, -sin(angle) );

            // Find the intersection of the beam with the R = 0 plane.
            avtVector planePt( 0, 0, 0 );
            avtVector planeNX( 1, 0, 0 );
            double planeX[4];

            planeX[0] = planeNX.x;
            planeX[1] = planeNX.y;
            planeX[2] = planeNX.z;
            planeX[3] = Dot( planePt, planeNX );

            avtVector dir(stopPoint-startPoint);
            double dot = Dot(planeNX, dir);
            avtVector w(startPoint - planePt);
        
            double t = -Dot(planeNX, w ) / dot;

            // Get the new stop point
            stopPoint = startPoint + dir * t;
          }

          else //if( atts.GetBeamAxis() == LineSamplerAttributes::Z )
          {
            // Get the inital stop point based on the angle
            stopPoint = startBeamOrigin +
              avtVector( -sin( angle ), 0, -cos(angle) );

            // Find the intersection of the beam with the Z = z_min plane.
            avtVector planePt( 0, 0, -1 );
            avtVector planeNX( 0, 0, 1 );
            double planeX[4];

            planeX[0] = planeNX.x;
            planeX[1] = planeNX.y;
            planeX[2] = planeNX.z;
            planeX[3] = Dot( planePt, planeNX );

            avtVector dir(stopPoint-startPoint);
            double dot = Dot(planeNX, dir);
            avtVector w(startPoint - planePt);
        
            double t = -Dot(planeNX, w ) / dot;

            // Get the new stop point
            stopPoint = startPoint + dir * t;
          }
        }

        // Now apply the transformations.
        vtkTransform *transform = vtkTransform::New();

        transform->Identity();
        transform->PostMultiply();

        // Rotate the beam poloidially. Most often this transformation
        // will not be needed. Assume the rotation is about the origin
        // of the beam.
        if( poloidalAngle )
        {
          // Rotation about the Y axis.
          transform->Translate( -startPoint.x, -startPoint.y, -startPoint.z );
          transform->RotateY( poloidalAngle );
          transform->Translate( startPoint.x, startPoint.y, startPoint.z );
        }

        // Poloidal plane tilting.
        if( tilt )
        {
          // Rotation about the X axis.
          transform->RotateX( tilt );
        }

        // Toroidal rotation.
        if( toroidalAngle )
        {
          // Rotation about the Z axis.
          transform->RotateZ( toroidalAngle );
        }

        vtkMatrix4x4 *matrix = transform->GetMatrix();

        double tmpPt[4];

        // Transform the start point
        tmpPt[0] = startPoint.x;
        tmpPt[1] = startPoint.y;
        tmpPt[2] = startPoint.z;
        tmpPt[3] = 1.0;

        matrix->MultiplyPoint( tmpPt, tmpPt );

        startPoint.x = tmpPt[0];
        startPoint.y = tmpPt[1];
        startPoint.z = tmpPt[2];
        
        // Transform the stop point
        tmpPt[0] = stopPoint.x;
        tmpPt[1] = stopPoint.y;
        tmpPt[2] = stopPoint.z;
        tmpPt[3] = 1.0;

        matrix->MultiplyPoint( tmpPt, tmpPt );

        stopPoint.x = tmpPt[0];
        stopPoint.y = tmpPt[1];
        stopPoint.z = tmpPt[2];

        transform->Delete();

        // sampling offset between points.
        avtVector delta =
          (stopPoint - startPoint) / (double) (nLinearSamples-1);

        // Create the points for sampling
        for( unsigned int i=0; i<nLinearSamples; ++i ) 
        {
          avtVector pt = startPoint + (double) i * delta;

          points->InsertPoint(i, pt.x, pt.y, pt.z);
          
          cells->InsertCellPoint(i);

          scalars->InsertTuple1(i, b);
        }
         
        // Create a new VTK polyline.
        vtkPolyData *pd = vtkPolyData::New();
        pd->SetPoints(points);
        pd->SetLines(cells);
        scalars->SetName("colorVar");
        pd->GetPointData()->SetScalars(scalars);
        append->AddInput(pd);
        
        points->Delete();
        cells->Delete();
        scalars->Delete();
      }   
    }

    append->Update();
    vtkPolyData *outPD = append->GetOutput();
    outPD->Register(NULL);
    outPD->SetSource(NULL);
    append->Delete();

    out_ds = outPD;

    vtkVisItProbeFilter *probeFilter = vtkVisItProbeFilter::New();

    probeFilter->SetSource( in_ds );
    probeFilter->SetInput( outPD );
    probeFilter->Update();

    out_ds = probeFilter->GetPolyDataOutput();
    out_ds->Register(NULL);
    out_ds->SetSource(NULL);

    probeFilter->Delete();

    return out_ds;
}

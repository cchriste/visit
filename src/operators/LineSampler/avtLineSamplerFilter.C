/*****************************************************************************
*
* Copyright (c) 2000 - 2010, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//  File: avtLineSamplerFilter.C
// ************************************************************************* //

#include <avtLineSamplerFilter.h>

#include <avtIntervalTree.h>
#include <avtVector.h>

#include <vtkAppendFilter.h>
#include <vtkUnstructuredGrid.h>
#include <vtkAppendPolyData.h>
#include <vtkCellArray.h>
#include <vtkCellData.h>
#include <vtkCleanPolyData.h>
#include <vtkDataSet.h>
#include <vtkFloatArray.h>
#include <vtkPointData.h>
#include <vtkPolyData.h>
#include <vtkPolyLine.h>
#include <vtkQuad.h>
#include <vtkTransform.h>

#include <vtkVisItProbeFilter.h>

// ****************************************************************************
//  Method: avtLineSamplerFilter constructor
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

avtLineSamplerFilter::avtLineSamplerFilter()
{
}


// ****************************************************************************
//  Method: avtLineSamplerFilter destructor
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
//  Modifications:
//
// ****************************************************************************

avtLineSamplerFilter::~avtLineSamplerFilter()
{
}


// ****************************************************************************
//  Method:  avtLineSamplerFilter::Create
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

avtFilter *
avtLineSamplerFilter::Create()
{
    return new avtLineSamplerFilter();
}


// ****************************************************************************
//  Method:      avtLineSamplerFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

void
avtLineSamplerFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const LineSamplerAttributes*)a;
}


// ****************************************************************************
//  Method: avtLineSamplerFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtLineSamplerFilter with the given
//      parameters would result in an equivalent avtLineSamplerFilter.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

bool
avtLineSamplerFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(LineSamplerAttributes*)a);
}


// ****************************************************************************
//  Method: avtLineSamplerFilter::ExecuteData
//
//  Purpose:
//      Sends the specified input and output through the LineSampler filter.
//
//  Arguments:
//      in_ds      The input dataset.
//      <unused>   The domain number.
//      <unused>   The label.
//
//  Returns:       The output dataset.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

vtkDataSet *
avtLineSamplerFilter::ExecuteData(vtkDataSet *in_ds, int, std::string)
{
    vtkDataSet *out_ds = NULL;
    vtkDataSet *outDS = NULL;

    vtkAppendPolyData *appendPolyData = vtkAppendPolyData::New();
    vtkAppendFilter *appendFilter = vtkAppendFilter::New();


    bool parallel = (atts.GetBeamType() == LineSamplerAttributes::Parallel );

    double beamSpacing = atts.GetSpacing();
    double beamAngle = atts.GetAngle();
    int nBeams = atts.GetNBeams();
    double *origin = atts.GetOrigin();
    double poloidalAngle = atts.GetPoloialAngle();
    double tilt = atts.GetPoloialTilt();
    double toroidalAngle = atts.GetToroialAngle();

    avtVector beamDirection;
    avtVector beamSpacingDirection;

    int nLinearSamples = atts.GetNLinearSamples();

    if( atts.GetBeamAxis() == LineSamplerAttributes::R )
    {
      beamDirection = avtVector(-1, 0, 0 );
      beamSpacingDirection = avtVector( 0, 0, beamSpacing );
    }
    else // if( atts.GetBeamAxis() == LineSamplerAttributes::Z )
    {
      beamDirection = avtVector(0, 0, -1);
      beamSpacingDirection = avtVector( beamSpacing, 0, 0 );
    }

    avtVector beamOrigin( origin[0], origin[1], origin[2] );

    avtVector startBeamOrigin;
    double startBeamAngle;
    double dAngle;

    if( atts.GetViewDimension() == LineSamplerAttributes::Three )
    {
      // Odd number of beams so the origin is the middle beam.
      if( nBeams % 2 == 1 )
      {
        if( parallel )
        {
          startBeamOrigin =
            beamOrigin - (int) (nBeams/2) * beamSpacingDirection;
        }
        else //if( fan )
        {
          startBeamOrigin = beamOrigin;

          if( nBeams > 1 )
          {
            dAngle = beamAngle / (double) (nBeams-1);
            startBeamAngle = (int) (nBeams/2) * dAngle;
          }
          else
            startBeamAngle = 0;
        }
      }

      // Even number of beams so the origin is between the middle two
      // beams.
      else // if( nBeams % 2 == 0 )
      {
        if( parallel )
          startBeamOrigin =
            beamOrigin - (nBeams/2.0-0.5) * beamSpacingDirection;
        else //if( fan )
        {
          startBeamOrigin = beamOrigin;

          if( nBeams > 1 )
          {
            dAngle = beamAngle / (double) (nBeams-1);
            startBeamAngle = (nBeams / 2.0 - 0.5)  * dAngle;
          }
          else
            startBeamAngle = 0;
        }
      }

      // Loop through each beam.
      for( int b=0; b<nBeams; ++b ) 
      {
        avtVector startPoint;
        avtVector stopPoint;
        avtVector normal;

        if( parallel )
        {
          startPoint = startBeamOrigin + (double) b * beamSpacingDirection;
          stopPoint  = startBeamOrigin + (double) b * beamSpacingDirection;

          avtDataset_p avtData = GetTypedInput();
          avtIntervalTree * avtIntTree =
            avtData->CalculateSpatialIntervalTree();

          double extents[6];
          avtIntTree->GetExtents( extents );

          if( atts.GetBeamAxis() == LineSamplerAttributes::R )
          {
            startPoint.x = extents[1]; // Need to get Rmax;
            stopPoint.x  = 0;

            normal = avtVector( 0, 0, 1 );
          }

          else //if( atts.GetBeamAxis() == LineSamplerAttributes::Z )
          {
            startPoint.z = extents[5];  // Need to get Zmax;
            stopPoint.z  = extents[4];  // Need to get Zmin;

            normal = avtVector( 1, 0, 0 );
          }
        }
        else //if( fan )
        {
          double angle =
            2.0 * M_PI * (startBeamAngle - (double) b * dAngle) / 360.0;

          startPoint = startBeamOrigin;

          if( atts.GetBeamAxis() == LineSamplerAttributes::R )
          {
            // Get the inital stop point based on the angle
            stopPoint = startBeamOrigin +
              avtVector( -cos( angle ), 0, -sin(angle) );

            normal = avtVector( -sin( angle ), 0, -cos(angle) );

            // Find the intersection of the beam with the R = 0 plane.
            avtVector planePt( 0, 0, 0 );
            avtVector planeNX( 1, 0, 0 );
            double planeX[4];

            planeX[0] = planeNX.x;
            planeX[1] = planeNX.y;
            planeX[2] = planeNX.z;
            planeX[3] = Dot( planePt, planeNX );

            avtVector dir(stopPoint-startPoint);
            double dot = Dot(planeNX, dir);
            avtVector w(startPoint - planePt);
        
            double t = -Dot(planeNX, w ) / dot;

            // Get the new stop point
            stopPoint = startPoint + dir * t;
          }

          else //if( atts.GetBeamAxis() == LineSamplerAttributes::Z )
          {
            // Get the inital stop point based on the angle
            stopPoint = startBeamOrigin +
              avtVector( -sin( angle ), 0, -cos(angle) );

            normal = avtVector( -cos( angle ), 0, -sin(angle) );

            // Find the intersection of the beam with the Z = z_min plane.
            avtVector planePt( 0, 0, -1 );
            avtVector planeNX( 0, 0, 1 );
            double planeX[4];

            planeX[0] = planeNX.x;
            planeX[1] = planeNX.y;
            planeX[2] = planeNX.z;
            planeX[3] = Dot( planePt, planeNX );

            avtVector dir(stopPoint-startPoint);
            double dot = Dot(planeNX, dir);
            avtVector w(startPoint - planePt);
        
            double t = -Dot(planeNX, w ) / dot;

            // Get the new stop point
            stopPoint = startPoint + dir * t;
          }
        }

        // Now apply the transformations.
        vtkTransform *transform = vtkTransform::New();

        transform->Identity();
        transform->PostMultiply();

        // Rotate the beam poloidially. Most often this transformation
        // will not be needed. Assume the rotation is about the origin
        // of the beam.
        if( poloidalAngle )
        {
          // Rotation about the Y axis.
          transform->Translate( -startPoint.x, -startPoint.y, -startPoint.z );
          transform->RotateY( poloidalAngle );
          transform->Translate( startPoint.x, startPoint.y, startPoint.z );
        }

        // Poloidal plane tilting.
        if( tilt )
        {
          // Rotation about the X axis.
          transform->RotateX( tilt );
        }

        // Toroidal rotation.
        if( toroidalAngle )
        {
          // Rotation about the Z axis.
          transform->RotateZ( toroidalAngle );
        }

        vtkMatrix4x4 *matrix = transform->GetMatrix();

        double tmpPt[4];

        // Transform the start point
        tmpPt[0] = startPoint.x;
        tmpPt[1] = startPoint.y;
        tmpPt[2] = startPoint.z;
        tmpPt[3] = 1.0;

        matrix->MultiplyPoint( tmpPt, tmpPt );

        startPoint.x = tmpPt[0];
        startPoint.y = tmpPt[1];
        startPoint.z = tmpPt[2];
        
        // Transform the stop point
        tmpPt[0] = stopPoint.x;
        tmpPt[1] = stopPoint.y;
        tmpPt[2] = stopPoint.z;
        tmpPt[3] = 1.0;

        matrix->MultiplyPoint( tmpPt, tmpPt );

        stopPoint.x = tmpPt[0];
        stopPoint.y = tmpPt[1];
        stopPoint.z = tmpPt[2];

        // Transform the normal
        tmpPt[0] = normal.x;
        tmpPt[1] = normal.y;
        tmpPt[2] = normal.z;
        tmpPt[3] = 1.0;

        matrix->MultiplyPoint( tmpPt, tmpPt );

        normal.x = tmpPt[0];
        normal.y = tmpPt[1];
        normal.z = tmpPt[2];

        transform->Delete();

        if( atts.GetBeamShape() == LineSamplerAttributes::Line )
          createLine( appendPolyData, startPoint, stopPoint );
        else if( atts.GetBeamShape() == LineSamplerAttributes::Cylinder )
          createCylinder( appendFilter, startPoint, stopPoint, normal );
        else if( atts.GetBeamShape() == LineSamplerAttributes::Cone )
          createCone( appendFilter, startPoint, stopPoint, normal );
      }   
    }

    if( atts.GetBeamShape() == LineSamplerAttributes::Line )
    {
      appendPolyData->Update();
      vtkPolyData *outPD = appendPolyData->GetOutput();
      outPD->Register(NULL);
      outPD->SetSource(NULL);
      appendPolyData->Delete();

      outDS = outPD;
    }
    else //if( atts.GetBeamShape() == LineSamplerAttributes::Cylinder ||
         //    atts.GetBeamShape() == LineSamplerAttributes::Cone )

    {
      appendFilter->Update();
      vtkUnstructuredGrid *outUG = appendFilter->GetOutput();

      outUG->Register(NULL);
      outUG->SetSource(NULL);
      appendFilter->Delete();

      outDS = outUG;
    }

    vtkVisItProbeFilter *probeFilter = vtkVisItProbeFilter::New();

    probeFilter->SetSource( in_ds );
    probeFilter->SetInput( outDS );
    probeFilter->Update();

    out_ds = probeFilter->GetOutput();

    out_ds->Register(NULL);
    out_ds->SetSource(NULL);

    probeFilter->Delete();

    return out_ds;
}

void
avtLineSamplerFilter::createLine( vtkAlgorithm *vtkAlgo,
                                  avtVector startPoint,
                                  avtVector stopPoint )
{
  int nLinearSamples = atts.GetNLinearSamples();

  //Create groups that represent each beam.
  vtkPoints *points = vtkPoints::New();
  vtkCellArray *cells = vtkCellArray::New();
//vtkFloatArray *scalars = vtkFloatArray::New();
            
  cells->InsertNextCell(nLinearSamples);
//scalars->Allocate    (nLinearSamples);


  // sampling offset between points.
  avtVector delta =
    (stopPoint - startPoint) / (double) (nLinearSamples-1);
  
  // Create the points for sampling
  for( unsigned int i=0; i<nLinearSamples; ++i )
  {
    avtVector pt = startPoint + (double) i * delta;
    
    points->InsertPoint(i, pt.x, pt.y, pt.z);
    
    cells->InsertCellPoint(i);

//  scalars->InsertTuple1(i, b);
  }
         
  // Create a new VTK polyline.
  vtkPolyData *pd = vtkPolyData::New();
  pd->SetPoints(points);
  pd->SetLines(cells);
//scalars->SetName("colorVar");
//pd->GetPointData()->SetScalars(scalars);
  ((vtkAppendPolyData*) vtkAlgo)->AddInput(pd);
  
  points->Delete();
  cells->Delete();
//scalars->Delete();
}

void
avtLineSamplerFilter::createCylinder( vtkAlgorithm *vtkAlgo,
                                      avtVector startPoint,
                                      avtVector stopPoint,
                                      avtVector normal )
{
  int nLinearSamples = atts.GetNLinearSamples();
  int nRadialSamples = atts.GetNRadialSamples();

  double radius = atts.GetRadius();

  // Create an unstructured quad for the island surface.
  vtkUnstructuredGrid *grid = vtkUnstructuredGrid::New();
  vtkQuad *quad = vtkQuad::New();
  vtkPoints *points = vtkPoints::New();
//  vtkFloatArray *scalars = vtkFloatArray::New();
    
  points->SetNumberOfPoints(nLinearSamples*nRadialSamples);
//  scalars->Allocate(nLinearSamples*nRadialSamples);
    
  float *points_ptr = (float *) points->GetVoidPointer(0);

  // sampling offset between points.
  avtVector deltaLinear =
    (stopPoint - startPoint) / (double) (nLinearSamples-1);

  double deltaAngle = 360.0 / (double) (nRadialSamples);

  for( unsigned int i=0, index=0; i<nLinearSamples; ++i )
  {
    avtVector basePoint = startPoint + (double) i * deltaLinear +
      radius * normal;

    for( unsigned int j=0; j<nRadialSamples; ++j, ++index )
    {
      double angle = (double) j * deltaAngle;

      // Now apply the transformations.
      vtkTransform *transform = vtkTransform::New();

      transform->Identity();
      transform->PostMultiply();

      transform->Translate( -startPoint.x, -startPoint.y, -startPoint.z );

      // Rotation about the axis.
      transform->RotateWXYZ( angle,
                             deltaLinear.x, deltaLinear.y, deltaLinear.z );

      transform->Translate( startPoint.x, startPoint.y, startPoint.z );

      vtkMatrix4x4 *matrix = transform->GetMatrix();

      float tmpPt[4];

      // Transform the start point
      tmpPt[0] = basePoint.x;
      tmpPt[1] = basePoint.y;
      tmpPt[2] = basePoint.z;
      tmpPt[3] = 1.0;

      matrix->MultiplyPoint( tmpPt, tmpPt );

      points_ptr[index*3  ] = tmpPt[0];
      points_ptr[index*3+1] = tmpPt[1];
      points_ptr[index*3+2] = tmpPt[2];
        
      transform->Delete();

//      scalars->InsertTuple1(index, index);

      // Create the quad.
      if( i<nLinearSamples-1 )
      {
        int i1 = i+1;
        int j1 = (j+1) % nRadialSamples;
          
        quad->GetPointIds()->SetId( 0, i  * nRadialSamples + j  );
        quad->GetPointIds()->SetId( 1, i1 * nRadialSamples + j  );
        quad->GetPointIds()->SetId( 2, i1 * nRadialSamples + j1 );
        quad->GetPointIds()->SetId( 3, i  * nRadialSamples + j1 );

        grid->InsertNextCell( quad->GetCellType(),
                              quad->GetPointIds() );                
      }
    }
  }

  // Stuff the points and scalars into the VTK unstructure grid.
  grid->SetPoints(points);
//  scalars->SetName("colorVar");
//  grid->GetPointData()->SetScalars(scalars);

  ((vtkAppendFilter*) vtkAlgo)->AddInput(grid);
    
  quad->Delete();
  points->Delete();
//  scalars->Delete();
}

void
avtLineSamplerFilter::createCone( vtkAlgorithm *vtkAlgo,
                                  avtVector startPoint,
                                  avtVector stopPoint,
                                  avtVector normal )
{
  int nLinearSamples = atts.GetNLinearSamples();
  int nRadialSamples = atts.GetNRadialSamples();

  double tangent = tan( 2.0 * M_PI * atts.GetDivergence() / 360.0 );

  // Create an unstructured quad for the island surface.
  vtkUnstructuredGrid *grid = vtkUnstructuredGrid::New();
  vtkQuad *quad = vtkQuad::New();
  vtkPoints *points = vtkPoints::New();
//  vtkFloatArray *scalars = vtkFloatArray::New();
    
  points->SetNumberOfPoints(nLinearSamples*nRadialSamples);
//  scalars->Allocate(nLinearSamples*nRadialSamples);
    
  float *points_ptr = (float *) points->GetVoidPointer(0);

  // sampling offset between points.
  avtVector deltaLinear =
    (stopPoint - startPoint) / (double) (nLinearSamples-1);

  double deltaAngle = 360.0 / (double) (nRadialSamples);

  for( unsigned int i=0, index=0; i<nLinearSamples; ++i )
  {
    double radius = ((double) i * deltaLinear.length()) * tangent;

    avtVector basePoint = startPoint + (double) i * deltaLinear +
      radius * normal;

    for( unsigned int j=0; j<nRadialSamples; ++j, ++index )
    {
      double angle = (double) j * deltaAngle;

      // Now apply the transformations.
      vtkTransform *transform = vtkTransform::New();

      transform->Identity();
      transform->PostMultiply();

      transform->Translate( -startPoint.x, -startPoint.y, -startPoint.z );

      // Rotation about the axis.
      transform->RotateWXYZ( angle,
                             deltaLinear.x, deltaLinear.y, deltaLinear.z );

      transform->Translate( startPoint.x, startPoint.y, startPoint.z );

      vtkMatrix4x4 *matrix = transform->GetMatrix();

      float tmpPt[4];

      // Transform the start point
      tmpPt[0] = basePoint.x;
      tmpPt[1] = basePoint.y;
      tmpPt[2] = basePoint.z;
      tmpPt[3] = 1.0;

      matrix->MultiplyPoint( tmpPt, tmpPt );

      points_ptr[index*3  ] = tmpPt[0];
      points_ptr[index*3+1] = tmpPt[1];
      points_ptr[index*3+2] = tmpPt[2];
        
      transform->Delete();

//      scalars->InsertTuple1(index, index);

      // Create the quad.
      if( i<nLinearSamples-1 )
      {
        int i1 = i+1;
        int j1 = (j+1) % nRadialSamples;
          
        quad->GetPointIds()->SetId( 0, i  * nRadialSamples + j  );
        quad->GetPointIds()->SetId( 1, i1 * nRadialSamples + j  );
        quad->GetPointIds()->SetId( 2, i1 * nRadialSamples + j1 );
        quad->GetPointIds()->SetId( 3, i  * nRadialSamples + j1 );

        grid->InsertNextCell( quad->GetCellType(),
                              quad->GetPointIds() );                
      }
    }
  }

  // Stuff the points and scalars into the VTK unstructure grid.
  grid->SetPoints(points);
//  scalars->SetName("colorVar");
//  grid->GetPointData()->SetScalars(scalars);

  ((vtkAppendFilter*) vtkAlgo)->AddInput(grid);
    
  quad->Delete();
  points->Delete();
//  scalars->Delete();
}

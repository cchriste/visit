/*****************************************************************************
*
* Copyright (c) 2000 - 2010, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//  File: avtLineSamplerFilter.C
// ************************************************************************* //

#include <avtLineSamplerFilter.h>

#include <avtIntervalTree.h>
#include <avtVector.h>

#include <vtkAppendFilter.h>
#include <vtkUnstructuredGrid.h>
#include <vtkAppendPolyData.h>
#include <vtkCellArray.h>
#include <vtkCellData.h>
#include <vtkCleanPolyData.h>
#include <vtkDataSet.h>
#include <vtkFloatArray.h>
#include <vtkPointData.h>
#include <vtkPolyData.h>
#include <vtkPolyLine.h>
#include <vtkQuad.h>
#include <vtkTransform.h>
#include <vtkTransformFilter.h>

#include <vtkVisItProbeFilter.h>

// ****************************************************************************
//  Method: avtLineSamplerFilter constructor
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

avtLineSamplerFilter::avtLineSamplerFilter()
{
}


// ****************************************************************************
//  Method: avtLineSamplerFilter destructor
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
//  Modifications:
//
// ****************************************************************************

avtLineSamplerFilter::~avtLineSamplerFilter()
{
}


// ****************************************************************************
//  Method:  avtLineSamplerFilter::Create
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

avtFilter *
avtLineSamplerFilter::Create()
{
    return new avtLineSamplerFilter();
}


// ****************************************************************************
//  Method:      avtLineSamplerFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

void
avtLineSamplerFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const LineSamplerAttributes*)a;
}


// ****************************************************************************
//  Method: avtLineSamplerFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtLineSamplerFilter with the given
//      parameters would result in an equivalent avtLineSamplerFilter.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

bool
avtLineSamplerFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(LineSamplerAttributes*)a);
}


// ****************************************************************************
//  Method: avtLineSamplerFilter::ExecuteData
//
//  Purpose:
//      Sends the specified input and output through the LineSampler filter.
//
//  Arguments:
//      in_ds      The input dataset.
//      <unused>   The domain number.
//      <unused>   The label.
//
//  Returns:       The output dataset.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

vtkDataSet *
avtLineSamplerFilter::ExecuteData(vtkDataSet *in_ds, int, std::string)
{
    vtkDataSet *out_ds = NULL;

    vtkAppendFilter *appendFilter = vtkAppendFilter::New();

    vtkTransformFilter *transformFilter = vtkTransformFilter::New();
    vtkTransform *transform = vtkTransform::New();
    transform->PostMultiply();

    vtkVisItProbeFilter *probeFilter = vtkVisItProbeFilter::New();
    probeFilter->SetSource( in_ds );

    double offset = atts.GetOffset();
    double angle = atts.GetAngle();
    int nBeams = atts.GetNBeams();
    double *origin = atts.GetOrigin();
    double poloidalAngle = atts.GetPoloialAngle();
    double rTilt = atts.GetPoloialRTilt();
    double zTilt = atts.GetPoloialZTilt();
    double toroidalAngle = atts.GetToroialAngle();

    double radius = atts.GetRadius();
    double divergence = atts.GetDivergence();


    avtVector beamDirection;

    // Set the beam direction
    if( atts.GetBeamAxis() == LineSamplerAttributes::R )
    {
      beamDirection = avtVector(-1, 0, 0 );
    }
    else // if( atts.GetBeamAxis() == LineSamplerAttributes::Z )
    {
      beamDirection = avtVector(0, 0, -1);
    }

    avtVector beamOffset(0,0,0);
    double beamAngle(0);

    // For a parallel set of beams set the offset between beams
    if( atts.GetBeamType() == LineSamplerAttributes::Parallel )
    {
      // When the beam is in the R direction we also need to include the
      // rTilt into the offset otherwise it is a rotation about itself.
      if( atts.GetBeamAxis() == LineSamplerAttributes::R )
      {
        beamOffset = avtVector( 0,
                                offset*sin(2.0*M_PI*rTilt/360.0),
                                offset*cos(2.0*M_PI*rTilt/360.0) );

        rTilt = 0;
      }
      // When the beam is in the Z direction we also need to include the
      // zTilt into the offset otherwise it is a rotation about itself.
      else // if( atts.GetBeamAxis() == LineSamplerAttributes::Z )
      {
        beamOffset = avtVector( offset*cos(2.0*M_PI*zTilt/360.0),
                                offset*sin(2.0*M_PI*zTilt/360.0),
                                0 );

        zTilt = 0;
      }
    }

    // For a fan beam set set the angle between beams
    else if( atts.GetBeamType() == LineSamplerAttributes::Fan )
    {
      beamAngle = angle / (double) (nBeams - 1);
    }

    // Get the indexing offset so that it is easy to calculate the
    // beam location based on a 0 to nBeans loop.
    double indexOffset;

    // Even number of beams
    if( nBeams % 2 == 1 )
      indexOffset = nBeams / 2.0 - 0.5;
    else
      indexOffset = nBeams / 2.0 - 1.0;

    // Loop through each beam.
    for( int b=0; b<nBeams; ++b ) 
    {
      // Inital start point is the origin.
      avtVector startPoint = avtVector( 0, 0,  0 );
      avtVector stopPoint;
      avtVector normal;
      
      // Stop point based on the beam direction With the normal being
      // at a 45 degree angle so that it can be rotated appropriately.
      if( atts.GetBeamAxis() == LineSamplerAttributes::R )
      {
        stopPoint = avtVector( -1, 0, 0 );
        normal = avtVector( 0, 1, 1 );
      }
      
      else //if( atts.GetBeamAxis() == LineSamplerAttributes::Z )
      {
        stopPoint = avtVector( 0, 0, -1 );     
        normal = avtVector( 1, 1, 0 );
      }

      normal.normalize();

      // Initial translation based on the user origin for the central
      // beam.
      avtVector translate( origin[0], origin[1], origin[2] );
      double poloidalBeamAngle = 0;

      // For a parallel beam set add the offset to the next beam.
      if( atts.GetBeamType() == LineSamplerAttributes::Parallel )
        translate += ((double) (b) - indexOffset) * beamOffset;

      // For a fan beam set, set the angle to the next beam.
      else //if( atts.GetBeamType() == LineSamplerAttributes::Fan )
        poloidalBeamAngle = ((double) (b) - indexOffset) * beamAngle;

      // Now apply the transformations.

      // Set up the transform for the normal
      transform->Identity();

      // Rotate the beam poloidially.
      if( poloidalBeamAngle || poloidalAngle )
        transform->RotateY( poloidalBeamAngle + poloidalAngle );

      // Poloidal plane x axis tilting.
      if( rTilt )
        transform->RotateX( rTilt );

      // Poloidal plane z axis tilting.
      if( zTilt )
        transform->RotateZ( zTilt );

      // Toroidal rotation.
      if( toroidalAngle )
        transform->RotateZ( toroidalAngle );

      // Transform the normal
      applyTransform( transform, normal );

        
      // Transform the start and stop points and check the extents so
      // that the beam goes from the start point through the dataset
      // appropriately.

      // Translate to the correct location
      if( translate.length() > 0 )
      {
        transform->Identity();
        transform->Translate( translate.x, translate.y, translate.z );

        applyTransform( transform, startPoint );
        applyTransform( transform, stopPoint );      

        checkExtents( startPoint, stopPoint );
      }

      // Rotate the beam poloidially.
      if( poloidalBeamAngle || poloidalAngle )
      {
        transform->Identity();
        transform->Translate( -startPoint.x, -startPoint.y, -startPoint.z );
        transform->RotateY( poloidalBeamAngle + poloidalAngle );
        transform->Translate( startPoint.x, startPoint.y, startPoint.z );

        applyTransform( transform, startPoint );
        applyTransform( transform, stopPoint );
          
        checkExtents( startPoint, stopPoint );
      }

      // Poloidal plane rTilting.
      if( rTilt )
      {
        transform->Identity();
        transform->Translate( -startPoint.x, -startPoint.y, -startPoint.z );
        transform->RotateX( rTilt );
        transform->Translate( startPoint.x, startPoint.y, startPoint.z );

        applyTransform( transform, startPoint );
        applyTransform( transform, stopPoint );
          
        checkExtents( startPoint, stopPoint );
      }

      // Poloidal plane rTilting.
      if( zTilt ) 
      {
        transform->Identity();
        transform->Translate( -startPoint.x, -startPoint.y, -startPoint.z );
        transform->RotateZ( zTilt );
        transform->Translate( startPoint.x, startPoint.y, startPoint.z );

        applyTransform( transform, startPoint );
        applyTransform( transform, stopPoint );
          
        checkExtents( startPoint, stopPoint );
      }

      // Toroidal rotation.
      if( toroidalAngle )
      {
        transform->Identity();
        transform->RotateZ( toroidalAngle );

        applyTransform( transform, startPoint );
        applyTransform( transform, stopPoint );

        // No extents checking as the beam is no longer in the
        // original plane.
      }

      // Create the appropriate goemetry.
      if( atts.GetBeamShape() == LineSamplerAttributes::Line )
      {
        out_ds = (vtkPolyData *) createLine( startPoint, stopPoint );
      }
      else if( atts.GetBeamShape() == LineSamplerAttributes::Cylinder )
      {
        out_ds = (vtkUnstructuredGrid *) 
          createCone( startPoint, stopPoint, normal, radius, 0 );
      }
      else if( atts.GetBeamShape() == LineSamplerAttributes::Cone )
      {
        out_ds = (vtkUnstructuredGrid *)
          createCone( startPoint, stopPoint, normal, 0, divergence );
      }

      // Do the sampling
      probeFilter->SetInput( out_ds );
      probeFilter->Update();

      out_ds = probeFilter->GetOutput();

      // If the user has elected to display the geometry in the Phi=0
      // plane then back out the toroidal rotation.
      if( atts.GetViewDimension() == LineSamplerAttributes::Two )
      {
        if( toroidalAngle )
        {
          transform->Identity();

          // Back out the toroidal transform.
          transform->RotateZ( -toroidalAngle );

          applyTransform( transform, startPoint );
          
          transformFilter->SetTransform( transform );
          transformFilter->SetInput( out_ds );
          
          out_ds = transformFilter->GetOutput();
          out_ds->Update();
          out_ds->Register(NULL);
          out_ds->SetSource(NULL);
        }
      }

      // If the user has elected to display the geometry as a 1D plot
      // then back out all of the transformations and put it into the
      // XY plane.
      else if( atts.GetViewDimension() == LineSamplerAttributes::One )
      {
        transform->Identity();

        // Back out the toroidal transform.
        if( toroidalAngle )
          transform->RotateZ( -toroidalAngle );

        // Get the startPoint now that it is back Phi=0 plane.
        applyTransform( transform, startPoint );

        // Back out the translation.
        if( startPoint.length() > 0 )
          transform->Translate( -startPoint.x, -startPoint.y, -startPoint.z );

        // Back out the zTilt plane transform.
        if( zTilt )
          transform->RotateZ( -zTilt );

        // Back out the rTilt plane transform.
        if( rTilt )
          transform->RotateX( -rTilt );

        // Back out the poloidal transform.
        if( poloidalBeamAngle || poloidalAngle )
          transform->RotateY( -(poloidalBeamAngle + poloidalAngle) );

        // Rotate to be along the x axis.
        transform->RotateY( -90 );
        // translate so each beam can be seen.
        transform->Translate( 0, (double) b*0.1, 0 );
        
        transformFilter->SetTransform( transform );
        transformFilter->SetInput( out_ds );

        out_ds = transformFilter->GetOutput();
        out_ds->Update();
      }

      out_ds->Register(NULL);
      out_ds->SetSource(NULL);

      // Merge all of the datasets together
      appendFilter->AddInput( out_ds );
    }

    // Get the appended datasets.
    appendFilter->Update();
    out_ds = appendFilter->GetOutput();
    out_ds->Register(NULL);
    out_ds->SetSource(NULL);

    // Nuke all the vtk filters
    appendFilter->Delete();    
    probeFilter->Delete();

    transform->Delete();
    transformFilter->Delete();

    return out_ds;
}

vtkPolyData*
avtLineSamplerFilter::createLine( avtVector startPoint,
                                  avtVector stopPoint )
{
  avtVector axis = (stopPoint - startPoint);

  // sampling offset between points.
  double sampleDistance = atts.GetSampleDistance();
  int nLinearSamples = ceil(axis.length() / sampleDistance) + 1;

  axis.normalize();
  avtVector delta = axis * sampleDistance;

  //Create groups that represent each beam.
  vtkPoints *points = vtkPoints::New();
  vtkCellArray *cells = vtkCellArray::New();
//vtkFloatArray *scalars = vtkFloatArray::New();
            
  cells->InsertNextCell(nLinearSamples);
//scalars->Allocate    (nLinearSamples);

  avtVector basePoint;

  // Create the points for sampling
  for( unsigned int i=0; i<nLinearSamples; ++i )
  {

    if( (double) i * delta.length() > (stopPoint - startPoint).length() )
      basePoint = stopPoint;
    else
      basePoint = startPoint + (double) i * delta;

    
    points->InsertPoint(i, basePoint.x, basePoint.y, basePoint.z);
    
    cells->InsertCellPoint(i);

//  scalars->InsertTuple1(i, b);
  }
         
  // Create a new VTK polyline.
  vtkPolyData *polydata = vtkPolyData::New();
  polydata->SetPoints(points);
  polydata->SetLines(cells);
//scalars->SetName("colorVar");
//polydata->GetPointData()->SetScalars(scalars);

  points->Delete();
  cells->Delete();
//scalars->Delete();

  return polydata;
}

vtkUnstructuredGrid *
avtLineSamplerFilter::createCone( avtVector startPoint,
                                  avtVector stopPoint,
                                  avtVector normal,
                                  double radius,
                                  double divergence )
{
  avtVector axis = (stopPoint - startPoint);

  // sampling offset between points.
  double sampleDistance = atts.GetSampleDistance();
  int nLinearSamples = ceil(axis.length() / sampleDistance) + 1;

  axis.normalize();
  avtVector delta = axis * sampleDistance;

  // sampling offset between arcs.
  double sampleArc = atts.GetSampleArc();
  int nRadialSamples = ceil( 360.0 / sampleArc );

  double tangent = tan( 2.0 * M_PI * divergence / 360.0 );

  // Create an unstructured quad for the island surface.
  vtkUnstructuredGrid *grid = vtkUnstructuredGrid::New();

  vtkQuad *quad = vtkQuad::New();
  vtkPoints *points = vtkPoints::New();
//  vtkFloatArray *scalars = vtkFloatArray::New();
    
  points->SetNumberOfPoints(nLinearSamples*nRadialSamples);
//  scalars->Allocate(nLinearSamples*nRadialSamples);
    
  float *points_ptr = (float *) points->GetVoidPointer(0);

  // sampling offset between points.
  avtVector basePoint;
  avtVector deltaLinear =
    (stopPoint - startPoint) / (double) (nLinearSamples-1);

  double deltaAngle = 360.0 / (double) (nRadialSamples);

  for( unsigned int i=0, index=0; i<nLinearSamples; ++i )
  {
    if( (double) i * deltaLinear.length() > (stopPoint - startPoint).length() )
      basePoint = stopPoint;
    else
      basePoint = startPoint + (double) i * deltaLinear;

    double dradius = ((double) i * deltaLinear.length()) * tangent;

    avtVector radialPoint = basePoint + (radius+dradius) * normal;

    for( unsigned int j=0; j<nRadialSamples; ++j, ++index )
    {
      double angle = (double) j * sampleArc;

      // Now apply the transformations.
      vtkTransform *transform = vtkTransform::New();

      transform->Identity();
      transform->PostMultiply();

      // Rotation about the axis.
      transform->Translate( -basePoint.x, -basePoint.y, -basePoint.z );
      transform->RotateWXYZ( angle,
                             deltaLinear.x, deltaLinear.y, deltaLinear.z );
      transform->Translate( basePoint.x, basePoint.y, basePoint.z );

      vtkMatrix4x4 *matrix = transform->GetMatrix();

      float tmpPt[4];

      // Transform the start point
      tmpPt[0] = radialPoint.x;
      tmpPt[1] = radialPoint.y;
      tmpPt[2] = radialPoint.z;
      tmpPt[3] = 1.0;

      matrix->MultiplyPoint( tmpPt, tmpPt );

      points_ptr[index*3  ] = tmpPt[0];
      points_ptr[index*3+1] = tmpPt[1];
      points_ptr[index*3+2] = tmpPt[2];
        
      transform->Delete();

//      scalars->InsertTuple1(index, index);

      // Create the quad.
      if( i<nLinearSamples-1 )
      {
        int i1 = i+1;
        int j1 = (j+1) % nRadialSamples;
          
        quad->GetPointIds()->SetId( 0, i  * nRadialSamples + j  );
        quad->GetPointIds()->SetId( 1, i1 * nRadialSamples + j  );
        quad->GetPointIds()->SetId( 2, i1 * nRadialSamples + j1 );
        quad->GetPointIds()->SetId( 3, i  * nRadialSamples + j1 );

        grid->InsertNextCell( quad->GetCellType(),
                              quad->GetPointIds() );                
      }
    }
  }

  // Stuff the points and scalars into the VTK unstructure grid.
  grid->SetPoints(points);
//  scalars->SetName("colorVar");
//  grid->GetPointData()->SetScalars(scalars);

  quad->Delete();
  points->Delete();
//  scalars->Delete();

  return grid;
}

avtVector
avtLineSamplerFilter::ProjectPointOnPlane( avtVector planePoint,
                                           avtVector planeNormal,
                                           avtVector point,
                                           avtVector axis )
{
  // Find the intersection of the beam with the R = 0 plane.
  double dot = Dot(planeNormal, axis);
  avtVector w(point - planePoint);
  
  double t = -Dot(planeNormal, w ) / dot;
  
  // Get the new stop point
  avtVector intersectingPoint = point + axis * t;

  return intersectingPoint;
}

void
avtLineSamplerFilter::applyTransform( vtkTransform* transform,
                                      avtVector &point )
{
  vtkMatrix4x4 *matrix;
  double tmpPt[4];
  
  matrix = transform->GetMatrix();

  // Transform the start point
  tmpPt[0] = point.x;
  tmpPt[1] = point.y;
  tmpPt[2] = point.z;
  tmpPt[3] = 1.0;

  matrix->MultiplyPoint( tmpPt, tmpPt );
  
  point.x = tmpPt[0];
  point.y = tmpPt[1];
  point.z = tmpPt[2];
}


void
avtLineSamplerFilter::checkExtents( avtVector &startPoint,
                                    avtVector &stopPoint )
{
  avtDataset_p avtData = GetTypedInput();
  avtIntervalTree * avtIntTree =
    avtData->CalculateSpatialIntervalTree();

  double extents[6];
  avtIntTree->GetExtents( extents );

  avtVector axis = stopPoint - startPoint;
  axis.normalize();

  if( atts.GetBeamAxis() == LineSamplerAttributes::R )
  {
    double Rmin;
    // Find the intersection of the beam with the X = Xmin plane.
    if( atts.GetCoordinateSystem() == LineSamplerAttributes::Cartesian )
      Rmin = extents[0];
    // Find the intersection of the beam with the R = 0 plane.
    else if( atts.GetCoordinateSystem() == LineSamplerAttributes::Cylindrical)
      Rmin = 0;
    
    // Find the intersection of the beam with the plane.
    stopPoint = ProjectPointOnPlane( avtVector( Rmin, 0, 0 ),
                                     avtVector( 1, 0, 0 ),
                                     startPoint,
                                     axis );
  }

  else //if( atts.GetBeamAxis() == LineSamplerAttributes::Z )
  {
    // Find the intersection of the beam with the Z = z_min plane.
    stopPoint = ProjectPointOnPlane( avtVector( 0, 0, extents[4] ),
                                     avtVector( 0, 0, -1 ),
                                     startPoint,
                                     axis );
  }

//   // Make sure the bounds of the beam are correct.
//   if( atts.GetBeamType() == LineSamplerAttributes::Parallel )
//   {
//     if( atts.GetBeamAxis() == LineSamplerAttributes::R )
//     {
//       // Find the intersection of the beam with the R = Rmax plane.
//       if( atts.GetBeamShape() == LineSamplerAttributes::Line ||
//        atts.GetBeamShape() == LineSamplerAttributes::Cylinder )
//      startPoint = ProjectPointOnPlane( avtVector( extents[1], 0, 0 ),
//                                        avtVector( 1, 0, 0 ),
//                                        startPoint,
//                                        axis );
//     }

//     else //if( atts.GetBeamAxis() == LineSamplerAttributes::Z )
//     {
//       // Find the intersection of the beam with the Z = Zmax plane.
//       if( atts.GetBeamShape() == LineSamplerAttributes::Line ||
//        atts.GetBeamShape() == LineSamplerAttributes::Cylinder )
//      startPoint = ProjectPointOnPlane( avtVector( 0, 0, extents[5] ),
//                                        avtVector( 0, 0, 1 ),
//                                        startPoint,
//                                        axis );
//     }
//   }
}

/*****************************************************************************
*
* Copyright (c) 2000 - 2011, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//  File: avtLineSamplerFilter.C
// ************************************************************************* //

#include <avtLineSamplerFilter.h>

#include <avtCallback.h>
#include <avtParallel.h>

#include <avtIntervalTree.h>
#include <avtDataAttributes.h>
#include <avtExtents.h>
#include <avtVector.h>

#include <vtkAppendFilter.h>
#include <vtkUnstructuredGrid.h>
#include <vtkAppendPolyData.h>
#include <vtkCellArray.h>
#include <vtkCellData.h>
#include <vtkCleanPolyData.h>
#include <vtkDataSet.h>
#include <vtkFloatArray.h>
#include <vtkPointData.h>
#include <vtkPolyData.h>
#include <vtkPolyLine.h>
#include <vtkQuad.h>
#include <vtkTransform.h>
#include <vtkTransformFilter.h>

#include <vtkVisItProbeFilter.h>

// ****************************************************************************
//  Method: avtLineSamplerFilter constructor
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

avtLineSamplerFilter::avtLineSamplerFilter() :
  haveData(true), composite_ds(0), newExtents(3)
{
}


// ****************************************************************************
//  Method: avtLineSamplerFilter destructor
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
//  Modifications:
//
// ****************************************************************************

avtLineSamplerFilter::~avtLineSamplerFilter()
{
}


// ****************************************************************************
//  Method:  avtLineSamplerFilter::Create
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

avtFilter *
avtLineSamplerFilter::Create()
{
    return new avtLineSamplerFilter();
}


// ****************************************************************************
//  Method:      avtLineSamplerFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

void
avtLineSamplerFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const LineSamplerAttributes*)a;
}


// ****************************************************************************
//  Method: avtLineSamplerFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtLineSamplerFilter with the given
//      parameters would result in an equivalent avtLineSamplerFilter.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

bool
avtLineSamplerFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(LineSamplerAttributes*)a);
}


// ****************************************************************************
//  Method: avtLineSamplerFilter::ExamineContact
//
//  Purpose: Examine the contract to get the current state of the time
//    slider. The time slider state is needed in case that the start
//    and end time are relative to the time slider.
//
//  Programmer: Oliver Ruebel
//  Creation:   May 07, 2009
//
//    Oliver Ruebel, Thu May 11 10:50
//
// ****************************************************************************
void
avtLineSamplerFilter::ExamineContract(avtContract_p in_contract)
{
    //Call the examine contract function of the super classes first
    avtPluginFilter::ExamineContract(in_contract);
    avtTimeLoopFilter::ExamineContract(in_contract);
    avtDatasetToDatasetFilter::ExamineContract(in_contract);
}


// ****************************************************************************
//  Method: avtLineSamplerFilter::InitializeTimeLoop
//
//  Purpose: Set the start, stop, and strides.
//
//  Programmer: Allen R. Sanderson
//  Creation:   May 07, 2011
//
// ****************************************************************************
void
avtLineSamplerFilter::InitializeTimeLoop(void)
{
    // If doing the current time step set the bounds to be the
    // currentTime.

    if( atts.GetTimeSampling() == LineSamplerAttributes::CurrentTimeStep )
    {
      // Update the start and end frame as well as the stride.
      SetStartFrame(currentTime);
      SetEndFrame(currentTime);
      SetStride( 1 );
    }

    // For mulitple times set the bounds from the attributes.
    else // if( atts.GetTimeSampling() ==
         //     LineSamplerAttributes::MultipleTimeSteps )
    {
      if( atts.GetTimeStepStart() < 0 )
      {
        std::string msg(GetType());
        msg = msg + ": Start index/Number of slices must be positive.";
        EXCEPTION1(ImproperUseException, msg);
      }

      if( atts.GetTimeStepStop() < 0 )
      {
        std::string msg(GetType());
        msg = msg + ": Stop index/Number of slices must be positive.";
        EXCEPTION1(ImproperUseException, msg);
      }

      SetStartFrame( atts.GetTimeStepStart() );
      SetEndFrame( atts.GetTimeStepStop() );
      SetStride( atts.GetTimeStepStride() );

    }

    // Misc initializations
    cachedAngle = -180;

    // Clean-up the current output dataset if necessary
    if( composite_ds ) {
        composite_ds->Delete();
        composite_ds = NULL;
    }
}


// ****************************************************************************
//  Method: avtLineSamplerFilter::Execute
//
//  Purpose: Defines what it means for this filter to "Execute". This
//    is where the actual iteration over time happens. This functions
//    is overwritten here to allow the dynamic setting of start and
//    end-time of the iteration.  The iteration over time is performed
//    using avtExecuteThenTimeLoopFilter::Execute(void)
//
//  Programmer: Oliver Ruebel
//  Creation:   May 07, 2009
//
// ****************************************************************************

void
avtLineSamplerFilter::Execute()
{
  int ts = currentTime;

    avtDataTree_p tree = GetInputDataTree();

    //Ask for the dataset
    int nds;
    vtkDataSet **dsets = tree->GetAllLeaves(nds);

    int nds2 = nds;
    SumIntAcrossAllProcessors(nds2);
    if (nds2 < 1 || nds > 1)
    {
        // Free the memory from the GetAllLeaves function call.
        delete [] dsets;

        EXCEPTION1(ImproperUseException, "Filter expected only one vtkDataSet"
                                         " in avtDataTree");
    }

    if (nds == 0)
    {
        // Free the memory from the GetAllLeaves function call.
        delete [] dsets;

        haveData = false;
        return;
    }

    vtkDataSet *currDs = dsets[0];

    // Free the memory from the GetAllLeaves function call.
    delete [] dsets;

    vtkDataSet *tmp_ds;

    double startAngle, stopAngle, deltaAngle;

    if( atts.GetToroidalIntegration() ==
        LineSamplerAttributes::ToroidalTimeSample )
    {
      startAngle = atts.GetToroidalAngleStart();
      stopAngle  = atts.GetToroidalAngleStop();
      deltaAngle = atts.GetToroidalAngleStride();
    }
    else
    {
      startAngle = 0;
      stopAngle = 1;
      deltaAngle = 1;
    }

    // Embed the sample toroidally as time in an outer loop.
    for( cachedAngle=startAngle; cachedAngle<stopAngle; cachedAngle+=deltaAngle )
    {
      tmp_ds = ExecuteChannelData(currDs, 0, "");

      if( atts.GetTimeSampling() == LineSamplerAttributes::CurrentTimeStep &&
          atts.GetToroidalIntegration() != LineSamplerAttributes::ToroidalTimeSample )
      {
        composite_ds = tmp_ds;
      }
      else //if( atts.GetTimeSampling() ==
           //    LineSamplerAttributes::MultipleTimeSteps )
      {
        if( atts.GetViewDimension() == LineSamplerAttributes::Two ||
            atts.GetViewDimension() == LineSamplerAttributes::Three )
        {
          std::string msg;
          msg += "The view dimension is not one. For collating multiple time " +
            std::string("steps the resulting plots are one dimensional.");
          
          avtCallback::IssueWarning(msg.c_str());
        }

        double heightPlotScale = atts.GetHeightPlotScale();
        double timePlotScale = atts.GetTimePlotScale();

        vtkUnstructuredGrid *uGrid;

        // First dataset so use it as the basis for the summation.
        if( composite_ds == NULL )
        {
          //Create and initalize the new dataset
          uGrid = vtkUnstructuredGrid::New();
          uGrid->SetPoints( vtkPoints::New() );
          
          vtkPointData* allData = tmp_ds->GetPointData();
          uGrid->GetPointData()->ShallowCopy(allData);
          uGrid->GetCellData()->ShallowCopy(tmp_ds->GetCellData());
          
          composite_ds = uGrid;
        }
        else
        {
          uGrid = vtkUnstructuredGrid::SafeDownCast(composite_ds);
        }
        
        int tPoints = composite_ds->GetNumberOfPoints();
        int nPoints = tmp_ds->GetNumberOfPoints();
        
        int timeStep = tPoints / nPoints;

        int nArrays, nChannels;

        if( atts.GetArrayConfiguration() == LineSamplerAttributes::Geometry )
        {
          nArrays = atts.GetNArrays();
          nChannels = atts.GetNChannels();
        }
        else //if( atts.GetArrayConfiguration() == LineSamplerAttributes::Manual )
        {
          nArrays = atts.GetNChannelListArrays();
          std::vector<double> listOfChannels = atts.GetChannelList();

          nChannels = listOfChannels.size() / 4;
        }

        if( nPoints != nArrays* nChannels )
        {
          std::string msg;
          msg += "The number of samples per channel is greater than one. " +
            std::string("Each sample will be part of single 1D curve");
          
          avtCallback::IssueWarning(msg.c_str());
        }

        // Traverse all points
        for( unsigned int i=0; i<nPoints; ++i )
        {
          // Get the next point and update its coordinates if necessary
          vtkDataArray *scalars = tmp_ds->GetPointData()->GetScalars();

          double nextPathPoint[3] = { timeStep * timePlotScale,
                                      i+heightPlotScale * *(scalars->GetTuple(i)),
                                      0 };

          vtkPoints* pathPoints = uGrid->GetPoints();
          pathPoints->InsertNextPoint( nextPathPoint );
          uGrid->SetPoints( pathPoints );

          // The index of the new point
          int  newPointIndex = uGrid->GetPoints()->GetNumberOfPoints()-1;
          int  newCellIndex = uGrid->GetNumberOfCells()-1;
        
          // Copy the pointdata from the input mesh to the output mesh
          vtkPointData* allData  = uGrid->GetPointData();
          vtkPointData* currData = tmp_ds->GetPointData();

          for( unsigned int j=0; j<allData->GetNumberOfArrays(); j++)
          {
            allData->GetArray(j)->
              InsertTuple( newPointIndex, currData->GetArray(j)->GetTuple(i) );
          }
          
          vtkCellData* allCellData = uGrid->GetCellData();
          vtkCellData* currCellData = tmp_ds->GetCellData();
          
          for( unsigned int j=0; j<allCellData->GetNumberOfArrays(); j++)
          {
            allCellData->GetArray(j)->
              InsertTuple( newCellIndex, currCellData->GetArray(j)->GetTuple(i) );
          }
        
          newCellIndex++;

          // Add a new line segment
          if( timeStep )
          {
            //define the points of the lines
            vtkIdType* pointList = new vtkIdType[2];
            pointList[0]   = newPointIndex - nPoints;
            pointList[1]   = newPointIndex;

            // Add a new line segment
            uGrid->InsertNextCell( VTK_LINE, 2, pointList );

            for( unsigned int j=0; j<allCellData->GetNumberOfArrays(); j++)
            {
              allCellData->GetArray(j)->
                InsertTuple( newCellIndex, currCellData->GetArray(j)->GetTuple(i) );
            }
          
            newCellIndex++;
            delete[] pointList;
          }
        }
      }
    }
}


// ****************************************************************************
//  Method: avtLineSamplerFilter::ExecuteChannelData
//
//  Purpose:
//      Sends the specified input and output through the LineSampler filter.
//
//  Arguments:
//      in_ds      The input dataset.
//      <unused>   The domain number.
//      <unused>   The label.
//
//  Returns:       The output dataset.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

vtkDataSet *
avtLineSamplerFilter::ExecuteChannelData(vtkDataSet *in_ds, int, std::string)
{
    
    double bounds[6];
    in_ds->GetBounds(bounds);

//     std::cerr << bounds[0] << "  "
//            << bounds[1] << "  "
//            << bounds[2] << "  "
//            << bounds[3] << "  "
//            << bounds[4] << "  "
//            << bounds[5] << "  "
//            << std:: endl;

    newExtents.Set( bounds );

    UpdateDataObjectInfo();

    vtkDataSet *out_ds = NULL;

    vtkAppendFilter *appendFilter = vtkAppendFilter::New();

    vtkTransformFilter *transformFilter = vtkTransformFilter::New();
    vtkTransform *transform = vtkTransform::New();
    transform->PostMultiply();

    vtkVisItProbeFilter *probeFilter = vtkVisItProbeFilter::New();
    probeFilter->SetSource( in_ds );

    std::vector<double> listOfChannels = atts.GetChannelList();

    int nArrays;
    double toroidalArrayAngle, toroidalOffsetAngle;
    int nChannels;

    if( atts.GetArrayConfiguration() == LineSamplerAttributes::Geometry )
    {
      nArrays = atts.GetNArrays();
      toroidalArrayAngle = atts.GetToroidalArrayAngle();

      toroidalOffsetAngle = atts.GetToroidalAngle();

      nChannels = atts.GetNChannels();
    }
    else //if( atts.GetArrayConfiguration() == LineSamplerAttributes::Manual )
    {
      nArrays = atts.GetNChannelListArrays();
      toroidalArrayAngle = atts.GetChannelListToroidalArrayAngle();

      toroidalOffsetAngle = atts.GetChannelListToroidalAngle();
      
      nChannels = listOfChannels.size() / 4;
    }

    LineSamplerAttributes::ChannelProjection projection =
      atts.GetChannelProjection();

    int nRows =
      (projection == LineSamplerAttributes::Grid) ? atts.GetNRows() : 1;

    int nColumns = nChannels / nRows;

    double *arrayOrigin = atts.GetArrayOrigin();

    double poloidalOffsetAngle, rTilt, zTilt;

    if( atts.GetArrayConfiguration() == LineSamplerAttributes::Geometry )
    {
      poloidalOffsetAngle = atts.GetPoloialAngle();
      rTilt = atts.GetPoloialRTilt();
      zTilt = atts.GetPoloialZTilt();
    }
    else //if( atts.GetArrayConfiguration() == LineSamplerAttributes::Manual )
    {
      poloidalOffsetAngle = 0;
      rTilt = 0;
      zTilt = 0;
    }

    double radius = atts.GetRadius();
    double divergence = atts.GetDivergence();

    double heightPlotScale = atts.GetHeightPlotScale();
    double channelPlotOffset  = atts.GetChannelPlotOffset();
    double arrayPlotOffset = atts.GetArrayPlotOffset();

    // Get the indexing offset so that it is easy to calculate the
    // line location based on a 0 to nChannels loop.
    double indexOffset = nChannels / 2.0 - 0.5;

    avtVector channelOffsetVec(0,0,0);
    avtVector rowOffsetVec(0,0,0);
    double channelAngle(0);

    // For a parallel set of channels set the offset between channels
    if( projection == LineSamplerAttributes::Parallel ||
        projection == LineSamplerAttributes::Grid )
    {
      double channelOffset = atts.GetChannelOffset();

      double rowOffset = atts.GetRowOffset();

      // When the channel is in the R direction we also need to include the
      // rTilt into the offset otherwise it is a rotation about itself.
      if( atts.GetArrayAxis() == LineSamplerAttributes::R )
      {
        channelOffsetVec = avtVector( 0,
                                      channelOffset*sin(2.0*M_PI*rTilt/360.0),
                                      channelOffset*cos(2.0*M_PI*rTilt/360.0) );

        if( projection == LineSamplerAttributes::Grid )
          rowOffsetVec = avtVector( 0,
                                    rowOffset*cos(2.0*M_PI*rTilt/360.0),
                                    rowOffset*sin(2.0*M_PI*rTilt/360.0) );

        rTilt = 0;
      }
      // When the channel is in the Z direction we also need to include the
      // zTilt into the offset otherwise it is a rotation about itself.
      else // if( atts.GetArrayAxis() == LineSamplerAttributes::Z )
      {
        channelOffsetVec = avtVector( channelOffset*cos(2.0*M_PI*zTilt/360.0),
                                      channelOffset*sin(2.0*M_PI*zTilt/360.0),
                                      0 );

        if( projection == LineSamplerAttributes::Grid )
          rowOffsetVec = avtVector( rowOffset*sin(2.0*M_PI*zTilt/360.0),
                                    rowOffset*cos(2.0*M_PI*zTilt/360.0),
                                    0 );

        zTilt = 0;
      }
    }

    // For a divergent channel set set the angle between channels
    else if( projection == LineSamplerAttributes::Divergent )
    {
      channelAngle = atts.GetChannelAngle();
    }

    avtVector channelDirection;

    // Set the channel direction
    if( atts.GetArrayAxis() == LineSamplerAttributes::R )
    {
      channelDirection = avtVector(-1, 0, 0 );
    }
    else // if( atts.GetArrayAxis() == LineSamplerAttributes::Z )
    {
      channelDirection = avtVector(0, 0, -1);
    }

    // Loop through each array.
    for( int a=0; a<nArrays; ++a ) 
    {
      // Loop through each channel.
      for( int c=0; c<nChannels; ++c ) 
      {
          // Inital start point is the origin.
          avtVector startPoint = avtVector( 0, 0,  0 );
          avtVector stopPoint;
          avtVector normal;
          
          // Stop point based on the channel direction With the normal being
          // at a 45 degree angle so that it can be rotated appropriately.
          if( atts.GetArrayConfiguration() == LineSamplerAttributes::Manual ||
              atts.GetArrayAxis() == LineSamplerAttributes::R )
          {
              stopPoint = avtVector( -1, 0, 0 );
              normal = avtVector( 0, 1, 1 );
          }
          
          else //if( atts.GetArrayAxis() == LineSamplerAttributes::Z )
          {
              stopPoint = avtVector( 0, 0, -1 );     
              normal = avtVector( 1, 1, 0 );
          }

          normal.normalize();
      
          double r, phi, z, poloidalAngle;

          if( atts.GetArrayConfiguration() == LineSamplerAttributes::Geometry )
          {
            r   = arrayOrigin[0];
            phi = arrayOrigin[1];
            z   = arrayOrigin[2];

            // Poloidal rotation
            poloidalAngle = poloidalOffsetAngle;
          }
          else //if( atts.GetArrayConfiguration() == LineSamplerAttributes::Manual )
          {
            // Note: Coordiantes are displayed as R, Z, Phi. But in
            // cylindrical it is R, Phi, Z.
            r   = listOfChannels[c*4  ];
            z   = listOfChannels[c*4+1];
            phi = listOfChannels[c*4+2];

            // Poloidal rotation
            poloidalAngle = 180.0 - listOfChannels[c*4+3];
          }         

          // For a divergent channel set, set the angle to the next
          // channel.
          if( projection == LineSamplerAttributes::Divergent )
            poloidalAngle += ((double) (c) - indexOffset) * channelAngle;

          // Toroidal rotation
          double toroidalAngle;

          if( atts.GetToroidalIntegration() ==
              LineSamplerAttributes::ToroidalTimeSample )
          {
            if( atts.GetToroidalAngleSampling() ==
                LineSamplerAttributes::ToroidalAngleAbsoluteSampling )
              {
                toroidalAngle = cachedAngle;
              }
            else if( atts.GetToroidalAngleSampling() ==
                     LineSamplerAttributes::ToroidalAngleRelativeSampling )
            {
              toroidalAngle = phi + toroidalOffsetAngle + cachedAngle;
            }
          }
          else
            toroidalAngle = phi + toroidalOffsetAngle;

          toroidalAngle += (double) a * toroidalArrayAngle;

          // Initial translation based on the user origin for the
          // central channel.
          avtVector translate( r, 0, z );

          if( atts.GetArrayConfiguration() == LineSamplerAttributes::Geometry )
          {
            // For a parallel channel set add the offset to the next
            // channel.
            if( projection == LineSamplerAttributes::Parallel )
              translate += ((double) (c) - indexOffset) * channelOffsetVec;
            
            // For a grid of channels set add the offset to the next
            // channel.
            if( projection == LineSamplerAttributes::Grid )
              translate +=
                ((double) (c%nColumns) - indexOffset) * channelOffsetVec +
                ((double) (c/nColumns)) * rowOffsetVec;
          }
            
          // Now apply the transformations.

          // Set up the transform for the normal
          transform->Identity();

          // Rotate the channel poloidially.
          if( poloidalAngle )
            transform->RotateY( poloidalAngle );

          // Poloidal plane x axis tilting.
          if( atts.GetArrayConfiguration() == LineSamplerAttributes::Geometry &&
              rTilt )
            transform->RotateX( rTilt );
          
          // Poloidal plane z axis tilting.
          if( atts.GetArrayConfiguration() == LineSamplerAttributes::Geometry &&
              zTilt )
            transform->RotateZ( zTilt );

          // Toroidal rotation.
          if( toroidalAngle != 0 )
            transform->RotateZ( toroidalAngle );

          // Transform the normal
          applyTransform( transform, normal );

          // Transform the start and stop points and check the extents so
          // that the channel goes from the start point through the dataset
          // appropriately.

          // Translate to the correct location
          if( translate.length() > 0 )
          {
              transform->Identity();
              transform->Translate( translate.x, translate.y, translate.z );

              applyTransform( transform, startPoint );
              applyTransform( transform, stopPoint );      

              checkExtents( startPoint, stopPoint );
          }

          // Rotate the channel poloidially.
          if( poloidalAngle )
          {
              transform->Identity();
              transform->Translate( -startPoint.x, -startPoint.y, -startPoint.z );
              transform->RotateY( poloidalAngle );
              transform->Translate( startPoint.x, startPoint.y, startPoint.z );
              
              applyTransform( transform, startPoint );
              applyTransform( transform, stopPoint );
              
              checkExtents( startPoint, stopPoint );
          }

          // Poloidal plane R Tilting.
          if( atts.GetArrayConfiguration() == LineSamplerAttributes::Geometry &&
              rTilt )
          {
              transform->Identity();
              transform->Translate( -startPoint.x, -startPoint.y, -startPoint.z );
              transform->RotateX( rTilt );
              transform->Translate( startPoint.x, startPoint.y, startPoint.z );

              applyTransform( transform, startPoint );
              applyTransform( transform, stopPoint );
          
              checkExtents( startPoint, stopPoint );
          }

          // Poloidal plane Z Tilting.
          if( atts.GetArrayConfiguration() == LineSamplerAttributes::Geometry &&
              zTilt ) 
          {
              transform->Identity();
              transform->Translate( -startPoint.x, -startPoint.y, -startPoint.z );
              transform->RotateZ( zTilt );
              transform->Translate( startPoint.x, startPoint.y, startPoint.z );

              applyTransform( transform, startPoint );
              applyTransform( transform, stopPoint );
          
              checkExtents( startPoint, stopPoint );
          }

          // Toroidal rotation.
          if( toroidalAngle != 0 )
          {
              transform->Identity();
              transform->RotateZ( toroidalAngle );

              applyTransform( transform, startPoint );
              applyTransform( transform, stopPoint );

              // No extents checking as the channel is no longer in the
              // original plane.
          }

          // Sample the complete cylinder
          if( atts.GetViewDimension() == LineSamplerAttributes::One &&
              atts.GetChannelGeometry() == LineSamplerAttributes::Cylinder )
          {
            // Get the base channel at r = 0
            out_ds = createLine( startPoint, stopPoint, true );

            // Do the sampling of the original dataset at r = 0
            probeFilter->SetInput( out_ds );
            probeFilter->Update();
            
            int nChannelSamples = out_ds->GetPointData()->GetNumberOfTuples();

            double sampleDistance = atts.GetSampleDistance();
            double sampleVolume   = atts.GetSampleVolume();

            avtVector axis = stopPoint - startPoint;

            // Get the normal to the line that goes through the origin
            double u = ((0 - startPoint.x) * (stopPoint.x-startPoint.x) +
                        (0 - startPoint.y) * (stopPoint.y-startPoint.y) +
                        (0 - startPoint.z) * (stopPoint.z-startPoint.z)) /
              (axis.length() * axis.length());
            
            avtVector normal = startPoint + u * axis;
            normal.normalize();

            std::cerr << "axis  " << axis << "  "
                      << "normal  " << normal << std::endl;

            // Loop through each radius.
            for( double r=sampleDistance; r<=radius; r+=sampleDistance )
            {
              // Get the circumference
              double circumference = 2.0 * M_PI * r;

              int nRadialSamples = (int) ceil( circumference / sampleDistance );

              double deltaAngle = 360.0 / nRadialSamples;

              // Loop through all of the sample toroidal angles.
              for( int n=0; n<nRadialSamples; ++n )
              {
                double angle = (double) n * deltaAngle;

                transform->Identity();

                transform->RotateWXYZ( angle, axis.x, axis.y, axis.z );

                avtVector offset = normal * radius;

                applyTransform( transform, offset );

                avtVector startBase = startPoint + offset;
                avtVector stopBase  = stopPoint  + offset;

                std::cerr << "startBase  " << startBase << "  "
                          << "stopBase  " << stopBase << std::endl;


                vtkDataSet *tmp_ds = createLine( startPoint, stopPoint, false );

                // Do the sampling of the original dataset
                probeFilter->SetInput( tmp_ds );
                probeFilter->Update();
              
                tmp_ds = probeFilter->GetOutput();

                float* out_data =
                  (float*) out_ds->GetPointData()->GetScalars()->GetVoidPointer(0);
                
                float* tmp_data =
                  (float*) tmp_ds->GetPointData()->GetScalars()->GetVoidPointer(0);
                double pts[3];
                
                // Do the summation for each channel
                for( unsigned int i=0; i<nChannelSamples; ++i )
                {
                  tmp_ds->GetPoint(i, pts);
                  
                  *out_data++ += sampleVolume * *tmp_data++;
                }
//            tmp_ds->Delete();
              }
            }
          }
          else
          {
            // Create the appropriate goemetry.
            if( atts.GetChannelGeometry() == LineSamplerAttributes::Point )
              out_ds = createPoint( startPoint, stopPoint, false );

            else if( atts.GetChannelGeometry() == LineSamplerAttributes::Line )
              out_ds = createLine( startPoint, stopPoint, false );

            else if( atts.GetChannelGeometry() == LineSamplerAttributes::Cylinder )
              out_ds = createCone( startPoint, stopPoint, normal, radius, 0 );

            else if( atts.GetChannelGeometry() == LineSamplerAttributes::Cone )
              out_ds = createCone( startPoint, stopPoint, normal, 0, divergence );
          
            // Do the sampling of the original dataset
            probeFilter->SetInput( out_ds );
            probeFilter->Update();
            
            out_ds = probeFilter->GetOutput();
          }

          // Integrate along the channel
          if( atts.GetViewDimension() == LineSamplerAttributes::One &&
              atts.GetChannelIntegration() ==
              LineSamplerAttributes::IntegrateAlongChannel )
          {
            vtkPoints *points = vtkPoints::New();
            vtkFloatArray *scalars = vtkFloatArray::New();
    
            points->SetNumberOfPoints(1);
            scalars->Allocate(1);

            float *points_ptr = (float *) points->GetVoidPointer(0);

            double pts[3];
            out_ds->GetPoint(0, pts);

            points_ptr[0] = pts[0];
            points_ptr[1] = pts[1];
            points_ptr[2] = pts[2];

            int nChannelSamples = out_ds->GetPointData()->GetNumberOfTuples();

            float* out_data =
              (float*) out_ds->GetPointData()->GetScalars()->GetVoidPointer(0);

            float sum = 0;

            double sampleDistance = atts.GetSampleDistance();
            double sampleVolume = atts.GetSampleVolume();

            // Do the summation for each channel
            for( unsigned int i=0; i<nChannelSamples; ++i )
              sum += sampleVolume * *out_data++;

            scalars->InsertTuple1(0, sum);

            vtkUnstructuredGrid *uGrid = vtkUnstructuredGrid::New();
            vtkIdType vertex = 0;

            uGrid->SetPoints(points);
            uGrid->Allocate(1);
            uGrid->InsertNextCell(VTK_VERTEX, 1, &vertex);
            scalars->SetName("colorVar");
            uGrid->GetPointData()->SetScalars(scalars);

            points->Delete();
            scalars->Delete();

//          out_ds->Delete();

            out_ds = uGrid;
          }

          // If the user has elected to display the geometry in the Phi=0
          // plane then back out the toroidal rotation.
          if( atts.GetViewDimension() == LineSamplerAttributes::Two )
          {
              if( toroidalAngle != 0 )
              {
                  transform->Identity();

                  // Back out the toroidal transform.
                  transform->RotateZ( -toroidalAngle - (double) a * toroidalArrayAngle );

                  transformFilter->SetTransform( transform );
                  transformFilter->SetInput( out_ds );
          
                  out_ds = transformFilter->GetOutput();
                  out_ds->Update();
              }
          }

          // If the user has elected to display the geometry as a 1D plot
          // then back out all of the transformations and put it into the
          // XY plane.
          else if( atts.GetViewDimension() == LineSamplerAttributes::One )
          {
              transform->Identity();

              // Back out the toroidal transform.
              if( toroidalAngle != 0 )
                transform->RotateZ( -toroidalAngle );

              // Get the startPoint now that it is back Phi=0 plane.
              applyTransform( transform, startPoint );

              // Back out the translation.
              if( startPoint.length() > 0 )
                transform->Translate( -startPoint.x, -startPoint.y, -startPoint.z );

              // Back out the zTilt plane transform.
              if( atts.GetArrayConfiguration() == LineSamplerAttributes::Geometry &&
                  zTilt )
                transform->RotateZ( -zTilt );

              // Back out the rTilt plane transform.
              if( atts.GetArrayConfiguration() == LineSamplerAttributes::Geometry &&
                  rTilt )
                transform->RotateX( -rTilt );

              // Back out the poloidal transform.
              if( poloidalAngle )
                transform->RotateY( -poloidalAngle );

              // Rotate to be along the x axis.
              if( atts.GetArrayConfiguration() == LineSamplerAttributes::Manual ||
                  atts.GetArrayAxis() == LineSamplerAttributes::R )
                transform->RotateY( 180 );
              else if( atts.GetArrayAxis() == LineSamplerAttributes::Z )
                transform->RotateY( -90 );

              // translate so each channel can be seen.
//               if( atts.GetChannelGeometry() == LineSamplerAttributes::Cylinder ||
//                   atts.GetChannelGeometry() == LineSamplerAttributes::Cone )
//                 transform->Translate( 0, (double) c*0.1, 0 );
        
              transformFilter->SetTransform( transform );
              transformFilter->SetInput( out_ds );

              out_ds = transformFilter->GetOutput();
              out_ds->Update();

              // At this point the data can now be elevated.
//               if( atts.GetChannelGeometry() == LineSamplerAttributes::Point ||
//                   atts.GetChannelGeometry() == LineSamplerAttributes::Line )
              {
                  double pt[3];

                  float *points_ptr;

                  if( atts.GetChannelIntegration() ==
                      LineSamplerAttributes::IntegrateAlongChannel ||
                      atts.GetChannelGeometry() == LineSamplerAttributes::Point ||
                      atts.GetViewGeometry() == LineSamplerAttributes::Points )
                  {
                    vtkUnstructuredGrid* out_ug = vtkUnstructuredGrid::SafeDownCast(out_ds);

                    points_ptr =
                      (float *) out_ug->GetPoints()->GetVoidPointer(0);
                  }
                  else //if( atts.GetChannelGeometry() == LineSamplerAttributes::Line )
                  {
                    vtkPolyData* out_pd = vtkPolyData::SafeDownCast(out_ds);

                    points_ptr =
                      (float *) out_pd->GetPoints()->GetVoidPointer(0);
                  }
          
                  vtkDataArray *scalars = out_ds->GetPointData()->GetScalars();

                  int nPts = scalars->GetNumberOfTuples();

                  // Adjust the X coordinate for each array
                  for( unsigned int i=0, j=0; i<nPts; ++i, j+=3)
                  {
                      points_ptr[j] += (double) a * arrayPlotOffset;
                  }

                  // Create a height field plot by adjusting Y
                  for( unsigned int i=0, j=1; i<nPts; ++i, j+=3)
                  {
                      points_ptr[j] = (double) c * channelPlotOffset +
                        heightPlotScale * *(scalars->GetTuple(i));
                  }
              }
          }

          out_ds->Register(NULL);
          out_ds->SetSource(NULL);

          // Merge all of the datasets together
          appendFilter->AddInput( out_ds );
      }
    }

    // Get the appended datasets.
    appendFilter->Update();
    out_ds = appendFilter->GetOutput();
    out_ds->Register(NULL);
    out_ds->SetSource(NULL);

    // Nuke all the vtk filters
    appendFilter->Delete();    
    probeFilter->Delete();

    transform->Delete();
    transformFilter->Delete();

    double newBounds[6];
    out_ds->GetBounds( newBounds );
    newExtents.Set( newBounds );

    UpdateDataObjectInfo();

    return out_ds;
}


vtkDataSet*
avtLineSamplerFilter::createPoint( avtVector startPoint,
                                   avtVector stopPoint,
                                   bool allocateScalars )
{
  avtVector axis = (stopPoint - startPoint);

  // Sampling offset between points.
  double sampleDistance = atts.GetSampleDistance();

  axis.normalize();
  avtVector delta = axis * sampleDistance;

  avtVector basePoint;

  if( delta.length() > (stopPoint - startPoint).length() )
    basePoint = stopPoint;
  else
    basePoint = startPoint + delta;
    
  // Create groups that represent each channel.
  vtkPoints *points = vtkPoints::New();

  points->InsertPoint(0, basePoint.x, basePoint.y, basePoint.z);

  vtkFloatArray *scalars = (allocateScalars ? vtkFloatArray::New() : NULL );

  if( allocateScalars && scalars )
  {
    scalars->Allocate(1);
    scalars->InsertTuple1(0, 0.0);
  }
         
  // Create a new VTK unstructured grid.
  vtkUnstructuredGrid *uGrid = vtkUnstructuredGrid::New();
  vtkIdType vertex = 0;

  uGrid->SetPoints(points);
  uGrid->Allocate(1);
  uGrid->InsertNextCell(VTK_VERTEX, 1, &vertex);

  if( allocateScalars && scalars )
  {
    scalars->SetName("colorVar");
    uGrid->GetPointData()->SetScalars(scalars);
  }

  points->Delete();
  if( allocateScalars && scalars )
    scalars->Delete();

  return uGrid;
}


vtkDataSet*
avtLineSamplerFilter::createLine( avtVector startPoint,
                                  avtVector stopPoint,
                                  bool allocateScalars)
{
  avtVector axis = (stopPoint - startPoint);

  // sampling offset between points.
  double sampleDistance = atts.GetSampleDistance();
  int nSamples = (int) (ceil(axis.length() / sampleDistance) + 1);

  axis.normalize();
//  avtVector delta = axis * sampleDistance;

  avtVector basePoint;
  avtVector delta = (stopPoint - startPoint) / (double) (nSamples-1);

  if( atts.GetViewGeometry() == 0 )
  {
    if( delta.length() > (stopPoint - startPoint).length() )
      basePoint = stopPoint;
    else
      basePoint = startPoint + delta;
    
    // Create groups that represent each channel.
    vtkPoints *points = vtkPoints::New();

    points->InsertPoint(0, basePoint.x, basePoint.y, basePoint.z);

    vtkFloatArray *scalars = (allocateScalars ? vtkFloatArray::New() : NULL );

    if( allocateScalars && scalars )
      scalars->Allocate(nSamples);
         
    avtVector basePoint;
    avtVector delta = (stopPoint - startPoint) / (double) (nSamples-1);
    
    // Create the points for sampling
    for( unsigned int i=0; i<nSamples; ++i )
    {
      if( (double) i * delta.length() > (stopPoint - startPoint).length() )
        basePoint = stopPoint;
      else
        basePoint = startPoint + (double) i * delta;
    
      points->InsertPoint(i, basePoint.x, basePoint.y, basePoint.z);
    
      if( allocateScalars && scalars )
        scalars->InsertTuple1(i, 0.0);
    }
         

    // Create a new VTK unstructured grid.
    vtkUnstructuredGrid *uGrid = vtkUnstructuredGrid::New();
    vtkIdType vertex = 0;

    uGrid->SetPoints(points);
    uGrid->Allocate(nSamples);

    for( unsigned int i=0; i<nSamples; ++i )
    {
      vertex = i;
      uGrid->InsertNextCell(VTK_VERTEX, 1, &vertex);
    }

    if( allocateScalars && scalars )
    {
      scalars->SetName("colorVar");
      uGrid->GetPointData()->SetScalars(scalars);
    }

    points->Delete();
    if( allocateScalars && scalars )
      scalars->Delete();

    return uGrid;
  }

  else
  {
    //Create groups that represent each channel.
    vtkPoints *points = vtkPoints::New();
    vtkCellArray *cells = vtkCellArray::New();
    vtkFloatArray *scalars = (allocateScalars ? vtkFloatArray::New() : NULL );
    
    cells->InsertNextCell(nSamples);
    if( allocateScalars && scalars )
      scalars->Allocate(nSamples);
    
    // Create the points for sampling
    for( unsigned int i=0; i<nSamples; ++i )
    {
      if( (double) i * delta.length() > (stopPoint - startPoint).length() )
        basePoint = stopPoint;
      else
        basePoint = startPoint + (double) i * delta;
    
      points->InsertPoint(i, basePoint.x, basePoint.y, basePoint.z);
    
      cells->InsertCellPoint(i);

      if( allocateScalars && scalars )
        scalars->InsertTuple1(i, 0.0);
    }
         
    // Create a new VTK polyline.
    vtkPolyData *polydata = vtkPolyData::New();
    polydata->SetPoints(points);
    polydata->SetLines(cells);
    if( allocateScalars && scalars )
    {
      scalars->SetName("colorVar");
      polydata->GetPointData()->SetScalars(scalars);
    }

    points->Delete();
    cells->Delete();
    if( allocateScalars && scalars )
      scalars->Delete();

    return polydata;
  }
}


vtkDataSet *
avtLineSamplerFilter::createCone( avtVector startPoint,
                                  avtVector stopPoint,
                                  avtVector normal,
                                  double radius,
                                  double divergence )
{
  avtVector axis = (stopPoint - startPoint);

  // sampling offset between points.
  double sampleDistance = atts.GetSampleDistance();
  int nSamples = (int) (ceil(axis.length() / sampleDistance) + 1);

  axis.normalize();
  //  avtVector delta = axis * sampleDistance;

  // Get the circumference
  double circumference = 2.0 * M_PI * radius;

  int nRadialSamples = (int) ceil( circumference / sampleDistance );

  if( nRadialSamples < 10 )
    nRadialSamples = 10;

  // sampling offset between arcs.
  double sampleArc = 360.0 / (double) nRadialSamples;

  double tangent = tan( 2.0 * M_PI * divergence / 360.0 );

  // Create an unstructured quad for the surface.
  vtkUnstructuredGrid *grid = vtkUnstructuredGrid::New();

  vtkQuad *quad = vtkQuad::New();
  vtkPoints *points = vtkPoints::New();
//  vtkFloatArray *scalars = vtkFloatArray::New();
    
  points->SetNumberOfPoints(nSamples*nRadialSamples);
//  scalars->Allocate(nSamples*nRadialSamples);
    
  float *points_ptr = (float *) points->GetVoidPointer(0);

  // sampling offset between points.
  avtVector basePoint;
  avtVector delta = (stopPoint - startPoint) / (double) (nSamples-1);

  double deltaAngle = 360.0 / (double) (nRadialSamples);

  for( unsigned int i=0, index=0; i<nSamples; ++i )
  {
    if( (double) i * delta.length() > (stopPoint - startPoint).length() )
      basePoint = stopPoint;
    else
      basePoint = startPoint + (double) i * delta;

    double dradius = ((double) i * delta.length()) * tangent;

    avtVector radialPoint = basePoint + (radius+dradius) * normal;

    for( unsigned int j=0; j<nRadialSamples; ++j, ++index )
    {
      double angle = (double) j * sampleArc;

      // Now apply the transformations.
      vtkTransform *transform = vtkTransform::New();

      transform->Identity();
      transform->PostMultiply();

      // Rotation about the axis.
      transform->Translate( -basePoint.x, -basePoint.y, -basePoint.z );
      transform->RotateWXYZ( angle,
                             delta.x, delta.y, delta.z );
      transform->Translate( basePoint.x, basePoint.y, basePoint.z );

      vtkMatrix4x4 *matrix = transform->GetMatrix();

      float tmpPt[4];

      // Transform the start point
      tmpPt[0] = radialPoint.x;
      tmpPt[1] = radialPoint.y;
      tmpPt[2] = radialPoint.z;
      tmpPt[3] = 1.0;

      matrix->MultiplyPoint( tmpPt, tmpPt );

      points_ptr[index*3  ] = tmpPt[0];
      points_ptr[index*3+1] = tmpPt[1];
      points_ptr[index*3+2] = tmpPt[2];
        
      transform->Delete();

//      scalars->InsertTuple1(index, index);

      // Create the quad.
      if( i<nSamples-1 )
      {
        int i1 = i+1;
        int j1 = (j+1) % nRadialSamples;
          
        quad->GetPointIds()->SetId( 0, i  * nRadialSamples + j  );
        quad->GetPointIds()->SetId( 1, i1 * nRadialSamples + j  );
        quad->GetPointIds()->SetId( 2, i1 * nRadialSamples + j1 );
        quad->GetPointIds()->SetId( 3, i  * nRadialSamples + j1 );

        grid->InsertNextCell( quad->GetCellType(),
                              quad->GetPointIds() );                
      }
    }
  }

  // Stuff the points and scalars into the VTK unstructure grid.
  grid->SetPoints(points);
//  scalars->SetName("colorVar");
//  grid->GetPointData()->SetScalars(scalars);

  quad->Delete();
  points->Delete();
//  scalars->Delete();

  return grid;
}

avtVector
avtLineSamplerFilter::ProjectPointOnPlane( avtVector planePoint,
                                           avtVector planeNormal,
                                           avtVector point,
                                           avtVector axis )
{
  // Find the intersection of the channel with the R = 0 plane.
  double dot = Dot(planeNormal, axis);
  avtVector w(point - planePoint);
  
  double t = -Dot(planeNormal, w ) / dot;
  
  // Get the new stop point
  avtVector intersectingPoint = point + axis * t;

  return intersectingPoint;
}

void
avtLineSamplerFilter::applyTransform( vtkTransform* transform,
                                      avtVector &point )
{
  vtkMatrix4x4 *matrix;
  double tmpPt[4];
  
  matrix = transform->GetMatrix();

  // Transform the start point
  tmpPt[0] = point.x;
  tmpPt[1] = point.y;
  tmpPt[2] = point.z;
  tmpPt[3] = 1.0;

  matrix->MultiplyPoint( tmpPt, tmpPt );
  
  point.x = tmpPt[0];
  point.y = tmpPt[1];
  point.z = tmpPt[2];
}


void
avtLineSamplerFilter::checkExtents( avtVector &startPoint,
                                    avtVector &stopPoint )
{
  avtDataset_p avtData = GetTypedInput();
  avtIntervalTree * avtIntTree =
    avtData->CalculateSpatialIntervalTree();
  
  double extents[6];
  avtIntTree->GetExtents( extents );

  std::cerr << extents[0] << "  " << extents[1] << "  "
            << extents[2] << "  " << extents[3] << "  "
            << extents[4] << "  " << extents[5] << "  "
            << std::endl;

//   for( int i=0; i<6; ++i )
//     extents[i] = bounds[i];

  // For cylindircal the extent is at R = 0, Y = 0.
  if( atts.GetCoordinateSystem() == LineSamplerAttributes::Cylindrical )
  {
    if( startPoint.x >= 0 && startPoint.y >= 0 )
      extents[0] = extents[2] = 0;
    else if( startPoint.x >= 0 && startPoint.y < 0 )
      extents[0] = extents[3] = 0;
    else if( startPoint.x < 0 && startPoint.y >= 0 )
      extents[1] = extents[2] = 0;
    else if( startPoint.x < 0 && startPoint.y < 0 )
      extents[1] = extents[3] = 0;
  }

  avtVector axis = stopPoint - startPoint;
  axis.normalize();

  // Check against the R axis first.
  if( axis != avtVector( 1, 0, 0 ) && axis != avtVector( -1, 0, 0 ) )
  {
    if( axis.x < 0 )
      // Find the intersection of the channel with the min R plane.
      stopPoint = ProjectPointOnPlane( avtVector( extents[0], 0, 0 ),
                                       avtVector( 1, 0, 0 ),
                                       startPoint,
                                       axis );
    else //if( axis.x >= 0 )
      // Find the intersection of the channel with the max R plane.
      stopPoint = ProjectPointOnPlane( avtVector( extents[1], 0, 0 ),
                                       avtVector( -1, 0, 0 ),
                                       startPoint,
                                       axis );
    
    // Y value is below the Y min or above the Y max then the
    // intersecting plane is that plane rather than the R plane.
    if( stopPoint.y < extents[2] || extents[3] < stopPoint.y )
    {
      if( axis != avtVector( 0, 1, 0 ) && axis != avtVector( 0, -1, 0 ) )
      {
        if( stopPoint.y < extents[2] )
          // Find the intersection of the channel with the min Y plane.
          stopPoint = ProjectPointOnPlane( avtVector( 0, 0, extents[2] ),
                                           avtVector( 0, 1, 0 ),
                                           startPoint,
                                           axis );
        
        else if( stopPoint.z > extents[3] )
          // Find the intersection of the channel with the max Y plane.
          stopPoint = ProjectPointOnPlane( avtVector( 0, 0, extents[3] ),
                                           avtVector( 0, -1, 0 ),
                                           startPoint,
                                           axis );
      }

      // Special case when the axis is in line with Y axis.
      else
      {
        stopPoint = startPoint;
        // Min Y plane
        if( axis.y < 0 )
          stopPoint.y = extents[2];
        // Max Y plane
        else if( axis.y >= 0 )
          stopPoint.y = extents[3];
      }
    }

    // Z value is below the Z min or above the Z max then the
    // intersecting plane is that plane rather than the R plane.
    if( stopPoint.z < extents[4] || extents[5] < stopPoint.z )
    {
      if( axis != avtVector( 0, 0, 1 ) && axis != avtVector( 0, 0, -1 ) )
      {
        if( stopPoint.z < extents[4] )
          // Find the intersection of the channel with the min Z plane.
          stopPoint = ProjectPointOnPlane( avtVector( 0, 0, extents[4] ),
                                           avtVector( 0, 0, 1 ),
                                           startPoint,
                                           axis );
        
        else if( stopPoint.z > extents[5] )
          // Find the intersection of the channel with the max Z plane.
          stopPoint = ProjectPointOnPlane( avtVector( 0, 0, extents[5] ),
                                           avtVector( 0, 0, -1 ),
                                           startPoint,
                                           axis );
      }

      // Special case when the axis is in line with Z axis.
      else
      {
        stopPoint = startPoint;
        // Min Z plane
        if( axis.z < 0 )
          stopPoint.z = extents[4];
        // Max Z plane
        else if( axis.z >= 0 )
          stopPoint.z = extents[5];
      }
    }
  }

  // Special case when the axis is in line with R axis.
  else
  {
    stopPoint = startPoint;

    // For cylindircal the extent is at R = 0.
    if( atts.GetCoordinateSystem() == LineSamplerAttributes::Cylindrical &&
        ((startPoint.x >= 0 && axis.x < 0) ||
         (startPoint.x <  0 && axis.x > 0)) )
      stopPoint.x = 0;
    // Min R plane
    else if( axis.x < 0 )
      stopPoint.x = extents[0];
    // Max R plane
    else if( axis.x >= 0 )
      stopPoint.x = extents[1];
  }
}


// ****************************************************************************
//  Method: avtTransform::UpdateDataObjectInfo
//
//  Purpose:
//      Changes the extents by the transform.
//
//  Programmer: Jeremy Meredith
//  Creation:   September 24, 2001
//
//  Modifications:
//
//    Hank Childs, Tue Mar  5 15:55:29 PST 2002
//    Also transformed current spatial extents.  Also told output that its
//    points were transformed.
//
//    Hank Childs, Fri Jan 13 09:49:08 PST 2006
//    Invalidate spatial meta-data.
//
//    Hank Childs, Thu Aug 26 13:47:30 PDT 2010
//    Change extents names.
//
// ****************************************************************************

void
avtLineSamplerFilter::UpdateDataObjectInfo(void)
{
    avtDataAttributes &inAtts = GetInput()->GetInfo().GetAttributes();
    avtDataAttributes &outAtts = GetOutput()->GetInfo().GetAttributes();

    (*outAtts.GetOriginalSpatialExtents()) = newExtents;
    (*outAtts.GetThisProcsOriginalSpatialExtents()) = newExtents;
    (*outAtts.GetDesiredSpatialExtents()) = newExtents;
    (*outAtts.GetActualSpatialExtents()) = newExtents;

    GetOutput()->GetInfo().GetValidity().SetPointsWereTransformed(true);
    GetOutput()->GetInfo().GetValidity().InvalidateSpatialMetaData();
}


// ****************************************************************************
//  Method: avtLineSamplerFilter::ExecutionSuccessful
//
//  Purpose:
//
//  Programmer: Hank Childs
//  Creation:   January 25, 2008
//
// ****************************************************************************
bool
avtLineSamplerFilter::ExecutionSuccessful(void)
{
  return haveData;
}


// ****************************************************************************
//  Method: avtLineSamplerFilter::CreateFinalOutput
//
//  Purpose:
//      This method is the mechanism for the base class to tell its derived
//      types that no more time slices are coming and it should put together
//      its final output. This method creates the final output dataset with
//      either all points of the different time slices or the dataset with
//      the particle paths.
//
//  Programmer: Hank Childs
//  Creation:   January 25, 2008
//
// ****************************************************************************

void
avtLineSamplerFilter::CreateFinalOutput(void)
{
     if (! haveData)
         return;

     avtDataTree_p newTree = new avtDataTree(composite_ds, 0);
     SetOutputDataTree(newTree);
}

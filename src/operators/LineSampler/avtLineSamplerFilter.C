/*****************************************************************************
*
* Copyright (c) 2000 - 2010, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//  File: avtLineSamplerFilter.C
// ************************************************************************* //

#include <avtLineSamplerFilter.h>

#include <avtIntervalTree.h>
#include <avtVector.h>

#include <vtkAppendFilter.h>
#include <vtkUnstructuredGrid.h>
#include <vtkAppendPolyData.h>
#include <vtkCellArray.h>
#include <vtkCellData.h>
#include <vtkCleanPolyData.h>
#include <vtkDataSet.h>
#include <vtkFloatArray.h>
#include <vtkPointData.h>
#include <vtkPolyData.h>
#include <vtkPolyLine.h>
#include <vtkQuad.h>
#include <vtkTransform.h>

#include <vtkVisItProbeFilter.h>

// ****************************************************************************
//  Method: avtLineSamplerFilter constructor
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

avtLineSamplerFilter::avtLineSamplerFilter()
{
}


// ****************************************************************************
//  Method: avtLineSamplerFilter destructor
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
//  Modifications:
//
// ****************************************************************************

avtLineSamplerFilter::~avtLineSamplerFilter()
{
}


// ****************************************************************************
//  Method:  avtLineSamplerFilter::Create
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

avtFilter *
avtLineSamplerFilter::Create()
{
    return new avtLineSamplerFilter();
}


// ****************************************************************************
//  Method:      avtLineSamplerFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

void
avtLineSamplerFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const LineSamplerAttributes*)a;
}


// ****************************************************************************
//  Method: avtLineSamplerFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtLineSamplerFilter with the given
//      parameters would result in an equivalent avtLineSamplerFilter.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

bool
avtLineSamplerFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(LineSamplerAttributes*)a);
}


// ****************************************************************************
//  Method: avtLineSamplerFilter::ExecuteData
//
//  Purpose:
//      Sends the specified input and output through the LineSampler filter.
//
//  Arguments:
//      in_ds      The input dataset.
//      <unused>   The domain number.
//      <unused>   The label.
//
//  Returns:       The output dataset.
//
//  Programmer: allen -- generated by xml2avt
//  Creation:   Wed Sep 29 13:42:47 PST 2010
//
// ****************************************************************************

vtkDataSet *
avtLineSamplerFilter::ExecuteData(vtkDataSet *in_ds, int, std::string)
{
    vtkDataSet *out_ds = NULL;
    vtkDataSet *outDS = NULL;

    vtkAppendPolyData *appendPolyData = vtkAppendPolyData::New();
    vtkAppendFilter *appendFilter = vtkAppendFilter::New();


    bool parallel = (atts.GetBeamType() == LineSamplerAttributes::Parallel );

    double beamSpacing = atts.GetSpacing();
    double beamAngle = atts.GetAngle();
    int nBeams = atts.GetNBeams();
    double *origin = atts.GetOrigin();
    double poloidalAngle = atts.GetPoloialAngle();
    double tilt = atts.GetPoloialTilt();
    double toroidalAngle = atts.GetToroialAngle();

    double radius = atts.GetRadius();
    double divergence = atts.GetDivergence();


    avtVector beamDirection;
    avtVector beamSpacingDirection;

    if( atts.GetBeamAxis() == LineSamplerAttributes::R )
    {
      beamDirection = avtVector(-1, 0, 0 );
      beamSpacingDirection = avtVector( 0, 0, beamSpacing );
    }
    else // if( atts.GetBeamAxis() == LineSamplerAttributes::Z )
    {
      beamDirection = avtVector(0, 0, -1);
      beamSpacingDirection = avtVector( beamSpacing, 0, 0 );
    }

    double startBeamAngle = -poloidalAngle;
    double dAngle = beamAngle / (double) (nBeams - 1);

    startBeamAngle = 0;

    // Get the indexing offset so that it is easy to calculate the
    // beam locaation based on a 0 to nBeans loop.
    double offset;

    // Even number of beams
    if( nBeams % 2 == 1 )
      offset = nBeams / 2.0 - 0.5;
    else
      offset = nBeams / 2.0 - 1.0;

    // Loop through each beam.
    for( int b=0; b<nBeams; ++b ) 
    {
      avtVector startPoint = avtVector( 0, 0,  0 );
      avtVector stopPoint;
      avtVector normal;
      
      if( atts.GetBeamAxis() == LineSamplerAttributes::R )
      {
        stopPoint  = avtVector( -1, 0, 0 );
        normal = avtVector( 0, 1, 1 );
      }
      
      else //if( atts.GetBeamAxis() == LineSamplerAttributes::Z )
      {
        stopPoint  = avtVector( 0, 0, -1 );     
        normal = avtVector( 1, 1, 0 );
      }

      normal.normalize();

      avtVector translate( origin[0], origin[1], origin[2] );
      double poloidalBeamAngle = 0;

      if( parallel )
        translate += ((double) (b) - offset) * beamSpacingDirection;
      else //if( fan )
        poloidalBeamAngle = ((double) (b) - offset) * dAngle;

      // Now apply the transformations.
      vtkTransform *transform = vtkTransform::New();
      transform->PostMultiply();


      // Set up the transform for the normal
      transform->Identity();

      // Rotate the beam poloidially.
      if( poloidalBeamAngle || poloidalAngle )
        transform->RotateY( poloidalBeamAngle + poloidalAngle );

      // Poloidal plane tilting.
      if( tilt )
        transform->RotateX( tilt );

      // Toroidal rotation.
      if( toroidalAngle )
        transform->RotateZ( toroidalAngle );

      // Transform the normal
      applyTransform( transform, normal );

        
      // Transform the start and stop points

      // Translate to the correct location
      if( translate.length() > 0 )
      {
        transform->Identity();
        transform->Translate( translate.x, translate.y, translate.z );

        // Transform the start point and stop point
        applyTransform( transform, startPoint );
        applyTransform( transform, stopPoint );      

        checkExtents( startPoint, stopPoint );
      }

      // Rotate the beam poloidially.
      if( poloidalBeamAngle || poloidalAngle )
      {
        transform->Identity();
        transform->Translate( -startPoint.x, -startPoint.y, -startPoint.z );
        transform->RotateY( poloidalBeamAngle + poloidalAngle );
        transform->Translate( startPoint.x, startPoint.y, startPoint.z );

        applyTransform( transform, startPoint );
        applyTransform( transform, stopPoint );
          
        checkExtents( startPoint, stopPoint );
      }

      // Poloidal plane tilting.
      if( tilt ) 
      {
        transform->Identity();
        transform->Translate( -startPoint.x, -startPoint.y, -startPoint.z );
        transform->RotateX( tilt );
        transform->Translate( startPoint.x, startPoint.y, startPoint.z );

        applyTransform( transform, startPoint );
        applyTransform( transform, stopPoint );
          
        checkExtents( startPoint, stopPoint );
      }

      // Toroidal rotation.
      if( toroidalAngle )
      {
        transform->Identity();
        transform->RotateZ( toroidalAngle );

        applyTransform( transform, startPoint );
        applyTransform( transform, stopPoint );

        // No extents checking as the beam is no longer in the
        // original plane.
      }

      transform->Delete();

      if( atts.GetBeamShape() == LineSamplerAttributes::Line )
        createLine( appendPolyData, startPoint, stopPoint );
      else if( atts.GetBeamShape() == LineSamplerAttributes::Cylinder )
        createCone( appendFilter, startPoint, stopPoint, normal, radius, 0 );
      else if( atts.GetBeamShape() == LineSamplerAttributes::Cone )
        createCone( appendFilter, startPoint, stopPoint, normal, 0, divergence );
    }

    if( atts.GetBeamShape() == LineSamplerAttributes::Line )
    {
      appendPolyData->Update();
      vtkPolyData *outPD = appendPolyData->GetOutput();
      outPD->Register(NULL);
      outPD->SetSource(NULL);
      appendPolyData->Delete();

      outDS = outPD;
    }
    else //if( atts.GetBeamShape() == LineSamplerAttributes::Cylinder ||
         //    atts.GetBeamShape() == LineSamplerAttributes::Cone )

    {
      appendFilter->Update();
      vtkUnstructuredGrid *outUG = appendFilter->GetOutput();

      outUG->Register(NULL);
      outUG->SetSource(NULL);
      appendFilter->Delete();

      outDS = outUG;
    }

    vtkVisItProbeFilter *probeFilter = vtkVisItProbeFilter::New();

    probeFilter->SetSource( in_ds );
    probeFilter->SetInput( outDS );
    probeFilter->Update();

    out_ds = probeFilter->GetOutput();

    out_ds->Register(NULL);
    out_ds->SetSource(NULL);

    probeFilter->Delete();

    if( atts.GetViewDimension() == LineSamplerAttributes::Two )
    {
    }
    else if( atts.GetViewDimension() == LineSamplerAttributes::One )
    {
    }

    return out_ds;
}

void
avtLineSamplerFilter::createLine( vtkAlgorithm *vtkAlgo,
                                  avtVector startPoint,
                                  avtVector stopPoint )
{
  avtVector axis = (stopPoint - startPoint);

  // sampling offset between points.
  double sampleDistance = atts.GetSampleDistance();
  int nLinearSamples = ceil(axis.length() / sampleDistance) + 1;

  axis.normalize();
  avtVector delta = axis * sampleDistance;

  //Create groups that represent each beam.
  vtkPoints *points = vtkPoints::New();
  vtkCellArray *cells = vtkCellArray::New();
//vtkFloatArray *scalars = vtkFloatArray::New();
            
  cells->InsertNextCell(nLinearSamples);
//scalars->Allocate    (nLinearSamples);

  avtVector basePoint;

  // Create the points for sampling
  for( unsigned int i=0; i<nLinearSamples; ++i )
  {

    if( (double) i * delta.length() > (stopPoint - startPoint).length() )
      basePoint = stopPoint;
    else
      basePoint = startPoint + (double) i * delta;

    
    points->InsertPoint(i, basePoint.x, basePoint.y, basePoint.z);
    
    cells->InsertCellPoint(i);

//  scalars->InsertTuple1(i, b);
  }
         
  // Create a new VTK polyline.
  vtkPolyData *pd = vtkPolyData::New();
  pd->SetPoints(points);
  pd->SetLines(cells);
//scalars->SetName("colorVar");
//pd->GetPointData()->SetScalars(scalars);
  ((vtkAppendPolyData*) vtkAlgo)->AddInput(pd);
  
  points->Delete();
  cells->Delete();
//scalars->Delete();
}

void
avtLineSamplerFilter::createCone( vtkAlgorithm *vtkAlgo,
                                  avtVector startPoint,
                                  avtVector stopPoint,
                                  avtVector normal,
                                  double radius,
                                  double divergence )
{
  avtVector axis = (stopPoint - startPoint);

  // sampling offset between points.
  double sampleDistance = atts.GetSampleDistance();
  int nLinearSamples = ceil(axis.length() / sampleDistance) + 1;

  axis.normalize();
  avtVector delta = axis * sampleDistance;

  // sampling offset between arcs.
  double sampleArc = atts.GetSampleArc();
  int nRadialSamples = ceil( 360.0 / sampleArc );

  double tangent = tan( 2.0 * M_PI * divergence / 360.0 );

  // Create an unstructured quad for the island surface.
  vtkUnstructuredGrid *grid = vtkUnstructuredGrid::New();
  vtkQuad *quad = vtkQuad::New();
  vtkPoints *points = vtkPoints::New();
//  vtkFloatArray *scalars = vtkFloatArray::New();
    
  points->SetNumberOfPoints(nLinearSamples*nRadialSamples);
//  scalars->Allocate(nLinearSamples*nRadialSamples);
    
  float *points_ptr = (float *) points->GetVoidPointer(0);

  // sampling offset between points.
  avtVector basePoint;
  avtVector deltaLinear =
    (stopPoint - startPoint) / (double) (nLinearSamples-1);

  double deltaAngle = 360.0 / (double) (nRadialSamples);

  for( unsigned int i=0, index=0; i<nLinearSamples; ++i )
  {
    if( (double) i * deltaLinear.length() > (stopPoint - startPoint).length() )
      basePoint = stopPoint;
    else
      basePoint = startPoint + (double) i * deltaLinear;

    double dradius = ((double) i * deltaLinear.length()) * tangent;

    avtVector radialPoint = basePoint + (radius+dradius) * normal;

    for( unsigned int j=0; j<nRadialSamples; ++j, ++index )
    {
      double angle = (double) j * sampleArc;

      // Now apply the transformations.
      vtkTransform *transform = vtkTransform::New();

      transform->Identity();
      transform->PostMultiply();

      // Rotation about the axis.
      transform->Translate( -basePoint.x, -basePoint.y, -basePoint.z );
      transform->RotateWXYZ( angle,
                             deltaLinear.x, deltaLinear.y, deltaLinear.z );
      transform->Translate( basePoint.x, basePoint.y, basePoint.z );

      vtkMatrix4x4 *matrix = transform->GetMatrix();

      float tmpPt[4];

      // Transform the start point
      tmpPt[0] = radialPoint.x;
      tmpPt[1] = radialPoint.y;
      tmpPt[2] = radialPoint.z;
      tmpPt[3] = 1.0;

      matrix->MultiplyPoint( tmpPt, tmpPt );

      points_ptr[index*3  ] = tmpPt[0];
      points_ptr[index*3+1] = tmpPt[1];
      points_ptr[index*3+2] = tmpPt[2];
        
      transform->Delete();

//      scalars->InsertTuple1(index, index);

      // Create the quad.
      if( i<nLinearSamples-1 )
      {
        int i1 = i+1;
        int j1 = (j+1) % nRadialSamples;
          
        quad->GetPointIds()->SetId( 0, i  * nRadialSamples + j  );
        quad->GetPointIds()->SetId( 1, i1 * nRadialSamples + j  );
        quad->GetPointIds()->SetId( 2, i1 * nRadialSamples + j1 );
        quad->GetPointIds()->SetId( 3, i  * nRadialSamples + j1 );

        grid->InsertNextCell( quad->GetCellType(),
                              quad->GetPointIds() );                
      }
    }
  }

  // Stuff the points and scalars into the VTK unstructure grid.
  grid->SetPoints(points);
//  scalars->SetName("colorVar");
//  grid->GetPointData()->SetScalars(scalars);

  ((vtkAppendFilter*) vtkAlgo)->AddInput(grid);
    
  quad->Delete();
  points->Delete();
//  scalars->Delete();
}

avtVector
avtLineSamplerFilter::ProjectPointOnPlane( avtVector planePoint,
                                           avtVector planeNormal,
                                           avtVector point,
                                           avtVector axis )
{
  // Find the intersection of the beam with the R = 0 plane.
  double dot = Dot(planeNormal, axis);
  avtVector w(point - planePoint);
  
  double t = -Dot(planeNormal, w ) / dot;
  
  // Get the new stop point
  avtVector intersectingPoint = point + axis * t;

  return intersectingPoint;
}

void
avtLineSamplerFilter::applyTransform( vtkTransform* transform,
                                      avtVector &point )
{
  vtkMatrix4x4 *matrix;
  double tmpPt[4];
  
  matrix = transform->GetMatrix();

  // Transform the start point
  tmpPt[0] = point.x;
  tmpPt[1] = point.y;
  tmpPt[2] = point.z;
  tmpPt[3] = 1.0;

  matrix->MultiplyPoint( tmpPt, tmpPt );
  
  point.x = tmpPt[0];
  point.y = tmpPt[1];
  point.z = tmpPt[2];
}


void
avtLineSamplerFilter::checkExtents( avtVector &startPoint,
                                    avtVector &stopPoint )
{
  avtDataset_p avtData = GetTypedInput();
  avtIntervalTree * avtIntTree =
    avtData->CalculateSpatialIntervalTree();

  double extents[6];
  avtIntTree->GetExtents( extents );

  avtVector axis = stopPoint - startPoint;
  axis.normalize();

  // Make sure the bounds of the beam are correct.
  if( atts.GetBeamType() == LineSamplerAttributes::Parallel )
  {
    if( atts.GetBeamAxis() == LineSamplerAttributes::R )
    {
      // Find the intersection of the beam with the R = Rmax plane.
//       if( atts.GetBeamShape() == LineSamplerAttributes::Line ||
//        atts.GetBeamShape() == LineSamplerAttributes::Cylinder )
//      startPoint = ProjectPointOnPlane( avtVector( extents[1], 0, 0 ),
//                                        avtVector( 1, 0, 0 ),
//                                        startPoint,
//                                        axis );

      // Find the intersection of the beam with the R = 0 plane.
      stopPoint = ProjectPointOnPlane( avtVector( 0, 0, 0 ),
                                       avtVector( 1, 0, 0 ),
                                       startPoint,
                                       axis );
    }

    else //if( atts.GetBeamAxis() == LineSamplerAttributes::Z )
    {
      // Find the intersection of the beam with the Z = Zmax plane.
//       if( atts.GetBeamShape() == LineSamplerAttributes::Line ||
//        atts.GetBeamShape() == LineSamplerAttributes::Cylinder )
//      startPoint = ProjectPointOnPlane( avtVector( 0, 0, extents[5] ),
//                                        avtVector( 0, 0, -1 ),
//                                        startPoint,
//                                        axis );

      // Find the intersection of the beam with the Z = Zmin plane.
      stopPoint = ProjectPointOnPlane( avtVector( 0, 0, extents[4] ),
                                       avtVector( 0, 0, 1 ),
                                       startPoint,
                                       axis );
    }
  }
  else //if( atts.GetBeamType() == LineSamplerAttributes::Fan )
  {
    if( atts.GetBeamAxis() == LineSamplerAttributes::R )
    {
      // Find the intersection of the beam with the R = 0 plane.
      stopPoint = ProjectPointOnPlane( avtVector( 0, 0, 0 ),
                                       avtVector( 1, 0, 0 ),
                                       startPoint,
                                       axis );
    }

    else //if( atts.GetBeamAxis() == LineSamplerAttributes::Z )
    {
      // Find the intersection of the beam with the Z = z_min plane.
      stopPoint = ProjectPointOnPlane( avtVector( 0, 0, extents[4] ),
                                       avtVector( 0, 0, -1 ),
                                       startPoint,
                                       axis );
    }
  }
}

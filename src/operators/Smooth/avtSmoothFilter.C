// ************************************************************************* //
//  File: avtSmoothFilter.C
// ************************************************************************* //

#include <avtSmoothFilter.h>

#include <vtkPolyData.h>
#include <vtkSmoothPolyDataFilter.h>

#include <avtCallback.h>

// ****************************************************************************
//  Method: avtSmoothFilter constructor
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Sun Aug 14 11:59:58 PDT 2005
//
// ****************************************************************************

avtSmoothFilter::avtSmoothFilter()
{
}


// ****************************************************************************
//  Method: avtSmoothFilter destructor
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Sun Aug 14 11:59:58 PDT 2005
//
//  Modifications:
//
// ****************************************************************************

avtSmoothFilter::~avtSmoothFilter()
{
}


// ****************************************************************************
//  Method:  avtSmoothFilter::Create
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Sun Aug 14 11:59:58 PDT 2005
//
// ****************************************************************************

avtFilter *
avtSmoothFilter::Create()
{
    return new avtSmoothFilter();
}


// ****************************************************************************
//  Method:      avtSmoothFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Sun Aug 14 11:59:58 PDT 2005
//
// ****************************************************************************

void
avtSmoothFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const SmoothOperatorAttributes*)a;
}


// ****************************************************************************
//  Method: avtSmoothFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtSmoothFilter with the given
//      parameters would result in an equivalent avtSmoothFilter.
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Sun Aug 14 11:59:58 PDT 2005
//
// ****************************************************************************

bool
avtSmoothFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(SmoothOperatorAttributes*)a);
}


// ****************************************************************************
//  Method: avtSmoothFilter::PreExecute
//
//  Purpose:
//      Called before ExecuteData, this will initialize issuedWarning.
//
//  Programmer: Hank Childs
//  Creation:   August 14, 2005
//
// ****************************************************************************

void
avtSmoothFilter::PreExecute(void)
{
    issuedWarning = false;
}


// ****************************************************************************
//  Method: avtSmoothFilter::ExecuteData
//
//  Purpose:
//      Sends the specified input and output through the Smooth filter.
//
//  Arguments:
//      in_ds      The input dataset.
//      <unused>   The domain number.
//      <unused>   The label.
//
//  Returns:       The output dataset.
//
//  Programmer: childs -- generated by xml2avt
//  Creation:   Sun Aug 14 11:59:58 PDT 2005
//
// ****************************************************************************

vtkDataSet *
avtSmoothFilter::ExecuteData(vtkDataSet *in_ds, int, std::string)
{
    if (in_ds->GetDataObjectType() != VTK_POLY_DATA)
    {
        if (!issuedWarning)
            avtCallback::IssueWarning("The Smooth operator can only be applied"
                     " to surfaces.  Please apply the ExternalSurface operator"
                     " before applying the Smooth operator.");
        issuedWarning = true;
        return in_ds;
    }

    vtkPolyData *pd = (vtkPolyData *) in_ds;
    vtkSmoothPolyDataFilter *smooth = vtkSmoothPolyDataFilter::New();
    smooth->SetInput(pd);

    smooth->SetConvergence(atts.GetConvergence());
    smooth->SetNumberOfIterations(atts.GetNumIterations());
    smooth->SetRelaxationFactor(atts.GetRelaxationFactor());
    smooth->SetFeatureEdgeSmoothing(atts.GetMaintainFeatures());
    smooth->SetFeatureAngle(atts.GetFeatureAngle());
    smooth->SetEdgeAngle(atts.GetEdgeAngle());
    smooth->SetBoundarySmoothing(atts.GetSmoothBoundaries());

    vtkPolyData *output = smooth->GetOutput();
    output->Update();

    ManageMemory(output);
    smooth->Delete();

    return output;
}

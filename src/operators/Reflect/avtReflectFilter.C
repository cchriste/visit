/*****************************************************************************
*
* Copyright (c) 2000 - 2006, The Regents of the University of California
* Produced at the Lawrence Livermore National Laboratory
* All rights reserved.
*
* This file is part of VisIt. For details, see http://www.llnl.gov/visit/. The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or materials provided with the distribution.
*  - Neither the name of the UC/LLNL nor  the names of its contributors may be
*    used to  endorse or  promote products derived from  this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED.  IN  NO  EVENT  SHALL  THE  REGENTS  OF  THE  UNIVERSITY OF
* CALIFORNIA, THE U.S.  DEPARTMENT  OF  ENERGY OR CONTRIBUTORS BE  LIABLE  FOR
* ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//  File: avtReflectFilter.C
// ************************************************************************* //

#include <avtReflectFilter.h>

#include <float.h>

#include <vtkCellData.h>
#include <vtkPointData.h>
#include <vtkPointSet.h>
#include <vtkRectilinearGrid.h>
#include <vtkUnsignedCharArray.h>

#include <avtDataTree.h>
#include <avtDatasetExaminer.h>
#include <avtExtents.h>

#include <DebugStream.h>
#include <ImproperUseException.h>

using   std::string;

static void ReflectVectorData(vtkDataSet *in_ds, int dim);


// ****************************************************************************
//  Function: Equal
//
//  Purpose:
//      Compares a float and a double and determines if they are equal.
//
//  Note:   Tried to do this with integer arithmetic but ran into compiler bugs
//          with gcc2.95 (worked with print statements, not without, with -O2).
//
//  Programmer: Hank Childs
//  Creation:   August 11, 2004
//
// ****************************************************************************

static inline bool
Equal(float t1, double t2)
{
    float v1 = t1;
    float v2 = (float) t2;

    // If they are exactly even, then no need to do more.
    if (v1 == v2)
        return true;

    // Rule out the 0's.
    if (v1 == 0.)
        return (fabs(v2) < 1e-10 ? true : false);
    if (v2 == 0.)
        return (fabs(v1) < 1e-10 ? true : false);
 
    // Make sure they are signed correctly.
    if (v1 < 0. && v2 > 0.)
        return false;
    if (v1 > 0. && v2 < 0.)
        return false;

    v1 = fabs(v1);
    v2 = fabs(v2);

    float greater = (v1 > v2 ? v1 : v2);
    float diff = fabs(v1-v2);
   
    // Save ourselves a divide -- below is the same as diff/greater < 1e-6.
    if (diff < (1e-6)*greater)
        return true;

    return false;
}


// ****************************************************************************
//  Method: avtReflectFilter constructor
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Thu Mar 7 10:35:24 PDT 2002
//
// ****************************************************************************

avtReflectFilter::avtReflectFilter()
{
    xReflect = 0.;
    yReflect = 0.;
    zReflect = 0.;
}


// ****************************************************************************
//  Method: avtReflectFilter destructor
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Thu Mar 7 10:35:24 PDT 2002
//
//  Modifications:
//
// ****************************************************************************

avtReflectFilter::~avtReflectFilter()
{
}


// ****************************************************************************
//  Method:  avtReflectFilter::Create
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Thu Mar 7 10:35:24 PDT 2002
//
// ****************************************************************************

avtFilter *
avtReflectFilter::Create()
{
    return new avtReflectFilter();
}


// ****************************************************************************
//  Method:      avtReflectFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Thu Mar 7 10:35:24 PDT 2002
//
// ****************************************************************************

void
avtReflectFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const ReflectAttributes*)a;
}


// ****************************************************************************
//  Method: avtReflectFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtReflectFilter with the given
//      parameters would result in an equivalent avtReflectFilter.
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Thu Mar 7 10:35:24 PDT 2002
//
// ****************************************************************************

bool
avtReflectFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(ReflectAttributes*)a);
}


// ****************************************************************************
//  Method: avtReflectFilter::PreExecute
//
//  Purpose:
//      Determines what lines/planes the data should be reflected across.  This
//      may be trivial (if they are all specified) or require some work (if
//      we are running in parallel).
//
//  Programmer: Hank Childs
//  Creation:   March 7, 2002
//
//  Modifications:
//
//    Jeremy Meredith, Mon Mar 11 15:41:55 PST 2002
//    Made octant 0 be +x+y+z.
//
//    Hank Childs, Mon Feb 24 17:19:42 PST 2003
//    Better checking of when we need to calculate extents in parallel.
//
//    Hank Childs, Wed Jun 25 09:30:59 PDT 2003
//    Fix stupid cut-n-paste bug.
//
// ****************************************************************************

void
avtReflectFilter::PreExecute(void)
{
    //
    // Calculating the extents may require parallel communication.  Only do
    // this if we are sure that we will need the extents.
    //
    double extents[6] = { -DBL_MAX, DBL_MAX, -DBL_MAX, DBL_MAX, 
                          -DBL_MAX, DBL_MAX };
    bool reflectX = false;
    bool reflectY = false;
    bool reflectZ = false;
    const int *shouldreflect = atts.GetReflections();
    for (int i = 0 ; i < 8 ; i++)
    {
        if (shouldreflect[i] != 0)
        {
            if (i & 1)
                reflectX = true;
            if (i & 2)
                reflectY = true;
            if (i & 4)
                reflectZ = true;
        }
    }
    bool needX = reflectX && atts.GetUseXBoundary();
    bool needY = reflectY && atts.GetUseYBoundary();
    bool needZ = reflectZ && atts.GetUseZBoundary();
    if (needX || needY || needZ)
    {
        GetSpatialExtents(extents);
    }

    if (atts.GetUseXBoundary())
    {
        //
        // If we are in an octant that is positive for X, then we want to
        // reflect along the minimum x-value.  Also, the octant number is set
        // up such that every other octant is positive for X.
        //
        int octant = atts.GetOctant();
        xReflect = (octant & 1 ? extents[1] : extents[0]);
    }
    else
    {
        xReflect = atts.GetSpecifiedX();
    }

    if (atts.GetUseYBoundary())
    {
        //
        // If we are in an octant that is positive for Y, then we want to
        // reflect along the minimum y-value.  Also, the octant number is set
        // up such that positive Y is paired off in twos.
        //
        int octant = atts.GetOctant();
        yReflect = (octant & 2 ? extents[3] : extents[2]);
    }
    else
    {
        yReflect = atts.GetSpecifiedY();
    }

    if (atts.GetUseZBoundary())
    {
        //
        // If we are in an octant that is positive for Y, then we want to
        // reflect along the minimum y-value.  Also, the octant number is set
        // up such that positive Z is the highest 4.
        //
        int octant = atts.GetOctant();
        zReflect = (octant & 4 ? extents[5] : extents[4]);
    }
    else
    {
        zReflect = atts.GetSpecifiedZ();
    }
}


// ****************************************************************************
//  Method: avtReflectFilter::PostExecute
//
//  Purpose:
//      Cleans up after the execution.  This manages extents.
//
//  Programmer: Hank Childs
//  Creation:   March 7, 2002
//
//  Modifications:
//
//    Hank Childs, Fri Mar 15 19:49:31 PST 2002
//    Account for dataset examiner.
//
//    Hank Childs, Thu Feb 26 16:19:33 PST 2004
//    Fix typo where data extents are being reset.
//
//    Hank Childs, Wed Aug 11 15:09:07 PDT 2004
//    Tell the output that it has ghost zones.
//
// ****************************************************************************

void
avtReflectFilter::PostExecute(void)
{
    avtDataAttributes &outAtts = GetOutput()->GetInfo().GetAttributes();
    outAtts.GetTrueSpatialExtents()->Clear();
    outAtts.GetEffectiveSpatialExtents()->Clear();
    outAtts.GetCurrentSpatialExtents()->Clear();

    if (GetInput()->GetInfo().GetAttributes().GetContainsGhostZones()
           != AVT_HAS_GHOSTS)
        outAtts.SetContainsGhostZones(AVT_CREATED_GHOSTS);

    double bounds[6];
    avtDataset_p ds = GetTypedOutput();
    avtDatasetExaminer::GetSpatialExtents(ds, bounds);
    outAtts.GetCumulativeTrueSpatialExtents()->Set(bounds);
}


// ****************************************************************************
//  Method: avtReflectFilter::PerformRestriction
//
//  Purpose:
//      Performs a restriction on the specification.  This is in place to
//      insure that we do static load balancing when extent calculation is
//      required.
//
//  Arguments:
//      spec    The current specification.
//
//  Returns:    A specification with the balancing potentially restricted.
//
//  Programmer: Hank Childs
//  Creation:   March 7, 2002
//
//  Modifications:
//    Kathleen Bonnell, Wed Jun 19 12:28:10 PDT 2002
//    Don't turn off Zone numbers if they have been turned on elsewhere in
//    the pipeline.
//
//    Kathleen Bonnell, Wed Jun 19 13:42:37 PDT 2002
//    Completely removed the code turning off zone numbers.  Why set a flag
//    to false if it is already false?  False is the default setting.
//
//    Kathleen Bonnell, Wed Jun  2 09:21:46 PDT 2004 
//    Turn on node numbers when required. 
//
// ****************************************************************************

avtPipelineSpecification_p
avtReflectFilter::PerformRestriction(avtPipelineSpecification_p spec)
{
    avtPipelineSpecification_p ns = new avtPipelineSpecification(spec);

    //
    // If we need to calculate the extents to reflect across, then we will have
    // to have all the domains together at the same time, so we have to use
    // static load balancing.
    //
    if (atts.GetUseXBoundary() || atts.GetUseYBoundary() ||
        atts.GetUseZBoundary())
    {
        ns->NoDynamicLoadBalancing();
    }

    if (spec->GetDataSpecification()->MayRequireZones())
    {
        ns->GetDataSpecification()->TurnZoneNumbersOn();
    }
    if (spec->GetDataSpecification()->MayRequireNodes())
    {
        ns->GetDataSpecification()->TurnNodeNumbersOn();
    }

    return ns;
}

// ****************************************************************************
//  Method: avtReflectFilter::RefashionDataObjectInfo
//
//  Purpose:
//     Specifies that this filter transforms the original dataset points. 
//
//  Programmer: Kathleen Bonnell 
//  Creation:   March 26, 2002 
//
//  Modifications:
//    Kathleen Bonnell, Mon Apr 14 09:57:39 PDT 2003
//    Set CanUseTransform to false.
//
//    Kathleen Bonnell, Wed Jun  2 09:21:46 PDT 2004 
//    Set CanUseInvTransform to false.
// 
//    Hank Childs, Fri Jan 13 09:58:47 PST 2006
//    Invalidate spatial meta-data.
//
// ****************************************************************************
 
void
avtReflectFilter::RefashionDataObjectInfo(void)
{
    GetOutput()->GetInfo().GetValidity().SetPointsWereTransformed(true);

    //
    // This filter invalidates any transform matrix in the pipeline.
    //
    GetOutput()->GetInfo().GetAttributes().SetCanUseInvTransform(false);
    GetOutput()->GetInfo().GetAttributes().SetCanUseTransform(false);

    GetOutput()->GetInfo().GetValidity().InvalidateSpatialMetaData();
}


// ****************************************************************************
//  Method: avtReflectFilter::ExecuteData
//
//  Purpose:
//      Sends the specified input and output through the Reflect filter.
//
//  Arguments:
//      in_ds      The input dataset.
//      dom        The domain number.
//      str        An identifying string.
//
//  Returns:       The output dataset.
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Thu Mar 7 10:35:24 PDT 2002
//
// ****************************************************************************

avtDataTree_p 
avtReflectFilter::ExecuteDataTree(vtkDataSet *in_ds, int dom, string str)
{
    int  i;

    if (in_ds == NULL)
    {
        return NULL;
    }

    //
    // Perform any of the 8 possible reflections.
    //
    const int *shouldreflect = atts.GetReflections();
    vtkDataSet *reflections[8];
    for (i = 0 ; i < 8 ; i++)
    {
        reflections[i] = NULL;
        if (shouldreflect[i] != 0)
        {
            reflections[i] = Reflect(in_ds, i);
        }
    }

    //
    // Construct a data tree out of our reflections.
    //
    avtDataTree_p rv = new avtDataTree(8, reflections, dom, str);

    //
    // Clean up memory.
    //
    for (i = 0 ; i < 8 ; i++)
    {
        if (reflections[i] != NULL)
        {
            reflections[i]->Delete();
        }
    }

    return rv;
}


// ****************************************************************************
//  Method: avtReflectFilter::Reflect
//
//  Purpose:
//      Determines what the mesh type is and calls the appropriate reflect
//      routine.
//
//  Arguments:
//      ds      The dataset to reflect.
//      dim     The dimension to reflect in.
//
//  Returns:    The dataset appropriately reflected.
//
//  Programmer: Hank Childs
//  Creation:   March 7, 2002
//
//  Modifications:
//
//    Hank Childs, Thu Jun 24 12:53:47 PDT 2004
//    Reflect vector data as well.
//
// ****************************************************************************

vtkDataSet *
avtReflectFilter::Reflect(vtkDataSet *ds, int dim)
{
    int dstype = ds->GetDataObjectType();
    vtkDataSet *rv = NULL;
    switch (dstype)
    {
      case VTK_RECTILINEAR_GRID:
        rv = ReflectRectilinear((vtkRectilinearGrid *) ds, dim);
        break;

      case VTK_STRUCTURED_GRID:
      case VTK_UNSTRUCTURED_GRID:
      case VTK_POLY_DATA:
        rv = ReflectPointSet((vtkPointSet *) ds, dim);
        break;

      default:
        debug1 << "Unknown data type for reflect filter = " << dstype << endl;
        break;
    }

    ReflectVectorData(rv, dim);

    return rv;
}


// ****************************************************************************
//  Method: avtReflectFilter::ReflectRectilinear
//
//  Purpose:
//      Reflects a rectilinear mesh.
//
//  Arguments:
//      ds      The dataset to reflect.
//      dim     The dimension to reflect in.
//
//  Returns:    The dataset reflected across val.
//
//  Programmer: Hank Childs
//  Creation:   March 7, 2002
//
//  Modifications:
//    Kathleen Bonnell, Fri Dec 13 16:41:12 PST 2002   
//    Use NewInstance instead of MakeObject in order to match vtk's new api. 
//    
//    Hank Childs, Wed Aug 11 14:43:44 PDT 2004
//    Create ghost nodes for nodes on a reflection plane.
//
//    Hank Childs, Fri Aug 27 15:25:22 PDT 2004
//    Rename ghost data arrays.
//
//    Hank Childs, Tue Jul  5 09:44:27 PDT 2005
//    Don't produce meshes that are "inside-out"/"degenerate". ['6321]
//
// ****************************************************************************

vtkDataSet *
avtReflectFilter::ReflectRectilinear(vtkRectilinearGrid *ds, int dim)
{
    vtkRectilinearGrid *out = (vtkRectilinearGrid *) ds->NewInstance();
    int nPts = ds->GetNumberOfPoints();
    int dims[3];
    ds->GetDimensions(dims);
    out->GetFieldData()->ShallowCopy(ds->GetFieldData());
    out->SetDimensions(dims);
    out->GetPointData()->CopyAllocate(ds->GetPointData());
    out->GetCellData()->CopyAllocate(ds->GetCellData());

    //
    // Reflect across X if appropriate.
    //
    bool flipI = false;
    if (dim & 1)
    {
        vtkDataArray *tmp = ReflectDataArray(ds->GetXCoordinates(), xReflect);
        out->SetXCoordinates(tmp);
        tmp->Delete();
        flipI = true;
    }
    else
        out->SetXCoordinates(ds->GetXCoordinates());

    //
    // Reflect across Y if appropriate.
    //
    bool flipJ = false;
    if (dim & 2)
    {
        vtkDataArray *tmp = ReflectDataArray(ds->GetYCoordinates(), yReflect);
        out->SetYCoordinates(tmp);
        tmp->Delete();
        flipJ = true;
    }
    else
        out->SetYCoordinates(ds->GetYCoordinates());

    //
    // Reflect across Z if appropriate.
    //
    bool flipK = false;
    if (dim & 4)
    {
        vtkDataArray *tmp = ReflectDataArray(ds->GetZCoordinates(), zReflect);
        out->SetZCoordinates(tmp);
        tmp->Delete();
        flipK = true;
    }
    else
        out->SetZCoordinates(ds->GetZCoordinates());


    //
    // Copy over the point data.
    //
    int i, j, k;
    vtkPointData *inPD  = ds->GetPointData();
    vtkPointData *outPD = out->GetPointData();
    for (k = 0 ; k < dims[2] ; k++)
        for (j = 0 ; j < dims[1] ; j++)
            for (i = 0 ; i < dims[0] ; i++)
            {
                int idx = k*dims[1]*dims[0] + j*dims[0] + i;
                int oldI = (flipI ? dims[0]-1-i : i);
                int oldJ = (flipJ ? dims[1]-1-j : j);
                int oldK = (flipK ? dims[2]-1-k : k);
                int oldIdx = oldK*dims[1]*dims[0] + oldJ*dims[0] + oldI;
                outPD->CopyData(inPD, oldIdx, idx);
            }
    vtkCellData *inCD  = ds->GetCellData();
    vtkCellData *outCD = out->GetCellData();

    int iEnd = dims[0]-1;
    if (iEnd <= 0)
        iEnd = 1;
    int jEnd = dims[1]-1;
    if (jEnd <= 0)
        jEnd = 1;
    int kEnd = dims[2]-1;
    if (kEnd <= 0)
        kEnd = 1;
    for (k = 0 ; k < kEnd ; k++)
        for (j = 0 ; j < jEnd ; j++)
            for (i = 0 ; i < iEnd ; i++)
            {
                int idx = k*(dims[1]-1)*(dims[0]-1) + j*(dims[0]-1) + i;
                int oldI = (flipI ? iEnd-1-i : i);
                int oldJ = (flipJ ? jEnd-1-j : j);
                int oldK = (flipK ? kEnd-1-k : k);
                int oldIdx =oldK*(dims[1]-1)*(dims[0]-1)+oldJ*(dims[0]-1)+oldI;
                outCD->CopyData(inCD, oldIdx, idx);
            }
    
    // Figure out which octents are present, meaning that nodes that are on
    // the reflection plane are now interior.
    bool doX, doY, doZ;
    HasNeighbor(dim, doX, doY, doZ);

    vtkUnsignedCharArray *gn = vtkUnsignedCharArray::New();
    gn->SetName("avtGhostNodes");
    gn->SetNumberOfTuples(nPts);
    unsigned char *gnp = gn->GetPointer(0);

    //
    // Start off by turning everything to 0.
    //
    for (i = 0 ; i < nPts ; i++)
        gnp[i] = 0;

    //
    // If the min-face is on the axis of reflection, then turn all the nodes
    // on that face to ghost nodes.
    //
    if (doX && Equal(out->GetXCoordinates()->GetTuple1(0), xReflect))
    {
        for (int k = 0 ; k < dims[2] ; k++)
            for (int j = 0 ; j < dims[1] ; j++)
            {
                int idx = 0 + j*dims[0] + k*dims[0]*dims[1];
                avtGhostData::AddGhostNodeType(gnp[idx], DUPLICATED_NODE);
            }
    }
    if (doX && Equal(out->GetXCoordinates()->GetTuple1(dims[0]-1), xReflect))
    {
        for (int k = 0 ; k < dims[2] ; k++)
            for (int j = 0 ; j < dims[1] ; j++)
            {
                int idx = dims[0]-1 + j*dims[0] + k*dims[0]*dims[1];
                avtGhostData::AddGhostNodeType(gnp[idx], DUPLICATED_NODE);
            }
    }
    if (doY && Equal(out->GetYCoordinates()->GetTuple1(0), yReflect))
    {
        for (int k = 0 ; k < dims[2] ; k++)
            for (int i = 0 ; i < dims[0] ; i++)
            {
                int idx = i + 0*dims[0] + k*dims[0]*dims[1];
                avtGhostData::AddGhostNodeType(gnp[idx], DUPLICATED_NODE);
            }
    }
    if (doY && Equal(out->GetYCoordinates()->GetTuple1(dims[1]-1), yReflect))
    {
        for (int k = 0 ; k < dims[2] ; k++)
            for (int i = 0 ; i < dims[0] ; i++)
            {
                int idx = i + (dims[1]-1)*dims[0] + k*dims[0]*dims[1];
                avtGhostData::AddGhostNodeType(gnp[idx], DUPLICATED_NODE);
            }
    }
    if (doZ && Equal(out->GetZCoordinates()->GetTuple1(0), zReflect))
    {
        for (int j = 0 ; j < dims[1] ; j++)
            for (int i = 0 ; i < dims[0] ; i++)
            {
                int idx = i + j*dims[0] + 0*dims[0]*dims[1];
                avtGhostData::AddGhostNodeType(gnp[idx], DUPLICATED_NODE);
            }
    }
    if (doZ && Equal(out->GetZCoordinates()->GetTuple1(dims[2]-1), zReflect))
    {
        for (int j = 0 ; j < dims[1] ; j++)
            for (int i = 0 ; i < dims[0] ; i++)
            {
                int idx = i + j*dims[0] + (dims[2]-1)*dims[0]*dims[1];
                avtGhostData::AddGhostNodeType(gnp[idx], DUPLICATED_NODE);
            }
    }

    out->GetPointData()->AddArray(gn);
    gn->Delete();

    return out;
}


// ****************************************************************************
//  Method: avtReflectFilter::ReflectDataArray
//
//  Purpose:
//      Reflects a single data array across a line.  This is used as a
//      convenience function for reflecting rectilinear grids.
//
//  Arguments:
//      coords  The coordinates to reflect.
//      val     The point to reflect about.
//
//  Returns:    The coordinates reflected; this must be deleted by the calling
//              object.
//
//  Programmer: Hank Childs
//  Creation:   March 8, 2002
//
//  Modifications:
//    Kathleen Bonnell, Fri Dec 13 16:41:12 PST 2002   
//    Use NewInstance instead of MakeObject in order to match vtk's new api. 
//    
//    Hank Childs, Fri Jul  1 10:50:58 PDT 2005
//    Reverse the coordinate array as we go.  Otherwise the grid will be
//    inverted.
//
// ****************************************************************************

vtkDataArray *
avtReflectFilter::ReflectDataArray(vtkDataArray *coords, double val)
{
    //
    // Reflect the coordinates across the line of reflection.
    //
    vtkDataArray *newcoords = coords->NewInstance();
    int nc = coords->GetNumberOfTuples();
    newcoords->SetNumberOfTuples(nc);

    if (coords->GetDataType() == VTK_FLOAT)
    {
        float *c = (float*)coords->GetVoidPointer(0);
        float *n = (float*)newcoords->GetVoidPointer(0);
        for (int i = 0 ; i < nc ; i++)
        {
            n[nc-i-1] = 2*val - c[i];
        }
    }
    else if (coords->GetDataType() == VTK_DOUBLE)
    {
        double *c = (double*)coords->GetVoidPointer(0);
        double *n = (double*)newcoords->GetVoidPointer(0);
        for (int i = 0 ; i < nc ; i++)
        {
            n[nc-i-1] = 2*val - c[i];
        }
    }


    return newcoords;
}


// ****************************************************************************
//  Method: avtReflectFilter::ReflectPointSet
//
//  Purpose:
//      Reflects a dataset that is derived from point set.
//
//  Arguments:
//      ds      The dataset to reflect.
//      dim     The dimension to reflect in.
//
//  Returns:    The dataset reflected across val.
//
//  Programmer: Hank Childs
//  Creation:   March 7, 2002
//
//  Modifications:
//    Kathleen Bonnell, Fri Dec 13 16:41:12 PST 2002   
//    Use NewInstance instead of MakeObject in order to match vtk's new api. 
//    
//    Hank Childs, Wed Aug 11 14:43:44 PDT 2004
//    Create ghost nodes for nodes on a reflection plane.
//
//    Hank Childs, Fri Aug 27 15:25:22 PDT 2004
//    Rename ghost data arrays.
//
// ****************************************************************************

vtkDataSet *
avtReflectFilter::ReflectPointSet(vtkPointSet *ds, int dim)
{
    vtkPointSet *out = (vtkPointSet *) ds->NewInstance();
    out->ShallowCopy(ds);

    vtkPoints *inPts  = ds->GetPoints();
    vtkPoints *outPts = vtkPoints::New();
    int nPts = inPts->GetNumberOfPoints();
    outPts->SetNumberOfPoints(nPts);

    // Figure out which octents are present, meaning that nodes that are on
    // the reflection plane are now interior.
    bool doX, doY, doZ;
    HasNeighbor(dim, doX, doY, doZ);

    vtkUnsignedCharArray *gn = vtkUnsignedCharArray::New();
    gn->SetName("avtGhostNodes");
    gn->SetNumberOfTuples(nPts);
    unsigned char *gnp = gn->GetPointer(0);

    for (int i = 0 ; i < nPts ; i++)
    {
        double pt[3];
        inPts->GetPoint(i, pt);
        if (dim & 1)
        {
            pt[0] = 2*xReflect - pt[0];
        }
        if (dim & 2)
        {
            pt[1] = 2*yReflect - pt[1];
        }
        if (dim & 4)
        {
            pt[2] = 2*zReflect - pt[2];
        }
        outPts->SetPoint(i, pt);

        gnp[i] = 0;
        if (doX && Equal(pt[0],xReflect))
            avtGhostData::AddGhostNodeType(gnp[i], DUPLICATED_NODE);
        if (doY && Equal(pt[1],yReflect))
            avtGhostData::AddGhostNodeType(gnp[i], DUPLICATED_NODE);
        if (doZ && Equal(pt[2],zReflect))
            avtGhostData::AddGhostNodeType(gnp[i], DUPLICATED_NODE);
    }

    out->SetPoints(outPts);
    outPts->Delete();
    out->GetPointData()->AddArray(gn);
    gn->Delete();

    return out;
}


// ****************************************************************************
//  Function: ReflectVectorData
//
//  Purpose:
//      Reflects the vector data.
//
//  Programmer: Hank Childs
//  Creation:   June 24, 2004
//
// ****************************************************************************

static void
ReflectVectorData(vtkDataSet *ds, int dim)
{
    if (dim == 0)
    {
        // No reflection.
        return;
    }

    int   i, j;

    // First identify which variables are vectors.  Point vectors only.
    std::vector<vtkDataArray *> pt_vectors;
    vtkPointData *pd = ds->GetPointData();
    for (i = 0 ; i < pd->GetNumberOfArrays() ; i++)
    {
        vtkDataArray *da = pd->GetArray(i);
        if (da->GetNumberOfComponents() == 3)
        {
            if (da->GetDataType() != VTK_FLOAT)
                continue;
            pt_vectors.push_back(da);
        }
    }
    
    // Now reverse the orientation of the vectors based on the axis of
    // reflection.  Point vectors only.
    std::vector<vtkDataArray *> new_pt_vectors;
    for (i = 0 ; i < pt_vectors.size() ; i++)
    {
        vtkDataArray *da = pt_vectors[i]->NewInstance();
        da->DeepCopy(pt_vectors[i]);
        da->SetName(pt_vectors[i]->GetName());
        const int ntups = da->GetNumberOfTuples();
        float *ptr = (float *) da->GetVoidPointer(0);
        for (j = 0 ; j < ntups ; j++)
        {
            if (dim & 1)
                *ptr *= -1.;
            ptr++;
            if (dim & 2)
                *ptr *= -1.;
            ptr++;
            if (dim & 4)
                *ptr *= -1.;
            ptr++;
        }
        new_pt_vectors.push_back(da);
    }

    // Now replace all of the original vectors with our new ones.
    for (i = 0 ; i < new_pt_vectors.size() ; i++)
    {
        bool isActiveVector = false;
        vtkDataArray *da = pd->GetVectors();
        if (da != NULL)
           if (strcmp(da->GetName(), new_pt_vectors[i]->GetName()) == 0)
               isActiveVector = true;
        pd->RemoveArray(new_pt_vectors[i]->GetName());
        if (isActiveVector)
            pd->SetVectors(new_pt_vectors[i]);
        else
            pd->AddArray(new_pt_vectors[i]);
        new_pt_vectors[i]->Delete();
    }

    // First identify which variables are vectors.  Now the cell vectors
    std::vector<vtkDataArray *> cell_vectors;
    vtkCellData *cd = ds->GetCellData();
    for (i = 0 ; i < cd->GetNumberOfArrays() ; i++)
    {
        vtkDataArray *da = cd->GetArray(i);
        if (da->GetNumberOfComponents() == 3)
        {
            if (da->GetDataType() != VTK_FLOAT)
                continue;
            cell_vectors.push_back(da);
        }
    }
    
    // Now reverse the orientation of the vectors based on the axis of
    // reflection.  Cell vectors only.
    std::vector<vtkDataArray *> new_cell_vectors;
    for (i = 0 ; i < cell_vectors.size() ; i++)
    {
        vtkDataArray *da = cell_vectors[i]->NewInstance();
        da->DeepCopy(cell_vectors[i]);
        da->SetName(cell_vectors[i]->GetName());
        const int ntups = da->GetNumberOfTuples();
        float *ptr = (float *) da->GetVoidPointer(0);
        for (j = 0 ; j < ntups ; j++)
        {
            if (dim & 1)
                *ptr *= -1.;
            ptr++;
            if (dim & 2)
                *ptr *= -1.;
            ptr++;
            if (dim & 4)
                *ptr *= -1.;
            ptr++;
        }
        new_cell_vectors.push_back(da);
    }

    // Now replace all of the original vectors with our new ones.
    for (i = 0 ; i < new_cell_vectors.size() ; i++)
    {
        bool isActiveVector = false;
        vtkDataArray *da = cd->GetVectors();
        if (da != NULL)
           if (strcmp(da->GetName(), new_cell_vectors[i]->GetName()) == 0)
               isActiveVector = true;
        cd->RemoveArray(new_cell_vectors[i]->GetName());
        if (isActiveVector)
            cd->SetVectors(new_cell_vectors[i]);
        else
            cd->AddArray(new_cell_vectors[i]);
        new_cell_vectors[i]->Delete();
    }
}


// ****************************************************************************
//  Method: avtReflectFilter::HasNeighbor
//
//  Purpose:
//      Determines if this reflected domain has a neighbor across each of the
//      three reflection planes.  If it does, then it will be internal to the
//      problem.  If not, it will still be external.
//
//  Programmer: Hank Childs
//  Creation:   August 11, 2004
//
// ****************************************************************************

void
avtReflectFilter::HasNeighbor(int octent, bool &doX, bool &doY, bool &doZ)
{
    const int *shouldreflect = atts.GetReflections();

    int xNeighbor = ((octent & 1) ? octent-1 : octent+1);
    doX = (shouldreflect[xNeighbor] != 0 ? true : false);

    int yNeighbor = ((octent & 2) ? octent-2 : octent+2);
    doY = (shouldreflect[yNeighbor] != 0 ? true : false);

    int zNeighbor = ((octent & 4) ? octent-4 : octent+4);
    doZ = (shouldreflect[zNeighbor] != 0 ? true : false);
}



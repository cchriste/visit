// ************************************************************************* //
//  File: avtReflectFilter.C
// ************************************************************************* //

#include <avtReflectFilter.h>

#include <float.h>

#include <vtkCellData.h>
#include <vtkPointData.h>
#include <vtkPointSet.h>
#include <vtkRectilinearGrid.h>

#include <avtDataTree.h>
#include <avtDatasetExaminer.h>
#include <avtExtents.h>

#include <DebugStream.h>
#include <ImproperUseException.h>

using   std::string;

static void ReflectVectorData(vtkDataSet *in_ds, int dim);


// ****************************************************************************
//  Method: avtReflectFilter constructor
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Thu Mar 7 10:35:24 PDT 2002
//
// ****************************************************************************

avtReflectFilter::avtReflectFilter()
{
    xReflect = 0.;
    yReflect = 0.;
    zReflect = 0.;
}


// ****************************************************************************
//  Method: avtReflectFilter destructor
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Thu Mar 7 10:35:24 PDT 2002
//
//  Modifications:
//
// ****************************************************************************

avtReflectFilter::~avtReflectFilter()
{
}


// ****************************************************************************
//  Method:  avtReflectFilter::Create
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Thu Mar 7 10:35:24 PDT 2002
//
// ****************************************************************************

avtFilter *
avtReflectFilter::Create()
{
    return new avtReflectFilter();
}


// ****************************************************************************
//  Method:      avtReflectFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Thu Mar 7 10:35:24 PDT 2002
//
// ****************************************************************************

void
avtReflectFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const ReflectAttributes*)a;
}


// ****************************************************************************
//  Method: avtReflectFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtReflectFilter with the given
//      parameters would result in an equivalent avtReflectFilter.
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Thu Mar 7 10:35:24 PDT 2002
//
// ****************************************************************************

bool
avtReflectFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(ReflectAttributes*)a);
}


// ****************************************************************************
//  Method: avtReflectFilter::PreExecute
//
//  Purpose:
//      Determines what lines/planes the data should be reflected across.  This
//      may be trivial (if they are all specified) or require some work (if
//      we are running in parallel).
//
//  Programmer: Hank Childs
//  Creation:   March 7, 2002
//
//  Modifications:
//
//    Jeremy Meredith, Mon Mar 11 15:41:55 PST 2002
//    Made octant 0 be +x+y+z.
//
//    Hank Childs, Mon Feb 24 17:19:42 PST 2003
//    Better checking of when we need to calculate extents in parallel.
//
//    Hank Childs, Wed Jun 25 09:30:59 PDT 2003
//    Fix stupid cut-n-paste bug.
//
// ****************************************************************************

void
avtReflectFilter::PreExecute(void)
{
    //
    // Calculating the extents may require parallel communication.  Only do
    // this if we are sure that we will need the extents.
    //
    double extents[6] = { -DBL_MAX, DBL_MAX, -DBL_MAX, DBL_MAX, 
                          -DBL_MAX, DBL_MAX };
    bool reflectX = false;
    bool reflectY = false;
    bool reflectZ = false;
    const int *shouldreflect = atts.GetReflections();
    for (int i = 0 ; i < 8 ; i++)
    {
        if (shouldreflect[i] != 0)
        {
            if (i & 1)
                reflectX = true;
            if (i & 2)
                reflectY = true;
            if (i & 4)
                reflectZ = true;
        }
    }
    bool needX = reflectX && atts.GetUseXBoundary();
    bool needY = reflectY && atts.GetUseYBoundary();
    bool needZ = reflectZ && atts.GetUseZBoundary();
    if (needX || needY || needZ)
    {
        GetSpatialExtents(extents);
    }

    if (atts.GetUseXBoundary())
    {
        //
        // If we are in an octant that is positive for X, then we want to
        // reflect along the minimum x-value.  Also, the octant number is set
        // up such that every other octant is positive for X.
        //
        int octant = atts.GetOctant();
        xReflect = (octant & 1 ? extents[1] : extents[0]);
    }
    else
    {
        xReflect = atts.GetSpecifiedX();
    }

    if (atts.GetUseYBoundary())
    {
        //
        // If we are in an octant that is positive for Y, then we want to
        // reflect along the minimum y-value.  Also, the octant number is set
        // up such that positive Y is paired off in twos.
        //
        int octant = atts.GetOctant();
        yReflect = (octant & 2 ? extents[3] : extents[2]);
    }
    else
    {
        yReflect = atts.GetSpecifiedY();
    }

    if (atts.GetUseZBoundary())
    {
        //
        // If we are in an octant that is positive for Y, then we want to
        // reflect along the minimum y-value.  Also, the octant number is set
        // up such that positive Z is the highest 4.
        //
        int octant = atts.GetOctant();
        zReflect = (octant & 4 ? extents[5] : extents[4]);
    }
    else
    {
        zReflect = atts.GetSpecifiedZ();
    }
}


// ****************************************************************************
//  Method: avtReflectFilter::PostExecute
//
//  Purpose:
//      Cleans up after the execution.  This manages extents.
//
//  Programmer: Hank Childs
//  Creation:   March 7, 2002
//
//  Modifications:
//
//    Hank Childs, Fri Mar 15 19:49:31 PST 2002
//    Account for dataset examiner.
//
//    Hank Childs, Thu Feb 26 16:19:33 PST 2004
//    Fix typo where data extents are being reset.
//
// ****************************************************************************

void
avtReflectFilter::PostExecute(void)
{
    avtDataAttributes &outAtts = GetOutput()->GetInfo().GetAttributes();
    outAtts.GetTrueSpatialExtents()->Clear();
    outAtts.GetEffectiveSpatialExtents()->Clear();
    outAtts.GetCurrentSpatialExtents()->Clear();

    double bounds[6];
    avtDataset_p ds = GetTypedOutput();
    avtDatasetExaminer::GetSpatialExtents(ds, bounds);
    outAtts.GetCumulativeTrueSpatialExtents()->Set(bounds);
}


// ****************************************************************************
//  Method: avtReflectFilter::PerformRestriction
//
//  Purpose:
//      Performs a restriction on the specification.  This is in place to
//      insure that we do static load balancing when extent calculation is
//      required.
//
//  Arguments:
//      spec    The current specification.
//
//  Returns:    A specification with the balancing potentially restricted.
//
//  Programmer: Hank Childs
//  Creation:   March 7, 2002
//
//  Modifications:
//    Kathleen Bonnell, Wed Jun 19 12:28:10 PDT 2002
//    Don't turn off Zone numbers if they have been turned on elsewhere in
//    the pipeline.
//
//    Kathleen Bonnell, Wed Jun 19 13:42:37 PDT 2002
//    Completely removed the code turning off zone numbers.  Why set a flag
//    to false if it is already false?  False is the default setting.
//
//    Kathleen Bonnell, Wed Jun  2 09:21:46 PDT 2004 
//    Turn on node numbers when required. 
//
// ****************************************************************************

avtPipelineSpecification_p
avtReflectFilter::PerformRestriction(avtPipelineSpecification_p spec)
{
    avtPipelineSpecification_p ns = new avtPipelineSpecification(spec);

    //
    // If we need to calculate the extents to reflect across, then we will have
    // to have all the domains together at the same time, so we have to use
    // static load balancing.
    //
    if (atts.GetUseXBoundary() || atts.GetUseYBoundary() ||
        atts.GetUseZBoundary())
    {
        ns->NoDynamicLoadBalancing();
    }

    if (spec->GetDataSpecification()->MayRequireZones())
    {
        ns->GetDataSpecification()->TurnZoneNumbersOn();
    }
    if (spec->GetDataSpecification()->MayRequireNodes())
    {
        ns->GetDataSpecification()->TurnNodeNumbersOn();
    }

    return ns;
}

// ****************************************************************************
//  Method: avtReflectFilter::RefashionDataObjectInfo
//
//  Purpose:
//     Specifies that this filter transforms the original dataset points. 
//
//  Programmer: Kathleen Bonnell 
//  Creation:   March 26, 2002 
//
//  Modifications:
//    Kathleen Bonnell, Mon Apr 14 09:57:39 PDT 2003
//    Set CanUseTransform to false.
//
//    Kathleen Bonnell, Wed Jun  2 09:21:46 PDT 2004 
//    Set CanUseInvTransform to false.
// 
// ****************************************************************************
 
void
avtReflectFilter::RefashionDataObjectInfo(void)
{
    GetOutput()->GetInfo().GetValidity().SetPointsWereTransformed(true);

    //
    // This filter invalidates any transform matrix in the pipeline.
    //
    GetOutput()->GetInfo().GetAttributes().SetCanUseInvTransform(false);
    GetOutput()->GetInfo().GetAttributes().SetCanUseTransform(false);
}


// ****************************************************************************
//  Method: avtReflectFilter::ExecuteData
//
//  Purpose:
//      Sends the specified input and output through the Reflect filter.
//
//  Arguments:
//      in_ds      The input dataset.
//      dom        The domain number.
//      str        An identifying string.
//
//  Returns:       The output dataset.
//
//  Programmer: childs -- generated by xml2info
//  Creation:   Thu Mar 7 10:35:24 PDT 2002
//
// ****************************************************************************

avtDataTree_p 
avtReflectFilter::ExecuteDataTree(vtkDataSet *in_ds, int dom, string str)
{
    int  i;

    if (in_ds == NULL)
    {
        return NULL;
    }

    //
    // Perform any of the 8 possible reflections.
    //
    const int *shouldreflect = atts.GetReflections();
    vtkDataSet *reflections[8];
    for (i = 0 ; i < 8 ; i++)
    {
        reflections[i] = NULL;
        if (shouldreflect[i] != 0)
        {
            reflections[i] = Reflect(in_ds, i);
        }
    }

    //
    // Construct a data tree out of our reflections.
    //
    avtDataTree_p rv = new avtDataTree(8, reflections, dom, str);

    //
    // Clean up memory.
    //
    for (i = 0 ; i < 8 ; i++)
    {
        if (reflections[i] != NULL)
        {
            reflections[i]->Delete();
        }
    }

    return rv;
}


// ****************************************************************************
//  Method: avtReflectFilter::Reflect
//
//  Purpose:
//      Determines what the mesh type is and calls the appropriate reflect
//      routine.
//
//  Arguments:
//      ds      The dataset to reflect.
//      dim     The dimension to reflect in.
//
//  Returns:    The dataset appropriately reflected.
//
//  Programmer: Hank Childs
//  Creation:   March 7, 2002
//
//  Modifications:
//
//    Hank Childs, Thu Jun 24 12:53:47 PDT 2004
//    Reflect vector data as well.
//
// ****************************************************************************

vtkDataSet *
avtReflectFilter::Reflect(vtkDataSet *ds, int dim)
{
    int dstype = ds->GetDataObjectType();
    vtkDataSet *rv = NULL;
    switch (dstype)
    {
      case VTK_RECTILINEAR_GRID:
        rv = ReflectRectilinear((vtkRectilinearGrid *) ds, dim);
        break;

      case VTK_STRUCTURED_GRID:
      case VTK_UNSTRUCTURED_GRID:
      case VTK_POLY_DATA:
        rv = ReflectPointSet((vtkPointSet *) ds, dim);
        break;

      default:
        debug1 << "Unknown data type for reflect filter = " << dstype << endl;
        break;
    }

    ReflectVectorData(rv, dim);

    return rv;
}


// ****************************************************************************
//  Method: avtReflectFilter::ReflectRectilinear
//
//  Purpose:
//      Reflects a rectilinear mesh.
//
//  Arguments:
//      ds      The dataset to reflect.
//      dim     The dimension to reflect in.
//
//  Returns:    The dataset reflected across val.
//
//  Programmer: Hank Childs
//  Creation:   March 7, 2002
//
//  Modifications:
//    Kathleen Bonnell, Fri Dec 13 16:41:12 PST 2002   
//    Use NewInstance instead of MakeObject in order to match vtk's new api. 
//    
// ****************************************************************************

vtkDataSet *
avtReflectFilter::ReflectRectilinear(vtkRectilinearGrid *ds, int dim)
{
    vtkRectilinearGrid *out = (vtkRectilinearGrid *) ds->NewInstance();
    out->ShallowCopy(ds);

    //
    // Reflect across X if appropriate.
    //
    if (dim & 1)
    {
        vtkDataArray *tmp = ReflectDataArray(out->GetXCoordinates(), xReflect);
        out->SetXCoordinates(tmp);
        tmp->Delete();
    }

    //
    // Reflect across Y if appropriate.
    //
    if (dim & 2)
    {
        vtkDataArray *tmp = ReflectDataArray(out->GetYCoordinates(), yReflect);
        out->SetYCoordinates(tmp);
        tmp->Delete();
    }

    //
    // Reflect across Z if appropriate.
    //
    if (dim & 4)
    {
        vtkDataArray *tmp = ReflectDataArray(out->GetZCoordinates(), zReflect);
        out->SetZCoordinates(tmp);
        tmp->Delete();
    }

    return out;
}


// ****************************************************************************
//  Method: avtReflectFilter::ReflectDataArray
//
//  Purpose:
//      Reflects a single data array across a line.  This is used as a
//      convenience function for reflecting rectilinear grids.
//
//  Arguments:
//      coords  The coordinates to reflect.
//      val     The point to reflect about.
//
//  Returns:    The coordinates reflected; this must be deleted by the calling
//              object.
//
//  Programmer: Hank Childs
//  Creation:   March 8, 2002
//
//  Modifications:
//    Kathleen Bonnell, Fri Dec 13 16:41:12 PST 2002   
//    Use NewInstance instead of MakeObject in order to match vtk's new api. 
//    
// ****************************************************************************

vtkDataArray *
avtReflectFilter::ReflectDataArray(vtkDataArray *coords, double val)
{
    //
    // Reflect the coordinates across the line of reflection.
    //
    vtkDataArray *newcoords = coords->NewInstance();
    int nc = coords->GetNumberOfTuples();
    newcoords->SetNumberOfTuples(nc);
    float *c = coords->GetTuple(0);
    float *n = newcoords->GetTuple(0);
    for (int i = 0 ; i < nc ; i++)
    {
        n[i] = 2*val - c[i];
    }

    return newcoords;
}


// ****************************************************************************
//  Method: avtReflectFilter::ReflectPointSet
//
//  Purpose:
//      Reflects a dataset that is derived from point set.
//
//  Arguments:
//      ds      The dataset to reflect.
//      dim     The dimension to reflect in.
//
//  Returns:    The dataset reflected across val.
//
//  Programmer: Hank Childs
//  Creation:   March 7, 2002
//
//  Modifications:
//    Kathleen Bonnell, Fri Dec 13 16:41:12 PST 2002   
//    Use NewInstance instead of MakeObject in order to match vtk's new api. 
//    
// ****************************************************************************

vtkDataSet *
avtReflectFilter::ReflectPointSet(vtkPointSet *ds, int dim)
{
    vtkPointSet *out = (vtkPointSet *) ds->NewInstance();
    out->ShallowCopy(ds);

    vtkPoints *inPts  = ds->GetPoints();
    vtkPoints *outPts = vtkPoints::New();
    int nPts = inPts->GetNumberOfPoints();
    outPts->SetNumberOfPoints(nPts);
    for (int i = 0 ; i < nPts ; i++)
    {
        float pt[3];
        inPts->GetPoint(i, pt);
        if (dim & 1)
        {
            pt[0] = 2*xReflect - pt[0];
        }
        if (dim & 2)
        {
            pt[1] = 2*yReflect - pt[1];
        }
        if (dim & 4)
        {
            pt[2] = 2*zReflect - pt[2];
        }
        outPts->SetPoint(i, pt);
    }

    out->SetPoints(outPts);
    outPts->Delete();

    return out;
}


// ****************************************************************************
//  Function: ReflectVectorData
//
//  Purpose:
//      Reflects the vector data.
//
//  Programmer: Hank Childs
//  Creation:   June 24, 2004
//
// ****************************************************************************

static void
ReflectVectorData(vtkDataSet *ds, int dim)
{
    if (dim == 0)
    {
        // No reflection.
        return;
    }

    int   i, j;

    // First identify which variables are vectors.  Point vectors only.
    std::vector<vtkDataArray *> pt_vectors;
    vtkPointData *pd = ds->GetPointData();
    for (i = 0 ; i < pd->GetNumberOfArrays() ; i++)
    {
        vtkDataArray *da = pd->GetArray(i);
        if (da->GetNumberOfComponents() == 3)
        {
            if (da->GetDataType() != VTK_FLOAT)
                continue;
            pt_vectors.push_back(da);
        }
    }
    
    // Now reverse the orientation of the vectors based on the axis of
    // reflection.  Point vectors only.
    std::vector<vtkDataArray *> new_pt_vectors;
    for (i = 0 ; i < pt_vectors.size() ; i++)
    {
        vtkDataArray *da = pt_vectors[i]->NewInstance();
        da->DeepCopy(pt_vectors[i]);
        da->SetName(pt_vectors[i]->GetName());
        const int ntups = da->GetNumberOfTuples();
        float *ptr = (float *) da->GetVoidPointer(0);
        for (j = 0 ; j < ntups ; j++)
        {
            if (dim & 1)
                *ptr *= -1.;
            ptr++;
            if (dim & 2)
                *ptr *= -1.;
            ptr++;
            if (dim & 4)
                *ptr *= -1.;
            ptr++;
        }
        new_pt_vectors.push_back(da);
    }

    // Now replace all of the original vectors with our new ones.
    for (i = 0 ; i < new_pt_vectors.size() ; i++)
    {
        bool isActiveVector = false;
        vtkDataArray *da = pd->GetVectors();
        if (da != NULL)
           if (strcmp(da->GetName(), new_pt_vectors[i]->GetName()) == 0)
               isActiveVector = true;
        pd->RemoveArray(new_pt_vectors[i]->GetName());
        if (isActiveVector)
            pd->SetVectors(new_pt_vectors[i]);
        else
            pd->AddArray(new_pt_vectors[i]);
        new_pt_vectors[i]->Delete();
    }

    // First identify which variables are vectors.  Now the cell vectors
    std::vector<vtkDataArray *> cell_vectors;
    vtkCellData *cd = ds->GetCellData();
    for (i = 0 ; i < cd->GetNumberOfArrays() ; i++)
    {
        vtkDataArray *da = cd->GetArray(i);
        if (da->GetNumberOfComponents() == 3)
        {
            if (da->GetDataType() != VTK_FLOAT)
                continue;
            cell_vectors.push_back(da);
        }
    }
    
    // Now reverse the orientation of the vectors based on the axis of
    // reflection.  Cell vectors only.
    std::vector<vtkDataArray *> new_cell_vectors;
    for (i = 0 ; i < cell_vectors.size() ; i++)
    {
        vtkDataArray *da = cell_vectors[i]->NewInstance();
        da->DeepCopy(cell_vectors[i]);
        da->SetName(cell_vectors[i]->GetName());
        const int ntups = da->GetNumberOfTuples();
        float *ptr = (float *) da->GetVoidPointer(0);
        for (j = 0 ; j < ntups ; j++)
        {
            if (dim & 1)
                *ptr *= -1.;
            ptr++;
            if (dim & 2)
                *ptr *= -1.;
            ptr++;
            if (dim & 4)
                *ptr *= -1.;
            ptr++;
        }
        new_cell_vectors.push_back(da);
    }

    // Now replace all of the original vectors with our new ones.
    for (i = 0 ; i < new_cell_vectors.size() ; i++)
    {
        bool isActiveVector = false;
        vtkDataArray *da = cd->GetVectors();
        if (da != NULL)
           if (strcmp(da->GetName(), new_cell_vectors[i]->GetName()) == 0)
               isActiveVector = true;
        cd->RemoveArray(new_cell_vectors[i]->GetName());
        if (isActiveVector)
            cd->SetVectors(new_cell_vectors[i]);
        else
            cd->AddArray(new_cell_vectors[i]);
        new_cell_vectors[i]->Delete();
    }
}



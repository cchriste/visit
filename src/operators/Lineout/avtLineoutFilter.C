// ************************************************************************* //
//  File: avtLineoutFilter.C
// ************************************************************************* //

#include <avtLineoutFilter.h>

#include <vtkDataSet.h>
#include <vtkLineoutFilter.h>
#include <vtkPolyData.h>
#include <avtDatasetExaminer.h>
#include <avtExtents.h>
#include <avtMetaData.h>
#include <avtIntervalTree.h>
#include <InvalidDimensionsException.h>
#include <DebugStream.h>


// ****************************************************************************
//  Method: avtLineoutFilter constructor
//
//  Programmer: kbonnell -- generated by xml2info
//  Creation:   Thu Apr 25 16:01:28 PST 2002
//
// ****************************************************************************

avtLineoutFilter::avtLineoutFilter()
{
    OverrideTrueSpatialExtents();
}


// ****************************************************************************
//  Method:  avtLineoutFilter::Create
//
//  Programmer: kbonnell -- generated by xml2info
//  Creation:   Thu Apr 25 16:01:28 PST 2002
//
// ****************************************************************************

avtFilter *
avtLineoutFilter::Create()
{
    return new avtLineoutFilter();
}


// ****************************************************************************
//  Method:      avtLineoutFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: kbonnell -- generated by xml2info
//  Creation:   Thu Apr 25 16:01:28 PST 2002
//
// ****************************************************************************

void
avtLineoutFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const LineoutAttributes*)a;
}


// ****************************************************************************
//  Method: avtLineoutFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtLineoutFilter with the given
//      parameters would result in an equivalent avtLineoutFilter.
//
//  Programmer: kbonnell -- generated by xml2info
//  Creation:   Thu Apr 25 16:01:28 PST 2002
//
// ****************************************************************************

bool
avtLineoutFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(LineoutAttributes*)a);
}


// ****************************************************************************
//  Method: avtLineoutFilter::ExecuteData
//
//  Purpose:
//      Sends the specified input and output through the Lineout filter.
//
//  Arguments:
//      in_ds      The input dataset.
//      <unused>   The domain number.
//      <unused>   The label.
//
//  Returns:       The output dataset.
//
//  Programmer: kbonnell -- generated by xml2info
//  Creation:   Thu Apr 25 16:01:28 PST 2002
//
//  Modifications:
//    Kathleen Bonnell, Fri Jul 12 17:28:31 PDT 2002 
//    No longer send YScale to vtkLineoutFilter, it is not needed.
//
//    Hank Childs, Tue Sep 10 16:46:57 PDT 2002
//    Re-work memory management.
//
//    Kathleen Bonnell, Tue Dec 23 10:18:06 PST 2003 
//    Set vtkLineoutFilter's UpdateGhostLevel, so that ghost levels can be 
//    ignored.  Ensure output has points.
//
// ****************************************************************************

vtkDataSet *
avtLineoutFilter::ExecuteData(vtkDataSet *in_ds, int domain, std::string)
{
    vtkLineoutFilter *filter = vtkLineoutFilter::New();
    double *dpt = atts.GetPoint1();

    float pt1[3] = {dpt[0], dpt[1], dpt[2]};
    dpt = atts.GetPoint2();
    float pt2[3] = {dpt[0], dpt[1], dpt[2]};

    filter->SetInput(in_ds);
    filter->SetPoint1(pt1);
    filter->SetPoint2(pt2);
    filter->SetNumberOfSamplePoints(atts.GetNumberOfSamplePoints());
    filter->GetOutput()->SetUpdateGhostLevel(0);
    vtkPolyData *outPolys = filter->GetOutput();
    outPolys->Update();

    vtkDataSet *rv = outPolys;
    if (outPolys->GetNumberOfCells() == 0 ||
        outPolys->GetNumberOfPoints() == 0)
    {
        debug5 << "vtkLineoutFilter returned empty DS for domain " 
               << domain << "." << endl;
        rv = NULL;
    }

    ManageMemory(rv);
    filter->Delete();

    return rv;
}


// ****************************************************************************
//  Method: avtLineoutFilter::RefashionDataObjectInfo
//
//  Purpose:
//      Allows the filter to change its output's data object information, which
//      is a description of the data object.
//
//  Programmer: Kathleen Bonnell 
//  Creation:   April 25, 202 
//
// ****************************************************************************

void
avtLineoutFilter::RefashionDataObjectInfo(void)
{
    GetOutput()->GetInfo().GetAttributes().SetTopologicalDimension(1);
    GetOutput()->GetInfo().GetValidity().InvalidateZones();
    GetOutput()->GetInfo().GetValidity().InvalidateSpatialMetaData();
}


// ****************************************************************************
//  Method: avtLineoutFilter::VerifyInput
//
//  Purpose:
//      Verifies that the input is 2D data, throws an exception if not.
//
//  Programmer: Kathleen Bonnell
//  Creation:   April 26, 2002
//
//  Modifications:
//    Kathleen Bonnell, Mon Dec 23 11:50:54 PST 2002  
//    Modified to test topological dimenions, so that lineouts of point-var
//    or lines data will be disallowed.  Lineouts of 3d now allowed.
//
// ****************************************************************************
 
void
avtLineoutFilter::VerifyInput(void)
{
    if  (GetInput()->GetInfo().GetAttributes().GetTopologicalDimension() < 2)
    {
        EXCEPTION2(InvalidDimensionsException, "Lineout", "2D or 3D");
    }
}




// ****************************************************************************
//  Method: avtLineoutFilter::PerformRestriction
//
//  Purpose:
//      Calculates the restriction on the meta-data and the line endpoints. 
//
//  Arguments:
//      spec    The current pipeline specification.
//
//  Returns:    The new specification.
//
//  Programmer: Kathleen Bonnell 
//  Creation:   December 19, 2003 
//
//  Modifications:
//
// ****************************************************************************


avtPipelineSpecification_p
avtLineoutFilter::PerformRestriction(avtPipelineSpecification_p spec)
{
    avtPipelineSpecification_p rv = new avtPipelineSpecification(spec);

    //
    // Get the interval tree.
    //
    avtIntervalTree *it = GetMetaData()->GetSpatialExtents();
    if (it == NULL)
    {
        return rv;
    }
    if (GetInput()->GetInfo().GetValidity().GetPointsWereTransformed())
    {
        return rv;
    }
    double *dpt = atts.GetPoint1();
    float pt1[3] = {dpt[0], dpt[1], dpt[2]};
    dpt = atts.GetPoint2();
    float pt2[3] = {dpt[0], dpt[1], dpt[2]};
    float rayDir[3] = {pt2[0]-pt1[0], pt2[1]-pt1[1], pt2[2]-pt1[2]};   

    vector<int> domains;
    it->GetDomainsList(pt1, rayDir, domains);
    rv->GetDataSpecification()->GetRestriction()->RestrictDomains(domains);

    return rv;
}


// ****************************************************************************
//  Method: avtLineoutFilter::PostExecute
//
//  Purpose:
//      Cleans up after the execution.  This manages extents.
//
//  Programmer: Kathleen Bonnell 
//  Creation:   January 14, 2004
//
//  Modifications:
//
// ****************************************************************************

void
avtLineoutFilter::PostExecute(void)
{
    avtDataAttributes &outAtts = GetOutput()->GetInfo().GetAttributes();
    outAtts.GetTrueSpatialExtents()->Clear();
    outAtts.GetEffectiveSpatialExtents()->Clear();

    double bounds[6];
    avtDataset_p ds = GetTypedOutput();
    avtDatasetExaminer::GetSpatialExtents(ds, bounds);
    outAtts.GetCumulativeTrueSpatialExtents()->Set(bounds);
}

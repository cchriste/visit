/*****************************************************************************
*
* Copyright (c) 2000 - 2006, The Regents of the University of California
* Produced at the Lawrence Livermore National Laboratory
* All rights reserved.
*
* This file is part of VisIt. For details, see http://www.llnl.gov/visit/. The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or materials provided with the distribution.
*  - Neither the name of the UC/LLNL nor  the names of its contributors may be
*    used to  endorse or  promote products derived from  this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED.  IN  NO  EVENT  SHALL  THE  REGENTS  OF  THE  UNIVERSITY OF
* CALIFORNIA, THE U.S.  DEPARTMENT  OF  ENERGY OR CONTRIBUTORS BE  LIABLE  FOR
* ANY  DIRECT,  INDIRECT,  INCIDENTAL,  SPECIAL,  EXEMPLARY,  OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

#include <PDFAttributes.h>
#include <DataNode.h>

//
// Enum conversion methods for PDFAttributes::Scaling
//

static const char *Scaling_strings[] = {
"Linear", "Log", "Skew"
};

std::string
PDFAttributes::Scaling_ToString(PDFAttributes::Scaling t)
{
    int index = int(t);
    if(index < 0 || index >= 3) index = 0;
    return Scaling_strings[index];
}

std::string
PDFAttributes::Scaling_ToString(int t)
{
    int index = (t < 0 || t >= 3) ? 0 : t;
    return Scaling_strings[index];
}

bool
PDFAttributes::Scaling_FromString(const std::string &s, PDFAttributes::Scaling &val)
{
    val = PDFAttributes::Linear;
    for(int i = 0; i < 3; ++i)
    {
        if(s == Scaling_strings[i])
        {
            val = (Scaling)i;
            return true;
        }
    }
    return false;
}

//
// Enum conversion methods for PDFAttributes::NumAxes
//

static const char *NumAxes_strings[] = {
"Two", "Three"};

std::string
PDFAttributes::NumAxes_ToString(PDFAttributes::NumAxes t)
{
    int index = int(t);
    if(index < 0 || index >= 2) index = 0;
    return NumAxes_strings[index];
}

std::string
PDFAttributes::NumAxes_ToString(int t)
{
    int index = (t < 0 || t >= 2) ? 0 : t;
    return NumAxes_strings[index];
}

bool
PDFAttributes::NumAxes_FromString(const std::string &s, PDFAttributes::NumAxes &val)
{
    val = PDFAttributes::Two;
    for(int i = 0; i < 2; ++i)
    {
        if(s == NumAxes_strings[i])
        {
            val = (NumAxes)i;
            return true;
        }
    }
    return false;
}

//
// Enum conversion methods for PDFAttributes::DensityType
//

static const char *DensityType_strings[] = {
"Probability", "ZoneCount"};

std::string
PDFAttributes::DensityType_ToString(PDFAttributes::DensityType t)
{
    int index = int(t);
    if(index < 0 || index >= 2) index = 0;
    return DensityType_strings[index];
}

std::string
PDFAttributes::DensityType_ToString(int t)
{
    int index = (t < 0 || t >= 2) ? 0 : t;
    return DensityType_strings[index];
}

bool
PDFAttributes::DensityType_FromString(const std::string &s, PDFAttributes::DensityType &val)
{
    val = PDFAttributes::Probability;
    for(int i = 0; i < 2; ++i)
    {
        if(s == DensityType_strings[i])
        {
            val = (DensityType)i;
            return true;
        }
    }
    return false;
}

// ****************************************************************************
// Method: PDFAttributes::PDFAttributes
//
// Purpose: 
//   Constructor for the PDFAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Mon Nov 21 08:16:57 PDT 2005
//
// Modifications:
//   
// ****************************************************************************

PDFAttributes::PDFAttributes() : AttributeSubject("sbbddidisbbddidiisbbddidibi")
{
    var1 = "default";
    var1MinFlag = false;
    var1MaxFlag = false;
    var1Min = 0;
    var1Max = 1;
    var1Scaling = Linear;
    var1SkewFactor = 1;
    var1NumSamples = 100;
    var2 = "default";
    var2MinFlag = false;
    var2MaxFlag = false;
    var2Min = 0;
    var2Max = 1;
    var2Scaling = Linear;
    var2SkewFactor = 1;
    var2NumSamples = 100;
    numAxes = Two;
    var3 = "default";
    var3MinFlag = false;
    var3MaxFlag = false;
    var3Min = 0;
    var3Max = 1;
    var3Scaling = Linear;
    var3SkewFactor = 1;
    var3NumSamples = 100;
    scaleCube = true;
    densityType = Probability;
}

// ****************************************************************************
// Method: PDFAttributes::PDFAttributes
//
// Purpose: 
//   Copy constructor for the PDFAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Mon Nov 21 08:16:57 PDT 2005
//
// Modifications:
//   
// ****************************************************************************

PDFAttributes::PDFAttributes(const PDFAttributes &obj) : AttributeSubject("sbbddidisbbddidiisbbddidibi")
{
    var1 = obj.var1;
    var1MinFlag = obj.var1MinFlag;
    var1MaxFlag = obj.var1MaxFlag;
    var1Min = obj.var1Min;
    var1Max = obj.var1Max;
    var1Scaling = obj.var1Scaling;
    var1SkewFactor = obj.var1SkewFactor;
    var1NumSamples = obj.var1NumSamples;
    var2 = obj.var2;
    var2MinFlag = obj.var2MinFlag;
    var2MaxFlag = obj.var2MaxFlag;
    var2Min = obj.var2Min;
    var2Max = obj.var2Max;
    var2Scaling = obj.var2Scaling;
    var2SkewFactor = obj.var2SkewFactor;
    var2NumSamples = obj.var2NumSamples;
    numAxes = obj.numAxes;
    var3 = obj.var3;
    var3MinFlag = obj.var3MinFlag;
    var3MaxFlag = obj.var3MaxFlag;
    var3Min = obj.var3Min;
    var3Max = obj.var3Max;
    var3Scaling = obj.var3Scaling;
    var3SkewFactor = obj.var3SkewFactor;
    var3NumSamples = obj.var3NumSamples;
    scaleCube = obj.scaleCube;
    densityType = obj.densityType;

    SelectAll();
}

// ****************************************************************************
// Method: PDFAttributes::~PDFAttributes
//
// Purpose: 
//   Destructor for the PDFAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Mon Nov 21 08:16:57 PDT 2005
//
// Modifications:
//   
// ****************************************************************************

PDFAttributes::~PDFAttributes()
{
    // nothing here
}

// ****************************************************************************
// Method: PDFAttributes::operator = 
//
// Purpose: 
//   Assignment operator for the PDFAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Mon Nov 21 08:16:57 PDT 2005
//
// Modifications:
//   
// ****************************************************************************

PDFAttributes& 
PDFAttributes::operator = (const PDFAttributes &obj)
{
    if (this == &obj) return *this;
    var1 = obj.var1;
    var1MinFlag = obj.var1MinFlag;
    var1MaxFlag = obj.var1MaxFlag;
    var1Min = obj.var1Min;
    var1Max = obj.var1Max;
    var1Scaling = obj.var1Scaling;
    var1SkewFactor = obj.var1SkewFactor;
    var1NumSamples = obj.var1NumSamples;
    var2 = obj.var2;
    var2MinFlag = obj.var2MinFlag;
    var2MaxFlag = obj.var2MaxFlag;
    var2Min = obj.var2Min;
    var2Max = obj.var2Max;
    var2Scaling = obj.var2Scaling;
    var2SkewFactor = obj.var2SkewFactor;
    var2NumSamples = obj.var2NumSamples;
    numAxes = obj.numAxes;
    var3 = obj.var3;
    var3MinFlag = obj.var3MinFlag;
    var3MaxFlag = obj.var3MaxFlag;
    var3Min = obj.var3Min;
    var3Max = obj.var3Max;
    var3Scaling = obj.var3Scaling;
    var3SkewFactor = obj.var3SkewFactor;
    var3NumSamples = obj.var3NumSamples;
    scaleCube = obj.scaleCube;
    densityType = obj.densityType;

    SelectAll();
    return *this;
}

// ****************************************************************************
// Method: PDFAttributes::operator == 
//
// Purpose: 
//   Comparison operator == for the PDFAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Mon Nov 21 08:16:57 PDT 2005
//
// Modifications:
//   
// ****************************************************************************

bool
PDFAttributes::operator == (const PDFAttributes &obj) const
{
    // Create the return value
    return ((var1 == obj.var1) &&
            (var1MinFlag == obj.var1MinFlag) &&
            (var1MaxFlag == obj.var1MaxFlag) &&
            (var1Min == obj.var1Min) &&
            (var1Max == obj.var1Max) &&
            (var1Scaling == obj.var1Scaling) &&
            (var1SkewFactor == obj.var1SkewFactor) &&
            (var1NumSamples == obj.var1NumSamples) &&
            (var2 == obj.var2) &&
            (var2MinFlag == obj.var2MinFlag) &&
            (var2MaxFlag == obj.var2MaxFlag) &&
            (var2Min == obj.var2Min) &&
            (var2Max == obj.var2Max) &&
            (var2Scaling == obj.var2Scaling) &&
            (var2SkewFactor == obj.var2SkewFactor) &&
            (var2NumSamples == obj.var2NumSamples) &&
            (numAxes == obj.numAxes) &&
            (var3 == obj.var3) &&
            (var3MinFlag == obj.var3MinFlag) &&
            (var3MaxFlag == obj.var3MaxFlag) &&
            (var3Min == obj.var3Min) &&
            (var3Max == obj.var3Max) &&
            (var3Scaling == obj.var3Scaling) &&
            (var3SkewFactor == obj.var3SkewFactor) &&
            (var3NumSamples == obj.var3NumSamples) &&
            (scaleCube == obj.scaleCube) &&
            (densityType == obj.densityType));
}

// ****************************************************************************
// Method: PDFAttributes::operator != 
//
// Purpose: 
//   Comparison operator != for the PDFAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Mon Nov 21 08:16:57 PDT 2005
//
// Modifications:
//   
// ****************************************************************************

bool
PDFAttributes::operator != (const PDFAttributes &obj) const
{
    return !(this->operator == (obj));
}

// ****************************************************************************
// Method: PDFAttributes::TypeName
//
// Purpose: 
//   Type name method for the PDFAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Mon Nov 21 08:16:57 PDT 2005
//
// Modifications:
//   
// ****************************************************************************

const std::string
PDFAttributes::TypeName() const
{
    return "PDFAttributes";
}

// ****************************************************************************
// Method: PDFAttributes::CopyAttributes
//
// Purpose: 
//   CopyAttributes method for the PDFAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Mon Nov 21 08:16:57 PDT 2005
//
// Modifications:
//   
// ****************************************************************************

bool
PDFAttributes::CopyAttributes(const AttributeGroup *atts)
{
    if(TypeName() != atts->TypeName())
        return false;

    // Call assignment operator.
    const PDFAttributes *tmp = (const PDFAttributes *)atts;
    *this = *tmp;

    return true;
}

// ****************************************************************************
// Method: PDFAttributes::CreateCompatible
//
// Purpose: 
//   CreateCompatible method for the PDFAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Mon Nov 21 08:16:57 PDT 2005
//
// Modifications:
//   
// ****************************************************************************

AttributeSubject *
PDFAttributes::CreateCompatible(const std::string &tname) const
{
    AttributeSubject *retval = 0;
    if(TypeName() == tname)
        retval = new PDFAttributes(*this);
    // Other cases could go here too. 

    return retval;
}

// ****************************************************************************
// Method: PDFAttributes::NewInstance
//
// Purpose: 
//   NewInstance method for the PDFAttributes class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Mon Nov 21 08:16:57 PDT 2005
//
// Modifications:
//   
// ****************************************************************************

AttributeSubject *
PDFAttributes::NewInstance(bool copy) const
{
    AttributeSubject *retval = 0;
    if(copy)
        retval = new PDFAttributes(*this);
    else
        retval = new PDFAttributes;

    return retval;
}

// ****************************************************************************
// Method: PDFAttributes::SelectAll
//
// Purpose: 
//   Selects all attributes.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Mon Nov 21 08:16:57 PDT 2005
//
// Modifications:
//   
// ****************************************************************************

void
PDFAttributes::SelectAll()
{
    Select(0, (void *)&var1);
    Select(1, (void *)&var1MinFlag);
    Select(2, (void *)&var1MaxFlag);
    Select(3, (void *)&var1Min);
    Select(4, (void *)&var1Max);
    Select(5, (void *)&var1Scaling);
    Select(6, (void *)&var1SkewFactor);
    Select(7, (void *)&var1NumSamples);
    Select(8, (void *)&var2);
    Select(9, (void *)&var2MinFlag);
    Select(10, (void *)&var2MaxFlag);
    Select(11, (void *)&var2Min);
    Select(12, (void *)&var2Max);
    Select(13, (void *)&var2Scaling);
    Select(14, (void *)&var2SkewFactor);
    Select(15, (void *)&var2NumSamples);
    Select(16, (void *)&numAxes);
    Select(17, (void *)&var3);
    Select(18, (void *)&var3MinFlag);
    Select(19, (void *)&var3MaxFlag);
    Select(20, (void *)&var3Min);
    Select(21, (void *)&var3Max);
    Select(22, (void *)&var3Scaling);
    Select(23, (void *)&var3SkewFactor);
    Select(24, (void *)&var3NumSamples);
    Select(25, (void *)&scaleCube);
    Select(26, (void *)&densityType);
}

///////////////////////////////////////////////////////////////////////////////
// Persistence methods
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: PDFAttributes::CreateNode
//
// Purpose: 
//   This method creates a DataNode representation of the object so it can be saved to a config file.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Mon Nov 21 08:16:57 PDT 2005
//
// Modifications:
//   
// ****************************************************************************

bool
PDFAttributes::CreateNode(DataNode *parentNode, bool completeSave, bool forceAdd)
{
    if(parentNode == 0)
        return false;

    PDFAttributes defaultObject;
    bool addToParent = false;
    // Create a node for PDFAttributes.
    DataNode *node = new DataNode("PDFAttributes");

    if(completeSave || !FieldsEqual(0, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var1", var1));
    }

    if(completeSave || !FieldsEqual(1, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var1MinFlag", var1MinFlag));
    }

    if(completeSave || !FieldsEqual(2, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var1MaxFlag", var1MaxFlag));
    }

    if(completeSave || !FieldsEqual(3, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var1Min", var1Min));
    }

    if(completeSave || !FieldsEqual(4, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var1Max", var1Max));
    }

    if(completeSave || !FieldsEqual(5, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var1Scaling", Scaling_ToString(var1Scaling)));
    }

    if(completeSave || !FieldsEqual(6, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var1SkewFactor", var1SkewFactor));
    }

    if(completeSave || !FieldsEqual(7, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var1NumSamples", var1NumSamples));
    }

    if(completeSave || !FieldsEqual(8, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var2", var2));
    }

    if(completeSave || !FieldsEqual(9, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var2MinFlag", var2MinFlag));
    }

    if(completeSave || !FieldsEqual(10, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var2MaxFlag", var2MaxFlag));
    }

    if(completeSave || !FieldsEqual(11, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var2Min", var2Min));
    }

    if(completeSave || !FieldsEqual(12, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var2Max", var2Max));
    }

    if(completeSave || !FieldsEqual(13, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var2Scaling", Scaling_ToString(var2Scaling)));
    }

    if(completeSave || !FieldsEqual(14, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var2SkewFactor", var2SkewFactor));
    }

    if(completeSave || !FieldsEqual(15, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var2NumSamples", var2NumSamples));
    }

    if(completeSave || !FieldsEqual(16, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("numAxes", NumAxes_ToString(numAxes)));
    }

    if(completeSave || !FieldsEqual(17, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var3", var3));
    }

    if(completeSave || !FieldsEqual(18, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var3MinFlag", var3MinFlag));
    }

    if(completeSave || !FieldsEqual(19, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var3MaxFlag", var3MaxFlag));
    }

    if(completeSave || !FieldsEqual(20, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var3Min", var3Min));
    }

    if(completeSave || !FieldsEqual(21, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var3Max", var3Max));
    }

    if(completeSave || !FieldsEqual(22, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var3Scaling", Scaling_ToString(var3Scaling)));
    }

    if(completeSave || !FieldsEqual(23, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var3SkewFactor", var3SkewFactor));
    }

    if(completeSave || !FieldsEqual(24, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("var3NumSamples", var3NumSamples));
    }

    if(completeSave || !FieldsEqual(25, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("scaleCube", scaleCube));
    }

    if(completeSave || !FieldsEqual(26, &defaultObject))
    {
        addToParent = true;
        node->AddNode(new DataNode("densityType", DensityType_ToString(densityType)));
    }


    // Add the node to the parent node.
    if(addToParent || forceAdd)
        parentNode->AddNode(node);
    else
        delete node;

    return (addToParent || forceAdd);
}

// ****************************************************************************
// Method: PDFAttributes::SetFromNode
//
// Purpose: 
//   This method sets attributes in this object from values in a DataNode representation of the object.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Mon Nov 21 08:16:57 PDT 2005
//
// Modifications:
//   
// ****************************************************************************

void
PDFAttributes::SetFromNode(DataNode *parentNode)
{
    int i;
    if(parentNode == 0)
        return;

    DataNode *searchNode = parentNode->GetNode("PDFAttributes");
    if(searchNode == 0)
        return;

    DataNode *node;
    if((node = searchNode->GetNode("var1")) != 0)
        SetVar1(node->AsString());
    if((node = searchNode->GetNode("var1MinFlag")) != 0)
        SetVar1MinFlag(node->AsBool());
    if((node = searchNode->GetNode("var1MaxFlag")) != 0)
        SetVar1MaxFlag(node->AsBool());
    if((node = searchNode->GetNode("var1Min")) != 0)
        SetVar1Min(node->AsDouble());
    if((node = searchNode->GetNode("var1Max")) != 0)
        SetVar1Max(node->AsDouble());
    if((node = searchNode->GetNode("var1Scaling")) != 0)
    {
        // Allow enums to be int or string in the config file
        if(node->GetNodeType() == INT_NODE)
        {
            int ival = node->AsInt();
            if(ival >= 0 && ival < 3)
                SetVar1Scaling(Scaling(ival));
        }
        else if(node->GetNodeType() == STRING_NODE)
        {
            Scaling value;
            if(Scaling_FromString(node->AsString(), value))
                SetVar1Scaling(value);
        }
    }
    if((node = searchNode->GetNode("var1SkewFactor")) != 0)
        SetVar1SkewFactor(node->AsDouble());
    if((node = searchNode->GetNode("var1NumSamples")) != 0)
        SetVar1NumSamples(node->AsInt());
    if((node = searchNode->GetNode("var2")) != 0)
        SetVar2(node->AsString());
    if((node = searchNode->GetNode("var2MinFlag")) != 0)
        SetVar2MinFlag(node->AsBool());
    if((node = searchNode->GetNode("var2MaxFlag")) != 0)
        SetVar2MaxFlag(node->AsBool());
    if((node = searchNode->GetNode("var2Min")) != 0)
        SetVar2Min(node->AsDouble());
    if((node = searchNode->GetNode("var2Max")) != 0)
        SetVar2Max(node->AsDouble());
    if((node = searchNode->GetNode("var2Scaling")) != 0)
    {
        // Allow enums to be int or string in the config file
        if(node->GetNodeType() == INT_NODE)
        {
            int ival = node->AsInt();
            if(ival >= 0 && ival < 3)
                SetVar2Scaling(Scaling(ival));
        }
        else if(node->GetNodeType() == STRING_NODE)
        {
            Scaling value;
            if(Scaling_FromString(node->AsString(), value))
                SetVar2Scaling(value);
        }
    }
    if((node = searchNode->GetNode("var2SkewFactor")) != 0)
        SetVar2SkewFactor(node->AsDouble());
    if((node = searchNode->GetNode("var2NumSamples")) != 0)
        SetVar2NumSamples(node->AsInt());
    if((node = searchNode->GetNode("numAxes")) != 0)
    {
        // Allow enums to be int or string in the config file
        if(node->GetNodeType() == INT_NODE)
        {
            int ival = node->AsInt();
            if(ival >= 0 && ival < 2)
                SetNumAxes(NumAxes(ival));
        }
        else if(node->GetNodeType() == STRING_NODE)
        {
            NumAxes value;
            if(NumAxes_FromString(node->AsString(), value))
                SetNumAxes(value);
        }
    }
    if((node = searchNode->GetNode("var3")) != 0)
        SetVar3(node->AsString());
    if((node = searchNode->GetNode("var3MinFlag")) != 0)
        SetVar3MinFlag(node->AsBool());
    if((node = searchNode->GetNode("var3MaxFlag")) != 0)
        SetVar3MaxFlag(node->AsBool());
    if((node = searchNode->GetNode("var3Min")) != 0)
        SetVar3Min(node->AsDouble());
    if((node = searchNode->GetNode("var3Max")) != 0)
        SetVar3Max(node->AsDouble());
    if((node = searchNode->GetNode("var3Scaling")) != 0)
    {
        // Allow enums to be int or string in the config file
        if(node->GetNodeType() == INT_NODE)
        {
            int ival = node->AsInt();
            if(ival >= 0 && ival < 3)
                SetVar3Scaling(Scaling(ival));
        }
        else if(node->GetNodeType() == STRING_NODE)
        {
            Scaling value;
            if(Scaling_FromString(node->AsString(), value))
                SetVar3Scaling(value);
        }
    }
    if((node = searchNode->GetNode("var3SkewFactor")) != 0)
        SetVar3SkewFactor(node->AsDouble());
    if((node = searchNode->GetNode("var3NumSamples")) != 0)
        SetVar3NumSamples(node->AsInt());
    if((node = searchNode->GetNode("scaleCube")) != 0)
        SetScaleCube(node->AsBool());
    if((node = searchNode->GetNode("densityType")) != 0)
    {
        // Allow enums to be int or string in the config file
        if(node->GetNodeType() == INT_NODE)
        {
            int ival = node->AsInt();
            if(ival >= 0 && ival < 2)
                SetDensityType(DensityType(ival));
        }
        else if(node->GetNodeType() == STRING_NODE)
        {
            DensityType value;
            if(DensityType_FromString(node->AsString(), value))
                SetDensityType(value);
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// Set property methods
///////////////////////////////////////////////////////////////////////////////

void
PDFAttributes::SetVar1(const std::string &var1_)
{
    var1 = var1_;
    Select(0, (void *)&var1);
}

void
PDFAttributes::SetVar1MinFlag(bool var1MinFlag_)
{
    var1MinFlag = var1MinFlag_;
    Select(1, (void *)&var1MinFlag);
}

void
PDFAttributes::SetVar1MaxFlag(bool var1MaxFlag_)
{
    var1MaxFlag = var1MaxFlag_;
    Select(2, (void *)&var1MaxFlag);
}

void
PDFAttributes::SetVar1Min(double var1Min_)
{
    var1Min = var1Min_;
    Select(3, (void *)&var1Min);
}

void
PDFAttributes::SetVar1Max(double var1Max_)
{
    var1Max = var1Max_;
    Select(4, (void *)&var1Max);
}

void
PDFAttributes::SetVar1Scaling(PDFAttributes::Scaling var1Scaling_)
{
    var1Scaling = var1Scaling_;
    Select(5, (void *)&var1Scaling);
}

void
PDFAttributes::SetVar1SkewFactor(double var1SkewFactor_)
{
    var1SkewFactor = var1SkewFactor_;
    Select(6, (void *)&var1SkewFactor);
}

void
PDFAttributes::SetVar1NumSamples(int var1NumSamples_)
{
    var1NumSamples = var1NumSamples_;
    Select(7, (void *)&var1NumSamples);
}

void
PDFAttributes::SetVar2(const std::string &var2_)
{
    var2 = var2_;
    Select(8, (void *)&var2);
}

void
PDFAttributes::SetVar2MinFlag(bool var2MinFlag_)
{
    var2MinFlag = var2MinFlag_;
    Select(9, (void *)&var2MinFlag);
}

void
PDFAttributes::SetVar2MaxFlag(bool var2MaxFlag_)
{
    var2MaxFlag = var2MaxFlag_;
    Select(10, (void *)&var2MaxFlag);
}

void
PDFAttributes::SetVar2Min(double var2Min_)
{
    var2Min = var2Min_;
    Select(11, (void *)&var2Min);
}

void
PDFAttributes::SetVar2Max(double var2Max_)
{
    var2Max = var2Max_;
    Select(12, (void *)&var2Max);
}

void
PDFAttributes::SetVar2Scaling(PDFAttributes::Scaling var2Scaling_)
{
    var2Scaling = var2Scaling_;
    Select(13, (void *)&var2Scaling);
}

void
PDFAttributes::SetVar2SkewFactor(double var2SkewFactor_)
{
    var2SkewFactor = var2SkewFactor_;
    Select(14, (void *)&var2SkewFactor);
}

void
PDFAttributes::SetVar2NumSamples(int var2NumSamples_)
{
    var2NumSamples = var2NumSamples_;
    Select(15, (void *)&var2NumSamples);
}

void
PDFAttributes::SetNumAxes(PDFAttributes::NumAxes numAxes_)
{
    numAxes = numAxes_;
    Select(16, (void *)&numAxes);
}

void
PDFAttributes::SetVar3(const std::string &var3_)
{
    var3 = var3_;
    Select(17, (void *)&var3);
}

void
PDFAttributes::SetVar3MinFlag(bool var3MinFlag_)
{
    var3MinFlag = var3MinFlag_;
    Select(18, (void *)&var3MinFlag);
}

void
PDFAttributes::SetVar3MaxFlag(bool var3MaxFlag_)
{
    var3MaxFlag = var3MaxFlag_;
    Select(19, (void *)&var3MaxFlag);
}

void
PDFAttributes::SetVar3Min(double var3Min_)
{
    var3Min = var3Min_;
    Select(20, (void *)&var3Min);
}

void
PDFAttributes::SetVar3Max(double var3Max_)
{
    var3Max = var3Max_;
    Select(21, (void *)&var3Max);
}

void
PDFAttributes::SetVar3Scaling(PDFAttributes::Scaling var3Scaling_)
{
    var3Scaling = var3Scaling_;
    Select(22, (void *)&var3Scaling);
}

void
PDFAttributes::SetVar3SkewFactor(double var3SkewFactor_)
{
    var3SkewFactor = var3SkewFactor_;
    Select(23, (void *)&var3SkewFactor);
}

void
PDFAttributes::SetVar3NumSamples(int var3NumSamples_)
{
    var3NumSamples = var3NumSamples_;
    Select(24, (void *)&var3NumSamples);
}

void
PDFAttributes::SetScaleCube(bool scaleCube_)
{
    scaleCube = scaleCube_;
    Select(25, (void *)&scaleCube);
}

void
PDFAttributes::SetDensityType(PDFAttributes::DensityType densityType_)
{
    densityType = densityType_;
    Select(26, (void *)&densityType);
}

///////////////////////////////////////////////////////////////////////////////
// Get property methods
///////////////////////////////////////////////////////////////////////////////

const std::string &
PDFAttributes::GetVar1() const
{
    return var1;
}

std::string &
PDFAttributes::GetVar1()
{
    return var1;
}

bool
PDFAttributes::GetVar1MinFlag() const
{
    return var1MinFlag;
}

bool
PDFAttributes::GetVar1MaxFlag() const
{
    return var1MaxFlag;
}

double
PDFAttributes::GetVar1Min() const
{
    return var1Min;
}

double
PDFAttributes::GetVar1Max() const
{
    return var1Max;
}

PDFAttributes::Scaling
PDFAttributes::GetVar1Scaling() const
{
    return Scaling(var1Scaling);
}

double
PDFAttributes::GetVar1SkewFactor() const
{
    return var1SkewFactor;
}

int
PDFAttributes::GetVar1NumSamples() const
{
    return var1NumSamples;
}

const std::string &
PDFAttributes::GetVar2() const
{
    return var2;
}

std::string &
PDFAttributes::GetVar2()
{
    return var2;
}

bool
PDFAttributes::GetVar2MinFlag() const
{
    return var2MinFlag;
}

bool
PDFAttributes::GetVar2MaxFlag() const
{
    return var2MaxFlag;
}

double
PDFAttributes::GetVar2Min() const
{
    return var2Min;
}

double
PDFAttributes::GetVar2Max() const
{
    return var2Max;
}

PDFAttributes::Scaling
PDFAttributes::GetVar2Scaling() const
{
    return Scaling(var2Scaling);
}

double
PDFAttributes::GetVar2SkewFactor() const
{
    return var2SkewFactor;
}

int
PDFAttributes::GetVar2NumSamples() const
{
    return var2NumSamples;
}

PDFAttributes::NumAxes
PDFAttributes::GetNumAxes() const
{
    return NumAxes(numAxes);
}

const std::string &
PDFAttributes::GetVar3() const
{
    return var3;
}

std::string &
PDFAttributes::GetVar3()
{
    return var3;
}

bool
PDFAttributes::GetVar3MinFlag() const
{
    return var3MinFlag;
}

bool
PDFAttributes::GetVar3MaxFlag() const
{
    return var3MaxFlag;
}

double
PDFAttributes::GetVar3Min() const
{
    return var3Min;
}

double
PDFAttributes::GetVar3Max() const
{
    return var3Max;
}

PDFAttributes::Scaling
PDFAttributes::GetVar3Scaling() const
{
    return Scaling(var3Scaling);
}

double
PDFAttributes::GetVar3SkewFactor() const
{
    return var3SkewFactor;
}

int
PDFAttributes::GetVar3NumSamples() const
{
    return var3NumSamples;
}

bool
PDFAttributes::GetScaleCube() const
{
    return scaleCube;
}

PDFAttributes::DensityType
PDFAttributes::GetDensityType() const
{
    return DensityType(densityType);
}

///////////////////////////////////////////////////////////////////////////////
// Select property methods
///////////////////////////////////////////////////////////////////////////////

void
PDFAttributes::SelectVar1()
{
    Select(0, (void *)&var1);
}

void
PDFAttributes::SelectVar2()
{
    Select(8, (void *)&var2);
}

void
PDFAttributes::SelectVar3()
{
    Select(17, (void *)&var3);
}

///////////////////////////////////////////////////////////////////////////////
// Keyframing methods
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: PDFAttributes::GetFieldName
//
// Purpose: 
//   This method returns the name of a field given its index.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Mon Nov 21 08:16:57 PDT 2005
//
// Modifications:
//   
// ****************************************************************************

std::string
PDFAttributes::GetFieldName(int index) const
{
    switch (index)
    {
        case 0:  return "var1";
        case 1:  return "Use variable 1 min";
        case 2:  return "Use variable 1 max";
        case 3:  return "Variable 1 Min";
        case 4:  return "Variable 1 Max";
        case 5:  return "Variable 1 scale";
        case 6:  return "Variable 1 skew factor";
        case 7:  return "Number of samples for variable 1?";
        case 8:  return "Variable 2";
        case 9:  return "Use variable 2 min";
        case 10:  return "Use variable 2 max";
        case 11:  return "Variable 2 Min";
        case 12:  return "Variable 2 Max";
        case 13:  return "Variable 2 scale";
        case 14:  return "Variable 2 skew factor";
        case 15:  return "Number of samples for variable 2?";
        case 16:  return "Number of variables";
        case 17:  return "Variable 3";
        case 18:  return "Use variable 3 min";
        case 19:  return "Use variable 3 max";
        case 20:  return "Variable 3 Min";
        case 21:  return "Variable 3 Max";
        case 22:  return "Variable 3 scale";
        case 23:  return "Variable 3 skew factor";
        case 24:  return "Number of samples for variable 3?";
        case 25:  return "Scale to cube";
        case 26:  return "Density Type";
        default:  return "invalid index";
    }
}

// ****************************************************************************
// Method: PDFAttributes::GetFieldType
//
// Purpose: 
//   This method returns the type of a field given its index.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Mon Nov 21 08:16:57 PDT 2005
//
// Modifications:
//   
// ****************************************************************************

AttributeGroup::FieldType
PDFAttributes::GetFieldType(int index) const
{
    switch (index)
    {
        case 0:  return FieldType_string;
        case 1:  return FieldType_bool;
        case 2:  return FieldType_bool;
        case 3:  return FieldType_double;
        case 4:  return FieldType_double;
        case 5:  return FieldType_enum;
        case 6:  return FieldType_double;
        case 7:  return FieldType_int;
        case 8:  return FieldType_string;
        case 9:  return FieldType_bool;
        case 10:  return FieldType_bool;
        case 11:  return FieldType_double;
        case 12:  return FieldType_double;
        case 13:  return FieldType_enum;
        case 14:  return FieldType_double;
        case 15:  return FieldType_int;
        case 16:  return FieldType_enum;
        case 17:  return FieldType_string;
        case 18:  return FieldType_bool;
        case 19:  return FieldType_bool;
        case 20:  return FieldType_double;
        case 21:  return FieldType_double;
        case 22:  return FieldType_enum;
        case 23:  return FieldType_double;
        case 24:  return FieldType_int;
        case 25:  return FieldType_bool;
        case 26:  return FieldType_enum;
        default:  return FieldType_unknown;
    }
}

// ****************************************************************************
// Method: PDFAttributes::GetFieldTypeName
//
// Purpose: 
//   This method returns the name of a field type given its index.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Mon Nov 21 08:16:57 PDT 2005
//
// Modifications:
//   
// ****************************************************************************

std::string
PDFAttributes::GetFieldTypeName(int index) const
{
    switch (index)
    {
        case 0:  return "string";
        case 1:  return "bool";
        case 2:  return "bool";
        case 3:  return "double";
        case 4:  return "double";
        case 5:  return "enum";
        case 6:  return "double";
        case 7:  return "int";
        case 8:  return "string";
        case 9:  return "bool";
        case 10:  return "bool";
        case 11:  return "double";
        case 12:  return "double";
        case 13:  return "enum";
        case 14:  return "double";
        case 15:  return "int";
        case 16:  return "enum";
        case 17:  return "string";
        case 18:  return "bool";
        case 19:  return "bool";
        case 20:  return "double";
        case 21:  return "double";
        case 22:  return "enum";
        case 23:  return "double";
        case 24:  return "int";
        case 25:  return "bool";
        case 26:  return "enum";
        default:  return "invalid index";
    }
}

// ****************************************************************************
// Method: PDFAttributes::FieldsEqual
//
// Purpose: 
//   This method compares two fields and return true if they are equal.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Mon Nov 21 08:16:57 PDT 2005
//
// Modifications:
//   
// ****************************************************************************

bool
PDFAttributes::FieldsEqual(int index_, const AttributeGroup *rhs) const
{
    const PDFAttributes &obj = *((const PDFAttributes*)rhs);
    bool retval = false;
    switch (index_)
    {
    case 0:
        {  // new scope
        retval = (var1 == obj.var1);
        }
        break;
    case 1:
        {  // new scope
        retval = (var1MinFlag == obj.var1MinFlag);
        }
        break;
    case 2:
        {  // new scope
        retval = (var1MaxFlag == obj.var1MaxFlag);
        }
        break;
    case 3:
        {  // new scope
        retval = (var1Min == obj.var1Min);
        }
        break;
    case 4:
        {  // new scope
        retval = (var1Max == obj.var1Max);
        }
        break;
    case 5:
        {  // new scope
        retval = (var1Scaling == obj.var1Scaling);
        }
        break;
    case 6:
        {  // new scope
        retval = (var1SkewFactor == obj.var1SkewFactor);
        }
        break;
    case 7:
        {  // new scope
        retval = (var1NumSamples == obj.var1NumSamples);
        }
        break;
    case 8:
        {  // new scope
        retval = (var2 == obj.var2);
        }
        break;
    case 9:
        {  // new scope
        retval = (var2MinFlag == obj.var2MinFlag);
        }
        break;
    case 10:
        {  // new scope
        retval = (var2MaxFlag == obj.var2MaxFlag);
        }
        break;
    case 11:
        {  // new scope
        retval = (var2Min == obj.var2Min);
        }
        break;
    case 12:
        {  // new scope
        retval = (var2Max == obj.var2Max);
        }
        break;
    case 13:
        {  // new scope
        retval = (var2Scaling == obj.var2Scaling);
        }
        break;
    case 14:
        {  // new scope
        retval = (var2SkewFactor == obj.var2SkewFactor);
        }
        break;
    case 15:
        {  // new scope
        retval = (var2NumSamples == obj.var2NumSamples);
        }
        break;
    case 16:
        {  // new scope
        retval = (numAxes == obj.numAxes);
        }
        break;
    case 17:
        {  // new scope
        retval = (var3 == obj.var3);
        }
        break;
    case 18:
        {  // new scope
        retval = (var3MinFlag == obj.var3MinFlag);
        }
        break;
    case 19:
        {  // new scope
        retval = (var3MaxFlag == obj.var3MaxFlag);
        }
        break;
    case 20:
        {  // new scope
        retval = (var3Min == obj.var3Min);
        }
        break;
    case 21:
        {  // new scope
        retval = (var3Max == obj.var3Max);
        }
        break;
    case 22:
        {  // new scope
        retval = (var3Scaling == obj.var3Scaling);
        }
        break;
    case 23:
        {  // new scope
        retval = (var3SkewFactor == obj.var3SkewFactor);
        }
        break;
    case 24:
        {  // new scope
        retval = (var3NumSamples == obj.var3NumSamples);
        }
        break;
    case 25:
        {  // new scope
        retval = (scaleCube == obj.scaleCube);
        }
        break;
    case 26:
        {  // new scope
        retval = (densityType == obj.densityType);
        }
        break;
    default: retval = false;
    }

    return retval;
}

///////////////////////////////////////////////////////////////////////////////
// User-defined methods.
///////////////////////////////////////////////////////////////////////////////


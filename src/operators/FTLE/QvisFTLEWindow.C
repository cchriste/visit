/*****************************************************************************
*
* Copyright (c) 2000 - 2012, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

#include "QvisFTLEWindow.h"

#include <FTLEAttributes.h>
#include <ViewerProxy.h>

#include <QCheckBox>
#include <QGroupBox>
#include <QLabel>
#include <QLayout>
#include <QLineEdit>
#include <QSpinBox>
#include <QButtonGroup>
#include <QRadioButton>
#include <QvisColorTableButton.h>
#include <QvisOpacitySlider.h>
#include <QvisColorButton.h>
#include <QvisLineStyleWidget.h>
#include <QvisLineWidthWidget.h>
#include <QvisVariableButton.h>

#include <stdio.h>
#include <string>

using std::string;

// ****************************************************************************
// Method: QvisFTLEWindow::QvisFTLEWindow
//
// Purpose: 
//   Constructor
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

QvisFTLEWindow::QvisFTLEWindow(const int type,
                         FTLEAttributes *subj,
                         const QString &caption,
                         const QString &shortName,
                         QvisNotepadArea *notepad)
    : QvisOperatorWindow(type,subj, caption, shortName, notepad)
{
    atts = subj;
}


// ****************************************************************************
// Method: QvisFTLEWindow::~QvisFTLEWindow
//
// Purpose: 
//   Destructor
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

QvisFTLEWindow::~QvisFTLEWindow()
{
}


// ****************************************************************************
// Method: QvisFTLEWindow::CreateWindowContents
//
// Purpose: 
//   Creates the widgets for the window.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
//   Hank Childs, Wed Apr 11 10:24:28 PDT 2012
//   Add buttons for steady/unstead and forwards/backwards.
//
// ****************************************************************************

void
QvisFTLEWindow::CreateWindowContents()
{
    QGridLayout *mainLayout = new QGridLayout(0);
    topLayout->addLayout(mainLayout);

    integrationTimeLabel = new QLabel(tr("Integration Time"), central);
    mainLayout->addWidget(integrationTimeLabel,0,0);
    integrationTime = new QLineEdit(central);
    connect(integrationTime, SIGNAL(returnPressed()),
            this, SLOT(integrationTimeProcessText()));
    mainLayout->addWidget(integrationTime, 0,1);

    QLabel *directionLabel = new QLabel(tr("FTLE Direction"), central);
    mainLayout->addWidget(directionLabel,1,0);
    direction = new QWidget(central);
    directionButtonGroup= new QButtonGroup(direction);
    QHBoxLayout *directionLayout = new QHBoxLayout(direction);
    directionLayout->setMargin(0);
    directionLayout->setSpacing(10);
    QRadioButton *directionDirectionForward = new QRadioButton(tr("Forward"), direction);
    directionButtonGroup->addButton(directionDirectionForward,0);
    directionLayout->addWidget(directionDirectionForward);
    QRadioButton *directionDirectionBackward = new QRadioButton(tr("Backward"), direction);
    directionButtonGroup->addButton(directionDirectionBackward,1);
    directionLayout->addWidget(directionDirectionBackward);
    connect(directionButtonGroup, SIGNAL(buttonClicked(int)),
            this, SLOT(directionChanged(int)));
    mainLayout->addWidget(direction, 1,1);

    QLabel *flowTypeLabel = new QLabel(tr("Treat flow as: "), central);
    mainLayout->addWidget(flowTypeLabel,2,0);
    flowType = new QWidget(central);
    flowTypeButtonGroup= new QButtonGroup(flowType);
    QHBoxLayout *flowTypeLayout = new QHBoxLayout(flowType);
    flowTypeLayout->setMargin(0);
    flowTypeLayout->setSpacing(10);
    QRadioButton *flowTypeFlowTypeUnsteady = new QRadioButton(tr("Unsteady state"), flowType);
    flowTypeButtonGroup->addButton(flowTypeFlowTypeUnsteady,0);
    flowTypeLayout->addWidget(flowTypeFlowTypeUnsteady);
    QRadioButton *flowTypeFlowTypeSteady = new QRadioButton(tr("Steady state"), flowType);
    flowTypeButtonGroup->addButton(flowTypeFlowTypeSteady,1);
    flowTypeLayout->addWidget(flowTypeFlowTypeSteady);
    connect(flowTypeButtonGroup, SIGNAL(buttonClicked(int)),
            this, SLOT(flowTypeChanged(int)));
    mainLayout->addWidget(flowType, 2,1);

    regionTypeLabel = new QLabel(tr("Where to evaluate FTLE"), central);
    mainLayout->addWidget(regionTypeLabel,3,0);
    regionType = new QWidget(central);
    regionTypeButtonGroup= new QButtonGroup(regionType);
    //QHBoxLayout *regionTypeLayout = new QHBoxLayout(regionType);
    //regionTypeLayout->setMargin(0);
    //regionTypeLayout->setSpacing(10);
    QRadioButton *regionTypeRegionNativeResolutionOfMesh = new QRadioButton(tr("At the native resolution of the mesh"), regionType);
    regionTypeButtonGroup->addButton(regionTypeRegionNativeResolutionOfMesh,0);
    //regionTypeLayout->addWidget(regionTypeRegionNativeResolutionOfMesh);
    mainLayout->addWidget(regionTypeRegionNativeResolutionOfMesh, 3,1);
    QRadioButton *regionTypeRegionRegularGrid = new QRadioButton(tr("On a regular grid"), regionType);
    regionTypeButtonGroup->addButton(regionTypeRegionRegularGrid,1);
    //regionTypeLayout->addWidget(regionTypeRegionRegularGrid);
    connect(regionTypeButtonGroup, SIGNAL(buttonClicked(int)),
            this, SLOT(regionTypeChanged(int)));
    mainLayout->addWidget(regionTypeRegionRegularGrid, 4,1);

    QGroupBox *regularGridBox = new QGroupBox(central);
    regularGridBox->setTitle(tr("Regular Grid"));
    topLayout->addWidget(regularGridBox);

    QGridLayout *rgridLayout = new QGridLayout(regularGridBox);
    ResolutionLabel = new QLabel(tr("Resolution"), central);
    rgridLayout->addWidget(ResolutionLabel,0,0);
    Resolution = new QLineEdit(central);
    connect(Resolution, SIGNAL(returnPressed()),
            this, SLOT(ResolutionProcessText()));
    rgridLayout->addWidget(Resolution, 0,1);

    UseDataSetStart = new QCheckBox(tr("Start at DataSet Extent"), central);
    connect(UseDataSetStart, SIGNAL(toggled(bool)),
            this, SLOT(UseDataSetStartChanged(bool)));
    rgridLayout->addWidget(UseDataSetStart, 1,0);

    StartPositionLabel = new QLabel(tr("Subset Start"), central);
    rgridLayout->addWidget(StartPositionLabel,2,0);
    StartPosition = new QLineEdit(central);
    connect(StartPosition, SIGNAL(returnPressed()),
            this, SLOT(StartPositionProcessText()));
    rgridLayout->addWidget(StartPosition, 2,1);

    UseDatasetEnd = new QCheckBox(tr("End at DataSet Extent"), central);
    connect(UseDatasetEnd, SIGNAL(toggled(bool)),
            this, SLOT(UseDatasetEndChanged(bool)));
    rgridLayout->addWidget(UseDatasetEnd, 3,0);

    EndPositionLabel = new QLabel(tr("Subset End"), central);
    rgridLayout->addWidget(EndPositionLabel,4,0);
    EndPosition = new QLineEdit(central);
    connect(EndPosition, SIGNAL(returnPressed()),
            this, SLOT(EndPositionProcessText()));
    rgridLayout->addWidget(EndPosition, 4,1);
}


// ****************************************************************************
// Method: QvisFTLEWindow::UpdateWindow
//
// Purpose: 
//   Updates the widgets in the window when the subject changes.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
//   Hank Childs, Wed Apr 11 10:24:28 PDT 2012
//   Add support for steady/unstead and forwards/backwards.
//
// ****************************************************************************

void
QvisFTLEWindow::UpdateWindow(bool doAll)
{

    for(int i = 0; i < atts->NumAttributes(); ++i)
    {
        if(!doAll)
        {
            if(!atts->IsSelected(i))
            {
                continue;
            }
        }

        switch(i)
        {
          case FTLEAttributes::ID_integrationTime:
            integrationTime->setText(DoubleToQString(atts->GetIntegrationTime()));
            break;
          case FTLEAttributes::ID_regionType:
            if (atts->GetRegionType() == FTLEAttributes::RegularGrid)
            {
                Resolution->setEnabled(true);
                if(ResolutionLabel)
                    ResolutionLabel->setEnabled(true);
                UseDataSetStart->setEnabled(true);
                UseDatasetEnd->setEnabled(true);
                if (atts->GetUseDataSetStart() == false)
                {
                    StartPosition->setEnabled(true);
                    if(StartPositionLabel)
                        StartPositionLabel->setEnabled(true);
                }
                if (atts->GetUseDataSetEnd() == false)
                {
                    EndPosition->setEnabled(true);
                    if(EndPositionLabel)
                        EndPositionLabel->setEnabled(true);
                }
            }
            else
            {
                Resolution->setEnabled(false);
                if(ResolutionLabel)
                    ResolutionLabel->setEnabled(false);
                UseDataSetStart->setEnabled(false);
                UseDatasetEnd->setEnabled(false);
                StartPosition->setEnabled(false);
                if(StartPositionLabel)
                    StartPositionLabel->setEnabled(false);
                EndPosition->setEnabled(false);
                if(EndPositionLabel)
                    EndPositionLabel->setEnabled(false);
            }
            regionTypeButtonGroup->blockSignals(true);
            if(regionTypeButtonGroup->button((int)atts->GetRegionType()) != 0)
                regionTypeButtonGroup->button((int)atts->GetRegionType())->setChecked(true);
            regionTypeButtonGroup->blockSignals(false);
            break;
          case FTLEAttributes::ID_Resolution:
            Resolution->setText(IntsToQString(atts->GetResolution(),3));
            break;
          case FTLEAttributes::ID_UseDataSetStart:
            if (atts->GetUseDataSetStart() == false)
            {
                StartPosition->setEnabled(true);
                if(StartPositionLabel)
                    StartPositionLabel->setEnabled(true);
            }
            else
            {
                StartPosition->setEnabled(false);
                if(StartPositionLabel)
                    StartPositionLabel->setEnabled(false);
            }
            UseDataSetStart->blockSignals(true);
            UseDataSetStart->setChecked(atts->GetUseDataSetStart());
            UseDataSetStart->blockSignals(false);
            break;
          case FTLEAttributes::ID_StartPosition:
            StartPosition->setText(DoublesToQString(atts->GetStartPosition(), 3));
            break;
          case FTLEAttributes::ID_UseDataSetEnd:
            if (atts->GetUseDataSetEnd() == false)
            {
                EndPosition->setEnabled(true);
                if(EndPositionLabel)
                    EndPositionLabel->setEnabled(true);
            }
            else
            {
                EndPosition->setEnabled(false);
                if(EndPositionLabel)
                    EndPositionLabel->setEnabled(false);
            }
            UseDatasetEnd->blockSignals(true);
            UseDatasetEnd->setChecked(atts->GetUseDataSetEnd());
            UseDatasetEnd->blockSignals(false);
            break;
          case FTLEAttributes::ID_EndPosition:
            EndPosition->setText(DoublesToQString(atts->GetEndPosition(), 3));
            break;
          case FTLEAttributes::ID_direction:
            directionButtonGroup->blockSignals(true);
            if(directionButtonGroup->button((int)atts->GetDirection()) != 0)
                directionButtonGroup->button((int)atts->GetDirection())->setChecked(true);
            directionButtonGroup->blockSignals(false);
            break;
          case FTLEAttributes::ID_flowType:
            flowTypeButtonGroup->blockSignals(true);
            if(flowTypeButtonGroup->button((int)atts->GetFlowType()) != 0)
                flowTypeButtonGroup->button((int)atts->GetFlowType())->setChecked(true);
            flowTypeButtonGroup->blockSignals(false);
            break;
        }
    }
}


// ****************************************************************************
// Method: QvisFTLEWindow::GetCurrentValues
//
// Purpose: 
//   Gets values from certain widgets and stores them in the subject.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisFTLEWindow::GetCurrentValues(int which_widget)
{
    bool doAll = (which_widget == -1);

    // Do integrationTime
    if(which_widget == FTLEAttributes::ID_integrationTime || doAll)
    {
        double val;
        if(LineEditGetDouble(integrationTime, val))
            atts->SetIntegrationTime(val);
        else
        {
            ResettingError(tr("Integration Time"),
                DoubleToQString(atts->GetIntegrationTime()));
            atts->SetIntegrationTime(atts->GetIntegrationTime());
        }
    }

    // Do Resolution
    if(which_widget == FTLEAttributes::ID_Resolution || doAll)
    {
        int val[3];
        if(LineEditGetInts(Resolution, val, 3))
            atts->SetResolution(val);
        else
        {
            ResettingError(tr("Resolution"),
                IntsToQString(atts->GetResolution(), 3));
            atts->SetResolution(atts->GetResolution());
        }
    }

    // Do StartPosition
    if(which_widget == FTLEAttributes::ID_StartPosition || doAll)
    {
        double val[3];
        if(LineEditGetDoubles(StartPosition, val, 3))
            atts->SetStartPosition(val);
        else
        {
            ResettingError(tr("Subset Start"),
                DoublesToQString(atts->GetStartPosition(),3));
            atts->SetStartPosition(atts->GetStartPosition());
        }
    }

    // Do EndPosition
    if(which_widget == FTLEAttributes::ID_EndPosition || doAll)
    {
        double val[3];
        if(LineEditGetDoubles(EndPosition, val, 3))
            atts->SetEndPosition(val);
        else
        {
            ResettingError(tr("Subset End"),
                DoublesToQString(atts->GetEndPosition(),3));
            atts->SetEndPosition(atts->GetEndPosition());
        }
    }

}


//
// Qt Slot functions
//


void
QvisFTLEWindow::integrationTimeProcessText()
{
    GetCurrentValues(FTLEAttributes::ID_integrationTime);
    Apply();
}


void
QvisFTLEWindow::regionTypeChanged(int val)
{
    if(val != atts->GetRegionType())
    {
        atts->SetRegionType(FTLEAttributes::Region(val));
        Apply();
    }
}


void
QvisFTLEWindow::ResolutionProcessText()
{
    GetCurrentValues(FTLEAttributes::ID_Resolution);
    Apply();
}


void
QvisFTLEWindow::UseDataSetStartChanged(bool val)
{
    atts->SetUseDataSetStart(val);
    Apply();
}


void
QvisFTLEWindow::StartPositionProcessText()
{
    GetCurrentValues(FTLEAttributes::ID_StartPosition);
    Apply();
}


void
QvisFTLEWindow::UseDatasetEndChanged(bool val)
{
    atts->SetUseDataSetEnd(val);
    Apply();
}


void
QvisFTLEWindow::EndPositionProcessText()
{
    GetCurrentValues(FTLEAttributes::ID_EndPosition);
    Apply();
}


void
QvisFTLEWindow::directionChanged(int val)
{
    if(val != atts->GetDirection())
    {
        atts->SetDirection(FTLEAttributes::Direction(val));
        SetUpdate(false);
        Apply();
    }
}


void
QvisFTLEWindow::flowTypeChanged(int val)
{
    if(val != atts->GetFlowType())
    {
        atts->SetFlowType(FTLEAttributes::FlowType(val));
        SetUpdate(false);
        Apply();
    }
}



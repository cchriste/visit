/*****************************************************************************
*
* Copyright (c) 2000 - 2014, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//  File: avtFTLEFilter.C
// ************************************************************************* //

#include <avtFTLEFilter.h>
#include <avtFTLEIC.h>

// For now use the avtFTLEIC as the state does not need to be recorded
//for the FSLE. That is because currently the integration is being
//done step by step rather than in chunks. However, the code is set up
//to use avtStreamlineIC. Which if the integration is done in chucks
//will probably be more efficient.

//#include <avtStreamlineIC.h>
#define avtStreamlineIC avtFTLEIC

#include <avtExtents.h>
#include <avtMatrix.h>
#include <vtkRectilinearGrid.h>
#include <vtkFloatArray.h>
#include <vtkPointData.h>
#include <vtkStreamer.h>

#include <avtParallel.h>
#include <avtCallback.h>

#include <avtOriginatingSource.h>
#include <avtGradientExpression.h>
#include <vtkVisItScalarTree.h>

#include <VisItException.h>
#include <ImproperUseException.h>

#include <iostream>
#include <limits>
#include <cmath>

// ****************************************************************************
//  Method: avtFTLEFilter constructor
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
//  Modifications:
//
//    Hank Childs, Wed Mar 28 08:36:34 PDT 2012
//    Initialize pathlines later.  Also set tolerances.
//
// ****************************************************************************

avtFTLEFilter::avtFTLEFilter() : seedVelocity(0,0,0)
{
    //outVarName ="operators/FTLE/mesh";
    //doPathlines();
    //SetPathlines(atts.GetPathlines(),
    //              atts.GetPathlinesOverrideStartingTimeFlag(),
    //              atts.GetPathlinesOverrideStartingTime(),
    //              atts.GetPathlinesCMFE());
    //SetPathlines(true,false,0,PICS_CONN_CMFE);
    //SetPathlines(false,false,0,PICS_CONN_CMFE);

    // These initializations prevent harmless UMRs when we do our first
    // cache lookups.
    global_bounds[0] = global_bounds[2] = global_bounds[4] = 0;
    global_bounds[1] = global_bounds[3] = global_bounds[5] = 1;
    global_resolution[0] = global_resolution[1] = global_resolution[2] = 10;
    absTol = 1e-6;
    relTol = 1e-7;

    numSteps = 0;
    fsle_dt = 0;
    fsle_ds = 0;

    minSizeValue = std::numeric_limits<double>::max();
    maxSizeValue = std::numeric_limits<double>::min();
}


// ****************************************************************************
//  Method: avtFTLEFilter destructor
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
//  Modifications:
//
// ****************************************************************************

avtFTLEFilter::~avtFTLEFilter()
{
}


// ****************************************************************************
//  Method: avtFTLEFilter::Create
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
// ****************************************************************************

avtFilter *avtFTLEFilter::Create()
{
    return new avtFTLEFilter();
}


// ****************************************************************************
//  Method: avtFTLEFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
//  Modifications:
//
//    Hank Childs, Tue Mar 27 16:24:13 PDT 2012
//    Don't do pathlines if steady state is indicated.
//
//    Hank Childs, Wed Apr 11 11:35:16 PDT 2012
//    Add reverse flow.
//
// ****************************************************************************

void
avtFTLEFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const FTLEAttributes*)a;

    needsRecalculation =
      atts.ChangesRequireRecalculation(*(const FTLEAttributes*)a);

    int CMFEType = (atts.GetPathlinesCMFE() == FTLEAttributes::CONN_CMFE
                    ? PICS_CONN_CMFE : PICS_POS_CMFE);

    SetPathlines(atts.GetPathlines(),
                 atts.GetPathlinesOverrideStartingTimeFlag(),
                 atts.GetPathlinesOverrideStartingTime(),
                 CMFEType);

    SetIntegrationDirection(atts.GetIntegrationDirection());

    SetFieldType(atts.GetFieldType());
    SetFieldConstant(atts.GetFieldConstant());
    SetVelocitySource(atts.GetVelocitySource());

    SetIntegrationType(atts.GetIntegrationType());
    SetParallelizationAlgorithm(atts.GetParallelizationAlgorithmType(), 
                                atts.GetMaxProcessCount(),
                                atts.GetMaxDomainCacheSize(),
                                atts.GetWorkGroupSize());

    if (atts.GetIntegrationType() == FTLEAttributes::DormandPrince)
    {
        if( atts.GetTerminateBySize() )
        {
          EXCEPTION1(ImproperUseException,
                     "When performing FSLE the step size must be fixed. "
                     "Please select a different solver and "
                     "set the maximum time step.");
        }

        // For DoPri, the max time step is sent in to the PICS filter
        // as the max step length.
        double step;
        if (atts.GetLimitMaximumTimestep())
          step = atts.GetMaxTimeStep();
        else
          step = 0;

        SetMaxStepLength(step);
    }
    else
        SetMaxStepLength(atts.GetMaxStepLength());

    double absTol = 0.;
    bool doBBox = (atts.GetAbsTolSizeType() == FTLEAttributes::FractionOfBBox);
    if (doBBox)
        absTol = atts.GetAbsTolBBox();
    else
        absTol = atts.GetAbsTolAbsolute();
    SetTolerances(atts.GetRelTol(), absTol, doBBox);

    SetTermination(atts.GetMaxSteps(),
                   atts.GetTerminateByDistance(),
                   atts.GetTermDistance(),
                   atts.GetTerminateByTime(),
                   atts.GetTermTime(),
                   atts.GetTerminateBySize(),
                   atts.GetTermSize());

    IssueWarningForMaxStepsTermination(atts.GetIssueTerminationWarnings());
    IssueWarningForStiffness(atts.GetIssueStiffnessWarnings());
    IssueWarningForCriticalPoints(atts.GetIssueCriticalPointsWarnings(),
                                  atts.GetCriticalPointThreshold());
}


// ****************************************************************************
//  Method: avtFTLEFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtFTLEFilter with the given
//      parameters would result in an equivalent avtFTLEFilter.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
// ****************************************************************************

bool
avtFTLEFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(FTLEAttributes*)a);
}


// ****************************************************************************
// Method: avtFTLEFilter::SetVelocitySource
//
// Purpose: 
//   Sets the integral curve velocity source.
//
// Arguments:
//   vel : The velocity of the point.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

void
avtFTLEFilter::SetVelocitySource(const double *p)
{
  seedVelocity.set(p);
}


// ****************************************************************************
//  Method: avtFTLEFilter::GetInitialVelocities
//
//  Purpose:
//      Get the seed velocities out of the attributes.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

std::vector<avtVector>
avtFTLEFilter::GetInitialVelocities(void)
{
    std::vector<avtVector> seedVels;

    seedVels.push_back( seedVelocity );

    return seedVels;
}


// ****************************************************************************
//  Method: avtFTLEFilter::SetTermination
//
//  Purpose:
//      Sets the termination criteria for an integral curve.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

void
avtFTLEFilter::SetTermination(int maxSteps_,
                              bool doDistance_, double maxDistance_,
                              bool doTime_,     double maxTime_,
                              bool doSize_,     double maxSize_)
{
    maxSteps = maxSteps_;
    doDistance = doDistance_;
    maxDistance = maxDistance_;
    doTime = doTime_;
    maxTime = maxTime_;
    doSize = doSize_;
    maxSize = maxSize_;
}


// ****************************************************************************
//  Method: avtFTLEFilter::CreateIntegralCurve
//
//  Purpose:
//      Create an uninitialized integral curve.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtIntegralCurve*
avtFTLEFilter::CreateIntegralCurve(void)
{
  if( doSize ) 
    return (new avtStreamlineIC());
  else
    return (new avtFTLEIC());
}


// ****************************************************************************
//  Method: avtFTLEFilter::CreateIntegralCurve
//
//  Purpose:
//      Create an integral curve with specific IDs and parameters.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtIntegralCurve*
avtFTLEFilter::CreateIntegralCurve(const avtIVPSolver* model,
                                   avtIntegralCurve::Direction dir,
                                   const double& t_start,
                                   const avtVector &p_start,
                                   const avtVector& v_start, long ID)
{
    double t;

    if (doPathlines)
    {
        if (dir == avtIntegralCurve::DIRECTION_BACKWARD)
            t = seedTime0 - maxTime;
        else
            t = seedTime0 + maxTime;
    }
    else
    {
        if (dir == avtIntegralCurve::DIRECTION_BACKWARD)
            t = -maxTime;
        else
            t = maxTime;
    }

    if( doSize )
    {
      // For now use the avtFTLEIC as the state does not need to be
      // recorded for the FSLE. That is because currently the
      // integration is being done step by step rather than in
      // chunks. However, the code is set up to use
      // avtStreamlineIC. Which if the integration is done in chucks
      // will probably be more efficient.

      // unsigned char attr = avtStateRecorderIntegralCurve::SAMPLE_POSITION;
      // attr |= avtStateRecorderIntegralCurve::SAMPLE_TIME;
      // attr |= avtStateRecorderIntegralCurve::SAMPLE_ARCLENGTH;
      
      // return
      //   (new avtStreamlineIC(numSteps, doDistance, maxDistance, doTime, t,
      //                        attr, model, dir, t_start, p_start, v_start, ID));
      return
        (new avtFTLEIC(numSteps, doDistance, maxDistance, doTime, t,
                       model, dir, t_start, p_start, v_start, ID));
    }
    else
    {
      return
        (new avtFTLEIC(maxSteps, doDistance, maxDistance, doTime, t,
                       model, dir, t_start, p_start, v_start, ID));
    }
}


// ****************************************************************************
//  Method: avtFTLEFilter::ModifyContract
//
//  Purpose:
//      Creates a contract the removes the operator-created-expression.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
// ****************************************************************************

avtContract_p
avtFTLEFilter::ModifyContract(avtContract_p in_contract)
{
    avtDataRequest_p in_dr = in_contract->GetDataRequest();
    std::string var =  in_dr->GetOriginalVariable();
//    in_contract->SetReplicateSingleDomainOnAllProcessors(true);
//    in_contract->SetOnDemandStreaming(false);
//    in_contract->GetDataRequest();
    in_dr->SetUsesAllDomains(true);
    if( strncmp(var.c_str(), "operators/FTLE/", strlen("operators/FTLE/")) == 0)
    {
        std::string justTheVar = var.substr(strlen("operators/FTLE/"));

        outVarName = justTheVar;
        avtDataRequest_p out_dr = new avtDataRequest(in_dr,justTheVar.c_str());
        //out_dr->SetDesiredGhostDataType(GHOST_NODE_DATA);
        //out_dr->SetDesiredGhostDataType(GHOST_ZONE_DATA);

        return avtPICSFilter::ModifyContract( new avtContract(in_contract,out_dr) );
    }

    return avtPICSFilter::ModifyContract(in_contract);
}


// ****************************************************************************
//  Method: avtFTLEFilter::UpdateDataObjectInfo
//
//  Purpose:
//      Tells output that we have a new variable.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
// ****************************************************************************

void
avtFTLEFilter::UpdateDataObjectInfo(void)
{
    avtDataAttributes &in_atts = GetInput()->GetInfo().GetAttributes();
    avtDataAttributes &atts = GetOutput()->GetInfo().GetAttributes();

    timeState = in_atts.GetTimeIndex();

    //the outvarname has been assigned and will be added.
    //outVarName = "velocity";
    if (outVarName != "")
    {
        std::string fullVarName = std::string("operators/FTLE/") + outVarName;
        atts.RemoveVariable(in_atts.GetVariableName());

        if (! atts.ValidVariable(fullVarName) )
        {
            //std::cout << "Adding variable: " << outVarName << std::endl;
            //atts.AddVariable(outVarName.c_str());
            atts.AddVariable((fullVarName).c_str());
            atts.SetActiveVariable(fullVarName.c_str());
            atts.SetVariableDimension(1);
            //atts.SetTopologicalDimension(3);
            atts.SetVariableType(AVT_SCALAR_VAR);
            atts.SetCentering(AVT_NODECENT);
        }
    }

    avtPICSFilter::UpdateDataObjectInfo();
}


// ****************************************************************************
//  Method: avtFTLEFilter::PreExecute
//
//  Purpose:
//      Initialize data attributes for this filter and its base type (PICS).
//
//  Programmer: Hari Krishna
//  Creation:   December 5, 2011
//
//  Modifications:
//
//    Hank Childs, Jul  6 14:17:47 PDT 2012
//    Set resolution for Z to be 1 for 2D meshes.
//
// ****************************************************************************

void 
avtFTLEFilter::PreExecute(void)
{
    SetActiveVariable(outVarName.c_str());
    GetSpatialExtents(global_bounds);

    if (GetInput()->GetInfo().GetAttributes().GetSpatialDimension() == 2)
    {
        // we set them to 0->1 earlier and GetSpatialExtents only sets the
        // X and Y parts of the extents for 2D.
        global_bounds[4] = 0;
        global_bounds[5] = 0;
    }

    if(atts.GetUseDataSetStart() == FTLEAttributes::Subset)
    {
        double* a = atts.GetStartPosition();
        global_bounds[0] = a[0];
        global_bounds[2] = a[1];
        global_bounds[4] = a[2];
    }

    if(atts.GetUseDataSetEnd() == FTLEAttributes::Subset)
    {
        double* a = atts.GetEndPosition();
        global_bounds[1] = a[0];
        global_bounds[3] = a[1];
        global_bounds[5] = a[2];
    }

    const int* res = atts.GetResolution();
    global_resolution[0] = res[0];
    global_resolution[1] = res[1];
    global_resolution[2] = res[2];
    if (global_bounds[4] == global_bounds[5])
        global_resolution[2] = 1;

    double minResolution = std::numeric_limits<float>::max();

    double resX, resY, resZ;

    if (global_resolution[0] > 1)
    {
      double pcnt = 1.0 / (double) (global_resolution[0]-1);

      resX = (global_bounds[1] - global_bounds[0]) * pcnt; 

      minResolution = std::min( resX, minResolution );
    }
      
    if (global_resolution[1] > 1)
    {
      double pcnt = 1.0 / (double) (global_resolution[1]-1);

      resY = (global_bounds[3] - global_bounds[2]) * pcnt; 
 
      minResolution = std::min( resY, minResolution );
    }
      
    if (global_resolution[2] > 1)
    {
      double pcnt = 1.0 / (double) (global_resolution[2]-1);

      resZ = (global_bounds[5] - global_bounds[4]) * pcnt; 

      minResolution = std::min( resZ, minResolution );
    }

    if( doSize && maxSize <= minResolution )
    {
        char str[1028];

        SNPRINTF(str, 1028, "\nThe size limit for the FSLE is %f. "
                 "and is equal to or smaller than the resolution of the grid "
                 "(%f, %f, %f). ",
                 atts.GetTermSize(), resX, resY, resZ );

        avtCallback::IssueWarning(str);
        
//      EXCEPTION1(ImproperUseException, str );
    }

    avtPICSFilter::PreExecute();
}


// ****************************************************************************
//  Method: avtFTLEFilter::Execute
//
//  Purpose:
//      Executes the FTLE.  If we already have a cached version, then it
//      just returns that version.  If not, it calls PICS execute, which will
//      call our FTLE set up routines via CreateIntegralCurveOutput.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

void
avtFTLEFilter::Execute(void)
{
    avtDataTree_p dt = GetCachedDataSet();

    if (!needsRecalculation && *dt != NULL)
    {
        debug1 << "FTLE: using cached version" << std::endl;
        if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
            if (PAR_Rank() != 0)
                dt = new avtDataTree();
        SetOutputDataTree(dt);
        return;
    }
    else
    {
      debug1 << "FTLE: no cached version, must re-execute" << std::endl;

      avtPICSFilter::Execute();

      std::vector<avtIntegralCurve *> ics;
      GetTerminatedIntegralCurves(ics);
      
      ReportWarnings( ics );
    }
}

// ****************************************************************************
//  Method: avtFTLEFilter::ContinueExecute
//
//  Purpose:
//      See if execution needs to continue.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

bool
avtFTLEFilter::ContinueExecute()
{
    ++numSteps;

    if( doTime || doDistance )
        return false;

    else //if( doSize )
    {
//      std::cerr << "Continue execute " << numSteps << std::endl;
    
      std::vector<avtIntegralCurve *> ics;
    
      GetTerminatedIntegralCurves(ics);
    
      if (atts.GetSourceType() == FTLEAttributes::NativeMesh)
      {
        if (ComputeNativeMeshFSLE(ics) == true )
          return false;
        else
          return true;

      }
      else //if (atts.GetSourceType() == FTLEAttributes::RegularGrid)
      {
        if (ComputeRectilinearGridFSLE(ics) == true )
          return false;
        else
          return true;
      }
    }
}

// ****************************************************************************
//  Method: avtFTLEFilter::CreateIntegralCurveOutput
//
//  Purpose:
//      Computes the FTLE output (via sub-routines) after the PICS filter has
//      calculated the final particle positions.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

void 
avtFTLEFilter::CreateIntegralCurveOutput(std::vector<avtIntegralCurve*> &ics)
{
  if( doTime || doDistance )
  {
    if (atts.GetSourceType() == FTLEAttributes::NativeMesh)
        ComputeNativeMeshFTLE(ics);
    else //if (atts.GetSourceType() == FTLEAttributes::RegularGrid)
        ComputeRectilinearGridFTLE(ics);
  }
  else if( doSize )
  {
    if (atts.GetSourceType() == FTLEAttributes::NativeMesh)
      CreateNativeMeshFSLEOutput(ics);
    else //if (atts.GetSourceType() == FTLEAttributes::RegularGrid)
      CreateRectilinearGridFSLEOutput(ics);
  }
}


// ****************************************************************************
//  Method: avtFTLEFilter::GetInitialLocations
//
//  Purpose:
//      Tells the PICS filter where to place the initial seed locations.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

std::vector<avtVector>
avtFTLEFilter::GetInitialLocations()
{
    seedPoints.clear();

    if (atts.GetSourceType() == FTLEAttributes::NativeMesh)
    {
        GetInitialLocationsFromNativeMesh(GetInputDataTree());
    }
    else //if (atts.GetSourceType() == FTLEAttributes::RegularGrid)
    {
        GetInitialLocationsFromRectilinearGrid();
    }

    return seedPoints;
}


// ****************************************************************************
//  Method: avtFTLEFilter::GetInitialLocationsFromMesh
//
//  Purpose:
//      Walks through an AVT data tree and sets up the initial locations from
//      each point in the mesh.
//
//  Arguments:
//      inDT          A pointer to a data tree.  
//
//  Programmer: Hank Childs
//  Creation:   December 5, 2011
//
// ****************************************************************************

void
avtFTLEFilter::GetInitialLocationsFromNativeMesh(avtDataTree_p inDT)
{
    if (*inDT == NULL)
        return;

    int nc = inDT->GetNChildren();

    if (nc <= 0 && !inDT->HasData())
    {
        return;
    }

    if (nc == 0)
    {
        //
        // there is only one dataset to process
        //
        vtkDataSet *in_ds = inDT->GetDataRepresentation().GetDataVTK();
        size_t pts = in_ds->GetNumberOfPoints();

        int numberOfSeeds = seedPoints.size();
        int totalNumberOfSeeds = numberOfSeeds + pts;

        seedPoints.resize( totalNumberOfSeeds );

        double points[3];
        for(size_t i = 0; i < pts; ++i)
        {
          in_ds->GetPoint(i, points);
          seedPoints[numberOfSeeds+i].set(points);
        }
    }
    else
    {
        //
        // there is more than one input dataset to process
        // and we need an output datatree for each
        //
        for (int j = 0; j < nc; j++)
        {
            if (inDT->ChildIsPresent(j))
            {
                GetInitialLocationsFromNativeMesh(inDT->GetChild(j));
            }
        }
    }
}


// ****************************************************************************
//  Method: avtFTLEFilter::GetInitialLocationsFromRectilinearGrid
//
//  Purpose:
//      Created a series of seeds points based on the user specified mesh
//
//  Programmer: Hank Childs
//  Creation:   December 5, 2011
//
// ****************************************************************************

void
avtFTLEFilter::GetInitialLocationsFromRectilinearGrid()
{
    //compute total number of seeds that will be generated.
    size_t totalNumberOfSeeds =
      global_resolution[0] * global_resolution[1] * global_resolution[2];
    
    seedPoints.resize(totalNumberOfSeeds);

    size_t l = 0; //current line of the seed.
  
    //add sample points by looping over in x,y,z
    for(int k = 0; k < global_resolution[2]; ++k)
    {
        double zpcnt = 0;

        if (global_resolution[2] > 1)
          zpcnt = ((double)k)/((double)global_resolution[2]-1);

        double z = global_bounds[4]*(1.0-zpcnt) + global_bounds[5]*zpcnt;
        
        for(int j = 0; j < global_resolution[1]; ++j)
        {
            double ypcnt = 0;

            if (global_resolution[1] > 1)
              ypcnt = ((double)j)/((double)global_resolution[1]-1);

            double y = global_bounds[2]*(1.0-ypcnt) + global_bounds[3]*ypcnt;
            
            for(int i = 0; i < global_resolution[0]; ++i)
            {
                double xpcnt = 0;

                if (global_resolution[0] > 1)
                  xpcnt = ((double)i)/((double)global_resolution[0]-1);

                double x =
                  global_bounds[0]*(1.0-xpcnt) +
                  global_bounds[1]*xpcnt;
                
                size_t index =
                  (global_resolution[1]*global_resolution[0]*k) +
                  (global_resolution[0]*j)+i;

                seedPoints[l++].set(x,y,z);
            }
        }
    }
}


// ****************************************************************************
//  Method: avtFTLEFilter::ComputeNativeMeshFTLE
//
//  Purpose:
//      Computes the FTLE after the particles have been advected.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

void avtFTLEFilter::ComputeNativeMeshFTLE(std::vector<avtIntegralCurve*> &ics)
{
    //accumulate all of the points then do jacobian?
    //or do jacobian then accumulate?
    //picking the first.

    double minv   = std::numeric_limits<double>::max();
    double maxv   = std::numeric_limits<double>::min();
    int    offset = 0;

    avtDataTree_p outTree =
      MultiBlockComputeFTLE(GetInputDataTree(), ics, offset, minv, maxv);

    if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
        if (PAR_Rank() != 0)
            outTree = new avtDataTree();
    SetOutputDataTree(outTree);

    avtDataAttributes &dataatts = GetOutput()->GetInfo().GetAttributes();
    avtExtents* e = dataatts.GetThisProcsActualDataExtents();

    double range[2];
    range[0] = minv;
    range[1] = maxv;
    e->Set(range);

    e = dataatts.GetThisProcsOriginalDataExtents();
    e->Set(range);

    e = dataatts.GetThisProcsActualSpatialExtents();
    e->Set(global_bounds);
    e = dataatts.GetThisProcsOriginalSpatialExtents();
    e->Set(global_bounds);
}


// ****************************************************************************
//  Method: avtFTLEFilter::MultiBlockComputeFTLE
//
//  Purpose:
//      Computes the FTLE for the whole data set, using the final
//      particle locations, at the blocks native mesh resolution.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtDataTree_p
avtFTLEFilter::MultiBlockComputeFTLE(avtDataTree_p inDT,
                                     std::vector<avtIntegralCurve*> &ics,
                                     int &offset, double &minv, double &maxv)
{
    if (*inDT == NULL)
        return 0;

    int nc = inDT->GetNChildren();

    if (nc <= 0 && !inDT->HasData())
    {
        return 0;
    }

    if (nc == 0)
    {
        //
        // there is only one dataset to process
        //
        vtkDataSet *in_ds = inDT->GetDataRepresentation().GetDataVTK();
        int dom = inDT->GetDataRepresentation().GetDomain();
        std::string label = inDT->GetDataRepresentation().GetLabel();

        vtkDataSet *out_ds =
          SingleBlockComputeFTLE(in_ds, ics, offset, dom, minv, maxv);
        avtDataTree_p rv = new avtDataTree(out_ds, dom, label);
        out_ds->Delete();
        return rv;
    }
    else
    {
      //
      // there is more than one input dataset to process
      // and we need an output datatree for each
      //
      avtDataTree_p *outDT = new avtDataTree_p[nc];
      for (int j = 0; j < nc; j++)
      {
          if (inDT->ChildIsPresent(j))
            outDT[j] = MultiBlockComputeFTLE(inDT->GetChild(j), ics, 
                                             offset, minv, maxv);
          else
            outDT[j] = NULL;
      }
      avtDataTree_p rv = new avtDataTree(nc, outDT);
      delete [] outDT;
      return rv;
    }
}


// ****************************************************************************
//  Method: avtFTLEFilter::SingleBlockComputeFTLE
//
//  Purpose:
//      Computes the FTLE for a single block of a data set, using the 
//      final particle locations, at the blocks native mesh resolution.
//
//  Arguments:
//      in_ds   The block to calculate the FTLE on
//      ics     The list of particles for all blocks on this MPI task.
//      domain  The domain number of in_ds
//      minv    The minimum FTLE value (output)
//      maxv    The maximum FTLE value (output)
//
//  Returns:    The new version of in_ds that includes the FTLE scalar
//              variable.  The calling function is responsible for dereferencing
//              this VTK object.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
//  Modifications:
//
//    Hank Childs, Tue Feb  5 08:12:33 PST 2013
//    Fix parallelization bug and memory leak.
//
// ****************************************************************************

vtkDataSet *
avtFTLEFilter::SingleBlockComputeFTLE(vtkDataSet *in_ds,
                                      std::vector<avtIntegralCurve*> &ics,
                                      int &offset, int domain,
                                      double &minv, double &maxv)
{
    //variable name.
    std::string var = std::string("operators/FTLE/") + outVarName;

    //create new instance from old.
    vtkDataSet* out_grid = in_ds->NewInstance();
    out_grid->ShallowCopy(in_ds);
    int nTuples = in_ds->GetNumberOfPoints();

    //an array for the initial locations.
    std::vector<avtVector> remapPoints;
    remapPoints.resize(nTuples);

    if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
    {
        // The parallel synchronization for when data is replicated involves
        // a sum across all processors.  So we want remapPoints to have the
        // location of the particle on one processor, and zero on the rest.
        // Do that here.
        // Special care is needed for the case where the particle never
        // advected.  Then we need to put the initial location on just one
        // processor.  We do this on rank 0.
        std::vector<int> iHavePoint(nTuples, 0);
        std::vector<int> anyoneHasPoint;

        for (size_t idx = 0; idx < ics.size(); idx++)
        {
            size_t index = ics[idx]->id;
            size_t l = (index-offset);
            if(l >= 0 && l < remapPoints.size())
            {
                iHavePoint[l] = 1;
            }
        }

        UnifyMaximumValue(iHavePoint, anyoneHasPoint);
        avtVector zero;
        zero.x = zero.y = zero.z = 0.;
        for (size_t i = 0; i < nTuples; i++)
            if (PAR_Rank() == 0 && !anyoneHasPoint[i])
                remapPoints[i] = seedPoints.at(offset + i);
            else
                remapPoints[i] = zero;
    }
    else
    {
        //copy the original seed points
        for(size_t i = 0; i < remapPoints.size(); ++i)
            remapPoints[i] = seedPoints.at(offset + i);
    }

#if 1
    for(int i = 0; i < ics.size(); ++i)
    {
        size_t index = ics[i]->id;
        int l = (index-offset);
        //std::cout << "l = " << l << " " << nTuples << std::endl;
        if(0 <= l && l < remapPoints.size())
        {
          // remapPoints[l] = ((avtFTLEIC*)ics[i])->GetEndPoint() -
          //                ((avtFTLEIC*)ics[i])->GetStartPoint();

          remapPoints.at(l) = ((avtFTLEIC*)ics[i])->GetEndPoint();
        }
    }

    //done with offset, increment it for the next call to this
    //function.
    offset += nTuples;

    //use static function in avtGradientExpression to calculate
    //gradients.  since this function only does scalar, break our
    //vectors into scalar components and calculate one at a time.

    vtkDataArray* jacobian[3];

    vtkFloatArray *component = vtkFloatArray::New();
    component->SetName(var.c_str());
    component->SetNumberOfTuples(nTuples);

    //temporarily add point data to output grid in order to calculate
    //gradient per component.

    //is this soft copy or deep copy?
    out_grid->GetPointData()->AddArray(component);
    out_grid->GetPointData()->SetActiveScalars(var.c_str());

    for(int i = 0; i < 3; ++i)
    {
        for(size_t j = 0; j < nTuples; ++j)
            component->SetTuple1(j, remapPoints[j][i]);

        if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
        {
            float *newvals = new float[nTuples];
            float *origvals = (float *) component->GetVoidPointer(0);
            SumFloatArrayAcrossAllProcessors(origvals, newvals, nTuples);
            // copy newvals back into origvals
            memcpy(origvals, newvals, nTuples*sizeof(float));
            delete [] newvals;
        }

        jacobian[i] =
          avtGradientExpression::CalculateGradient(out_grid, var.c_str());
    }

    for (int i = 0; i < nTuples; i++)
        component->SetTuple1(i, std::numeric_limits<float>::epsilon());

    //now have the jacobian - 3 arrays with 3 components.
    ComputeFTLE(jacobian, component);

    for(int i = 0; i < nTuples; ++i)
    {
        minv = std::min(component->GetTuple1(i), minv);
        maxv = std::max(component->GetTuple1(i), maxv);
    }

    component->Delete();

    jacobian[0]->Delete();
    jacobian[1]->Delete();
    jacobian[2]->Delete();
#else
    // This code shows the distance a particle traveled ... very
    // useful for debugging.
    vtkFloatArray *arr = vtkFloatArray::New();
    arr->SetNumberOfTuples(nTuples);

    for (int i = 0; i < nTuples; i++)
        arr->SetTuple1(i, -1);

    for(int i = 0; i < ics.size(); ++i)
    {
        size_t index = ics[i]->id;
        int l = (index-offset);
        if(0 <= l && l < nTuples)
        {
          avtVector diff = (((avtFTLEIC*)ics[i])->GetEndPoint()[0] -
                            ((avtFTLEIC*)ics[i])->GetStartPoint()[0]);

            arr->SetTuple1(l, diff );
        }
    }

    for(int i = 0; i < nTuples; ++i)
    {
        minv = std::min(arr->GetTuple1(i), minv);
        maxv = std::max(arr->GetTuple1(i), maxv);
    }

    arr->SetName(var.c_str());

    out_grid->GetPointData()->AddArray(arr);
    arr->Delete();
    out_grid->GetPointData()->SetActiveScalars(var.c_str());

    //done with offset, increment it for the next call to this
    //function.
    offset += nTuples;
#endif

    //Store this dataset in Cache for next time.
    std::string str = CreateCacheString();

    StoreArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                            outVarName.c_str(),domain, -1,
                            str.c_str(), out_grid);

    // Calling function must free this.
    return out_grid;
}


// ****************************************************************************
//  Method: avtFTLEFilter::ComputeRectilinearGridFTLE
//
//  Purpose:
//      Computes the FTLE on a rectilinear grid.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
//    Mark C. Miller, Wed Aug 22 19:22:40 PDT 2012
//    Fix leak of all_indices, index_counts, all_points, result_counts on 
//    rank 0 (root).
// ****************************************************************************

void
avtFTLEFilter::ComputeRectilinearGridFTLE(std::vector<avtIntegralCurve*> &ics)
{
    //variable name.
    std::string var = std::string("operators/FTLE/") + outVarName;

    //algorithm sends index to global datastructure as well as end points.
    //Send List of index into global array to rank 0
    //Send end positions into global array to rank 0

    //loop over all the intelgral curves and add it back to the
    //original list of seeds.
    intVector indices(ics.size());
    doubleVector points(ics.size()*3);

    for(size_t i=0, j=0; i<ics.size(); ++i, j+=3)
    {
        indices[i] = ics[i]->id;

        // avtVector distance = ( ((avtFTLEIC*)ics[i])->GetEndPoint() -
        //                        ((avtFTLEIC*)ics[i])->GetStartPoint() );

        // if(distance.length() > 0)
        //    std::cout << "distance: " << indices[i]
        //           << " " << distance.length() << std::endl;

        avtVector end_point = ((avtFTLEIC*)ics[i])->GetEndPoint();

        // std::cout << PAR_Rank() << " ics: " << indices[i] << " "
        //             << end_point << std::endl;

        points[j+0] = end_point[0];
        points[j+1] = end_point[1];
        points[j+2] = end_point[2];
    }

    // std::cout << PAR_Rank() << " total integral pts: "
    //        << ics.size() << std::endl;
    // std::flush(cout);

    int* all_indices = 0;
    int* index_counts = 0;
    double* all_points = 0;
    int *point_counts = 0;

    Barrier();

    CollectIntArraysOnRootProc(all_indices, index_counts,
                               &indices.front(), indices.size());

    CollectDoubleArraysOnRootProc(all_points, point_counts,
                                  &points.front(), points.size());

    Barrier();

    //root should now have index into global structure and all
    //matching end positions.
    if(PAR_Rank() != 0)
    {
        //std::cout << PAR_Rank() << " creating dummy output" << std::endl;
        avtDataTree* dummy = new avtDataTree();
        SetOutputDataTree(dummy);
    }
    else
    {
        //rank 0
        //now create a rectilinear grid.
        vtkRectilinearGrid* rect_grid = vtkRectilinearGrid::New();

        vtkFloatArray* lxcoord = vtkFloatArray::New();
        vtkFloatArray* lycoord = vtkFloatArray::New();
        vtkFloatArray* lzcoord = vtkFloatArray::New();

        rect_grid->SetDimensions(global_resolution);

        lxcoord->SetNumberOfTuples(global_resolution[0]);
        for (int i = 0; i < global_resolution[0]; i++)
        {
            double pcnt = 0;
            if (global_resolution[0] > 1)
                pcnt = ((double)i)/((double)global_resolution[0]-1);
            lxcoord->SetTuple1(i, global_bounds[0]*(1.0-pcnt) + global_bounds[1]*pcnt);
        }

        lycoord->SetNumberOfTuples(global_resolution[1]);
        for (int i = 0; i < global_resolution[1]; i++)
        {
            double pcnt = 0;
            if (global_resolution[1] > 1)
                pcnt = ((double)i)/((double)global_resolution[1]-1);
            lycoord->SetTuple1(i, global_bounds[2]*(1.0-pcnt) + global_bounds[3]*pcnt);
        }

        lzcoord->SetNumberOfTuples(global_resolution[2]);
        for (int i = 0; i < global_resolution[2]; i++)
        {
            double pcnt = 0;
            if (global_resolution[2] > 1)
                pcnt = ((double)i)/((double)global_resolution[2]-1);
            lzcoord->SetTuple1(i, global_bounds[4]*(1.0-pcnt) + global_bounds[5]*pcnt);
        }

        rect_grid->SetXCoordinates(lxcoord);
        rect_grid->SetYCoordinates(lycoord);
        rect_grid->SetZCoordinates(lzcoord);

        //cleanup
        lxcoord->Delete();
        lycoord->Delete();
        lzcoord->Delete();

        //now global grid has been created.
        size_t leafSize =
          global_resolution[0] * global_resolution[1] * global_resolution[2];

        // std::cout << "final resolution: " << PAR_Rank() << " "
        //         << global_resolution[0] << " "
        //         << global_resolution[1] << " "
        //         << global_resolution[2] << std::endl;

        vtkDataArray* jacobian[3];
        vtkFloatArray *component = vtkFloatArray::New();

        component->SetName(var.c_str());
        component->SetNumberOfTuples(leafSize);

        rect_grid->GetPointData()->AddArray(component);
        rect_grid->GetPointData()->SetActiveScalars(var.c_str());

        //calculate jacobian in parts (x,y,z).
        std::vector<avtVector> remapPoints(leafSize);

        //update remapPoints with new value bounds from integral curves.
        int par_size = PAR_Size();
        size_t total = 0;
        for(int i = 0; i < par_size; ++i)
        {
            if(index_counts[i]*3 != point_counts[i])
            {
              EXCEPTION1(VisItException,
                         "Index count does not the result count." );
            }
            total += index_counts[i];
        }

        // std::cout << "total number integrated: " << total << std::endl;

        for(int j = 0,k = 0; j < total; ++j, k += 3)
        {
            size_t index = all_indices[j];

            if(index >= leafSize)
            {
              EXCEPTION1(VisItException,
                         "More integral curves were generatated than "
                         "grid points." );
            }

            // std::cout << index << " before " << remapPoints[index]
            //        << std::endl;
            
            remapPoints[index].set( all_points[k+0],
                                    all_points[k+1],
                                    all_points[k+2]);
            
            // std::cout << PAR_Rank() << " " << index << " "
            //        << remapPoints[index] << std::endl;
            // std::cout << "middle: " << avtVector( all_points[k+0],
            //                                    all_points[k+1],
            //                                    all_points[k+2])
            //        << std::endl;
            // std::cout << index << " after " << remapPoints[index]
            //        << std::endl;
        }

        for(int i = 0; i < 3; ++i)
        {
            for(size_t j = 0; j < leafSize; ++j)
                component->SetTuple1(j, remapPoints[j][i]);

            jacobian[i] =
              avtGradientExpression::CalculateGradient(rect_grid, var.c_str());
        }

        for (size_t l = 0; l < leafSize; l++)
            component->SetTuple1(l, std::numeric_limits<float>::epsilon());

        ComputeFTLE(jacobian, component);

        //min and max values over all datasets of the tree.
        double minv = std::numeric_limits<double>::max();
        double maxv = std::numeric_limits<double>::min();

        for(size_t l = 0; l < leafSize; ++l)
        {
            minv = std::min(component->GetTuple1(l), minv);
            maxv = std::max(component->GetTuple1(l), maxv);
        }

        //cleanup.
        component->Delete();
        jacobian[0]->Delete();
        jacobian[1]->Delete();
        jacobian[2]->Delete();

        if (all_indices)  delete [] all_indices;
        if (index_counts) delete [] index_counts;
        if (all_points)   delete [] all_points;
        if (point_counts) delete [] point_counts;

        //store this dataset in Cache for next time.
        // double bounds[6];
        // rect_grid->GetBounds(bounds);

        // std::cout << "final size and bounds: "
        //        << PAR_Rank() << " " << leafSize << " "
        //        << bounds[0] << " " << bounds[1] << " " << bounds[2]
        //        << " " << bounds[3] << " " << bounds[4] << " "
        //        << bounds[5] << std::endl;

        std::string str = CreateCacheString();
        StoreArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                                outVarName.c_str(), -1, -1,
                                str.c_str(), rect_grid);

        int index = 0;//what does index mean in this context?
        avtDataTree* dt = new avtDataTree(rect_grid,index);
        int x = 0;
        dt->GetAllLeaves(x);

        // std::cout << "total leaves:: " << x << std::endl;

        SetOutputDataTree(dt);

        //set atts.
        avtDataAttributes &dataatts = GetOutput()->GetInfo().GetAttributes();
        avtExtents* e = dataatts.GetThisProcsActualDataExtents();

        double range[2];
        range[0] = minv;
        range[1] = maxv;
        e->Set(range);
    }
}


// ****************************************************************************
//  Method: avtFTLEFilter::ComputeFTLE
//
//  Purpose:
//      Computes the FTLE given a Jacobian. Which is the following:
//      log of the square root of the maximum eigen vector of the
//      jacobian * jacobian transposed with the result divided 
//      by the time or distance.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
//  Modifications:
//
//    Hank Childs, Fri Sep  7 15:47:12 PDT 2012
//    Convert calculation to double precision, which prevents a "cliff" from
//    too large epsilon associated with float.
//
// ****************************************************************************

void avtFTLEFilter::ComputeFTLE(vtkDataArray *jacobian[3], vtkDataArray *result)
{
    size_t nTuples = result->GetNumberOfTuples();

    for(size_t l = 0; l < nTuples; ++l)
    {
        double * j0 = jacobian[0]->GetTuple3(l);
        double * j1 = jacobian[1]->GetTuple3(l);
        double * j2 = jacobian[2]->GetTuple3(l);

        //x,y,z components compute left,right
        avtVector dx(j0[0],j1[0],j2[0]);
        //x,y,z components compute top,bottom
        avtVector dy(j0[1],j1[1],j2[1]);
        //x,y,z components compute front,back
        avtVector dz(j0[2],j1[2],j2[2]);

        // std::cout << dx << " " << dy << " " << dz << std::endl;

        // Compute the 
        //J*J^T
        //float a = dx.dot(dx), b = dx.dot(dy), c = dx.dot(dz);
        //float d = dy.dot(dy), e = dy.dot(dz), f = dz.dot(dz);

        double a = dx.x*dx.x + dx.y*dx.y + dx.z*dx.z;
        double b = dx.x*dy.x + dx.y*dy.y + dx.z*dy.z;
        double c = dx.x*dz.x + dx.y*dz.y + dx.z*dz.z;
        double d = dy.x*dy.x + dy.y*dy.y + dy.z*dy.z;
        double e = dy.x*dz.x + dy.y*dz.y + dy.z*dz.z;
        double f = dz.x*dz.x + dz.y*dz.y + dz.z*dz.z;
        double x = ( a + d + f ) / 3.0f;

        a -= x;
        d -= x;
        f -= x;

        double q = (a*d*f + b*e*c + c*b*e - c*d*c - e*e*a - f*b*b) / 2.0f;
        double r = (a*a + b*b + c*c + b*b + d*d + e*e + c*c + e*e + f*f);
        r /= 6.0f;

        double D = (r*r*r - q*q);
        double phi = 0.0f;

        // std::cout << a << " " << b << " " << c << " " << d << " "
        //           << e << " " << f << " " << x << " " << q << " "
        //           << r << std::endl;

        if( D < std::numeric_limits<double>::epsilon())
            phi = 0.0f;
        else
        {
            phi = atanf( sqrtf(D)/q ) / 3.0f;

            if( phi < 0 )
                phi += M_PI;
        }

        const double sqrt3 = sqrtf(3.0f);
        const double sqrtr = sqrtf(r);

        double sinphi = 0.0f, cosphi = 0.0f;
        sinphi = sinf(phi);
        cosphi = cosf(phi);

        double lambda = 1.0f;
        lambda = std::max( lambda, x + 2.0f*sqrtr*cosphi );
        lambda = std::max( lambda, x - sqrtr*(cosphi + sqrt3*sinphi) );
        lambda = std::max( lambda, x - sqrtr*(cosphi - sqrt3*sinphi) );

        // lambda = log( sqrtf( lambda ) ) + 0.000000001;
        // std::cout << "s: " << lambda << std::endl;
        lambda = log( sqrtf( lambda ) );

        if( doTime )
          lambda /= maxTime;
        else if( doDistance )
          lambda /= maxDistance;
        else if( doSize )
          lambda /= maxSize;

        // std::cout << "lambda :" << lambda << std::endl;
        result->SetTuple1(l, lambda);
    }
}


// ****************************************************************************
//  Method: avtFTLEFilter::CreateFSLEDataTree
//
//  Purpose:
//      Create the output tree for the whole data set, using the 
//      input tree using the blocks native resolution.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

avtDataTree_p
avtFTLEFilter::CreateFSLEDataTree(avtDataTree_p inDT)
{
    if (*inDT == NULL)
      return 0;
    
    int nc = inDT->GetNChildren();
    
    if (nc <= 0 && !inDT->HasData())
    {
      return 0;
    }

    if (nc == 0)
    {
        //variable name.
        std::string var = std::string("operators/FTLE/") + outVarName;

        //
        // there is only one dataset to process
        //
        vtkDataSet *in_ds = inDT->GetDataRepresentation().GetDataVTK();

        if (in_ds->GetDataObjectType() != VTK_RECTILINEAR_GRID)
        {
          EXCEPTION1(VisItException,
                     "Can only compute FSLE on rectilinear meshs. "
                     "The native mesh is not a rectilienar mesh. "
                     "Please use a 'Source type' of 'Regular grid' instead.");
        }

        //create new instance from old.
        // vtkDataSet* out_ds = in_ds->NewInstance();
        // out_ds->ShallowCopy(in_ds);
        // int nTuples = in_ds->GetNumberOfPoints();


        int dims[3];
        
        ((vtkRectilinearGrid*)in_ds)->GetDimensions(dims);

        //now create a rectilinear grid.
        
        // The grid is stored so not to be created as each curve is
        // extended.
        vtkRectilinearGrid *out_ds = vtkRectilinearGrid::New();
        out_ds->SetDimensions(dims);
        
        vtkFloatArray* lxcoord = vtkFloatArray::New();
        vtkFloatArray* lycoord = vtkFloatArray::New();
        vtkFloatArray* lzcoord = vtkFloatArray::New();
        
        //Note this grid is a uniform gird which allows the
        //avtGradientExpression to be used to get the distances
        //between integral curves.
        lxcoord->SetNumberOfTuples(dims[0]);
        for (int i = 0; i < dims[0]; i++)
          lxcoord->SetTuple1(i, i);
      
        lycoord->SetNumberOfTuples(dims[1]);
        for (int i = 0; i < dims[1]; i++)
          lycoord->SetTuple1(i, i);
      
        lzcoord->SetNumberOfTuples(dims[2]);
        for (int i = 0; i < dims[2]; i++)
          lzcoord->SetTuple1(i, i);
      
        out_ds->SetXCoordinates(lxcoord);
        out_ds->SetYCoordinates(lycoord);
        out_ds->SetZCoordinates(lzcoord);
        
        //cleanup
        lxcoord->Delete();
        lycoord->Delete();
        lzcoord->Delete();

        int nTuples = dims[0] * dims[1] * dims[2];

        // Create storage for the components that need to be used
        // for calculating the exponent. All arrays but the exponent
        // array will be deleted when done.
        vtkFloatArray *exponents = vtkFloatArray::New();
        exponents->SetName(var.c_str());
        exponents->SetNumberOfTuples(nTuples);
        out_ds->GetPointData()->AddArray(exponents);
        // Will set the exponents to be the active scalars when
        // finished. In the mean time the component is the working
        // active scalars.
//      out_ds->GetPointData()->SetActiveScalars(var.c_str());

        vtkFloatArray *component = vtkFloatArray::New();
        component->SetName("component");
        component->SetNumberOfTuples(nTuples);
        out_ds->GetPointData()->AddArray(component);
        out_ds->GetPointData()->SetActiveScalars("component");
        
        vtkFloatArray *times = vtkFloatArray::New();
        times->SetName("times");
        times->SetNumberOfTuples(nTuples);
        out_ds->GetPointData()->AddArray(times);

        vtkFloatArray *lengths = vtkFloatArray::New();
        lengths->SetName("lengths");
        lengths->SetNumberOfTuples(nTuples);
        out_ds->GetPointData()->AddArray(lengths);

        // The mask array is a tally to indicate whether a curve
        // needs to have additional integration. WHen the tally
        // reachs a count of seven no additional integration is
        // required. (Sseven == six neighbors and itself).
        vtkIntArray *mask = vtkIntArray::New();
        mask->SetName("mask");
        mask->SetNumberOfTuples(nTuples);
        out_ds->GetPointData()->AddArray(mask);

        for (size_t l = 0; l < nTuples; l++)
        {
          exponents->SetTuple1(l, std::numeric_limits<float>::min());
          mask->SetTuple1(l, 0 );
        }
        
        // Preincraement the mask as boundary nodes will not be
        // accessed fully.
        int k1 = 0;
        int k_1 = global_resolution[2]-1;

        // Z plane
        for(int j = 0; j < global_resolution[1]; ++j)
        {
          for(int i = 0; i < global_resolution[0]; ++i)
          {
            Increment( i, j, k1,  mask,
                       global_resolution[0],
                       global_resolution[1],
                       global_resolution[2] );
            Increment( i, j, k_1, mask,
                       global_resolution[0],
                       global_resolution[1],
                       global_resolution[2] );
          }
        }
          
        int j1 = 0;
        int j_1 = global_resolution[1]-1;
          
        for(int k = 0; k < global_resolution[2]; ++k)
        {
          for(int i = 0; i < global_resolution[0]; ++i)
          {
            Increment( i, j1,  k, mask,
                       global_resolution[0],
                       global_resolution[1],
                       global_resolution[2] );
            Increment( i, j_1, k, mask,
                       global_resolution[0],
                       global_resolution[1],
                       global_resolution[2] );
          }
        }

        int i1 = 0;
        int i_1 = global_resolution[0]-1;
          
        for(int k = 0; k < global_resolution[2]; ++k)
        {
          for(int j = 0; j < global_resolution[1]; ++j)
          {
            Increment( i1, j,  k, mask,
                       global_resolution[0],
                       global_resolution[1],
                       global_resolution[2] );
            Increment( i_1, j, k, mask,
                       global_resolution[0],
                       global_resolution[1],
                       global_resolution[2] );
          }
        }
          
        //cleanup
        exponents->Delete();
        component->Delete();
        times->Delete();
        lengths->Delete();
        mask->Delete();
        
        int dom = inDT->GetDataRepresentation().GetDomain();
        std::string label = inDT->GetDataRepresentation().GetLabel();
        avtDataTree_p rv = new avtDataTree(out_ds, dom, label);
        out_ds->Delete();
        return rv;
    }
    else
    {
      //
      // there is more than one input dataset to process
      // and we need an output datatree for each
      //
      avtDataTree_p *outDT = new avtDataTree_p[nc];
      for (int j = 0; j < nc; j++)
      {
          if (inDT->ChildIsPresent(j))
            outDT[j] = CreateFSLEDataTree(inDT->GetChild(j));
          else
            outDT[j] = NULL;
      }
      avtDataTree_p rv = new avtDataTree(nc, outDT);
      delete [] outDT;
      return rv;
    }
}


// ****************************************************************************
//  Method: avtFTLEFilter::CreateFSLEDataSet
//
//  Purpose:
//      Create the output tree for the whole data set, using the 
//      input tree using the blocks native resolution.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

vtkDataSet*
avtFTLEFilter::CreateFSLEDataSet()
{
  //rank 0
  //variable name.
  std::string var = std::string("operators/FTLE/") + outVarName;

  //now create a rectilinear grid.
  size_t nTuples =
    global_resolution[0] * global_resolution[1] * global_resolution[2];

          
  // The grid is stored so not to be created as each curve is
  // extended.
  vtkRectilinearGrid* rect_grid = vtkRectilinearGrid::New();

  rect_grid->SetDimensions(global_resolution);
      
  vtkFloatArray* lxcoord = vtkFloatArray::New();
  vtkFloatArray* lycoord = vtkFloatArray::New();
  vtkFloatArray* lzcoord = vtkFloatArray::New();

  //Note this grid is a uniform gird which allows the
  //avtGradientExpression to be used to get the distances
  //between integral curves.
  lxcoord->SetNumberOfTuples(global_resolution[0]);
  for (int i = 0; i < global_resolution[0]; i++)
    lxcoord->SetTuple1(i, i);
      
  lycoord->SetNumberOfTuples(global_resolution[1]);
  for (int i = 0; i < global_resolution[1]; i++)
    lycoord->SetTuple1(i, i);
      
  lzcoord->SetNumberOfTuples(global_resolution[2]);
  for (int i = 0; i < global_resolution[2]; i++)
    lzcoord->SetTuple1(i, i);
      
  rect_grid->SetXCoordinates(lxcoord);
  rect_grid->SetYCoordinates(lycoord);
  rect_grid->SetZCoordinates(lzcoord);
        
  //cleanup
  lxcoord->Delete();
  lycoord->Delete();
  lzcoord->Delete();

  // std::cout << "final resolution: " << PAR_Rank() << " "
  //         << global_resolution[0] << " "
  //         << global_resolution[1] << " "
  //         << global_resolution[2] << std::endl;

  // Create storage for the components that need to be used
  // for calculating the exponent. All arrays but the exponent
  // array will be deleted when done.
  vtkFloatArray *exponents = vtkFloatArray::New();
  exponents->SetName(var.c_str());
  exponents->SetNumberOfTuples(nTuples);
  rect_grid->GetPointData()->AddArray(exponents);
  // Will set the exponents to be the active scalars when
  // finished. In the mean time the component is the working
  // active scalars.
  // rect_grid->GetPointData()->SetActiveScalars(var.c_str());

  vtkFloatArray *component = vtkFloatArray::New();
  component->SetName("component");
  component->SetNumberOfTuples(nTuples);
  rect_grid->GetPointData()->AddArray(component);
  rect_grid->GetPointData()->SetActiveScalars("component");

  vtkFloatArray *times = vtkFloatArray::New();
  times->SetName("times");
  times->SetNumberOfTuples(nTuples);
  rect_grid->GetPointData()->AddArray(times);

  vtkFloatArray *lengths = vtkFloatArray::New();
  lengths->SetName("lengths");
  lengths->SetNumberOfTuples(nTuples);
  rect_grid->GetPointData()->AddArray(lengths);

  // The mask array is a tally to indicate whether a curve
  // needs to have additional integration. WHen the tally
  // reachs a count of seven no additional integration is
  // required. (Sseven == six neighbors and itself).
  vtkIntArray *mask = vtkIntArray::New();
  mask->SetName("mask");
  mask->SetNumberOfTuples(nTuples);
  rect_grid->GetPointData()->AddArray(mask);

  for (size_t l=0; l<nTuples; l++)
  {
    exponents->SetTuple1(l, std::numeric_limits<float>::min());
    mask->SetTuple1(l, 0 );
  }
          
  // Preincraement the mask as boundary nodes will not be accessed
  // fully.
  int k1 = 0;
  int k_1 = global_resolution[2]-1;
  
  // Z plane
  for(int j = 0; j < global_resolution[1]; ++j)
  {
    for(int i = 0; i < global_resolution[0]; ++i)
    {
      Increment( i, j, k1,  mask,
                 global_resolution[0],
                 global_resolution[1],
                 global_resolution[2] );
      Increment( i, j, k_1, mask,
                 global_resolution[0],
                 global_resolution[1],
                 global_resolution[2] );
    }
  }
  
  int j1 = 0;
  int j_1 = global_resolution[1]-1;
  
  for(int k = 0; k < global_resolution[2]; ++k)
   {
     for(int i = 0; i < global_resolution[0]; ++i)
     {
       Increment( i, j1,  k, mask,
                  global_resolution[0],
                  global_resolution[1],
                  global_resolution[2] );
       Increment( i, j_1, k, mask,
                  global_resolution[0],
                  global_resolution[1],
                  global_resolution[2] );
     }
   }
  
  int i1 = 0;
  int i_1 = global_resolution[0]-1;
  
  for(int k = 0; k < global_resolution[2]; ++k)
  {
    for(int j = 0; j < global_resolution[1]; ++j)
    {
      Increment( i1, j,  k, mask,
                 global_resolution[0],
                 global_resolution[1],
                 global_resolution[2] );
      Increment( i_1, j, k, mask,
                 global_resolution[0],
                 global_resolution[1],
                 global_resolution[2] );
    }
  }
  
  //cleanup
  exponents->Delete();
  component->Delete();
  times->Delete();
  lengths->Delete();
  mask->Delete();

  return rect_grid;
}
  

// ****************************************************************************
//  Method: avtFTLEFilter::ComputeNativeMeshFSLE
//
//  Purpose:
//      Computes the FSLE on a native resolution grid.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
//    Mark C. Miller, Wed Aug 22 19:22:40 PDT 2012
//    Fix leak of all_indices, index_counts, all_result, result_counts on 
//    rank 0 (root).
// ****************************************************************************

bool
avtFTLEFilter::ComputeNativeMeshFSLE(std::vector<avtIntegralCurve*> &ics)
{
    int offset = 0;

    if( *fsle_dt == NULL )
    {
      fsle_dt = CreateFSLEDataTree(GetInputDataTree());
      
      if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
        if (PAR_Rank() != 0)
          fsle_dt = new avtDataTree();

      SetOutputDataTree(fsle_dt);
    }

    return MultiBlockComputeFSLE(fsle_dt, ics, offset);
}


// ****************************************************************************
//  Method: avtFTLEFilter::MultiBlockComputeFSLE
//
//  Purpose:
//      Computes the FTLE for the whole data set, using the 
//      final particle locations, at the blocks native resolution.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

bool
avtFTLEFilter::MultiBlockComputeFSLE(avtDataTree_p outDT,
                                     std::vector<avtIntegralCurve*> &ics,
                                     int &offset)
{
    if ( *outDT == NULL)
        return true;

    int nc = outDT->GetNChildren();

    if( nc <= 0 && !outDT->HasData())
        return true;

    if (nc == 0)
    {
        //
        // there is only one dataset to process
        //
        vtkDataSet *out_ds = outDT->GetDataRepresentation().GetDataVTK();

        return SingleBlockComputeFSLE( out_ds, ics, offset );
    }
    else
    {
      bool haveAllExponents = true;

      //
      // there is more than one input dataset to process
      // and we need an output datatree for each
      //
      for (int j = 0; j < nc; j++)
      {
        if (outDT->ChildIsPresent(j) )
        {
          if( MultiBlockComputeFSLE( outDT->GetChild(j), ics, offset ) == false )
            haveAllExponents = false;
        }
      }

      return haveAllExponents;
    }
}


// ****************************************************************************
//  Method: avtFTLEFilter::SingleBlockComputeFSLE
//
//  Purpose:
//      Computes the FSLE for a single block of a data set, using the 
//      final particle locations, at the blocks native resolution.
//
//  Arguments:
//      out_ds  The block to calculate the FSLE on
//      ics     The list of particles for all blocks on this MPI task.
//
//  Returns:    The new version of in_ds that includes the FTLE scalar
//              variable.  The calling function is responsible for dereferencing
//              this VTK object.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
//    Hank Childs, Tue Feb  5 08:12:33 PST 2013
//    Fix parallelization bug and memory leak.
//
// ****************************************************************************

bool
avtFTLEFilter::SingleBlockComputeFSLE(vtkDataSet *out_ds,
                                      std::vector<avtIntegralCurve*> &ics,
                                      int &offset)
{
    //variable name.
    std::string var = std::string("operators/FTLE/") + outVarName;

    int nTuples = out_ds->GetNumberOfPoints();
    
    int dims[3];

    if (out_ds->GetDataObjectType() == VTK_RECTILINEAR_GRID)
    {
      ((vtkRectilinearGrid*)out_ds)->GetDimensions(dims);
    }      
    else
    {
      EXCEPTION1(VisItException,
                 "Can only compute SingleBlockComputeFSLE on rectilinear grids. ");
    }

    // Get the stored data arrays
    vtkDataArray* jacobian[3];
    
    vtkFloatArray *exponents = (vtkFloatArray *)
      out_ds->GetPointData()->GetArray(var.c_str());
    vtkFloatArray *component = (vtkFloatArray *)
      out_ds->GetPointData()->GetArray("component");
    vtkFloatArray *times = (vtkFloatArray *)
      out_ds->GetPointData()->GetArray("times");
    vtkFloatArray *lengths = (vtkFloatArray *)
      out_ds->GetPointData()->GetArray("lengths");
    vtkIntArray *mask = (vtkIntArray *)
      out_ds->GetPointData()->GetArray("mask");
    
    // Storage for the points, times, and lengths
    std::vector<avtVector> remapPoints(nTuples);
    std::vector<double> remapTimes(nTuples);
    std::vector<double> remapLengths(nTuples);

    if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
    {
        // The parallel synchronization for when data is replicated involves
        // a sum across all processors.  So we want remapPoints to have the
        // location of the particle on one processor, and zero on the rest.
        // Do that here.
        // Special care is needed for the case where the particle never
        // advected.  Then we need to put the initial location on just one
        // processor.  We do this on rank 0.
        std::vector<int> iHavePoint(nTuples, 0);
        std::vector<int> anyoneHasPoint;

        for (size_t idx = 0; idx < ics.size(); idx++)
        {
            size_t index = ics[idx]->id;
            size_t l = (index-offset);
            if(l >= 0 && l < remapPoints.size())
            {
                iHavePoint[l] = 1;
            }
        }

        UnifyMaximumValue(iHavePoint, anyoneHasPoint);
        avtVector zero;
        zero.x = zero.y = zero.z = 0.;
        for (size_t i = 0; i < nTuples; i++)
            if (PAR_Rank() == 0 && !anyoneHasPoint[i])
            {
                remapPoints[i] = seedPoints.at(offset + i);
                remapTimes[i] = 0;
                remapLengths[i] = 0;
            }
            else
            {
                remapPoints[i] = zero;
                remapTimes[i] = 0;
                remapLengths[i] = 0;
            }
    }
    else
    {
        //copy the original seed points
        for(size_t i = 0; i < remapPoints.size(); ++i)
        {
            remapPoints[i] = seedPoints.at(offset + i);
            remapTimes[i] = 0;
            remapLengths[i] = 0;
        }
    }

    for(int i = 0; i < ics.size(); ++i)
    {
        avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];

        size_t index = ic->id;
        int l = (index-offset);

        //std::cout << "l = " << l << " " << nTuples << std::endl;
        if(0 <= l && l < remapPoints.size())
        {
          // remapPoints[l] = ((avtFTLEIC*)ics[i])->GetEndPoint() -
          //                ((avtFTLEIC*)ics[i])->GetStartPoint();

          remapPoints.at(l) = ic->GetEndPoint();

          if( doPathlines )
            remapTimes.at(l) = ic->GetTime() - seedTime0;
          else
            remapTimes.at(l) = ic->GetTime();

          remapLengths.at(l) = ic->GetDistance();
        }
    }

    //use static function in avtGradientExpression to calculate
    //gradients.  since this function only does scalar, break our
    //vectors into scalar components and calculate one at a time.

    for(int i = 0; i < 3; ++i)
    {
        for(size_t j = 0; j < nTuples; ++j)
            component->SetTuple1(j, remapPoints[j][i]);

        if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
        {
            float *newvals = new float[nTuples];
            float *origvals = (float *) component->GetVoidPointer(0);
            SumFloatArrayAcrossAllProcessors(origvals, newvals, nTuples);
            // copy newvals back into origvals
            memcpy(origvals, newvals, nTuples*sizeof(float));
            delete [] newvals;
        }

        jacobian[i] =
          avtGradientExpression::CalculateGradient(out_ds, var.c_str());
    }

    // Store the times and lengths for the exponent.
    for(size_t l = 0; l < nTuples; ++l)
    {
      times->SetTuple1(l, remapTimes[l]);
      lengths->SetTuple1(l, remapLengths[l]);
    }

    // Compute the FSLE
    ComputeFSLE(jacobian, times, lengths, exponents, mask,
                dims[0], dims[1], dims[2]);

    jacobian[0]->Delete();
    jacobian[1]->Delete();
    jacobian[2]->Delete();

    bool haveAllExponents = true;

    // For each integral curve check it's mask value to see it
    // additional integration is required.
    for(size_t i=0; i<ics.size(); ++i)
    {
      avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];

      size_t index = ic->id;
      int l = (index-offset);

      if( mask->GetTuple1( l ) < 7 )
      {
        ic->maxSteps++;
        ic->status.ClearTerminationMet();
      }

      // Check to see if all exponents have been found.
      if( exponents->GetTuple1(l) == std::numeric_limits<float>::min() &&
          ic->maxSteps < maxSteps )
        haveAllExponents = false;
    }
    
    //done with offset, increment it for the next call to this
    //function.
    offset += nTuples;

    return haveAllExponents;
}


// ****************************************************************************
//  Method: avtFTLEFilter::ComputeRectilinearGridFSLE
//
//  Purpose:
//      Computes the FSLE on a rectilinear grid.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//    Mark C. Miller, Wed Aug 22 19:22:40 PDT 2012
//    Fix leak of all_indices, index_counts, all_result, result_counts on 
//    rank 0 (root).
// ****************************************************************************

bool
avtFTLEFilter::ComputeRectilinearGridFSLE(std::vector<avtIntegralCurve*> &ics)
{
//  std::cerr << "Computing ... " << std::endl;

    //algorithm sends index to global datastructure as well as end points.
    //Send List of index into global array to rank 0
    //Send end positions into global array to rank 0

    //loop over all the intelgral curves and add it back to the
    //original list of seeds.
    intVector indices(ics.size());
    doubleVector points(ics.size()*3);
    doubleVector times(ics.size());
    doubleVector lengths(ics.size());

    for(size_t i=0, j=0; i<ics.size(); ++i, j+=3)
    {
        avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];

        indices[i] = ic->id;

        avtVector point = ic->GetEndPoint();

        points[j+0] = point[0];
        points[j+1] = point[1];
        points[j+2] = point[2];

        if( doPathlines )
          times[i] = ic->GetTime() - seedTime0;
        else
          times[i] = ic->GetTime();

        lengths[i] = ic->GetDistance();

        // std::cout << PAR_Rank() << " ics: " << indices[i] << " "
        //             << end_point << std::endl;
    }

    // std::cout << PAR_Rank() << " total integral pts: "
    //        << ics.size() << std::endl;
    // std::flush(cout);

    int* all_indices = 0;
    int* index_counts = 0;

    double* all_points = 0;
    int *point_counts = 0;

    double* all_times = 0;
    int *time_counts = 0;

    double* all_lengths = 0;
    int *length_counts = 0;

    Barrier();

    CollectIntArraysOnRootProc(all_indices, index_counts,
                               &indices.front(), indices.size());

    CollectDoubleArraysOnRootProc(all_points, point_counts,
                                  &points.front(), points.size());

    CollectDoubleArraysOnRootProc(all_times, time_counts,
                                  &times.front(), times.size());

    CollectDoubleArraysOnRootProc(all_lengths, length_counts,
                                  &lengths.front(), lengths.size());

    Barrier();

    //root should now have index into global structure and all
    //matching end positions.
    if(PAR_Rank() != 0)
    {
        return true;
    }
    else
    {
        //variable name.
        std::string var = std::string("operators/FTLE/") + outVarName;

        //now global grid has been created.
        if( fsle_ds == 0 )
          fsle_ds = CreateFSLEDataSet();

        // Get the stored data arrays
        vtkDataArray* jacobian[3];

        vtkFloatArray *exponents = (vtkFloatArray *)
          fsle_ds->GetPointData()->GetArray(var.c_str());
        vtkFloatArray *component = (vtkFloatArray *)
          fsle_ds->GetPointData()->GetArray("component");
        vtkFloatArray *times = (vtkFloatArray *)
          fsle_ds->GetPointData()->GetArray("times");
        vtkFloatArray *lengths = (vtkFloatArray *)
          fsle_ds->GetPointData()->GetArray("lengths");
        vtkIntArray *mask = (vtkIntArray *)
          fsle_ds->GetPointData()->GetArray("mask");

        size_t nTuples = exponents->GetNumberOfTuples();

        // Storage for the points, times, and lengths
        std::vector<avtVector> remapPoints(nTuples);
        std::vector<double> remapTimes(nTuples);
        std::vector<double> remapLengths(nTuples);

        //update remapPoints with new value bounds from integral curves.
        int par_size = PAR_Size();
        size_t total = 0;
        for(int i = 0; i < par_size; ++i)
        {
            if(index_counts[i]*3 != point_counts[i] ||
               index_counts[i]   != time_counts[i] ||
               index_counts[i]   != length_counts[i])
            {
              EXCEPTION1(VisItException,
                         "Index count does not the result count." );
            }

            total += index_counts[i];
        }

        // std::cout << "total number integrated: " << total << std::endl;

        for(int j=0, k=0; j<total; ++j, k+=3)
        {
            size_t index = all_indices[j];

            if(nTuples <= index)
            {
              EXCEPTION1(VisItException,
                         "More integral curves were generatated than "
                         "grid points." );
            }

            // std::cout << index << " before " << remapPoints[index]
            //        << std::endl;
            
            remapPoints[index].set( all_points[k+0],
                                    all_points[k+1],
                                    all_points[k+2]);

            remapTimes[index] = all_times[j];
            remapLengths[index] = all_lengths[j];

            // std::cout << PAR_Rank() << " " << index << " "
            //        << remapPoints[index] << std::endl;
            // std::cout << "middle: " << avtVector( all_points[k+0],
            //                                    all_points[k+1],
            //                                    all_points[k+2])
            //        << std::endl;
            // std::cout << index << " after " << remapPoints[index]
            //        << std::endl;
        }

        //calculate jacobian in parts (x,y,z).  The jacobian really
        //contains the xyz distance components in parts which when
        //combined given the distance between the end points
        //neighboring integral curves.
        for(int i = 0; i < 3; ++i)
        {
            // Store the point component by component
            for(size_t l=0; l<nTuples; ++l)
                component->SetTuple1(l, remapPoints[l][i]);

            jacobian[i] =
              avtGradientExpression::CalculateGradient(fsle_ds, "component");
        }

        // Store the times and lengths for the exponent.
        for(size_t l=0; l<nTuples; ++l)
        {
          times->SetTuple1(l, remapTimes[l]);
          lengths->SetTuple1(l, remapLengths[l]);
        }

        // Compute the FSLE
        ComputeFSLE(jacobian, times, lengths, exponents, mask,
                    global_resolution[0],
                    global_resolution[1],
                    global_resolution[2] );

        jacobian[0]->Delete();
        jacobian[1]->Delete();
        jacobian[2]->Delete();

        bool haveAllExponents = true;

        // For each integral curve check it's mask value to see it
        // additional integration is required.
        for(size_t i=0; i<ics.size(); ++i)
        {
          avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];

          size_t l = ic->id; // The curve id is the index into the VTK data.

          if( mask->GetTuple1( l ) < 7 )
          {
            ic->maxSteps++;
            ic->status.ClearTerminationMet();
          }

          // Check to see if all exponents have been found.
          if( exponents->GetTuple1(l) == std::numeric_limits<float>::min() &&
              ic->maxSteps < maxSteps )
            haveAllExponents = false;
        }

        //cleanup.
        if (all_indices)   delete [] all_indices;
        if (index_counts)  delete [] index_counts;

        if (all_points)    delete [] all_points;
        if (point_counts)  delete [] point_counts;

        if (all_times)    delete [] all_times;
        if (time_counts)  delete [] time_counts;

        if (all_lengths)    delete [] all_lengths;
        if (length_counts)  delete [] length_counts;

        return haveAllExponents;
    }
}


// ****************************************************************************
//  Method: avtFTLEFilter::ComputeFSLE
//
//  Purpose:
//      Computes the FSLE given a Jacobian.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

void avtFTLEFilter::ComputeFSLE(vtkDataArray *jacobian[3],              
                                vtkDataArray *times,
                                vtkDataArray *lengths,
                                vtkDataArray *exponents,
                                vtkDataArray *mask,
                                int x_max, int y_max, int z_max )
{
  //min and max values over all datasets of the tree.
  // double minv = std::numeric_limits<double>::max();
  // double maxv = std::numeric_limits<double>::min();

  size_t l = 0;

  for(int k=0, k1=1, k_1=-1; k<z_max; ++k, ++k1, ++k_1)
  {
    for(int j=0, j1=1, j_1=-1; j<y_max; ++j, ++j1, ++j_1)
    {
      for(int i=0, i1=1, i_1=-1; i<x_max; ++i, ++i1, ++i_1)
      {
        double lambda = exponents->GetTuple1(l);

        // If the exponent was previously set skip checking it.
        if( lambda == std::numeric_limits<float>::min() )
        {
          // Check for a curve that has terminated which will not have
          // taken a step forward or backwards.
          if( floor( fabs(times->GetTuple1(l)) / maxStepLength + 0.5) !=
              numSteps )
          {
            // If a curve has terminated set the exponent to zero.
            lambda = 0;
            exponents->SetTuple1(l, lambda);
            mask->SetTuple1( l, 7 );
            
            // Counter to note that the neighbors do
            // not need additon advection.
            Increment( i1,   j,  k,   mask, x_max, y_max, z_max );
            Increment( i_1,  j,  k,   mask, x_max, y_max, z_max );
            Increment( i,   j1,  k,   mask, x_max, y_max, z_max );
            Increment( i,   j_1, k,   mask, x_max, y_max, z_max );
            Increment( i,   j,   k1,  mask, x_max, y_max, z_max );
            Increment( i,   j,   k_1, mask, x_max, y_max, z_max );
          }

          // Check the distances between neighbors.
          else
          {
            double *jac0 = jacobian[0]->GetTuple3(l);
            double *jac1 = jacobian[1]->GetTuple3(l);
            double *jac2 = jacobian[2]->GetTuple3(l);

            avtVector dx, dy, dz;

            // It is possible that one neighbor has terminated but not
            // the other. However, there is not a way to detected this
            // case when using the gradient expression. As such,
            // currently both neighbors must be valid.

            //x,y,z components compute left,right
            if( Value( i,   j, k, times, x_max, y_max, z_max ) ==
                Value( i1,  j, k, times, x_max, y_max, z_max ) &&
                Value( i,   j, k, times, x_max, y_max, z_max ) ==
                Value( i_1, j, k, times, x_max, y_max, z_max ) )
              dx = avtVector(jac0[0],jac1[0],jac2[0]);
            else
              dx = avtVector(0,0,0);
            
            //x,y,z components compute top,bottom
            if( Value( i, j,   k, times, x_max, y_max, z_max ) ==
                Value( i, j1,  k, times, x_max, y_max, z_max ) &&
                Value( i, j,   k, times, x_max, y_max, z_max ) ==
                Value( i, j_1, k, times, x_max, y_max, z_max ) )
              dy = avtVector(jac0[1],jac1[1],jac2[1]);
            else
              dy = avtVector(0,0,0);
            
            //x,y,z components compute front,back
            if( Value( i, j, k,   times, x_max, y_max, z_max ) ==
                Value( i, j, k1,  times, x_max, y_max, z_max ) &&
                Value( i, j, k,   times, x_max, y_max, z_max ) ==
                Value( i, j, k_1, times, x_max, y_max, z_max ) )
              dz = avtVector(jac0[2],jac1[2],jac2[2]);
            else
              dz = avtVector(0,0,0);

            double size = std::max( std::max( dx.length(), dy.length() ),
                                    dz.length() );

            minSizeValue = std::min(size, minSizeValue);
            maxSizeValue = std::max(size, maxSizeValue);
        
            // Record the Lynapouv exponent if the max
            // size has been reached.
            if( maxSize < size )
            {
              lambda =
                log( size / lengths->GetTuple1(l) ) / fabs(times->GetTuple1(l));
              
              exponents->SetTuple1(l, lambda);

              // Counter to note that the neighbors do
              // not need additon advection.
              Increment( i,    j,  k,   mask, x_max, y_max, z_max );
              Increment( i1,   j,  k,   mask, x_max, y_max, z_max );
              Increment( i_1,  j,  k,   mask, x_max, y_max, z_max );
              Increment( i,   j1,  k,   mask, x_max, y_max, z_max );
              Increment( i,   j_1, k,   mask, x_max, y_max, z_max );
              Increment( i,   j,   k1,  mask, x_max, y_max, z_max );
              Increment( i,   j,   k_1, mask, x_max, y_max, z_max );
            }
          }
        }

        // minv = std::min(lambda, minv);
        // maxv = std::max(lambda, maxv);  
        
        ++l;
      }
    }
  }
}


// ****************************************************************************
//  Method: avtFTLEFilter::InBounds
//
//  Purpose:
//      Returns true if indexes are in bounds.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

int avtFTLEFilter::InBounds( int x, int y, int z,
                             int x_max, int y_max, int z_max )
{
  if( 0 <= x && x < x_max &&
      0 <= y && y < y_max &&
      0 <= z && z < z_max )
    return (z * y_max + y) * x_max + x;
  else
    return -1;
}


// ****************************************************************************
//  Method: avtFTLEFilter::Increment
//
//  Purpose:
//      Increments a counter
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

void avtFTLEFilter::Increment( int x, int y, int z, vtkDataArray *array,
                               int x_max, int y_max, int z_max )
{
  int l = InBounds( x, y, z, x_max, y_max, z_max );
  
  if( 0 <= l && l < array->GetNumberOfTuples() )
  {      
    int cc = array->GetTuple1(l);
    ++cc;
    array->SetTuple1(l, cc);
  }
}


// ****************************************************************************
//  Method: avtFTLEFilter::Value
//
//  Purpose:
//      Returns the value for a coordinate
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

bool avtFTLEFilter::Value( int x, int y, int z, vtkDataArray *array,
                                int x_max, int y_max, int z_max )
{
  int l = InBounds( x, y, z, x_max, y_max, z_max );

  if( 0 <= l && l < array->GetNumberOfTuples() )
    return array->GetTuple1(l);
  else
    return 0;
}


// ****************************************************************************
//  Method: avtFTLEFilter::CreateNativeMeshFSLEOutput
//
//  Purpose:
//      Computes the FSLE output (via sub-routines) after the PICS filter
//      has calculated the particle positions.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

void 
avtFTLEFilter::CreateNativeMeshFSLEOutput(std::vector<avtIntegralCurve*> &ics)
{
    //accumulate all of the points then do jacobian?
    //or do jacobian then accumulate?
    //picking the first.

    int    offset = 0;
    double minv   = std::numeric_limits<double>::max();
    double maxv   = std::numeric_limits<double>::min();
    int    count  = 0;

    MultiBlockCreateFSLEOutput(GetInputDataTree(), GetDataTree(),
                               ics, offset, minv, maxv, count);

    int nTuples = ics.size();

    if( 1 || count <= nTuples/10 )
    {
      if( minSizeValue == std::numeric_limits<double>::max() )
        minSizeValue = 0.0;
      
      if( maxSizeValue == std::numeric_limits<double>::min() )
        maxSizeValue = 0.0;
      
      char str[1028];
      
      SNPRINTF(str, 1028, "\n%d%% of the nodes (%d of %d nodes) "
               "exaimed produced a valid exponent (%f to %f). "
               "This may be due to too large of a size limit (%f), "
               "too small of an integration step (%f), or "
               "too few integration steps (%d out of %d where taken), or "
               "simply due to the nature of the data. "
               "The size range was from %f to %f. ",
               (int) (100.0 * (double) count / (double) nTuples),
               count, nTuples,
               minv, maxv,
               maxSize, maxStepLength, numSteps, maxSteps,
               minSizeValue, maxSizeValue );
      
      avtCallback::IssueWarning(str);
    }

    avtDataAttributes &dataatts = GetOutput()->GetInfo().GetAttributes();
    avtExtents* e = dataatts.GetThisProcsActualDataExtents();

    double range[2];
    range[0] = minv;
    range[1] = maxv;
    e->Set(range);

    e = dataatts.GetThisProcsOriginalDataExtents();
    e->Set(range);

    e = dataatts.GetThisProcsActualSpatialExtents();
    e->Set(global_bounds);
    e = dataatts.GetThisProcsOriginalSpatialExtents();
    e->Set(global_bounds);
}


// ****************************************************************************
//  Method: avtFTLEFilter::MultiBlockCreateFSLEOutput
//
//  Purpose:
//      Computes the FTLE for the whole data set, using the 
//      final particle locations, at the blocks native resolution.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

void
avtFTLEFilter::MultiBlockCreateFSLEOutput(avtDataTree_p inDT,
                                          avtDataTree_p outDT,
                                          std::vector<avtIntegralCurve*> &ics,
                                          int &offset,
                                          double &minv, double &maxv,
                                          int &count)
{
    if (*inDT == NULL || *outDT == NULL)
        return;

    int nc = inDT->GetNChildren();

    if (nc <= 0 && !inDT->HasData())
        return;

    if (nc == 0)
    {
        //
        // there is only one dataset to process
        //
        vtkDataSet *in_ds = inDT->GetDataRepresentation().GetDataVTK();
        vtkDataSet *out_ds = outDT->GetDataRepresentation().GetDataVTK();

        int dom = inDT->GetDataRepresentation().GetDomain();
        std::string label = inDT->GetDataRepresentation().GetLabel();

        SingleBlockCreateFSLEOutput(in_ds, out_ds, ics,
                                    offset, dom, minv, maxv, count);
    }
    else
    {
      //
      // there is more than one input dataset to process
      // and we need an output datatree for each
      //
      for (int j = 0; j < nc; j++)
      {
          if (inDT->ChildIsPresent(j))
            MultiBlockCreateFSLEOutput(inDT->GetChild(j), outDT->GetChild(j),
                                       ics, offset, minv, maxv, count);
      }
    }
}


// ****************************************************************************
//  Method: avtFTLEFilter::SingleBlockCreateFSLEOutput
//
//  Purpose:
//      Computes the FTLE for a single block of a data set, using the 
//      final particle locations, at the blocks native resolution.
//
//  Arguments:
//      in_ds   The block to calculate the FTLE on
//      ics     The list of particles for all blocks on this MPI task.
//      domain  The domain number of in_ds
//      minv    The minimum FSLE value (output)
//      maxv    The maximum FSLE value (output)
//      count   The number of nodes with a valid exponent
//
//  Returns:    The new version of in_ds that includes the FTLE scalar
//              variable.  The calling function is responsible for dereferencing
//              this VTK object.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
//    Hank Childs, Tue Feb  5 08:12:33 PST 2013
//    Fix parallelization bug and memory leak.
//
// ****************************************************************************

void
avtFTLEFilter::SingleBlockCreateFSLEOutput(vtkDataSet *in_ds,
                                           vtkDataSet *out_ds,
                                           std::vector<avtIntegralCurve*> &ics,
                                           int &offset, int domain,
                                           double &minv, double &maxv,
                                           int &count)
{
  //variable name.
  std::string var = std::string("operators/FTLE/") + outVarName;

  // Set the grid points to the actual grid (i.e. replace the
  // uniform grid used to get the distances via the gradient
  // expression).
  if (out_ds->GetDataObjectType() == VTK_RECTILINEAR_GRID)
  {
    ((vtkRectilinearGrid*)out_ds)->
      SetXCoordinates( ((vtkRectilinearGrid*)in_ds)->GetXCoordinates() );
    ((vtkRectilinearGrid*)out_ds)->
      SetYCoordinates( ((vtkRectilinearGrid*)in_ds)->GetYCoordinates() );
    ((vtkRectilinearGrid*)out_ds)->
      SetZCoordinates( ((vtkRectilinearGrid*)in_ds)->GetZCoordinates() );
  }      
  else
  {
    EXCEPTION1(VisItException,
               "Can only compute SingleBlockCreateFSLEOutput on rectilinear grids. ");
  }

  vtkFloatArray *exponents = (vtkFloatArray *)
    out_ds->GetPointData()->GetArray(var.c_str());

  int nTuples = exponents->GetNumberOfTuples();

  for(size_t i=0; i<ics.size(); ++i)
  {
    avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];
    
    size_t index = ic->id;
    int l = (index-offset);

    double lambda = exponents->GetTuple1(l);
    
    if( lambda == std::numeric_limits<float>::min() )
    {
      lambda = 0;
      exponents->SetTuple1(l, lambda );
    }
    else
    {
      ic->status.ClearTerminationMet();
    }
    
    minv = std::min(lambda, minv);
    maxv = std::max(lambda, maxv);
    
    if( lambda != 0 )
      ++count;
  }

      
  // Remove the working arrays.
  out_ds->GetPointData()->RemoveArray("component");
  out_ds->GetPointData()->RemoveArray("times");
  out_ds->GetPointData()->RemoveArray("lengths");
  out_ds->GetPointData()->RemoveArray("mask");

  // Make the exponents the the active scalars.
  out_ds->GetPointData()->SetActiveScalars(var.c_str());

  //done with offset, increment it for the next call to this
  //function.
  offset += nTuples;

  //store this dataset in Cache for next time.
  // double bounds[6];
  // fsle_ds->GetBounds(bounds);
          
  // std::cout << "final size and bounds: "
  //          << PAR_Rank() << " " << leafSize << " "
  //          << bounds[0] << " " << bounds[1] << " " << bounds[2]
  //          << " " << bounds[3] << " " << bounds[4] << " "
  //          << bounds[5] << std::endl;

  // std::cerr << "Caching fsle_ds" << std::endl;
  
  
  //Store this dataset in Cache for next time.
  std::string str = CreateCacheString();
  
  StoreArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                          outVarName.c_str(), domain, -1,
                          str.c_str(), out_ds);
}


// ****************************************************************************
//  Method: avtFTLEFilter::CreateRectilinearGridFSLEOutput
//
//  Purpose:
//      Computes the FSLE output (via sub-routines) after the PICS filter
//      has calculated the particle positions.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

void 
avtFTLEFilter::CreateRectilinearGridFSLEOutput(std::vector<avtIntegralCurve*> &ics)
{
    //root should now have index into global structure and all
    //matching end positions.
    if(PAR_Rank() != 0)
    {
        //std::cout << PAR_Rank() << " creating dummy output" << std::endl;
        avtDataTree* dummy = new avtDataTree();
        SetOutputDataTree(dummy);
    }
    else
    {
      if (fsle_ds->GetDataObjectType() != VTK_RECTILINEAR_GRID)
      {
        EXCEPTION1(VisItException,
                   "Can only compute CreateRectilinearGridFSLEOutput on rectilinear grids. ");
      }

      //variable name.
      std::string var = std::string("operators/FTLE/") + outVarName;

      // Set the grid points to the actual grid (i.e. replace the
      // uniform grid used to get the distances via the gradient
      // expression).
      vtkFloatArray* lxcoord = vtkFloatArray::New();
      vtkFloatArray* lycoord = vtkFloatArray::New();
      vtkFloatArray* lzcoord = vtkFloatArray::New();
      
      vtkRectilinearGrid *fsle_rect_grid = (vtkRectilinearGrid *) fsle_ds;

      lxcoord->SetNumberOfTuples(global_resolution[0]);
      for (int i = 0; i < global_resolution[0]; i++)
      {
        double pcnt = 0;
        if (global_resolution[0] > 1)
          pcnt = ((double)i)/((double)global_resolution[0]-1);
        lxcoord->SetTuple1(i, global_bounds[0]*(1.0-pcnt) + global_bounds[1]*pcnt);
      }
      
      lycoord->SetNumberOfTuples(global_resolution[1]);
      for (int i = 0; i < global_resolution[1]; i++)
      {
        double pcnt = 0;
        if (global_resolution[1] > 1)
          pcnt = ((double)i)/((double)global_resolution[1]-1);
        lycoord->SetTuple1(i, global_bounds[2]*(1.0-pcnt) + global_bounds[3]*pcnt);
      }
      
      lzcoord->SetNumberOfTuples(global_resolution[2]);
      for (int i = 0; i < global_resolution[2]; i++)
      {
        double pcnt = 0;
        if (global_resolution[2] > 1)
          pcnt = ((double)i)/((double)global_resolution[2]-1);
        lzcoord->SetTuple1(i, global_bounds[4]*(1.0-pcnt) + global_bounds[5]*pcnt);
      }
      
      fsle_rect_grid->SetXCoordinates(lxcoord);
      fsle_rect_grid->SetYCoordinates(lycoord);
      fsle_rect_grid->SetZCoordinates(lzcoord);
      
      //cleanup
      lxcoord->Delete();
      lycoord->Delete();
      lzcoord->Delete();

      vtkFloatArray *exponents = (vtkFloatArray *)
        fsle_ds->GetPointData()->GetArray(var.c_str());

      int nTuples = exponents->GetNumberOfTuples();

      //min and max values over all datasets of the tree.
      double minv = std::numeric_limits<double>::max();
      double maxv = std::numeric_limits<double>::min();
      
      int count = 0;

      for(size_t i=0; i<ics.size(); ++i)
      {
        avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];

        size_t l = ic->id; // The curve id is the index into the VTK data.

        double lambda = exponents->GetTuple1(l);

        if( lambda == std::numeric_limits<float>::min() )
        {
          lambda = 0;
          exponents->SetTuple1(l, lambda );
        }
        else
        {
          ic->status.ClearTerminationMet();
        }

        minv = std::min(lambda, minv);
        maxv = std::max(lambda, maxv);

        if( lambda != 0 )
          ++count;
      }

      if( count <= nTuples/10 )
      {
        if( minSizeValue == std::numeric_limits<double>::max() )
          minSizeValue = 0.0;

        if( maxSizeValue == std::numeric_limits<double>::min() )
          maxSizeValue = 0.0;

        char str[1028];

        SNPRINTF(str, 1028, "\n%d%% of the nodes (%d of %d nodes) "
                 "exaimed produced a valid exponent (%f to %f). "
                 "This may be due to too large of a size limit (%f), "
                 "too small of an integration step (%f), or "
                 "too few integration steps (%d out of %d where taken), or "
                 "simply due to the nature of the data. "
                 "The size range was from %f to %f. ",
                 (int) (100.0 * (double) count / (double) nTuples),
                 count, nTuples,
                 minv, maxv,
                 maxSize, maxStepLength, numSteps, maxSteps,
                 minSizeValue, maxSizeValue );

        avtCallback::IssueWarning(str);
      }
      
      // Make the exponents the the active scalars.
      fsle_ds->GetPointData()->SetActiveScalars(var.c_str());

      // Remove the working arrays.
      fsle_ds->GetPointData()->RemoveArray("component");
      fsle_ds->GetPointData()->RemoveArray("times");
      fsle_ds->GetPointData()->RemoveArray("lengths");
      fsle_ds->GetPointData()->RemoveArray("mask");

      //store this dataset in Cache for next time.
      // double bounds[6];
      // fsle_ds->GetBounds(bounds);
          
      // std::cout << "final size and bounds: "
      //          << PAR_Rank() << " " << leafSize << " "
      //          << bounds[0] << " " << bounds[1] << " " << bounds[2]
      //          << " " << bounds[3] << " " << bounds[4] << " "
      //          << bounds[5] << std::endl;

      // std::cerr << "Caching fsle_ds" << std::endl;
      std::string str = CreateCacheString();
      StoreArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                              outVarName.c_str(), -1, -1,
                              str.c_str(), fsle_ds);
      
      int index = 0;//what does index mean in this context?
      avtDataTree* dt = new avtDataTree(fsle_ds,index);
      int x = 0;
      dt->GetAllLeaves(x);
      
      // std::cout << "total leaves:: " << x << std::endl;
      
      SetOutputDataTree(dt);
      
      //set atts.
      avtDataAttributes &dataatts = GetOutput()->GetInfo().GetAttributes();
      avtExtents* e = dataatts.GetThisProcsActualDataExtents();
      
      double range[2];
      range[0] = minv;
      range[1] = maxv;
      e->Set(range);
    }
}


// ****************************************************************************
//  Method: avtFTLEFilter::ReportWarnings() 
//
//  Purpose:
//      Reports any potential integration warnings
//
//  Programmer: Allen Sanderson
//  Creation:   20 August 2013
//
//  Modifications:
//
// ****************************************************************************

void
avtFTLEFilter::ReportWarnings(std::vector<avtIntegralCurve *> &ics)
{
    if (ics.size() == 0)
        return;

    int numICs = ics.size();
//    int numPts = 0;
    int numEarlyTerminators = 0;
    int numStiff = 0;
    int numCritPts = 0;

    if (DebugStream::Level5())
        debug5 << "::CreateIntegralCurveOutput " << ics.size() << endl;

    //See how many pts, ics we have so we can preallocate everything.
    for (int i = 0; i < numICs; i++)
    {
        bool terminatedBecauseOfMaxSteps;
        bool encounteredNumericalProblems;

        if( doSize )
        {
            avtStreamlineIC *ic = dynamic_cast<avtStreamlineIC*>(ics[i]);
            terminatedBecauseOfMaxSteps  = ic->TerminatedBecauseOfMaxSteps();
            encounteredNumericalProblems = ic->EncounteredNumericalProblems();
        }
        else
        {
            avtFTLEIC *ic = dynamic_cast<avtFTLEIC*>(ics[i]);
            terminatedBecauseOfMaxSteps  = ic->TerminatedBecauseOfMaxSteps();
            encounteredNumericalProblems = ic->EncounteredNumericalProblems();
        }

        // NOT USED ??????????????????????????
        // size_t numSamps = (ic ? ic->GetNumberOfSamples() : 0);
        // if (numSamps > 1)
        //     numPts += numSamps;

        if (terminatedBecauseOfMaxSteps)
        {
            // Calculated only with avtStateRecorderIntegralCurve
            // if (ic->SpeedAtTermination() <= criticalPointThreshold)
            //     numCritPts++;
            // else
            numEarlyTerminators++;
        }

        if (encounteredNumericalProblems)
            numStiff++;
    }

    char str[4096] = "";

    if ((doDistance || doTime || doSize) && issueWarningForMaxStepsTermination)
    {
        SumIntAcrossAllProcessors(numEarlyTerminators);
        if (numEarlyTerminators > 0)
        {
          SNPRINTF(str, 4096,
                   "%s\n%d of your integral curves terminated because they "
                   "reached the maximum number of steps.  This may be indicative of your "
                   "time or distance criteria being too large or of other attributes being "
                   "set incorrectly (example: your step size is too small).  If you are "
                   "confident in your settings and want the particles to advect farther, "
                   "you should increase the maximum number of steps.  If you want to disable "
                   "this message, you can do this under the Advaced tab."
                   "  Note that this message does not mean that an error has occurred; it simply "
                   "means that VisIt stopped advecting particles because it reached the maximum "
                   "number of steps. (That said, this case happens most often when other attributes "
                   "are set incorrectly.)\n", str, numEarlyTerminators);
        }
    }

    if (issueWarningForCriticalPoints)
    {
        SumIntAcrossAllProcessors(numCritPts);
        if (numCritPts > 0)
        {
            SNPRINTF(str, 4096, 
                     "%s\n%d of your integral curves circled round and round a critical point (a zero"
                     " velocity location).  Normally, VisIt is able to advect the particle "
                     "to the critical point location and terminate.  However, VisIt was not able "
                     "to do this for these particles due to numerical issues.  In all likelihood, "
                     "additional steps will _not_ help this problem and only cause execution to "
                     "take longer.  If you want to disable this message, you can do this under "
                     "the Advanced tab.\n", str, numCritPts);
        }
    }

    if (issueWarningForStiffness)
    {
        SumIntAcrossAllProcessors(numStiff);
        if (numStiff > 0)
        {
            SNPRINTF(str, 4096, 
                     "%s\n%d of your integral curves were unable to advect because of \"stiffness\".  "
                     "When one component of a velocity field varies quickly and another stays "
                     "relatively constant, then it is not possible to choose step sizes that "
                     "remain within tolerances.  This condition is referred to as stiffness and "
                     "VisIt stops advecting in this case.  If you want to disable this message, "
                     "you can do this under the Advanced tab.\n", str,numStiff);
        }
    }

    if( strlen( str ) )
      avtCallback::IssueWarning(str);
}


// ****************************************************************************
//  Method: avtFTLEFilter::CreateCacheString
//
//  Purpose:
//      A routine that calculates a string for caching that encodes all the
//      parameters of the FTLE: bounds, integration time, and variable name.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

std::string
avtFTLEFilter::CreateCacheString(void)
{
  const int*    resolution = atts.GetResolution();
  const double* startPosition = atts.GetStartPosition();
  const double* endPosition = atts.GetEndPosition();
  const double* velocitySource = atts.GetVelocitySource();

  std::ostringstream os;

  os << seedTime0 << "  "
     << atts.GetSourceType() << " "
     << resolution[0] << " "
     << resolution[1] << " "
     << resolution[2] << " "
     << atts.GetUseDataSetStart() << " "
     << startPosition[0] << " "
     << startPosition[1] << " "
     << startPosition[2] << " "
     << atts.GetUseDataSetEnd() << " "
     << endPosition[0] << " "
     << endPosition[1] << " "
     << endPosition[2] << " "
     << atts.GetIntegrationDirection() << " "
     << atts.GetMaxSteps() << " "
     << atts.GetTerminationType() << " "
     << atts.GetTerminateBySize() << " "
     << atts.GetTermSize() << " "
     << atts.GetTerminateByDistance() << " "
     << atts.GetTermDistance() << " "
     << atts.GetTerminateByTime() << " "
     << atts.GetTermTime() << " "
     << atts.GetMaxStepLength() << " "
     << atts.GetLimitMaximumTimestep() << " "
     << atts.GetMaxTimeStep() << " "
     << atts.GetRelTol() << " "
     << atts.GetAbsTolSizeType() << " "
     << atts.GetAbsTolAbsolute() << " "
     << atts.GetAbsTolBBox() << " "
     << atts.GetFieldType() << " "
     << atts.GetFieldConstant() << " "
     << velocitySource[0] << " "
     << velocitySource[1] << " "
     << velocitySource[2] << " "
     << atts.GetIntegrationType() << " "
     << atts.GetParallelizationAlgorithmType() << " "
     << atts.GetMaxProcessCount() << " "
     << atts.GetMaxDomainCacheSize() << " "
     << atts.GetWorkGroupSize() << " "
     << atts.GetPathlines() << " "
     << atts.GetPathlinesOverrideStartingTimeFlag() << " "
     << atts.GetPathlinesOverrideStartingTime() << " "
     << atts.GetPathlinesCMFE() << " "
     << atts.GetForceNodeCenteredData() << " "
     << atts.GetIssueTerminationWarnings() << " "
     << atts.GetIssueStiffnessWarnings() << " "
     << atts.GetIssueCriticalPointsWarnings() << " "
     << atts.GetCriticalPointThreshold() << " ";

  return os.str();
}


// ****************************************************************************
//  Method: avtFTLEFilter::GetCachedDataSet
//
//  Purpose:
//      Checks to see if we have already calculated the FTLE.  Works for
//      both resampling and native options (realized through sub-routine calls).
//      This routine uses collective communication to decided whether
//      it can use a cached data set.
//      - For the native resolution, all domains on all MPI tasks must have
//      the FTLE cached.
//      - For the resampled version, one MPI task somewhere must find it.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtDataTree_p
avtFTLEFilter::GetCachedDataSet()
{
    avtDataTree_p rv = NULL;
    if (atts.GetSourceType() == FTLEAttributes::NativeMesh)
    {
        rv = GetCachedNativeDataSet(GetInputDataTree());
        int looksOK = 1;
        if ((*rv == NULL) && (*(GetInputDataTree()) != NULL))
            looksOK = 0;
        looksOK = UnifyMinimumValue(looksOK); // if any fails, we all fail
        if (looksOK == 0)
            rv = NULL;
    }
    else //if (atts.GetSourceType() == FTLEAttributes::RegularGrid)
    {
        rv = GetCachedResampledDataSet();
        int looksOK = (*rv == NULL ? 0 : 1);
        looksOK = UnifyMaximumValue(looksOK); // if one has it, we're all OK
        if (looksOK == 0)
            rv = NULL;
        else if ((looksOK == 1) && (*rv == NULL))
            rv = new avtDataTree();
    }
    return rv;
}

// ****************************************************************************
//  Method: avtFTLEFilter::GetCachedNativeDataSet
//
//  Purpose:
//      Checks the cache to see if we have calculated the FTLE on this
//      domain previously.  Checks to make sure parameters match: integration
//      time, etc.
//
//  Programmer: Hank Childs
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtDataTree_p
avtFTLEFilter::GetCachedNativeDataSet(avtDataTree_p inDT)
{
    if (*inDT == NULL)
        return NULL;

    int nc = inDT->GetNChildren();

    if (nc <= 0 && !inDT->HasData())
    {
        // degenerate.  just return.
        return NULL;
    }

    if (nc == 0)
    {
        //
        // there is only one dataset to process
        //
        vtkDataSet *in_ds = inDT->GetDataRepresentation().GetDataVTK();
        int dom = inDT->GetDataRepresentation().GetDomain();
        std::string label = inDT->GetDataRepresentation().GetLabel();
        std::string str = CreateCacheString();
        vtkDataSet *rv = (vtkDataSet *)
                         FetchArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                                                 outVarName.c_str(), dom, -1, str.c_str());
        if (rv == NULL)
            return NULL;
        else
            return new avtDataTree(rv, dom, label);
    }

    //
    // there is more than one input dataset to process
    // and we need an output datatree for each
    //
    avtDataTree_p *outDT = new avtDataTree_p[nc];
    bool badOne = false;
    for (int j = 0; j < nc; j++)
    {
        if (inDT->ChildIsPresent(j))
        {
            outDT[j] = GetCachedNativeDataSet(inDT->GetChild(j));
            if (*(outDT[j]) == NULL)
                badOne = true;
        }
        else
        {
            outDT[j] = NULL;
        }
    }
    avtDataTree_p rv = NULL;
    if (!badOne) // if we don't have FTLE for one domain, then just re-calc whole thing
        rv = new avtDataTree(nc, outDT);
    delete [] outDT;
    return rv;
}


// ****************************************************************************
//  Method: avtFTLEFilter::GetCachedResampledDataSet
//
//  Purpose:
//      Checks the cache to see if we have calculated the FTLE before.  It
//      also ensures that the parameters of previous calculations are the
//      same: integration time, bounds, variable, etc.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtDataTree_p
avtFTLEFilter::GetCachedResampledDataSet()
{
    std::string str = CreateCacheString();
    vtkRectilinearGrid *rv = (vtkRectilinearGrid *)
                     FetchArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                                             outVarName.c_str(), -1, -1,
                                             str.c_str());

    if(rv != NULL)
    {
        return new avtDataTree(rv, -1);
    }

    return NULL;
}

/*****************************************************************************
*
* Copyright (c) 2000 - 2014, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

#include "QvisPeaksOverThresholdWindow.h"

#include <PeaksOverThresholdAttributes.h>
#include <ViewerProxy.h>

#include <QCheckBox>
#include <QLabel>
#include <QLayout>
#include <QLineEdit>
#include <QSpinBox>
#include <QButtonGroup>
#include <QRadioButton>
#include <QGroupBox>
#include <QComboBox>
#include <QvisColorTableButton.h>
#include <QvisOpacitySlider.h>
#include <QvisColorButton.h>
#include <QvisLineStyleWidget.h>
#include <QvisLineWidthWidget.h>
#include <QvisVariableButton.h>

#include <stdio.h>
#include <string>

using std::string;

// ****************************************************************************
// Method: QvisPeaksOverThresholdWindow::QvisPeaksOverThresholdWindow
//
// Purpose: 
//   Constructor
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

QvisPeaksOverThresholdWindow::QvisPeaksOverThresholdWindow(const int type,
                         PeaksOverThresholdAttributes *subj,
                         const QString &caption,
                         const QString &shortName,
                         QvisNotepadArea *notepad)
    : QvisOperatorWindow(type,subj, caption, shortName, notepad)
{
    atts = subj;
}


// ****************************************************************************
// Method: QvisPeaksOverThresholdWindow::~QvisPeaksOverThresholdWindow
//
// Purpose: 
//   Destructor
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

QvisPeaksOverThresholdWindow::~QvisPeaksOverThresholdWindow()
{
}


// ****************************************************************************
// Method: QvisPeaksOverThresholdWindow::CreateWindowContents
//
// Purpose: 
//   Creates the widgets for the window.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisPeaksOverThresholdWindow::CreateWindowContents()
{
    int row = 0;
    //
    // Inputs group box
    //
    QGroupBox *inputGroup = new QGroupBox(central);
    inputGroup->setTitle(tr("Inputs"));
    topLayout->addWidget(inputGroup);
    QGridLayout *inputLayout = new QGridLayout(inputGroup);
    inputLayout->setMargin(5);
    inputLayout->setSpacing(10);

    inputLayout->addWidget(new QLabel(tr("Start year"), central), 0, 0);
    dataYearBegin = new QLineEdit(central);
    connect(dataYearBegin, SIGNAL(returnPressed()),
            this, SLOT(dataYearBeginProcessText()));
    inputLayout->addWidget(dataYearBegin, 0,1);

    dataAnalysisYearRangeEnabled = new QCheckBox(tr("Analysis year range"), central);
    connect(dataAnalysisYearRangeEnabled, SIGNAL(toggled(bool)),
            this, SLOT(dataAnalysisYearRangeEnabledChanged(bool)));
    inputLayout->addWidget(dataAnalysisYearRangeEnabled, 1,0);
    dataAnalysisYear1 = new QLineEdit(central);
    connect(dataAnalysisYear1, SIGNAL(returnPressed()),
            this, SLOT(dataAnalysisYear1ProcessText()));
    inputLayout->addWidget(dataAnalysisYear1, 1,1);
    dataAnalysisYear2 = new QLineEdit(central);
    connect(dataAnalysisYear2, SIGNAL(returnPressed()),
            this, SLOT(dataAnalysisYear2ProcessText()));
    inputLayout->addWidget(dataAnalysisYear2, 1,2);

    ensemble = new QCheckBox(tr("Ensemble"), central);
    connect(ensemble, SIGNAL(toggled(bool)),
            this, SLOT(ensembleChanged(bool)));
    inputLayout->addWidget(ensemble, 2,0);

    numEnsemblesLabel = new QLabel(tr("Number of members"), central);
    inputLayout->addWidget(numEnsemblesLabel,2,1);
    numEnsembles = new QLineEdit(central);
    connect(numEnsembles, SIGNAL(returnPressed()),
            this, SLOT(numEnsemblesProcessText()));
    inputLayout->addWidget(numEnsembles, 2,2);

    cutoffLabel = new QLabel(tr("Cutoff"), central);
    inputLayout->addWidget(cutoffLabel,3,0);
    cutoff = new QLineEdit(central);
    connect(cutoff, SIGNAL(returnPressed()),
            this, SLOT(cutoffProcessText()));
    inputLayout->addWidget(cutoff, 3,1);

    dataScalingLabel = new QLabel(tr("Data Scaling"), central);
    inputLayout->addWidget(dataScalingLabel,3,2);
    dataScaling = new QLineEdit(central);
    connect(dataScaling, SIGNAL(returnPressed()),
            this, SLOT(dataScalingProcessText()));
    inputLayout->addWidget(dataScaling, 3,3);

    //
    // Analysis group box
    //
    row = 0;
    QGroupBox *analysisGroup = new QGroupBox(central);
    analysisGroup->setTitle(tr("Analysis"));
    topLayout->addWidget(analysisGroup);
    QGridLayout *analysisLayout = new QGridLayout(analysisGroup);
    analysisLayout->setMargin(5);
    analysisLayout->setSpacing(10);

    cutoffModeButtonGroup = new QButtonGroup(central);
    QRadioButton *rb = new QRadioButton(tr("Upper tail"), central );
    rb->setChecked(true);
    cutoffModeButtonGroup->addButton(rb, 0);
    analysisLayout->addWidget(rb, row, 0);
    rb = new QRadioButton(tr("Lower tail"), central );
    cutoffModeButtonGroup->addButton(rb, 1);
    analysisLayout->addWidget(rb, row, 1);
    
    // Each time a radio button is clicked, call the centeringClicked slot.
    connect(cutoffModeButtonGroup, SIGNAL(buttonClicked(int)),
            this, SLOT(cutoffModeChanged(int)));
    row++;

    noConsecutiveDay = new QCheckBox(tr("No consecutive day events"), central);
    connect(noConsecutiveDay, SIGNAL(toggled(bool)),
            this, SLOT(noConsecutiveDayChanged(bool)));
    analysisLayout->addWidget(noConsecutiveDay, row,0);
    row++;

    analysisLayout->addWidget(new QLabel(tr("Optimization"), central), row, 0);
    optimizationSelect = new QComboBox(central);
    optimizationSelect->addItem(tr("Nelder-Mead"));
    optimizationSelect->addItem(tr("BFGS"));
    connect(optimizationSelect, SIGNAL(activated(int)),
            this, SLOT(optimizationChanged(int))); 
    analysisLayout->addWidget(optimizationSelect, row, 1);
    row++;

    analysisLayout->addWidget(new QLabel(tr("Aggregation"), central), row, 0);
    aggregationSelect = new QComboBox(central);
    aggregationSelect->addItem(tr("Annual"));
    aggregationSelect->addItem(tr("Seasonal"));
    aggregationSelect->addItem(tr("Monthly"));
    connect(aggregationSelect, SIGNAL(activated(int)),
            this, SLOT(aggregationChanged(int))); 
    analysisLayout->addWidget(aggregationSelect, row, 1);

    analysisLayout->addWidget(new QLabel(tr("Percentile"), central),row,2);
    annualPercentile = new QLineEdit(central);
    connect(annualPercentile, SIGNAL(returnPressed()),
            this, SLOT(annualPercentileProcessText()));
    analysisLayout->addWidget(annualPercentile, row, 3);

    seasonalPercentile = new QLineEdit(central);
    connect(seasonalPercentile, SIGNAL(returnPressed()),
            this, SLOT(seasonalPercentileProcessText()));
    analysisLayout->addWidget(seasonalPercentile, row,3);

    monthlyPercentile = new QLineEdit(central);
    connect(monthlyPercentile, SIGNAL(returnPressed()),
            this, SLOT(monthlyPercentileProcessText()));
    analysisLayout->addWidget(monthlyPercentile, row,3);
    row++;

    daysPerYearLabel = new QLabel(tr("Days per year"), central);
    analysisLayout->addWidget(daysPerYearLabel, row,0);
    daysPerYear = new QLineEdit(central);
    connect(daysPerYear, SIGNAL(returnPressed()),
            this, SLOT(daysPerYearProcessText()));
    analysisLayout->addWidget(daysPerYear, row,1);

    daysPerMonthLabel = new QLabel(tr("Days per month"), central);
    analysisLayout->addWidget(daysPerMonthLabel,row,0);
    daysPerMonth = new QLineEdit(central);
    connect(daysPerMonth, SIGNAL(returnPressed()),
            this, SLOT(daysPerMonthProcessText()));
    analysisLayout->addWidget(daysPerMonth, row,1);
    row++;

    //
    // Trend Modeling group box
    //
    QGroupBox *trendGroup = new QGroupBox(central);
    trendGroup->setTitle(tr("Trend Modeling"));
    analysisLayout->addWidget(trendGroup, row, 0);
    QGridLayout *trendLayout = new QGridLayout(trendGroup);
    trendLayout->setMargin(5);
    trendLayout->setSpacing(10);
    row = 0;

    covariateModelScale = new QCheckBox(tr("Linear trend in log scale parameter"), central);
    connect(covariateModelScale, SIGNAL(toggled(bool)),
            this, SLOT(covariateModelScaleChanged(bool)));
    trendLayout->addWidget(covariateModelScale, row,0);
    row++;

    covariateModelLocation = new QCheckBox(tr("Linear trend in location parameter"), central);
    connect(covariateModelLocation, SIGNAL(toggled(bool)),
            this, SLOT(covariateModelLocationChanged(bool)));
    trendLayout->addWidget(covariateModelLocation, row,0);
    row++;

    covariateModelShape = new QCheckBox(tr("Linear trend in shape parameter"), central);
    connect(covariateModelShape, SIGNAL(toggled(bool)),
            this, SLOT(covariateModelShapeChanged(bool)));
    trendLayout->addWidget(covariateModelShape, row,0);
    row++;


    //
    // Outputs group box
    //
    QGroupBox *outputGroup = new QGroupBox(central);
    outputGroup->setTitle(tr("Outputs"));
    topLayout->addWidget(outputGroup);
    QGridLayout *outputLayout = new QGridLayout(outputGroup);
    outputLayout->setMargin(5);
    outputLayout->setSpacing(10);

    computeCovariates = new QCheckBox(tr("Compute return value for years"), central);
    connect(computeCovariates, SIGNAL(toggled(bool)),
            this, SLOT(computeCovariatesChanged(bool)));
    outputLayout->addWidget(computeCovariates, 0,0);

    covariateReturnYears = new QLineEdit(central);
    connect(covariateReturnYears, SIGNAL(returnPressed()),
            this, SLOT(covariateReturnYearsProcessText()));
    outputLayout->addWidget(covariateReturnYears, 0,1);

    computeRVDifferences = new QCheckBox(tr("Compute return value differences for years"), central);
    connect(computeRVDifferences, SIGNAL(toggled(bool)),
            this, SLOT(computeRVDifferencesChanged(bool)));
    outputLayout->addWidget(computeRVDifferences, 1,0);

    rvDifference1 = new QLineEdit(central);
    connect(rvDifference1, SIGNAL(returnPressed()),
            this, SLOT(rvDifference1ProcessText()));
    outputLayout->addWidget(rvDifference1, 1,1);
    rvDifference2 = new QLineEdit(central);
    connect(rvDifference2, SIGNAL(returnPressed()),
            this, SLOT(rvDifference2ProcessText()));
    outputLayout->addWidget(rvDifference2, 1,2);

    computeParamValues = new QCheckBox(tr("Output parameter values"), central);
    connect(computeParamValues, SIGNAL(toggled(bool)),
            this, SLOT(computeParamValuesChanged(bool)));
    outputLayout->addWidget(computeParamValues, 2,0);
    computeParamValues->hide();

    
    dumpData = new QCheckBox(tr("Dump Data"), central);
    connect(dumpData, SIGNAL(toggled(bool)),
            this, SLOT(dumpDataChanged(bool)));
    outputLayout->addWidget(dumpData, 3,0);

    dumpDebug = new QCheckBox(tr("Dump Debug"), central);
    connect(dumpDebug, SIGNAL(toggled(bool)),
            this, SLOT(dumpDebugChanged(bool)));
    outputLayout->addWidget(dumpDebug, 4,0);

    displayLabel = new QLabel(tr("Display"), central);
    outputLayout->addWidget(displayLabel, 5, 0);
    displaySeasonSelect = new QComboBox(central);
    displaySeasonSelect->addItem(tr("Winter"));
    displaySeasonSelect->addItem(tr("Spring"));
    displaySeasonSelect->addItem(tr("Summer"));
    displaySeasonSelect->addItem(tr("Fall"));
    connect(displaySeasonSelect, SIGNAL(activated(int)),
            this, SLOT(displaySeasonChanged(int)));
    outputLayout->addWidget(displaySeasonSelect, 5, 1);

    displayMonthSelect = new QComboBox(central);
    displayMonthSelect->addItem(tr("January"));
    displayMonthSelect->addItem(tr("February"));
    displayMonthSelect->addItem(tr("March"));
    displayMonthSelect->addItem(tr("April"));
    displayMonthSelect->addItem(tr("May"));
    displayMonthSelect->addItem(tr("June"));
    displayMonthSelect->addItem(tr("July"));
    displayMonthSelect->addItem(tr("August"));
    displayMonthSelect->addItem(tr("September"));
    displayMonthSelect->addItem(tr("October"));
    displayMonthSelect->addItem(tr("November"));
    displayMonthSelect->addItem(tr("December"));
    connect(displayMonthSelect, SIGNAL(activated(int)),
            this, SLOT(displayMonthChanged(int))); 
    outputLayout->addWidget(displayMonthSelect, 5, 1);
}


// ****************************************************************************
// Method: QvisPeaksOverThresholdWindow::UpdateWindow
//
// Purpose: 
//   Updates the widgets in the window when the subject changes.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisPeaksOverThresholdWindow::UpdateWindow(bool doAll)
{

    for(int i = 0; i < atts->NumAttributes(); ++i)
    {
        if(!doAll)
        {
            if(!atts->IsSelected(i))
            {
                continue;
            }
        }

        switch(i)
        {
          case PeaksOverThresholdAttributes::ID_dataYearBegin:
            dataYearBegin->setText(IntToQString(atts->GetDataYearBegin()));
            break;
          case PeaksOverThresholdAttributes::ID_dataAnalysisYearRangeEnabled:
            if (atts->GetDataAnalysisYearRangeEnabled() == true)
            {
                dataAnalysisYear1->setEnabled(true);
                dataAnalysisYear2->setEnabled(true);
            }
            else
            {
                dataAnalysisYear1->setEnabled(false);
                dataAnalysisYear2->setEnabled(false);
            }
            dataAnalysisYearRangeEnabled->blockSignals(true);
            dataAnalysisYearRangeEnabled->setChecked(atts->GetDataAnalysisYearRangeEnabled());
            dataAnalysisYearRangeEnabled->blockSignals(false);
            break;
           case PeaksOverThresholdAttributes::ID_dataAnalysisYear1:
            dataAnalysisYear1->setText(IntToQString(atts->GetDataAnalysisYear1()));
            break;
           case PeaksOverThresholdAttributes::ID_dataAnalysisYear2:
            dataAnalysisYear2->setText(IntToQString(atts->GetDataAnalysisYear2()));
            break;
          case PeaksOverThresholdAttributes::ID_ensemble:
            if (atts->GetEnsemble() == true)
            {
                numEnsembles->setEnabled(true);
                if(numEnsemblesLabel)
                    numEnsemblesLabel->setEnabled(true);
            }
            else
            {
                numEnsembles->setEnabled(false);
                if(numEnsemblesLabel)
                    numEnsemblesLabel->setEnabled(false);
            }
            ensemble->blockSignals(true);
            ensemble->setChecked(atts->GetEnsemble());
            ensemble->blockSignals(false);
            break;
          case PeaksOverThresholdAttributes::ID_numEnsembles:
            numEnsembles->setText(IntToQString(atts->GetNumEnsembles()));
            break;
          case PeaksOverThresholdAttributes::ID_cutoff:
            cutoff->setText(FloatToQString(atts->GetCutoff()));
            break;
          case PeaksOverThresholdAttributes::ID_cutoffMode:
            cutoffModeButtonGroup->blockSignals(true);
            if(cutoffModeButtonGroup->button((int)atts->GetCutoffMode()) != 0)
                cutoffModeButtonGroup->button((int)atts->GetCutoffMode())->setChecked(true);
            cutoffModeButtonGroup->blockSignals(false);
            break;
          case PeaksOverThresholdAttributes::ID_dataScaling:
            dataScaling->setText(DoubleToQString(atts->GetDataScaling()));
            break;
          case PeaksOverThresholdAttributes::ID_aggregation:
              annualPercentile->setEnabled(false);
              monthlyPercentile->setEnabled(false);
              seasonalPercentile->setEnabled(false);
              annualPercentile->hide();
              monthlyPercentile->hide();
              seasonalPercentile->hide();

              daysPerYearLabel->setEnabled(false);
              daysPerYearLabel->hide();
              daysPerYear->setEnabled(false);
              daysPerYear->hide();
              daysPerMonthLabel->setEnabled(false);
              daysPerMonthLabel->hide();
              daysPerMonth->setEnabled(false);
              daysPerMonth->hide();

              displayLabel->hide();
              displayLabel->setEnabled(false);
              displayMonthSelect->hide();
              displayMonthSelect->setEnabled(false);
              displaySeasonSelect->hide();
              displaySeasonSelect->setEnabled(false);

              
            if (atts->GetAggregation() == PeaksOverThresholdAttributes::ANNUAL)
            {
                annualPercentile->show();
                annualPercentile->setEnabled(true);
                
                daysPerYear->setEnabled(true);
                daysPerYear->show();
                daysPerYearLabel->setEnabled(true);
                daysPerYearLabel->show();
            }
            else if (atts->GetAggregation() == PeaksOverThresholdAttributes::SEASONAL)
            {
                seasonalPercentile->show();
                seasonalPercentile->setEnabled(true);
                daysPerMonth->setEnabled(true);
                daysPerMonth->show();
                daysPerMonthLabel->setEnabled(true);
                daysPerMonthLabel->show();
                displayLabel->show();
                displayLabel->setEnabled(true);
                displaySeasonSelect->show();
                displaySeasonSelect->setEnabled(true);
            }
            else if (atts->GetAggregation() == PeaksOverThresholdAttributes::MONTHLY)
            {
                monthlyPercentile->show();
                monthlyPercentile->setEnabled(true);
                daysPerMonth->setEnabled(true);
                daysPerMonth->show();
                daysPerMonthLabel->setEnabled(true);
                daysPerMonthLabel->show();
                displayLabel->show();
                displayLabel->setEnabled(true);
                displayMonthSelect->show();
                displayMonthSelect->setEnabled(true);

            }
            aggregationSelect->blockSignals(true);
            aggregationSelect->setCurrentIndex(int(atts->GetAggregation()));
            aggregationSelect->blockSignals(false);
            break;
          case PeaksOverThresholdAttributes::ID_annualPercentile:
            annualPercentile->setText(DoubleToQString(atts->GetAnnualPercentile()));
            break;
          case PeaksOverThresholdAttributes::ID_seasonalPercentile:
            seasonalPercentile->setText(DoublesToQString(atts->GetSeasonalPercentile(), 4));
            break;
          case PeaksOverThresholdAttributes::ID_monthlyPercentile:
            monthlyPercentile->setText(DoublesToQString(atts->GetMonthlyPercentile(), 12));
            break;
          case PeaksOverThresholdAttributes::ID_daysPerYear:
            daysPerYear->setText(IntToQString(atts->GetDaysPerYear()));
            break;
          case PeaksOverThresholdAttributes::ID_daysPerMonth:
            daysPerMonth->setText(IntsToQString(atts->GetDaysPerMonth(),12));
            break;
          case PeaksOverThresholdAttributes::ID_covariateModelScale:
          {
              /*
              bool anyTrue = (atts->GetCovariateModelScale() == true ||
                              atts->GetCovariateModelLocation() == true ||
                              atts->GetCovariateModelShape() == true);
              covariateReturnYears->setEnabled(anyTrue);
              covariateReturnYears->setEnabled(anyTrue);
              computeRVDifferences->setEnabled(anyTrue);
              rvDifference1->setEnabled(anyTrue);
              rvDifference2->setEnabled(anyTrue);
              cout<<"anyTrue= "<<anyTrue<<endl;
              */

              covariateModelScale->blockSignals(true);
              covariateModelScale->setChecked(atts->GetCovariateModelScale());
              covariateModelScale->blockSignals(false);
              break;
          }
          case PeaksOverThresholdAttributes::ID_covariateModelLocation:
          {
              /*
              bool anyTrue = (atts->GetCovariateModelScale() == true ||
                              atts->GetCovariateModelLocation() == true ||
                              atts->GetCovariateModelShape() == true);
              covariateReturnYears->setEnabled(anyTrue);
              covariateReturnYears->setEnabled(anyTrue);
              computeRVDifferences->setEnabled(anyTrue);
              rvDifference1->setEnabled(anyTrue);
              rvDifference2->setEnabled(anyTrue);
              cout<<"anyTrue= "<<anyTrue<<endl;
              */
              
              covariateModelLocation->blockSignals(true);
              covariateModelLocation->setChecked(atts->GetCovariateModelLocation());
              covariateModelLocation->blockSignals(false);
              break;
          }
          case PeaksOverThresholdAttributes::ID_covariateModelShape:
          {
              /*
              bool anyTrue = (atts->GetCovariateModelScale() == true ||
                              atts->GetCovariateModelLocation() == true ||
                              atts->GetCovariateModelShape() == true);
              covariateReturnYears->setEnabled(anyTrue);
              covariateReturnYears->setEnabled(anyTrue);
              computeRVDifferences->setEnabled(anyTrue);
              rvDifference1->setEnabled(anyTrue);
              rvDifference2->setEnabled(anyTrue);
              cout<<"anyTrue= "<<anyTrue<<endl;
              */

              covariateModelShape->blockSignals(true);
              covariateModelShape->setChecked(atts->GetCovariateModelShape());
              covariateModelShape->blockSignals(false);
              break;
          }
          case PeaksOverThresholdAttributes::ID_computeCovariates:
            if (atts->GetComputeCovariates() == true)
            {
                covariateReturnYears->setEnabled(true);
            }
            else
            {
                covariateReturnYears->setEnabled(false);
            }
            computeCovariates->blockSignals(true);
            computeCovariates->setChecked(atts->GetComputeCovariates());
            computeCovariates->blockSignals(false);
            break;
          case PeaksOverThresholdAttributes::ID_covariateReturnYears:
            covariateReturnYears->setText(IntsToQString(atts->GetCovariateReturnYears()));
            break;
          case PeaksOverThresholdAttributes::ID_computeRVDifferences:
            if (atts->GetComputeRVDifferences() == true)
            {
                rvDifference1->setEnabled(true);
                rvDifference2->setEnabled(true);
            }
            else
            {
                rvDifference1->setEnabled(false);
                rvDifference2->setEnabled(false);
            }
            computeRVDifferences->blockSignals(true);
            computeRVDifferences->setChecked(atts->GetComputeRVDifferences());
            computeRVDifferences->blockSignals(false);
            break; 
          case PeaksOverThresholdAttributes::ID_rvDifference1:
            rvDifference1->setText(IntToQString(atts->GetRvDifference1()));
            break;
          case PeaksOverThresholdAttributes::ID_rvDifference2:
            rvDifference2->setText(IntToQString(atts->GetRvDifference2()));
            break;
          case PeaksOverThresholdAttributes::ID_computeParamValues:
            computeParamValues->blockSignals(true);
            computeParamValues->setChecked(atts->GetComputeParamValues());
            computeParamValues->blockSignals(false);
            break;
          case PeaksOverThresholdAttributes::ID_displayMonth:
            displayMonthSelect->blockSignals(true);
            displayMonthSelect->setCurrentIndex(int(atts->GetDisplayMonth()));
            displayMonthSelect->blockSignals(false);
            break;
          case PeaksOverThresholdAttributes::ID_displaySeason:
            displaySeasonSelect->blockSignals(true);
            displaySeasonSelect->setCurrentIndex(int(atts->GetDisplaySeason()));
            displaySeasonSelect->blockSignals(false);
            break;
          case PeaksOverThresholdAttributes::ID_dumpData:
            dumpData->blockSignals(true);
            dumpData->setChecked(atts->GetDumpData());
            dumpData->blockSignals(false);
            break;
          case PeaksOverThresholdAttributes::ID_dumpDebug:
            dumpDebug->blockSignals(true);
            dumpDebug->setChecked(atts->GetDumpDebug());
            dumpDebug->blockSignals(false);
            break;
        case PeaksOverThresholdAttributes::ID_noConsecutiveDay:
            noConsecutiveDay->blockSignals(true);
            noConsecutiveDay->setChecked(atts->GetNoConsecutiveDay());
            noConsecutiveDay->blockSignals(false);
            break;
          case PeaksOverThresholdAttributes::ID_optimizationMethod:
            optimizationSelect->blockSignals(true);
            optimizationSelect->setCurrentIndex(int(atts->GetOptimizationMethod()));
            optimizationSelect->blockSignals(false);
            break;
        }
    }
}


// ****************************************************************************
// Method: QvisPeaksOverThresholdWindow::GetCurrentValues
//
// Purpose: 
//   Gets values from certain widgets and stores them in the subject.
//
// Note:       Autogenerated by xml2window.
//
// Programmer: xml2window
// Creation:   omitted
//
// Modifications:
//   
// ****************************************************************************

void
QvisPeaksOverThresholdWindow::GetCurrentValues(int which_widget)
{
    bool doAll = (which_widget == -1);

    // Do dataYearBegin
    if(which_widget == PeaksOverThresholdAttributes::ID_dataYearBegin || doAll)
    {
        int val;
        if(LineEditGetInt(dataYearBegin, val))
            atts->SetDataYearBegin(val);
        else
        {
            ResettingError(tr("Year begin"),
                IntToQString(atts->GetDataYearBegin()));
            atts->SetDataYearBegin(atts->GetDataYearBegin());
        }
    }
    // Do dataAnalysisYear1
    if(which_widget == PeaksOverThresholdAttributes::ID_dataAnalysisYear1 || doAll)
    {
        int val;
        if(LineEditGetInt(dataAnalysisYear1, val))
            atts->SetDataAnalysisYear1(val);
        else
        {
            ResettingError(tr("Analysis year 1"),
                IntToQString(atts->GetDataAnalysisYear1()));
            atts->SetDataAnalysisYear1(atts->GetDataAnalysisYear1());
        }
    }

    // Do dataAnalysisYear2
    if(which_widget == PeaksOverThresholdAttributes::ID_dataAnalysisYear2 || doAll)
    {
        int val;
        if(LineEditGetInt(dataAnalysisYear2, val))
            atts->SetDataAnalysisYear2(val);
        else
        {
            ResettingError(tr("Analysis year 1"),
                IntToQString(atts->GetDataAnalysisYear2()));
            atts->SetDataAnalysisYear2(atts->GetDataAnalysisYear2());
        }
    }

    // Do numEnsembles
    if(which_widget == PeaksOverThresholdAttributes::ID_numEnsembles || doAll)
    {
        int val;
        if(LineEditGetInt(numEnsembles, val))
            atts->SetNumEnsembles(val);
        else
        {
            ResettingError(tr("Number of members"),
                IntToQString(atts->GetNumEnsembles()));
            atts->SetNumEnsembles(atts->GetNumEnsembles());
        }
    }

    // Do cutoff
    if(which_widget == PeaksOverThresholdAttributes::ID_cutoff || doAll)
    {
        float val;
        if(LineEditGetFloat(cutoff, val))
            atts->SetCutoff(val);
        else
        {
            ResettingError(tr("Cutoff"),
                FloatToQString(atts->GetCutoff()));
            atts->SetCutoff(atts->GetCutoff());
        }
    }

    // Do dataScaling
    if(which_widget == PeaksOverThresholdAttributes::ID_dataScaling || doAll)
    {
        double val;
        if(LineEditGetDouble(dataScaling, val))
            atts->SetDataScaling(val);
        else
        {
            ResettingError(tr("Data Scaling"),
                DoubleToQString(atts->GetDataScaling()));
            atts->SetDataScaling(atts->GetDataScaling());
        }
    }

    // Do annualPercentile
    if(which_widget == PeaksOverThresholdAttributes::ID_annualPercentile || doAll)
    {
        double val;
        if(LineEditGetDouble(annualPercentile, val))
            atts->SetAnnualPercentile(val);
        else
        {
            ResettingError(tr("Annual Percentile"),
                DoubleToQString(atts->GetAnnualPercentile()));
            atts->SetAnnualPercentile(atts->GetAnnualPercentile());
        }
    }

    // Do seasonalPercentile
    if(which_widget == PeaksOverThresholdAttributes::ID_seasonalPercentile || doAll)
    {
        double val[4];
        if(LineEditGetDoubles(seasonalPercentile, val, 4))
            atts->SetSeasonalPercentile(val);
        else
        {
            ResettingError(tr("Seasonal Percentile"),
                DoublesToQString(atts->GetSeasonalPercentile(),4));
            atts->SetSeasonalPercentile(atts->GetSeasonalPercentile());
        }
    }

    // Do monthlyPercentile
    if(which_widget == PeaksOverThresholdAttributes::ID_monthlyPercentile || doAll)
    {
        double val[12];
        if(LineEditGetDoubles(monthlyPercentile, val, 12))
            atts->SetMonthlyPercentile(val);
        else
        {
            ResettingError(tr("Monthly Percentile"),
                DoublesToQString(atts->GetMonthlyPercentile(),12));
            atts->SetMonthlyPercentile(atts->GetMonthlyPercentile());
        }
    }

    // Do daysPerYear
    if(which_widget == PeaksOverThresholdAttributes::ID_daysPerYear || doAll)
    {
        int val;
        if(LineEditGetInt(daysPerYear, val))
            atts->SetDaysPerYear(val);
        else
        {
            ResettingError(tr("Days per year"),
                IntToQString(atts->GetDaysPerYear()));
            atts->SetDaysPerYear(atts->GetDaysPerYear());
        }
    }

    // Do daysPerMonth
    if(which_widget == PeaksOverThresholdAttributes::ID_daysPerMonth || doAll)
    {
        int val[12];
        if(LineEditGetInts(daysPerMonth, val, 12))
            atts->SetDaysPerMonth(val);
        else
        {
            ResettingError(tr("Days per month"),
                IntsToQString(atts->GetDaysPerMonth(), 12));
            atts->SetDaysPerMonth(atts->GetDaysPerMonth());
        }
    }

    // Do covariateReturnYears
    if(which_widget == PeaksOverThresholdAttributes::ID_covariateReturnYears || doAll)
    {
        intVector val;
        if(LineEditGetInts(covariateReturnYears, val))
            atts->SetCovariateReturnYears(val);
        else
        {
            ResettingError(tr("Return values computed for years"),
                IntsToQString(atts->GetCovariateReturnYears()));
            atts->SetCovariateReturnYears(atts->GetCovariateReturnYears());
        }
    }

    // Do rvDifference1
    if(which_widget == PeaksOverThresholdAttributes::ID_rvDifference1 || doAll)
    {
        int val;
        if(LineEditGetInt(rvDifference1, val))
            atts->SetRvDifference1(val);
        else
        {
            ResettingError(tr("RV Difference1"),
                IntToQString(atts->GetRvDifference1()));
            atts->SetRvDifference1(atts->GetRvDifference1());
        }
    }

    // Do rvDifference2
    if(which_widget == PeaksOverThresholdAttributes::ID_rvDifference2 || doAll)
    {
        int val;
        if(LineEditGetInt(rvDifference2, val))
            atts->SetRvDifference2(val);
        else
        {
            ResettingError(tr("RV Difference2"),
                IntToQString(atts->GetRvDifference2()));
            atts->SetRvDifference2(atts->GetRvDifference2());
        }
    }
}


//
// Qt Slot functions
//


void
QvisPeaksOverThresholdWindow::dataYearBeginProcessText()
{
    GetCurrentValues(PeaksOverThresholdAttributes::ID_dataYearBegin);
    Apply();
}


void
QvisPeaksOverThresholdWindow::dataAnalysisYearRangeEnabledChanged(bool val)
{
    atts->SetDataAnalysisYearRangeEnabled(val);
    Apply();
}

void
QvisPeaksOverThresholdWindow::dataAnalysisYear1ProcessText()
{
    GetCurrentValues(PeaksOverThresholdAttributes::ID_dataAnalysisYear1);
    Apply();
}


void
QvisPeaksOverThresholdWindow::dataAnalysisYear2ProcessText()
{
    GetCurrentValues(PeaksOverThresholdAttributes::ID_dataAnalysisYear2);
    Apply();
}

void
QvisPeaksOverThresholdWindow::ensembleChanged(bool val)
{
    atts->SetEnsemble(val);
    Apply();
}


void
QvisPeaksOverThresholdWindow::numEnsemblesProcessText()
{
    GetCurrentValues(PeaksOverThresholdAttributes::ID_numEnsembles);
    Apply();
}


void
QvisPeaksOverThresholdWindow::cutoffProcessText()
{
    GetCurrentValues(PeaksOverThresholdAttributes::ID_cutoff);
    Apply();
}


void
QvisPeaksOverThresholdWindow::cutoffModeChanged(int val)
{
    if(val != atts->GetCutoffMode())
    {
        atts->SetCutoffMode(PeaksOverThresholdAttributes::CutoffModeType(val));
        SetUpdate(false);
        Apply();
    }
}


void
QvisPeaksOverThresholdWindow::dataScalingProcessText()
{
    GetCurrentValues(PeaksOverThresholdAttributes::ID_dataScaling);
    Apply();
}


void
QvisPeaksOverThresholdWindow::aggregationChanged(int val)
{
    if(val != atts->GetAggregation())
    {
        atts->SetAggregation(PeaksOverThresholdAttributes::AggregationType(val));
        Apply();
    }
}


void
QvisPeaksOverThresholdWindow::optimizationChanged(int val)
{
    if(val != atts->GetOptimizationMethod())
    {
        atts->SetOptimizationMethod(PeaksOverThresholdAttributes::OptimizationType(val));
        Apply();
    }
}


void
QvisPeaksOverThresholdWindow::annualPercentileProcessText()
{
    GetCurrentValues(PeaksOverThresholdAttributes::ID_annualPercentile);
    Apply();
}


void
QvisPeaksOverThresholdWindow::seasonalPercentileProcessText()
{
    GetCurrentValues(PeaksOverThresholdAttributes::ID_seasonalPercentile);
    Apply();
}


void
QvisPeaksOverThresholdWindow::monthlyPercentileProcessText()
{
    GetCurrentValues(PeaksOverThresholdAttributes::ID_monthlyPercentile);
    Apply();
}


void
QvisPeaksOverThresholdWindow::daysPerYearProcessText()
{
    GetCurrentValues(PeaksOverThresholdAttributes::ID_daysPerYear);
    Apply();
}


void
QvisPeaksOverThresholdWindow::daysPerMonthProcessText()
{
    GetCurrentValues(PeaksOverThresholdAttributes::ID_daysPerMonth);
    Apply();
}


void
QvisPeaksOverThresholdWindow::covariateModelScaleChanged(bool val)
{
    atts->SetCovariateModelScale(val);
    SetUpdate(false);
    Apply();
}


void
QvisPeaksOverThresholdWindow::covariateModelLocationChanged(bool val)
{
    atts->SetCovariateModelLocation(val);
    SetUpdate(false);
    Apply();
}


void
QvisPeaksOverThresholdWindow::covariateModelShapeChanged(bool val)
{
    atts->SetCovariateModelShape(val);
    SetUpdate(false);
    Apply();
}


void
QvisPeaksOverThresholdWindow::computeCovariatesChanged(bool val)
{
    atts->SetComputeCovariates(val);
    Apply();
}


void
QvisPeaksOverThresholdWindow::covariateReturnYearsProcessText()
{
    GetCurrentValues(PeaksOverThresholdAttributes::ID_covariateReturnYears);
    Apply();
}


void
QvisPeaksOverThresholdWindow::computeRVDifferencesChanged(bool val)
{
    atts->SetComputeRVDifferences(val);
    Apply();
}

void
QvisPeaksOverThresholdWindow::rvDifference1ProcessText()
{
    GetCurrentValues(PeaksOverThresholdAttributes::ID_rvDifference1);
    Apply();
}


void
QvisPeaksOverThresholdWindow::rvDifference2ProcessText()
{
    GetCurrentValues(PeaksOverThresholdAttributes::ID_rvDifference2);
    Apply();
}


void
QvisPeaksOverThresholdWindow::computeParamValuesChanged(bool val)
{
    atts->SetComputeParamValues(val);
    SetUpdate(false);
    Apply();
}


void
QvisPeaksOverThresholdWindow::displaySeasonChanged(int val)
{
    if(val != atts->GetDisplaySeason())
    {
        atts->SetDisplaySeason(PeaksOverThresholdAttributes::SeasonType(val));
        SetUpdate(false);
        Apply();
    }
}


void
QvisPeaksOverThresholdWindow::displayMonthChanged(int val)
{
    if(val != atts->GetDisplayMonth())
    {
        atts->SetDisplayMonth(PeaksOverThresholdAttributes::MonthType(val));
        SetUpdate(false);
        Apply();
    }
}


void
QvisPeaksOverThresholdWindow::dumpDataChanged(bool val)
{
    atts->SetDumpData(val);
    SetUpdate(false);
    Apply();
}

void
QvisPeaksOverThresholdWindow::dumpDebugChanged(bool val)
{
    atts->SetDumpDebug(val);
    SetUpdate(false);
    Apply();
}

void
QvisPeaksOverThresholdWindow::noConsecutiveDayChanged(bool val)
{
    atts->SetNoConsecutiveDay(val);
    SetUpdate(false);
    Apply();
}




/*****************************************************************************
*
* Copyright (c) 2000 - 2013, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//  File: avtLCSFilter.C
// ************************************************************************* //

#include <avtLCSFilter.h>
#include <avtLCSIC.h>

// For now use the avtLCSIC as the state does not need to be recorded
// for the FSLE. That is because currently the integration is being
// done step by step rather than in chunks. However, the code is set up
// to use avtStreamlineIC. Which if the integration is done in chucks
// will probably be more efficient.

//#include <avtStreamlineIC.h>
#define avtStreamlineIC avtLCSIC

#include <avtExtents.h>
#include <avtMatrix.h>
#include <avtParallel.h>
#include <avtCallback.h>

#include <avtOriginatingSource.h>
#include <avtGradientExpression.h>
#include <vtkVisItScalarTree.h>

#include <VisItException.h>
#include <ImproperUseException.h>

#include <vtkUniformGrid.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkFloatArray.h>
#include <vtkPointData.h>
#include <vtkStreamer.h>

#include <iostream>
#include <limits>
#include <cmath>

// ****************************************************************************
//  Method: avtLCSFilter constructor
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
//  Modifications:
//
//    Hank Childs, Wed Mar 28 08:36:34 PDT 2012
//    Initialize pathlines later.  Also set tolerances.
//
// ****************************************************************************

avtLCSFilter::avtLCSFilter() : seedVelocity(0,0,0)
{
    //outVarName ="operators/LCS/mesh";
    //doPathlines();
    //SetPathlines(atts.GetPathlines(),
    //              atts.GetPathlinesOverrideStartingTimeFlag(),
    //              atts.GetPathlinesOverrideStartingTime(),
    //              atts.GetPathlinesCMFE());
    //SetPathlines(true,false,0,PICS_CONN_CMFE);
    //SetPathlines(false,false,0,PICS_CONN_CMFE);

    // These initializations prevent harmless UMRs when we do our first
    // cache lookups.
    global_bounds[0] = global_bounds[2] = global_bounds[4] = 0;
    global_bounds[1] = global_bounds[3] = global_bounds[5] = 1;
    global_resolution[0] = global_resolution[1] = global_resolution[2] = 10;
    absTol = 1e-6;
    relTol = 1e-7;

    numSteps = 0;
    fsle_dt = 0;
    fsle_ds = 0;

    minSizeValue = std::numeric_limits<double>::max();
    maxSizeValue = std::numeric_limits<double>::min();
}


// ****************************************************************************
//  Method: avtLCSFilter destructor
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
//  Modifications:
//
// ****************************************************************************

avtLCSFilter::~avtLCSFilter()
{
}


// ****************************************************************************
//  Method: avtLCSFilter::Create
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
// ****************************************************************************

avtFilter *avtLCSFilter::Create()
{
    return new avtLCSFilter();
}


// ****************************************************************************
//  Method: avtLCSFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
//  Modifications:
//
//    Hank Childs, Tue Mar 27 16:24:13 PDT 2012
//    Don't do pathlines if steady state is indicated.
//
//    Hank Childs, Wed Apr 11 11:35:16 PDT 2012
//    Add reverse flow.
//
// ****************************************************************************

void
avtLCSFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const LCSAttributes*)a;

    needsRecalculation =
      atts.ChangesRequireRecalculation(*(const LCSAttributes*)a);

    int CMFEType = (atts.GetPathlinesCMFE() == LCSAttributes::CONN_CMFE
                    ? PICS_CONN_CMFE : PICS_POS_CMFE);

    SetPathlines(atts.GetPathlines(),
                 atts.GetPathlinesOverrideStartingTimeFlag(),
                 atts.GetPathlinesOverrideStartingTime(),
                 CMFEType);

    SetIntegrationDirection(atts.GetIntegrationDirection());

    SetFieldType(atts.GetFieldType());
    SetFieldConstant(atts.GetFieldConstant());
    SetVelocitySource(atts.GetVelocitySource());

    SetIntegrationType(atts.GetIntegrationType());
    SetParallelizationAlgorithm(atts.GetParallelizationAlgorithmType(), 
                                atts.GetMaxProcessCount(),
                                atts.GetMaxDomainCacheSize(),
                                atts.GetWorkGroupSize());

    if (atts.GetIntegrationType() == LCSAttributes::DormandPrince)
    {
      if( atts.GetOperationType() ==  LCSAttributes::Lyapunov &&
            atts.GetTerminateBySize() )
        {
          EXCEPTION1(ImproperUseException,
                     "When performing FSLE the step size must be fixed. "
                     "Please select a different solver and "
                     "set the maximum time step.");
        }

        // For DoPri, the max time step is sent in to the PICS filter
        // as the max step length.
        double step;
        if (atts.GetLimitMaximumTimestep())
          step = atts.GetMaxTimeStep();
        else
          step = 0;

        SetMaxStepLength(step);
    }
    else
        SetMaxStepLength(atts.GetMaxStepLength());

    double absTol = 0.;
    bool doBBox = (atts.GetAbsTolSizeType() == LCSAttributes::FractionOfBBox);
    if (doBBox)
        absTol = atts.GetAbsTolBBox();
    else
        absTol = atts.GetAbsTolAbsolute();
    SetTolerances(atts.GetRelTol(), absTol, doBBox);

    SetTermination(atts.GetMaxSteps(),
                   atts.GetTerminateByDistance(),
                   atts.GetTermDistance(),
                   atts.GetTerminateByTime(),
                   atts.GetTermTime(),
                   atts.GetTerminateBySize(),
                   atts.GetTermSize());

    IssueWarningForMaxStepsTermination(atts.GetIssueTerminationWarnings());
    IssueWarningForStiffness(atts.GetIssueStiffnessWarnings());
    IssueWarningForCriticalPoints(atts.GetIssueCriticalPointsWarnings(),
                                  atts.GetCriticalPointThreshold());
}


// ****************************************************************************
//  Method: avtLCSFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtLCSFilter with the given
//      parameters would result in an equivalent avtLCSFilter.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
// ****************************************************************************

bool
avtLCSFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(LCSAttributes*)a);
}


// ****************************************************************************
// Method: avtLCSFilter::SetVelocitySource
//
// Purpose: 
//   Sets the integral curve velocity source.
//
// Arguments:
//   vel : The velocity of the point.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

void
avtLCSFilter::SetVelocitySource(const double *p)
{
  seedVelocity.set(p);
}


// ****************************************************************************
//  Method: avtLCSFilter::GetInitialVelocities
//
//  Purpose:
//      Get the seed velocities out of the attributes.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

std::vector<avtVector>
avtLCSFilter::GetInitialVelocities(void)
{
    std::vector<avtVector> seedVels;

    seedVels.push_back( seedVelocity );

    return seedVels;
}


// ****************************************************************************
//  Method: avtLCSFilter::SetTermination
//
//  Purpose:
//      Sets the termination criteria for an integral curve.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

void
avtLCSFilter::SetTermination(int maxSteps_,
                              bool doDistance_, double maxDistance_,
                              bool doTime_,     double maxTime_,
                              bool doSize_,     double maxSize_)
{
    maxSteps = maxSteps_;
    doDistance = doDistance_;
    maxDistance = maxDistance_;
    doTime = doTime_;
    maxTime = maxTime_;
    doSize = doSize_;
    maxSize = maxSize_;
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateIntegralCurve
//
//  Purpose:
//      Create an uninitialized integral curve.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtIntegralCurve*
avtLCSFilter::CreateIntegralCurve(void)
{
  if( doSize ) 
    return (new avtStreamlineIC());
  else
    return (new avtLCSIC());
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateIntegralCurve
//
//  Purpose:
//      Create an integral curve with specific IDs and parameters.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtIntegralCurve*
avtLCSFilter::CreateIntegralCurve(const avtIVPSolver* model,
                                   avtIntegralCurve::Direction dir,
                                   const double& t_start,
                                   const avtVector &p_start,
                                   const avtVector& v_start, long ID)
{
    double t;

    if (doPathlines)
    {
        if (dir == avtIntegralCurve::DIRECTION_BACKWARD)
            t = seedTime0 - maxTime;
        else
            t = seedTime0 + maxTime;
    }
    else
    {
        if (dir == avtIntegralCurve::DIRECTION_BACKWARD)
            t = -maxTime;
        else
            t = maxTime;
    }

    if( doSize )
    {
      // For now use the avtLCSIC as the state does not need to be
      // recorded for the FSLE. That is because currently the
      // integration is being done step by step rather than in
      // chunks. However, the code is set up to use
      // avtStreamlineIC. Which if the integration is done in chucks
      // will probably be more efficient.

      // unsigned char attr = avtStateRecorderIntegralCurve::SAMPLE_POSITION;
      // attr |= avtStateRecorderIntegralCurve::SAMPLE_TIME;
      // attr |= avtStateRecorderIntegralCurve::SAMPLE_ARCLENGTH;
      
      // return
      //   (new avtStreamlineIC(numSteps, doDistance, maxDistance, doTime, t,
      //                        attr, model, dir, t_start, p_start, v_start, ID));
      return
        (new avtLCSIC(numSteps, doDistance, maxDistance, doTime, t,
                       model, dir, t_start, p_start, v_start, ID));
    }
    else
    {
      return
        (new avtLCSIC(maxSteps, doDistance, maxDistance, doTime, t,
                       model, dir, t_start, p_start, v_start, ID));
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::ModifyContract
//
//  Purpose:
//      Creates a contract the removes the operator-created-expression.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
// ****************************************************************************

avtContract_p
avtLCSFilter::ModifyContract(avtContract_p in_contract)
{
    avtDataRequest_p in_dr = in_contract->GetDataRequest();
    std::string var =  in_dr->GetOriginalVariable();
//    in_contract->SetReplicateSingleDomainOnAllProcessors(true);
//    in_contract->SetOnDemandStreaming(false);
//    in_contract->GetDataRequest();
    in_dr->SetUsesAllDomains(true);
    if( strncmp(var.c_str(), "operators/LCS/", strlen("operators/LCS/")) == 0)
    {
        std::string justTheVar = var.substr(strlen("operators/LCS/"));

        outVarName = justTheVar;
        avtDataRequest_p out_dr = new avtDataRequest(in_dr,justTheVar.c_str());
        //out_dr->SetDesiredGhostDataType(GHOST_NODE_DATA);
        //out_dr->SetDesiredGhostDataType(GHOST_ZONE_DATA);

        return avtPICSFilter::ModifyContract( new avtContract(in_contract,out_dr) );
    }

    return avtPICSFilter::ModifyContract(in_contract);
}


// ****************************************************************************
//  Method: avtLCSFilter::UpdateDataObjectInfo
//
//  Purpose:
//      Tells output that we have a new variable.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
// ****************************************************************************

void
avtLCSFilter::UpdateDataObjectInfo(void)
{
    avtDataAttributes &in_atts = GetInput()->GetInfo().GetAttributes();
    avtDataAttributes &atts = GetOutput()->GetInfo().GetAttributes();

    timeState = in_atts.GetTimeIndex();

    //the outvarname has been assigned and will be added.
    //outVarName = "velocity";
    if (outVarName != "")
    {
        std::string fullVarName = std::string("operators/LCS/") + outVarName;
        atts.RemoveVariable(in_atts.GetVariableName());

        if (! atts.ValidVariable(fullVarName) )
        {
            //std::cout << "Adding variable: " << outVarName << std::endl;
            //atts.AddVariable(outVarName.c_str());
            atts.AddVariable((fullVarName).c_str());
            atts.SetActiveVariable(fullVarName.c_str());
            atts.SetVariableDimension(1);
            //atts.SetTopologicalDimension(3);
            atts.SetVariableType(AVT_SCALAR_VAR);
            atts.SetCentering(AVT_NODECENT);
        }
    }

    avtPICSFilter::UpdateDataObjectInfo();
}


// ****************************************************************************
//  Method: avtLCSFilter::PreExecute
//
//  Purpose:
//      Initialize data attributes for this filter and its base type (PICS).
//
//  Programmer: Hari Krishna
//  Creation:   December 5, 2011
//
//  Modifications:
//
//    Hank Childs, Jul  6 14:17:47 PDT 2012
//    Set resolution for Z to be 1 for 2D meshes.
//
// ****************************************************************************

void 
avtLCSFilter::PreExecute(void)
{
    SetActiveVariable(outVarName.c_str());
    GetSpatialExtents(global_bounds);

    if (GetInput()->GetInfo().GetAttributes().GetSpatialDimension() == 2)
    {
        // we set them to 0->1 earlier and GetSpatialExtents only sets the
        // X and Y parts of the extents for 2D.
        global_bounds[4] = 0;
        global_bounds[5] = 0;
    }

    if(atts.GetUseDataSetStart() == LCSAttributes::Subset)
    {
        double* a = atts.GetStartPosition();
        global_bounds[0] = a[0];
        global_bounds[2] = a[1];
        global_bounds[4] = a[2];
    }

    if(atts.GetUseDataSetEnd() == LCSAttributes::Subset)
    {
        double* a = atts.GetEndPosition();
        global_bounds[1] = a[0];
        global_bounds[3] = a[1];
        global_bounds[5] = a[2];
    }

    const int* res = atts.GetResolution();
    global_resolution[0] = res[0];
    global_resolution[1] = res[1];
    global_resolution[2] = res[2];
    if (global_bounds[4] == global_bounds[5])
        global_resolution[2] = 1;

    double minResolution = std::numeric_limits<float>::max();

    double resX, resY, resZ;

    if (global_resolution[0] > 1)
    {
      double pcnt = 1.0 / (double) (global_resolution[0]-1);

      resX = (global_bounds[1] - global_bounds[0]) * pcnt; 

      minResolution = std::min( resX, minResolution );
    }
      
    if (global_resolution[1] > 1)
    {
      double pcnt = 1.0 / (double) (global_resolution[1]-1);

      resY = (global_bounds[3] - global_bounds[2]) * pcnt; 
 
      minResolution = std::min( resY, minResolution );
    }
      
    if (global_resolution[2] > 1)
    {
      double pcnt = 1.0 / (double) (global_resolution[2]-1);

      resZ = (global_bounds[5] - global_bounds[4]) * pcnt; 

      minResolution = std::min( resZ, minResolution );
    }

    if( atts.GetOperationType() ==  LCSAttributes::Lyapunov &&
        doSize && maxSize <= minResolution )
    {
        char str[1028];

        SNPRINTF(str, 1028, "\nThe size limit for the FSLE is %f. "
                 "and is equal to or smaller than the resolution of the grid "
                 "(%f, %f, %f). ",
                 atts.GetTermSize(), resX, resY, resZ );

        avtCallback::IssueWarning(str);
        
//      EXCEPTION1(ImproperUseException, str );
    }

    avtPICSFilter::PreExecute();
}


// ****************************************************************************
//  Method: avtLCSFilter::Execute
//
//  Purpose:
//      Executes the LCS.  If we already have a cached version, then it
//      just returns that version.  If not, it calls PICS execute, which will
//      call our LCS set up routines via CreateIntegralCurveOutput.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

void
avtLCSFilter::Execute(void)
{
    avtDataTree_p dt = GetCachedDataSet();

    if (!needsRecalculation && *dt != NULL)
    {
        debug1 << "LCS: using cached version" << std::endl;
        if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
            if (PAR_Rank() != 0)
                dt = new avtDataTree();
        SetOutputDataTree(dt);
        return;
    }
    else
    {
      debug1 << "LCS: no cached version, must re-execute" << std::endl;

      avtPICSFilter::Execute();

      std::vector<avtIntegralCurve *> ics;
      GetTerminatedIntegralCurves(ics);
      
      ReportWarnings( ics );
    }
}

// ****************************************************************************
//  Method: avtLCSFilter::ContinueExecute
//
//  Purpose:
//      See if execution needs to continue.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

bool
avtLCSFilter::ContinueExecute()
{
    ++numSteps;

    if( atts.GetOperationType() == LCSAttributes::Lyapunov )
    {
      if( doSize )
      {
//      std::cerr << "Continue execute " << numSteps << std::endl;
        
        std::vector<avtIntegralCurve *> ics;
        
        GetTerminatedIntegralCurves(ics);
        
        if (atts.GetSourceType() == LCSAttributes::NativeMesh)
        {
          if (NativeMeshIterativeCalc(ics) == true )
            return false;
          else
            return true;
        }
        else //if (atts.GetSourceType() == LCSAttributes::RegularGrid)
        {
          if (RectilinearGridIterativeCalc(ics) == true )
            return false;
          else
            return true;
        }
      }
    }

    return false;
}

// ****************************************************************************
//  Method: avtLCSFilter::CreateIntegralCurveOutput
//
//  Purpose:
//      Computes the LCS output (via sub-routines) after the PICS filter has
//      calculated the final particle positions.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

void 
avtLCSFilter::CreateIntegralCurveOutput(std::vector<avtIntegralCurve*> &ics)
{
  if( atts.GetOperationType() == LCSAttributes::Lyapunov )
  {
    if( doTime || doDistance )
    {
      if (atts.GetSourceType() == LCSAttributes::NativeMesh)
        NativeMeshSingleCalc(ics);
      else //if (atts.GetSourceType() == LCSAttributes::RegularGrid)
        RectilinearGridSingleCalc(ics);
    }
    else if( doSize )
    {
      if (atts.GetSourceType() == LCSAttributes::NativeMesh)
        CreateNativeMeshIterativeCalcOutput(ics);
      else //if (atts.GetSourceType() == LCSAttributes::RegularGrid)
        CreateRectilinearGridIterativeCalcOutput(ics);
    }
  }
  else
  {
    if (atts.GetSourceType() == LCSAttributes::NativeMesh)
      NativeMeshSingleCalc(ics);
    else //if (atts.GetSourceType() == LCSAttributes::RegularGrid)
      RectilinearGridSingleCalc(ics);
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::GetInitialLocations
//
//  Purpose:
//      Tells the PICS filter where to place the initial seed locations.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

std::vector<avtVector>
avtLCSFilter::GetInitialLocations()
{
    seedPoints.clear();

    if (atts.GetSourceType() == LCSAttributes::NativeMesh)
    {
        GetInitialLocationsFromNativeMesh(GetInputDataTree());
    }
    else //if (atts.GetSourceType() == LCSAttributes::RegularGrid)
    {
        GetInitialLocationsFromRectilinearGrid();
    }

    return seedPoints;
}


// ****************************************************************************
//  Method: avtLCSFilter::GetInitialLocationsFromMesh
//
//  Purpose:
//      Walks through an AVT data tree and sets up the initial locations from
//      each point in the mesh.
//
//  Arguments:
//      inDT          A pointer to a data tree.  
//
//  Programmer: Hank Childs
//  Creation:   December 5, 2011
//
// ****************************************************************************

void
avtLCSFilter::GetInitialLocationsFromNativeMesh(avtDataTree_p inDT)
{
    if (*inDT == NULL)
        return;

    int nc = inDT->GetNChildren();

    if (nc <= 0 && !inDT->HasData())
    {
        return;
    }

    if (nc == 0)
    {
        //
        // there is only one dataset to process
        //
        vtkDataSet *in_ds = inDT->GetDataRepresentation().GetDataVTK();
        size_t pts = in_ds->GetNumberOfPoints();

        int numberOfSeeds = seedPoints.size();
        int totalNumberOfSeeds = numberOfSeeds + pts;

        seedPoints.resize( totalNumberOfSeeds );

        double points[3];
        for(size_t i = 0; i < pts; ++i)
        {
          in_ds->GetPoint(i, points);
          seedPoints[numberOfSeeds+i].set(points);
        }
    }
    else
    {
        //
        // there is more than one input dataset to process
        // and we need an output datatree for each
        //
        for (int j = 0; j < nc; j++)
        {
            if (inDT->ChildIsPresent(j))
            {
                GetInitialLocationsFromNativeMesh(inDT->GetChild(j));
            }
        }
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::GetInitialLocationsFromRectilinearGrid
//
//  Purpose:
//      Created a series of seeds points based on the user specified mesh
//
//  Programmer: Hank Childs
//  Creation:   December 5, 2011
//
// ****************************************************************************

void
avtLCSFilter::GetInitialLocationsFromRectilinearGrid()
{
    //compute total number of seeds that will be generated.
    size_t totalNumberOfSeeds =
      global_resolution[0] * global_resolution[1] * global_resolution[2];
    
    seedPoints.resize(totalNumberOfSeeds);

    size_t l = 0; //current line of the seed.
  
    //add sample points by looping over in x,y,z
    for(int k = 0; k < global_resolution[2]; ++k)
    {
        double zpcnt = 0;

        if (global_resolution[2] > 1)
          zpcnt = ((double)k)/((double)global_resolution[2]-1);

        double z = global_bounds[4]*(1.0-zpcnt) + global_bounds[5]*zpcnt;
        
        for(int j = 0; j < global_resolution[1]; ++j)
        {
            double ypcnt = 0;

            if (global_resolution[1] > 1)
              ypcnt = ((double)j)/((double)global_resolution[1]-1);

            double y = global_bounds[2]*(1.0-ypcnt) + global_bounds[3]*ypcnt;
            
            for(int i = 0; i < global_resolution[0]; ++i)
            {
                double xpcnt = 0;

                if (global_resolution[0] > 1)
                  xpcnt = ((double)i)/((double)global_resolution[0]-1);

                double x =
                  global_bounds[0]*(1.0-xpcnt) +
                  global_bounds[1]*xpcnt;
                
                size_t index =
                  (global_resolution[1]*global_resolution[0]*k) +
                  (global_resolution[0]*j)+i;

                seedPoints[l++].set(x,y,z);
            }
        }
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::NativeMeshSingleCalc
//
//  Purpose:
//      Computes the FTLE and similar values that are neighbor
//      independent after the particles have been advected.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

void avtLCSFilter::NativeMeshSingleCalc(std::vector<avtIntegralCurve*> &ics)
{
    //accumulate all of the points then do jacobian?
    //or do jacobian then accumulate?
    //picking the first.

    double minv   = std::numeric_limits<double>::max();
    double maxv   = std::numeric_limits<double>::min();
    int    offset = 0;

    avtDataTree_p outTree =
      MultiBlockSingleCalc(GetInputDataTree(), ics, offset, minv, maxv);

    if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
        if (PAR_Rank() != 0)
            outTree = new avtDataTree();
    SetOutputDataTree(outTree);

    avtDataAttributes &dataatts = GetOutput()->GetInfo().GetAttributes();
    avtExtents* e = dataatts.GetThisProcsActualDataExtents();

    double range[2];
    range[0] = minv;
    range[1] = maxv;
    e->Set(range);

    e = dataatts.GetThisProcsOriginalDataExtents();
    e->Set(range);

    e = dataatts.GetThisProcsActualSpatialExtents();
    e->Set(global_bounds);
    e = dataatts.GetThisProcsOriginalSpatialExtents();
    e->Set(global_bounds);
}


// ****************************************************************************
//  Method: avtLCSFilter::MultiBlockSingleCalc
//
//  Purpose:
//      Computes the FTLE and similar values that are neighbor
//      independent for the whole data set, using the final particle
//      locations, at the blocks native mesh resolution.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtDataTree_p
avtLCSFilter::MultiBlockSingleCalc( avtDataTree_p inDT,
                                    std::vector<avtIntegralCurve*> &ics,
                                    int &offset, double &minv, double &maxv )
{
    if (*inDT == NULL)
        return 0;

    int nc = inDT->GetNChildren();

    if (nc <= 0 && !inDT->HasData())
    {
        return 0;
    }

    if (nc == 0)
    {
        //
        // there is only one dataset to process
        //
        vtkDataSet *in_ds = inDT->GetDataRepresentation().GetDataVTK();
        int dom = inDT->GetDataRepresentation().GetDomain();
        std::string label = inDT->GetDataRepresentation().GetLabel();

        vtkDataSet *out_ds =
          SingleBlockSingleCalc( in_ds, ics, offset, dom, minv, maxv );
        avtDataTree_p rv = new avtDataTree(out_ds, dom, label);
        out_ds->Delete();
        return rv;
    }
    else
    {
      //
      // there is more than one input dataset to process
      // and we need an output datatree for each
      //
      avtDataTree_p *outDT = new avtDataTree_p[nc];
      for (int j = 0; j < nc; j++)
      {
          if (inDT->ChildIsPresent(j))
            outDT[j] = MultiBlockSingleCalc( inDT->GetChild(j), ics, 
                                                    offset, minv, maxv );
          else
            outDT[j] = NULL;
      }
      avtDataTree_p rv = new avtDataTree(nc, outDT);
      delete [] outDT;
      return rv;
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::SingleBlockSingleCalc
//
//  Purpose:
//      Computes the FTLE and similar values that are neighbor
//      independent for a single block of a data set, using the final
//      particle locations, at the blocks native mesh resolution.
//
//  Arguments:
//      in_ds   The block to calculate the value on
//      ics     The list of particles for all blocks on this MPI task.
//      domain  The domain number of in_ds
//      minv    The minimum value (output)
//      maxv    The maximum value (output)
//
//  Returns:    The new version of in_ds that includes the scalar
//              variable.  The calling function is responsible for
//              dereferencing this VTK object.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
//  Modifications:
//
//    Hank Childs, Tue Feb  5 08:12:33 PST 2013
//    Fix parallelization bug and memory leak.
//
// ****************************************************************************

vtkDataSet *
avtLCSFilter::SingleBlockSingleCalc( vtkDataSet *in_ds,
                                     std::vector<avtIntegralCurve*> &ics,
                                     int &offset, int domain,
                                     double &minv, double &maxv )
{
    //variable name.
    std::string var = std::string("operators/LCS/") + outVarName;

    //create new instance from old.
    vtkDataSet* out_grid = in_ds->NewInstance();
    out_grid->ShallowCopy(in_ds);
    int nTuples = in_ds->GetNumberOfPoints();

    //an array for the initial locations.
    std::vector<avtVector> remapPoints;
    remapPoints.resize(nTuples);

    if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
    {
        // The parallel synchronization for when data is replicated involves
        // a sum across all processors.  So we want remapPoints to have the
        // location of the particle on one processor, and zero on the rest.
        // Do that here.
        // Special care is needed for the case where the particle never
        // advected.  Then we need to put the initial location on just one
        // processor.  We do this on rank 0.
        std::vector<int> iHavePoint(nTuples, 0);
        std::vector<int> anyoneHasPoint;

        for (size_t idx = 0; idx < ics.size(); idx++)
        {
            size_t index = ics[idx]->id;
            size_t l = (index-offset);
            if(l >= 0 && l < remapPoints.size())
            {
                iHavePoint[l] = 1;
            }
        }

        UnifyMaximumValue(iHavePoint, anyoneHasPoint);
        avtVector zero;
        zero.x = zero.y = zero.z = 0.;
        for (size_t i = 0; i < nTuples; i++)
            if (PAR_Rank() == 0 && !anyoneHasPoint[i])
                remapPoints[i] = seedPoints.at(offset + i);
            else
                remapPoints[i] = zero;
    }
    else
    {
        //copy the original seed points
        for(size_t i = 0; i < remapPoints.size(); ++i)
            remapPoints[i] = seedPoints.at(offset + i);
    }

    for(int i = 0; i < ics.size(); ++i)
    {
        size_t index = ics[i]->id;
        int l = (index-offset);
        //std::cout << "l = " << l << " " << nTuples << std::endl;
        if(0 <= l && l < remapPoints.size())
        {
          // remapPoints[l] = ((avtLCSIC*)ics[i])->GetEndPoint() -
          //                ((avtLCSIC*)ics[i])->GetStartPoint();

          if( atts.GetOperationType() == LCSAttributes::Lyapunov )
          {
            remapPoints.at(l) = ((avtLCSIC*)ics[i])->GetEndPoint();
          }
          else
          {
            remapPoints.at(l) =
              avtVector( ((avtLCSIC*)ics[i])->GetTime(),
                         ((avtLCSIC*)ics[i])->GetDistance(),
                         ((avtLCSIC*)ics[i])->GetSummation0() /
                         (double) ((avtLCSIC*)ics[i])->GetNumSteps() );
          }
        }
    }

    //done with offset, increment it for the next call to this
    //function.
    offset += nTuples;

    //use static function in avtGradientExpression to calculate
    //gradients.  since this function only does scalar, break our
    //vectors into scalar components and calculate one at a time.

    vtkDataArray* jacobian[3];

    vtkFloatArray *component = vtkFloatArray::New();
    component->SetName(var.c_str());
    component->SetNumberOfTuples(nTuples);

    //temporarily add point data to output grid in order to calculate
    //gradient per component.

    //is this soft copy or deep copy?
    out_grid->GetPointData()->AddArray(component);
    out_grid->GetPointData()->SetActiveScalars(var.c_str());

    if( atts.GetOperationType() == LCSAttributes::Lyapunov )
    {
      for(int i = 0; i < 3; ++i)
      {
        for(size_t j = 0; j < nTuples; ++j)
            component->SetTuple1(j, remapPoints[j][i]);

        if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
        {
            float *newvals = new float[nTuples];
            float *origvals = (float *) component->GetVoidPointer(0);
            SumFloatArrayAcrossAllProcessors(origvals, newvals, nTuples);
            // copy newvals back into origvals
            memcpy(origvals, newvals, nTuples*sizeof(float));
            delete [] newvals;
        }

        jacobian[i] =
          avtGradientExpression::CalculateGradient(out_grid, var.c_str());
      }

      for (int i = 0; i < nTuples; i++)
        component->SetTuple1(i, std::numeric_limits<float>::epsilon());

      //now have the jacobian - 3 arrays with 3 components.
      ComputeFTLE(jacobian, component);

      jacobian[0]->Delete();
      jacobian[1]->Delete();
      jacobian[2]->Delete();
    }
    else
    {
      int index = atts.GetOperationType() - 1;

      for(size_t j = 0; j < nTuples; ++j)
        component->SetTuple1(j, remapPoints[j][index]);
    }

    for(int i = 0; i < nTuples; ++i)
    {
        minv = std::min(component->GetTuple1(i), minv);
        maxv = std::max(component->GetTuple1(i), maxv);
    }

    component->Delete();

    //Store this dataset in Cache for next time.
    std::string str = CreateCacheString();

    StoreArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                            outVarName.c_str(),domain, -1,
                            str.c_str(), out_grid);

    // Calling function must free this.
    return out_grid;
}


// ****************************************************************************
//  Method: avtLCSFilter::RectilinearGridSingleCalc
//
//  Purpose:
//      Computes the FTLE and similar values that are neighbor
//      independent on a rectilinear grid.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
//    Mark C. Miller, Wed Aug 22 19:22:40 PDT 2012
//    Fix leak of all_indices, index_counts, all_points, result_counts on 
//    rank 0 (root).
// ****************************************************************************

void
avtLCSFilter::RectilinearGridSingleCalc(std::vector<avtIntegralCurve*> &ics)
{
    int    maxSteps = std::numeric_limits<int>::min();
    double maxTime = std::numeric_limits<double>::min();
    double maxLength = std::numeric_limits<double>::min();

    //variable name.
    std::string var = std::string("operators/LCS/") + outVarName;

    //algorithm sends index to global datastructure as well as end points.
    //Send List of index into global array to rank 0
    //Send end positions into global array to rank 0

    //loop over all the intelgral curves and add it back to the
    //original list of seeds.
    intVector indices(ics.size());
    doubleVector points(ics.size()*3);
    doubleVector times(ics.size());
    doubleVector lengths(ics.size());

    for(size_t i=0, j=0; i<ics.size(); ++i, j+=3)
    {
        indices[i] = ics[i]->id;
        times[i] = ((avtLCSIC*)ics[i])->GetTime();
        lengths[i] = ((avtLCSIC*)ics[i])->GetArcLength();

        maxSteps  = std::max( ((avtLCSIC*)ics[i])->GetNumSteps(), maxSteps);
        maxTime   = std::max( ((avtLCSIC*)ics[i])->GetTime(), maxTime);
        maxLength = std::max( ((avtLCSIC*)ics[i])->GetArcLength(), maxLength);

        if( atts.GetOperationType() == LCSAttributes::Lyapunov )
        {
          avtVector end_point = ((avtLCSIC*)ics[i])->GetEndPoint();
          
          // std::cout << PAR_Rank() << " ics: " << indices[i] << " "
          //             << end_point << std::endl;

          points[j+0] = end_point[0];
          points[j+1] = end_point[1];
          points[j+2] = end_point[2];
        }
        else
        {
          points[j+0] = ((avtLCSIC*)ics[i])->GetTime();
          points[j+1] = ((avtLCSIC*)ics[i])->GetArcLength();
          points[j+2] = ((avtLCSIC*)ics[i])->GetSummation0() /
            (double) ((avtLCSIC*)ics[i])->GetNumSteps();
        }
    }

    std::cerr << "Max steps " << maxSteps
              << "  max time " << maxTime
              << "  max arc length " << maxLength
              << std::endl;

    // std::cout << PAR_Rank() << " total integral pts: "
    //        << ics.size() << std::endl;
    // std::flush(cout);

    int* all_indices = 0;
    int* index_counts = 0;

    double* all_times = 0;
    int *time_counts = 0;

    double* all_lengths = 0;
    int *length_counts = 0;

    double* all_points = 0;
    int *point_counts = 0;

    Barrier();

    CollectIntArraysOnRootProc(all_indices, index_counts,
                               &indices.front(), indices.size());

    CollectDoubleArraysOnRootProc(all_times, time_counts,
                                  &times.front(), times.size());

    CollectDoubleArraysOnRootProc(all_lengths, time_counts,
                                  &lengths.front(), lengths.size());

    CollectDoubleArraysOnRootProc(all_points, point_counts,
                                  &points.front(), points.size());

    Barrier();

    //root should now have index into global structure and all
    //matching end positions.
    if(PAR_Rank() != 0)
    {
        //std::cout << PAR_Rank() << " creating dummy output" << std::endl;
        avtDataTree* dummy = new avtDataTree();
        SetOutputDataTree(dummy);
    }
    else
    {
        //rank 0
        //now create a rectilinear grid.
        vtkRectilinearGrid* rect_grid = vtkRectilinearGrid::New();

        vtkFloatArray* lxcoord = vtkFloatArray::New();
        vtkFloatArray* lycoord = vtkFloatArray::New();
        vtkFloatArray* lzcoord = vtkFloatArray::New();

        rect_grid->SetDimensions(global_resolution);

        lxcoord->SetNumberOfTuples(global_resolution[0]);
        for (int i = 0; i < global_resolution[0]; i++)
        {
            double pcnt = 0;
            if (global_resolution[0] > 1)
                pcnt = ((double)i)/((double)global_resolution[0]-1);
            lxcoord->SetTuple1(i, global_bounds[0]*(1.0-pcnt) + global_bounds[1]*pcnt);
        }

        lycoord->SetNumberOfTuples(global_resolution[1]);
        for (int i = 0; i < global_resolution[1]; i++)
        {
            double pcnt = 0;
            if (global_resolution[1] > 1)
                pcnt = ((double)i)/((double)global_resolution[1]-1);
            lycoord->SetTuple1(i, global_bounds[2]*(1.0-pcnt) + global_bounds[3]*pcnt);
        }

        lzcoord->SetNumberOfTuples(global_resolution[2]);
        for (int i = 0; i < global_resolution[2]; i++)
        {
            double pcnt = 0;
            if (global_resolution[2] > 1)
                pcnt = ((double)i)/((double)global_resolution[2]-1);
            lzcoord->SetTuple1(i, global_bounds[4]*(1.0-pcnt) + global_bounds[5]*pcnt);
        }

        rect_grid->SetXCoordinates(lxcoord);
        rect_grid->SetYCoordinates(lycoord);
        rect_grid->SetZCoordinates(lzcoord);

        //cleanup
        lxcoord->Delete();
        lycoord->Delete();
        lzcoord->Delete();

        //now global grid has been created.
        size_t leafSize =
          global_resolution[0] * global_resolution[1] * global_resolution[2];

        // std::cout << "final resolution: " << PAR_Rank() << " "
        //         << global_resolution[0] << " "
        //         << global_resolution[1] << " "
        //         << global_resolution[2] << std::endl;

        vtkFloatArray *component = vtkFloatArray::New();
        component->SetName(var.c_str());
        component->SetNumberOfTuples(leafSize);

        rect_grid->GetPointData()->AddArray(component);
        rect_grid->GetPointData()->SetActiveScalars(var.c_str());

        //calculate jacobian in parts (x,y,z).
        std::vector<double> remapTimes(leafSize);
        std::vector<double> remapLengths(leafSize);
        std::vector<avtVector> remapPoints(leafSize);

        //update remapPoints with new value bounds from integral curves.
        int par_size = PAR_Size();
        size_t total = 0;
        for(int i = 0; i < par_size; ++i)
        {
            if(index_counts[i]*3 != point_counts[i])
            {
              EXCEPTION1(VisItException,
                         "Index count does not the result count." );
            }
            total += index_counts[i];
        }

        // std::cout << "total number integrated: " << total << std::endl;

        for(int j = 0,k = 0; j < total; ++j, k += 3)
        {
            size_t index = all_indices[j];

            if(index >= leafSize)
            {
              EXCEPTION1(VisItException,
                         "More integral curves were generatated than "
                         "grid points." );
            }

            // std::cout << index << " before " << remapPoints[index]
            //        << std::endl;

            remapTimes[index] = all_times[j];
            remapLengths[index] = all_lengths[j];

            remapPoints[index].set( all_points[k+0],
                                    all_points[k+1],
                                    all_points[k+2]);
            
            // std::cout << PAR_Rank() << " " << index << " "
            //        << remapPoints[index] << std::endl;
            // std::cout << "middle: " << avtVector( all_points[k+0],
            //                                    all_points[k+1],
            //                                    all_points[k+2])
            //        << std::endl;
            // std::cout << index << " after " << remapPoints[index]
            //        << std::endl;
        }

        if( atts.GetOperationType() == LCSAttributes::Lyapunov )
        {
          vtkDataArray* jacobian[3];

          for(int i = 0; i < 3; ++i)
          {
            for (size_t l = 0; l < leafSize; l++)
                component->SetTuple1(l, remapPoints[l][i]);

            jacobian[i] =
              avtGradientExpression::CalculateGradient(rect_grid, var.c_str());
          }

          for (size_t l = 0; l < leafSize; l++)
            component->SetTuple1(l, std::numeric_limits<float>::epsilon());

          ComputeFTLE(jacobian, component);

          jacobian[0]->Delete();
          jacobian[1]->Delete();
          jacobian[2]->Delete();
        }
        else
        {
          int index = atts.GetOperationType() - 1;

          if( atts.GetOperatorType() == LCSAttributes::BaseValue )
          {
            for (size_t l = 0; l < leafSize; l++)
              component->SetTuple1(l, remapPoints[l][index]);
          }

          else if( atts.GetOperatorType() == LCSAttributes::Gradient )
          {
            // The base value is used to clamp the log values to be only
            // positive or both positive and negative.
            double baseValue;

            if (atts.GetClampLogValues() == true )
              baseValue = 1.0;
            else
              baseValue = std::numeric_limits<double>::epsilon();

            for (size_t l = 0; l < leafSize; l++)
              component->SetTuple1(l, remapPoints[l][index]);

            vtkDataArray* gradient =
              avtGradientExpression::CalculateGradient(rect_grid, var.c_str());

            for (size_t l = 0; l < leafSize; l++)
            {
              double *grad = gradient->GetTuple3(l);

              double lambda = baseValue;
              lambda = std::max( lambda, grad[0]*grad[0] );
              lambda = std::max( lambda, grad[1]*grad[1] );
              lambda = std::max( lambda, grad[2]*grad[2] );
              lambda = log( sqrtf( lambda ) );

              if( doTime )
                lambda /= maxTime;
              else if( doDistance )
                lambda /= maxDistance;

              component->SetTuple1(l, lambda);
            }

            gradient->Delete();
          }
          else if( atts.GetOperatorType() == LCSAttributes::Jacobian )
          {
            vtkDataArray* jacobian[3];

            for(int i = 0; i < 3; ++i)
            {
              for (size_t l = 0; l < leafSize; l++)
              {
                component->SetTuple1(l, remapPoints[l][index]);
              }

              jacobian[i] =
                avtGradientExpression::CalculateGradient(rect_grid, var.c_str());

              // Remove the cross product values.
              for (size_t l = 0; l < leafSize; l++)
              {
                double *j = jacobian[i]->GetTuple3(l);

                for(int k = 0; k < 3; ++k)
                  if( i != k ) j[k] = 0;

                jacobian[i]->SetTuple3(l, j[0], j[1], j[2]);
              }
            }

            for (size_t l = 0; l < leafSize; l++)
            {
              component->SetTuple1(l, std::numeric_limits<float>::epsilon());
            }

            ComputeFTLE(jacobian, component);

            jacobian[0]->Delete();
            jacobian[1]->Delete();
            jacobian[2]->Delete();
          }
          else //if( atts.GetOperatorType() == LCSAttributes::Ratio )
          {
            vtkFloatArray *time = vtkFloatArray::New();
            time->SetName("times");
            time->SetNumberOfTuples(leafSize);

            vtkFloatArray *length = vtkFloatArray::New();
            length->SetName("lengths");
            length->SetNumberOfTuples(leafSize);

            for (size_t l = 0; l < leafSize; l++)
            {
              time->SetTuple1(l, remapTimes[l]);
              length->SetTuple1(l, remapLengths[l]);
            }

            ComputeFLLE(time, length, component,
                        global_resolution[0],
                        global_resolution[1],
                        global_resolution[2] );

            time->Delete();
            length->Delete();
          }
        }


        //min and max values over all datasets of the tree.
        double minv = std::numeric_limits<double>::max();
        double maxv = std::numeric_limits<double>::min();

        for(size_t l = 0; l < leafSize; ++l)
        {
            minv = std::min(component->GetTuple1(l), minv);
            maxv = std::max(component->GetTuple1(l), maxv);
        }

        //cleanup.
        component->Delete();

        if (all_indices)  delete [] all_indices;
        if (index_counts) delete [] index_counts;

        if (all_times)  delete [] all_times;
        if (time_counts) delete [] time_counts;

        if (all_lengths)  delete [] all_lengths;
        if (length_counts) delete [] length_counts;

        if (all_points)   delete [] all_points;
        if (point_counts) delete [] point_counts;

        //store this dataset in Cache for next time.
        // double bounds[6];
        // rect_grid->GetBounds(bounds);

        // std::cout << "final size and bounds: "
        //        << PAR_Rank() << " " << leafSize << " "
        //        << bounds[0] << " " << bounds[1] << " " << bounds[2]
        //        << " " << bounds[3] << " " << bounds[4] << " "
        //        << bounds[5] << std::endl;

        std::string str = CreateCacheString();
        StoreArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                                outVarName.c_str(), -1, -1,
                                str.c_str(), rect_grid);

        int index = 0;//what does index mean in this context?
        avtDataTree* dt = new avtDataTree(rect_grid,index);
        int x = 0;
        dt->GetAllLeaves(x);

        // std::cout << "total leaves:: " << x << std::endl;

        SetOutputDataTree(dt);

        //set atts.
        avtDataAttributes &dataatts = GetOutput()->GetInfo().GetAttributes();
        avtExtents* e = dataatts.GetThisProcsActualDataExtents();

        double range[2];
        range[0] = minv;
        range[1] = maxv;
        e->Set(range);
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::ComputeFTLE
//
//  Purpose:
//      Computes the FTLE or FLLE given a Jacobian. Which is the
//      following: log of the square root of the maximum eigen value
//      of the right Caughy-Green Tensor with the result divided by
//      the time or distance.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
//  Modifications:
//
//    Hank Childs, Fri Sep  7 15:47:12 PDT 2012
//    Convert calculation to double precision, which prevents a "cliff" from
//    too large epsilon associated with float.
//
// ****************************************************************************

void avtLCSFilter::ComputeFTLE(vtkDataArray *jacobian[3], vtkDataArray *result)
{
    size_t nTuples = result->GetNumberOfTuples();

    // The base value is used to clamp the log values to be only
    // positive or both positive and negative.
    double baseValue;

    if (atts.GetClampLogValues() == true )
      baseValue = 1.0;
    else
      baseValue = std::numeric_limits<double>::epsilon();


    for(size_t l = 0; l < nTuples; ++l)
    {
        double * j0 = jacobian[0]->GetTuple3(l);
        double * j1 = jacobian[1]->GetTuple3(l);
        double * j2 = jacobian[2]->GetTuple3(l);

        //x,y,z components compute left,right
        avtVector dx(j0[0],j1[0],j2[0]);
        //x,y,z components compute top,bottom
        avtVector dy(j0[1],j1[1],j2[1]);
        //x,y,z components compute front,back
        avtVector dz(j0[2],j1[2],j2[2]);

        // Compute the 
        //J*J^T
        //float a = dx.dot(dx), b = dx.dot(dy), c = dx.dot(dz);
        //float d = dy.dot(dy), e = dy.dot(dz), f = dz.dot(dz);

        double a = dx.x*dx.x + dx.y*dx.y + dx.z*dx.z;
        double b = dx.x*dy.x + dx.y*dy.y + dx.z*dy.z;
        double c = dx.x*dz.x + dx.y*dz.y + dx.z*dz.z;
        double d = dy.x*dy.x + dy.y*dy.y + dy.z*dy.z;
        double e = dy.x*dz.x + dy.y*dz.y + dy.z*dz.z;
        double f = dz.x*dz.x + dz.y*dz.y + dz.z*dz.z;
        double x = ( a + d + f ) / 3.0f;

        a -= x;
        d -= x;
        f -= x;

        double q = (a*d*f + b*e*c + c*b*e - c*d*c - e*e*a - f*b*b) / 2.0f;
        double r = (a*a + b*b + c*c + b*b + d*d + e*e + c*c + e*e + f*f);
        r /= 6.0f;

        double D = (r*r*r - q*q);
        double phi = 0.0f;

        // std::cout << a << " " << b << " " << c << " " << d << " "
        //           << e << " " << f << " " << x << " " << q << " "
        //           << r << std::endl;

        if( D < std::numeric_limits<double>::epsilon())
            phi = 0.0f;
        else
        {
            phi = atanf( sqrtf(D)/q ) / 3.0f;

            if( phi < 0 )
                phi += M_PI;
        }

        const double sqrt3 = sqrtf(3.0f);
        const double sqrtr = sqrtf(r);

        double sinphi = 0.0f, cosphi = 0.0f;
        sinphi = sinf(phi);
        cosphi = cosf(phi);

        double lambda = baseValue;
        lambda = std::max( lambda, x + 2.0f*sqrtr*cosphi );
        lambda = std::max( lambda, x - sqrtr*(cosphi + sqrt3*sinphi) );
        lambda = std::max( lambda, x - sqrtr*(cosphi - sqrt3*sinphi) );
        lambda = log( sqrtf( lambda ) );

        if( doTime )
          lambda /= maxTime;
        else if( doDistance )
          lambda /= maxDistance;

        result->SetTuple1(l, lambda);
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateIterativeCalcDataTree
//
//  Purpose:
//      Create the output tree for the whole data set, using the 
//      input tree using the blocks native resolution.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

avtDataTree_p
avtLCSFilter::CreateIterativeCalcDataTree(avtDataTree_p inDT)
{
    if (*inDT == NULL)
      return 0;
    
    int nc = inDT->GetNChildren();
    
    if (nc <= 0 && !inDT->HasData())
    {
      return 0;
    }

    if (nc == 0)
    {
        //variable name.
        std::string var = std::string("operators/LCS/") + outVarName;

        //
        // there is only one dataset to process
        //
        vtkDataSet *in_ds = inDT->GetDataRepresentation().GetDataVTK();
        vtkDataSet *out_ds;

        //create new instance from old.
        // vtkDataSet* out_ds = in_ds->NewInstance();
        // out_ds->ShallowCopy(in_ds);
        // int nTuples = in_ds->GetNumberOfPoints();

        int dims[3];
        int nTuples;

        if (in_ds->GetDataObjectType() == VTK_UNIFORM_GRID)
        {
          ((vtkUniformGrid*)in_ds)->GetDimensions(dims);

          nTuples = dims[0] * dims[1] * dims[2];

          //now create a rectilinear grid.
        
          // The grid is stored so not to be created as each curve is
          // extended.
          vtkUniformGrid *out_ug = vtkUniformGrid::New();
          out_ug->SetDimensions(dims);
          out_ug->SetExtent( 0, dims[0]-1, 0, dims[1]-1, 0, dims[2]-1 );

          out_ds = out_ug;
        }
        
        else if (in_ds->GetDataObjectType() == VTK_RECTILINEAR_GRID)
        {
          ((vtkRectilinearGrid*)in_ds)->GetDimensions(dims);

          nTuples = dims[0] * dims[1] * dims[2];

          //now create a rectilinear grid.
        
          // The grid is stored so not to be created as each curve is
          // extended.
          vtkRectilinearGrid *out_rg = vtkRectilinearGrid::New();
          out_rg->SetDimensions(dims);
        
          vtkFloatArray* lxcoord = vtkFloatArray::New();
          vtkFloatArray* lycoord = vtkFloatArray::New();
          vtkFloatArray* lzcoord = vtkFloatArray::New();
        
          //Note this grid is a uniform gird which allows the
          //avtGradientExpression to be used to get the distances
          //between integral curves.
          lxcoord->SetNumberOfTuples(dims[0]);
          for (int i = 0; i < dims[0]; i++)
            lxcoord->SetTuple1(i, i);
      
          lycoord->SetNumberOfTuples(dims[1]);
          for (int j = 0; j < dims[1]; j++)
            lycoord->SetTuple1(j, j);
      
          lzcoord->SetNumberOfTuples(dims[2]);
          for (int k = 0; k < dims[2]; k++)
            lzcoord->SetTuple1(k, k);
      
          out_rg->SetXCoordinates(lxcoord);
          out_rg->SetYCoordinates(lycoord);
          out_rg->SetZCoordinates(lzcoord);
        
          //cleanup
          lxcoord->Delete();
          lycoord->Delete();
          lzcoord->Delete();

          out_ds = out_rg;
        }
        else if (in_ds->GetDataObjectType() == VTK_STRUCTURED_GRID)
        {
          ((vtkStructuredGrid*)in_ds)->GetDimensions(dims);

          nTuples = dims[0] * dims[1] * dims[2];

          //now create a structured grid.
        
          // The grid is stored so not to be created as each curve is
          // extended.
          vtkStructuredGrid *out_sg = vtkStructuredGrid::New();
          out_sg->SetDimensions(dims);

          vtkPoints* points = vtkPoints::New();

          points->SetNumberOfPoints( nTuples );

          size_t l = 0;

          for (int k = 0; k < dims[2]; k++)
          {
            for (int j = 0; j < dims[1]; j++)
            {
              for (int i = 0; i < dims[0]; i++)
              {
                points->SetPoint(l, i, j, k );
              }
            }
          }

          out_sg->SetPoints( points );

          //cleanup
          points->Delete();

          out_ds = out_sg;
        }
        else
        {
          EXCEPTION1(VisItException,
                     "Can only compute FSLE on structure meshs "
                     "(uniform, rectilinear, or structured grids). "
                     "The native mesh is not a structure mesh. "
                     "Please use a 'Source type' of 'Regular grid' instead.");
        }

        // Create storage for the components that need to be used
        // for calculating the exponent. All arrays but the exponent
        // array will be deleted when done.
        vtkFloatArray *exponents = vtkFloatArray::New();
        exponents->SetName(var.c_str());
        exponents->SetNumberOfTuples(nTuples);
        out_ds->GetPointData()->AddArray(exponents);
        // Will set the exponents to be the active scalars when
        // finished. In the mean time the component is the working
        // active scalars.
//      out_ds->GetPointData()->SetActiveScalars(var.c_str());

        vtkFloatArray *component = vtkFloatArray::New();
        component->SetName("component");
        component->SetNumberOfTuples(nTuples);
        out_ds->GetPointData()->AddArray(component);
        out_ds->GetPointData()->SetActiveScalars("component");
        
        vtkFloatArray *times = vtkFloatArray::New();
        times->SetName("times");
        times->SetNumberOfTuples(nTuples);
        out_ds->GetPointData()->AddArray(times);

        vtkFloatArray *lengths = vtkFloatArray::New();
        lengths->SetName("lengths");
        lengths->SetNumberOfTuples(nTuples);
        out_ds->GetPointData()->AddArray(lengths);

        vtkFloatArray *distx = vtkFloatArray::New();
        distx->SetName("distx");
        distx->SetNumberOfTuples(nTuples);
        out_ds->GetPointData()->AddArray(distx);

        vtkFloatArray *disty = vtkFloatArray::New();
        disty->SetName("disty");
        disty->SetNumberOfTuples(nTuples);
        out_ds->GetPointData()->AddArray(disty);

        vtkFloatArray *distz = vtkFloatArray::New();
        distz->SetName("distz");
        distz->SetNumberOfTuples(nTuples);
        out_ds->GetPointData()->AddArray(distz);

        // The mask array is a tally to indicate whether a curve
        // needs to have additional integration. WHen the tally
        // reachs a count of seven no additional integration is
        // required. (Sseven == six neighbors and itself).
        vtkIntArray *mask = vtkIntArray::New();
        mask->SetName("mask");
        mask->SetNumberOfTuples(nTuples);
        out_ds->GetPointData()->AddArray(mask);

        for (size_t l = 0; l < nTuples; l++)
        {
          exponents->SetTuple1(l, std::numeric_limits<float>::min());
          mask->SetTuple1(l, 0 );
        }
        
        // Preincraement the mask as boundary nodes will not be
        // accessed fully.
        int k1 = 0;
        int k_1 = global_resolution[2]-1;

        // Z plane
        for(int j = 0; j < global_resolution[1]; ++j)
        {
          for(int i = 0; i < global_resolution[0]; ++i)
          {
            Increment( i, j, k1,  mask,
                       global_resolution[0],
                       global_resolution[1],
                       global_resolution[2] );
            Increment( i, j, k_1, mask,
                       global_resolution[0],
                       global_resolution[1],
                       global_resolution[2] );
          }
        }
          
        int j1 = 0;
        int j_1 = global_resolution[1]-1;
          
        for(int k = 0; k < global_resolution[2]; ++k)
        {
          for(int i = 0; i < global_resolution[0]; ++i)
          {
            Increment( i, j1,  k, mask,
                       global_resolution[0],
                       global_resolution[1],
                       global_resolution[2] );
            Increment( i, j_1, k, mask,
                       global_resolution[0],
                       global_resolution[1],
                       global_resolution[2] );
          }
        }

        int i1 = 0;
        int i_1 = global_resolution[0]-1;
          
        for(int k = 0; k < global_resolution[2]; ++k)
        {
          for(int j = 0; j < global_resolution[1]; ++j)
          {
            Increment( i1, j,  k, mask,
                       global_resolution[0],
                       global_resolution[1],
                       global_resolution[2] );
            Increment( i_1, j, k, mask,
                       global_resolution[0],
                       global_resolution[1],
                       global_resolution[2] );
          }
        }
          

        vtkDataArray* dxyz[3];

        for(int i = 0; i < 3; ++i)
        {
          // Store the point component by component
          for(size_t l=0; l<nTuples; ++l)
            component->SetTuple1(l, in_ds->GetPoint( l )[i]);
          
          dxyz[i] =
            avtGradientExpression::CalculateGradient(fsle_ds, "component");
        }
          
        for(size_t l=0; l<nTuples; ++l)
        {
          double *dxyz0 = dxyz[0]->GetTuple3(l);
          double *dxyz1 = dxyz[1]->GetTuple3(l);
          double *dxyz2 = dxyz[2]->GetTuple3(l);
          
          distx->SetTuple1( l, avtVector(dxyz0[0], dxyz1[0], dxyz2[0]).length() );
          disty->SetTuple1( l, avtVector(dxyz0[1], dxyz1[1], dxyz2[1]).length() );
          distz->SetTuple1( l, avtVector(dxyz0[2], dxyz1[2], dxyz2[2]).length() );
        }

        dxyz[0]->Delete();
        dxyz[1]->Delete();
        dxyz[2]->Delete();


        //cleanup
        exponents->Delete();
        component->Delete();
        times->Delete();
        lengths->Delete();
        mask->Delete();
        
        int dom = inDT->GetDataRepresentation().GetDomain();
        std::string label = inDT->GetDataRepresentation().GetLabel();
        avtDataTree_p rv = new avtDataTree(out_ds, dom, label);
        out_ds->Delete();
        return rv;
    }
    else
    {
      //
      // there is more than one input dataset to process
      // and we need an output datatree for each
      //
      avtDataTree_p *outDT = new avtDataTree_p[nc];
      for (int j = 0; j < nc; j++)
      {
          if (inDT->ChildIsPresent(j))
            outDT[j] = CreateIterativeCalcDataTree(inDT->GetChild(j));
          else
            outDT[j] = NULL;
      }
      avtDataTree_p rv = new avtDataTree(nc, outDT);
      delete [] outDT;
      return rv;
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateIterativeCalcDataSet
//
//  Purpose:
//      Create the output tree for the whole data set, using the 
//      input tree using the blocks native resolution.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

vtkDataSet*
avtLCSFilter::CreateIterativeCalcDataSet()
{
  //rank 0
  //variable name.
  std::string var = std::string("operators/LCS/") + outVarName;

  //now create a rectilinear grid.
  size_t nTuples =
    global_resolution[0] * global_resolution[1] * global_resolution[2];

          
  // The grid is stored so not to be created as each curve is
  // extended.
  vtkRectilinearGrid* rect_grid = vtkRectilinearGrid::New();

  rect_grid->SetDimensions(global_resolution);
      
  vtkFloatArray* lxcoord = vtkFloatArray::New();
  vtkFloatArray* lycoord = vtkFloatArray::New();
  vtkFloatArray* lzcoord = vtkFloatArray::New();

  //Note this grid is a uniform gird which allows the
  //avtGradientExpression to be used to get the distances
  //between integral curves.
  lxcoord->SetNumberOfTuples(global_resolution[0]);
  for (int i = 0; i < global_resolution[0]; i++)
    lxcoord->SetTuple1(i, i);
      
  lycoord->SetNumberOfTuples(global_resolution[1]);
  for (int i = 0; i < global_resolution[1]; i++)
    lycoord->SetTuple1(i, i);
      
  lzcoord->SetNumberOfTuples(global_resolution[2]);
  for (int i = 0; i < global_resolution[2]; i++)
    lzcoord->SetTuple1(i, i);
      
  rect_grid->SetXCoordinates(lxcoord);
  rect_grid->SetYCoordinates(lycoord);
  rect_grid->SetZCoordinates(lzcoord);
        
  //cleanup
  lxcoord->Delete();
  lycoord->Delete();
  lzcoord->Delete();

  // std::cout << "final resolution: " << PAR_Rank() << " "
  //         << global_resolution[0] << " "
  //         << global_resolution[1] << " "
  //         << global_resolution[2] << std::endl;

  // Create storage for the components that need to be used
  // for calculating the exponent. All arrays but the exponent
  // array will be deleted when done.
  vtkFloatArray *exponents = vtkFloatArray::New();
  exponents->SetName(var.c_str());
  exponents->SetNumberOfTuples(nTuples);
  rect_grid->GetPointData()->AddArray(exponents);
  // Will set the exponents to be the active scalars when
  // finished. In the mean time the component is the working
  // active scalars.
  // rect_grid->GetPointData()->SetActiveScalars(var.c_str());

  vtkFloatArray *component = vtkFloatArray::New();
  component->SetName("component");
  component->SetNumberOfTuples(nTuples);
  rect_grid->GetPointData()->AddArray(component);
  rect_grid->GetPointData()->SetActiveScalars("component");

  vtkFloatArray *times = vtkFloatArray::New();
  times->SetName("times");
  times->SetNumberOfTuples(nTuples);
  rect_grid->GetPointData()->AddArray(times);

  vtkFloatArray *lengths = vtkFloatArray::New();
  lengths->SetName("lengths");
  lengths->SetNumberOfTuples(nTuples);
  rect_grid->GetPointData()->AddArray(lengths);

  vtkFloatArray *distx = vtkFloatArray::New();
  distx->SetName("distx");
  distx->SetNumberOfTuples(nTuples);
  rect_grid->GetPointData()->AddArray(distx);

  vtkFloatArray *disty = vtkFloatArray::New();
  disty->SetName("disty");
  disty->SetNumberOfTuples(nTuples);
  rect_grid->GetPointData()->AddArray(disty);

  vtkFloatArray *distz = vtkFloatArray::New();
  distz->SetName("distz");
  distz->SetNumberOfTuples(nTuples);
  rect_grid->GetPointData()->AddArray(distz);


  // The mask array is a tally to indicate whether a curve
  // needs to have additional integration. WHen the tally
  // reachs a count of seven no additional integration is
  // required. (Sseven == six neighbors and itself).
  vtkIntArray *mask = vtkIntArray::New();
  mask->SetName("mask");
  mask->SetNumberOfTuples(nTuples);
  rect_grid->GetPointData()->AddArray(mask);

  for (size_t l=0; l<nTuples; l++)
  {
    exponents->SetTuple1(l, std::numeric_limits<float>::min());
    mask->SetTuple1(l, 0 );
  }
          
  // Preincraement the mask as boundary nodes will not be accessed
  // fully.
  int k1 = 0;
  int k_1 = global_resolution[2]-1;
  
  // Z plane
  for(int j = 0; j < global_resolution[1]; ++j)
  {
    for(int i = 0; i < global_resolution[0]; ++i)
    {
      Increment( i, j, k1,  mask,
                 global_resolution[0],
                 global_resolution[1],
                 global_resolution[2] );
      Increment( i, j, k_1, mask,
                 global_resolution[0],
                 global_resolution[1],
                 global_resolution[2] );
    }
  }
  
  int j1 = 0;
  int j_1 = global_resolution[1]-1;
  
  for(int k = 0; k < global_resolution[2]; ++k)
  {
    for(int i = 0; i < global_resolution[0]; ++i)
    {
      Increment( i, j1,  k, mask,
                 global_resolution[0],
                 global_resolution[1],
                 global_resolution[2] );
      Increment( i, j_1, k, mask,
                 global_resolution[0],
                 global_resolution[1],
                 global_resolution[2] );
    }
  }
  
  int i1 = 0;
  int i_1 = global_resolution[0]-1;
  
  for(int k = 0; k < global_resolution[2]; ++k)
  {
    for(int j = 0; j < global_resolution[1]; ++j)
    {
      Increment( i1, j,  k, mask,
                 global_resolution[0],
                 global_resolution[1],
                 global_resolution[2] );
      Increment( i_1, j, k, mask,
                 global_resolution[0],
                 global_resolution[1],
                 global_resolution[2] );
    }
  }

  vtkDataArray* dxyz[3];

  for(int i = 0; i < 3; ++i)
  {
    // Store the point component by component
    for(size_t l=0; l<nTuples; ++l)
      component->SetTuple1(l, rect_grid->GetPoint( l )[i]);

    dxyz[i] =
      avtGradientExpression::CalculateGradient(rect_grid, "component");
  }

  for(size_t l=0; l<nTuples; ++l)
  {
    double *dxyz0 = dxyz[0]->GetTuple3(l);
    double *dxyz1 = dxyz[1]->GetTuple3(l);
    double *dxyz2 = dxyz[2]->GetTuple3(l);

    distx->SetTuple1( l, avtVector(dxyz0[0], dxyz1[0], dxyz2[0]).length() );
    disty->SetTuple1( l, avtVector(dxyz0[1], dxyz1[1], dxyz2[1]).length() );
    distz->SetTuple1( l, avtVector(dxyz0[2], dxyz1[2], dxyz2[2]).length() );
  }

  dxyz[0]->Delete();
  dxyz[1]->Delete();
  dxyz[2]->Delete();
  
  //cleanup
  exponents->Delete();
  component->Delete();
  times->Delete();
  lengths->Delete();
  mask->Delete();

  distx->Delete();
  disty->Delete();
  distz->Delete();

  return rect_grid;
}
  

// ****************************************************************************
//  Method: avtLCSFilter::NativeMeshIterativeCalc
//
//  Purpose:
//      Computes the FSLE and similar values that are neighbor
//      dependent on a native resolution grid.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
//    Mark C. Miller, Wed Aug 22 19:22:40 PDT 2012
//    Fix leak of all_indices, index_counts, all_result, result_counts on 
//    rank 0 (root).
// ****************************************************************************

bool
avtLCSFilter::NativeMeshIterativeCalc(std::vector<avtIntegralCurve*> &ics)
{
    int offset = 0;

    if( *fsle_dt == NULL )
    {
      fsle_dt = CreateIterativeCalcDataTree(GetInputDataTree());
      
      if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
        if (PAR_Rank() != 0)
          fsle_dt = new avtDataTree();

      SetOutputDataTree(fsle_dt);
    }

    return MultiBlockIterativeCalc(fsle_dt, ics, offset);
}


// ****************************************************************************
//  Method: avtLCSFilter::MultiBlockIterativeCalc
//
//  Purpose:
//      Computes the FSLE and similar values that are neighbor
//      dependent for the whole data set, using the final particle
//      locations, at the blocks native resolution.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

bool
avtLCSFilter::MultiBlockIterativeCalc(avtDataTree_p outDT,
                                     std::vector<avtIntegralCurve*> &ics,
                                     int &offset)
{
    if ( *outDT == NULL)
        return true;

    int nc = outDT->GetNChildren();

    if( nc <= 0 && !outDT->HasData())
        return true;

    if (nc == 0)
    {
        //
        // there is only one dataset to process
        //
        vtkDataSet *out_ds = outDT->GetDataRepresentation().GetDataVTK();

        return SingleBlockIterativeCalc( out_ds, ics, offset );
    }
    else
    {
      bool haveAllExponents = true;

      //
      // there is more than one input dataset to process
      // and we need an output datatree for each
      //
      for (int j = 0; j < nc; j++)
      {
        if (outDT->ChildIsPresent(j) )
        {
          if( MultiBlockIterativeCalc( outDT->GetChild(j), ics, offset ) == false )
            haveAllExponents = false;
        }
      }

      return haveAllExponents;
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::SingleBlockIterativeCalc
//
//  Purpose:
//      Computes the FSLE and similar values that are neighbor
//      dependent for a single block of a data set, using the final
//      particle locations, at the blocks native resolution.
//
//  Arguments:
//      out_ds  The block to calculate the FSLE on
//      ics     The list of particles for all blocks on this MPI task.
//
//  Returns:    The new version of in_ds that includes the FSLE scalar
//              variable.  The calling function is responsible for
//              dereferencing this VTK object.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
//    Hank Childs, Tue Feb  5 08:12:33 PST 2013
//    Fix parallelization bug and memory leak.
//
// ****************************************************************************

bool
avtLCSFilter::SingleBlockIterativeCalc( vtkDataSet *out_ds,
                                        std::vector<avtIntegralCurve*> &ics,
                                        int &offset )
{
    //variable name.
    std::string var = std::string("operators/LCS/") + outVarName;

    int nTuples = out_ds->GetNumberOfPoints();
    
    int dims[3];

    if (out_ds->GetDataObjectType() == VTK_UNIFORM_GRID)
    {
      ((vtkUniformGrid*)out_ds)->GetDimensions(dims);
    }      
    else if (out_ds->GetDataObjectType() == VTK_RECTILINEAR_GRID)
    {
      ((vtkRectilinearGrid*)out_ds)->GetDimensions(dims);
    }      
    else if (out_ds->GetDataObjectType() == VTK_STRUCTURED_GRID)
    {
      ((vtkStructuredGrid*)out_ds)->GetDimensions(dims);
    }      
    else
    {
      EXCEPTION1(VisItException,
                 "Can only compute SingleBlockIterativeCalc on "
                 "imagedata, rectilinear grids, or structured grids. ");
    }

    // Get the stored data arrays
    vtkDataArray* jacobian[3];
    
    vtkFloatArray *exponents = (vtkFloatArray *)
      out_ds->GetPointData()->GetArray(var.c_str());
    vtkFloatArray *component = (vtkFloatArray *)
      out_ds->GetPointData()->GetArray("component");
    vtkFloatArray *times = (vtkFloatArray *)
      out_ds->GetPointData()->GetArray("times");
    vtkFloatArray *lengths = (vtkFloatArray *)
      out_ds->GetPointData()->GetArray("lengths");
    vtkIntArray *mask = (vtkIntArray *)
      out_ds->GetPointData()->GetArray("mask");

    vtkFloatArray *distx = (vtkFloatArray *)
      out_ds->GetPointData()->GetArray("distx");
    vtkFloatArray *disty = (vtkFloatArray *)
      out_ds->GetPointData()->GetArray("disty");    
    vtkFloatArray *distz = (vtkFloatArray *)
      out_ds->GetPointData()->GetArray("distz");
    
    // Storage for the points, times, and lengths
    std::vector<avtVector> remapPoints(nTuples);
    std::vector<double> remapTimes(nTuples);
    std::vector<double> remapLengths(nTuples);

    if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
    {
        // The parallel synchronization for when data is replicated involves
        // a sum across all processors.  So we want remapPoints to have the
        // location of the particle on one processor, and zero on the rest.
        // Do that here.
        // Special care is needed for the case where the particle never
        // advected.  Then we need to put the initial location on just one
        // processor.  We do this on rank 0.
        std::vector<int> iHavePoint(nTuples, 0);
        std::vector<int> anyoneHasPoint;

        for (size_t idx = 0; idx < ics.size(); idx++)
        {
            size_t index = ics[idx]->id;
            size_t l = (index-offset);
            if(l >= 0 && l < remapPoints.size())
            {
                iHavePoint[l] = 1;
            }
        }

        UnifyMaximumValue(iHavePoint, anyoneHasPoint);
        avtVector zero;
        zero.x = zero.y = zero.z = 0.;
        for (size_t i = 0; i < nTuples; i++)
            if (PAR_Rank() == 0 && !anyoneHasPoint[i])
            {
                remapPoints[i] = seedPoints.at(offset + i);
                remapTimes[i] = 0;
                remapLengths[i] = 0;
            }
            else
            {
                remapPoints[i] = zero;
                remapTimes[i] = 0;
                remapLengths[i] = 0;
            }
    }
    else
    {
        //copy the original seed points
        for(size_t i = 0; i < remapPoints.size(); ++i)
        {
            remapPoints[i] = seedPoints.at(offset + i);
            remapTimes[i] = 0;
            remapLengths[i] = 0;
        }
    }

    for(int i = 0; i < ics.size(); ++i)
    {
        avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];

        size_t index = ic->id;
        int l = (index-offset);

        //std::cout << "l = " << l << " " << nTuples << std::endl;
        if(0 <= l && l < remapPoints.size())
        {
          // remapPoints[l] = ((avtLCSIC*)ics[i])->GetEndPoint() -
          //                ((avtLCSIC*)ics[i])->GetStartPoint();

          remapPoints.at(l) = ic->GetEndPoint();

          if( doPathlines )
            remapTimes.at(l) = ic->GetTime() - seedTime0;
          else
            remapTimes.at(l) = ic->GetTime();

          remapLengths.at(l) = ic->GetDistance();
        }
    }

    //use static function in avtGradientExpression to calculate
    //gradients.  since this function only does scalar, break our
    //vectors into scalar components and calculate one at a time.

    for(int i = 0; i < 3; ++i)
    {
        for(size_t j = 0; j < nTuples; ++j)
            component->SetTuple1(j, remapPoints[j][i]);

        if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
        {
            float *newvals = new float[nTuples];
            float *origvals = (float *) component->GetVoidPointer(0);
            SumFloatArrayAcrossAllProcessors(origvals, newvals, nTuples);
            // copy newvals back into origvals
            memcpy(origvals, newvals, nTuples*sizeof(float));
            delete [] newvals;
        }

        jacobian[i] =
          avtGradientExpression::CalculateGradient(out_ds, var.c_str());
    }

    // Store the times and lengths for the exponent.
    for(size_t l = 0; l < nTuples; ++l)
    {
      times->SetTuple1(l, remapTimes[l]);
      lengths->SetTuple1(l, remapLengths[l]);
    }

    // Compute the FSLE
    ComputeFSLE( jacobian, distx, disty, distz,
                 times, lengths, exponents, mask,
                 dims[0], dims[1], dims[2]);

    jacobian[0]->Delete();
    jacobian[1]->Delete();
    jacobian[2]->Delete();

    bool haveAllExponents = true;

    // For each integral curve check it's mask value to see it
    // additional integration is required.
    for(size_t i=0; i<ics.size(); ++i)
    {
      avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];

      size_t index = ic->id;
      int l = (index-offset);

      if( mask->GetTuple1( l ) < 7 )
      {
        ic->maxSteps++;
        ic->status.ClearTerminationMet();
      }

      // Check to see if all exponents have been found.
      if( exponents->GetTuple1(l) == std::numeric_limits<float>::min() &&
          ic->maxSteps < maxSteps )
        haveAllExponents = false;
    }
    
    //done with offset, increment it for the next call to this
    //function.
    offset += nTuples;

    return haveAllExponents;
}


// ****************************************************************************
//  Method: avtLCSFilter::RectilinearGridIterativeCalc
//
//  Purpose:
//      Computes the FSLE and similar values that are neighbor
//      dependent on a rectilinear grid.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//    Mark C. Miller, Wed Aug 22 19:22:40 PDT 2012
//    Fix leak of all_indices, index_counts, all_result, result_counts on 
//    rank 0 (root).
// ****************************************************************************

bool
avtLCSFilter::RectilinearGridIterativeCalc( std::vector<avtIntegralCurve*> &ics )
{
//  std::cerr << "Computing ... " << std::endl;

    //algorithm sends index to global datastructure as well as end points.
    //Send List of index into global array to rank 0
    //Send end positions into global array to rank 0

    //loop over all the intelgral curves and add it back to the
    //original list of seeds.
    intVector indices(ics.size());
    doubleVector points(ics.size()*3);
    doubleVector times(ics.size());
    doubleVector lengths(ics.size());

    for(size_t i=0, j=0; i<ics.size(); ++i, j+=3)
    {
        avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];

        indices[i] = ic->id;

        avtVector spoint = ic->GetStartPoint();

        avtVector point = ic->GetEndPoint();

//      if( spoint[0] == 79 && spoint[1] == 90 && spoint[2] == 10 )
        // if( spoint[0] == 76 && spoint[1] == 88 && spoint[2] == 10 )
        //   std::cerr << i << "   " << ic->id << "   "
        //          << spoint[0] << "  " << spoint[1] << "  " << spoint[2] << "    "

        //          << point[0] << "  " << point[1] << "  " << point[2] << "  "
        //          << std::endl;

        points[j+0] = point[0];
        points[j+1] = point[1];
        points[j+2] = point[2];

        if( doPathlines )
          times[i] = ic->GetTime() - seedTime0;
        else
          times[i] = ic->GetTime();

        lengths[i] = ic->GetDistance();

        // std::cout << PAR_Rank() << " ics: " << indices[i] << " "
        //             << end_point << std::endl;
    }

    // std::cout << PAR_Rank() << " total integral pts: "
    //        << ics.size() << std::endl;
    // std::flush(cout);

    int* all_indices = 0;
    int* index_counts = 0;

    double* all_points = 0;
    int *point_counts = 0;

    double* all_times = 0;
    int *time_counts = 0;

    double* all_lengths = 0;
    int *length_counts = 0;

    Barrier();

    CollectIntArraysOnRootProc(all_indices, index_counts,
                               &indices.front(), indices.size());

    CollectDoubleArraysOnRootProc(all_points, point_counts,
                                  &points.front(), points.size());

    CollectDoubleArraysOnRootProc(all_times, time_counts,
                                  &times.front(), times.size());

    CollectDoubleArraysOnRootProc(all_lengths, length_counts,
                                  &lengths.front(), lengths.size());

    Barrier();

    //root should now have index into global structure and all
    //matching end positions.
    if(PAR_Rank() != 0)
    {
        return true;
    }
    else
    {
        //variable name.
        std::string var = std::string("operators/LCS/") + outVarName;

        //now global grid has been created.
        if( fsle_ds == 0 )
          fsle_ds = CreateIterativeCalcDataSet();

        // Get the stored data arrays
        vtkDataArray* jacobian[3];

        vtkFloatArray *exponents = (vtkFloatArray *)
          fsle_ds->GetPointData()->GetArray(var.c_str());
        vtkFloatArray *component = (vtkFloatArray *)
          fsle_ds->GetPointData()->GetArray("component");
        vtkFloatArray *times = (vtkFloatArray *)
          fsle_ds->GetPointData()->GetArray("times");
        vtkFloatArray *lengths = (vtkFloatArray *)
          fsle_ds->GetPointData()->GetArray("lengths");
        vtkIntArray *mask = (vtkIntArray *)
          fsle_ds->GetPointData()->GetArray("mask");

        vtkFloatArray *distx = (vtkFloatArray *)
          fsle_ds->GetPointData()->GetArray("distx");
        vtkFloatArray *disty = (vtkFloatArray *)
          fsle_ds->GetPointData()->GetArray("disty");
        vtkFloatArray *distz = (vtkFloatArray *)
          fsle_ds->GetPointData()->GetArray("distz");


        size_t nTuples = exponents->GetNumberOfTuples();

        // Storage for the points, times, and lengths
        std::vector<avtVector> remapPoints(nTuples);
        std::vector<double> remapTimes(nTuples);
        std::vector<double> remapLengths(nTuples);

        //update remapPoints with new value bounds from integral curves.
        int par_size = PAR_Size();
        size_t total = 0;
        for(int i = 0; i < par_size; ++i)
        {
            if(index_counts[i]*3 != point_counts[i] ||
               index_counts[i]   != time_counts[i] ||
               index_counts[i]   != length_counts[i])
            {
              EXCEPTION1(VisItException,
                         "Index count does not the result count." );
            }

            total += index_counts[i];
        }

        // std::cout << "total number integrated: " << total << std::endl;

        for(int j=0, k=0; j<total; ++j, k+=3)
        {
            size_t index = all_indices[j];

            if(nTuples <= index)
            {
              EXCEPTION1(VisItException,
                         "More integral curves were generatated than "
                         "grid points." );
            }

            // std::cout << index << " before " << remapPoints[index]
            //        << std::endl;
            
            remapPoints[index].set( all_points[k+0],
                                    all_points[k+1],
                                    all_points[k+2]);

            remapTimes[index] = all_times[j];
            remapLengths[index] = all_lengths[j];

            // std::cout << PAR_Rank() << " " << index << " "
            //        << remapPoints[index] << std::endl;
            // std::cout << "middle: " << avtVector( all_points[k+0],
            //                                    all_points[k+1],
            //                                    all_points[k+2])
            //        << std::endl;
            // std::cout << index << " after " << remapPoints[index]
            //        << std::endl;
        }

        //calculate jacobian in parts (x,y,z).  The jacobian really
        //contains the xyz distance components in parts which when
        //combined given the distance between the end points
        //neighboring integral curves.

        // std::cerr << remapPoints[34][0] << "  "
        //        << remapPoints[34][1] << "  "
        //        << remapPoints[34][2] << "  "
        //        << std::endl;

        for(int i = 0; i < 3; ++i)
        {
            // Store the point component by component
            for(size_t l=0; l<nTuples; ++l)
                component->SetTuple1(l, remapPoints[l][i]);

            jacobian[i] =
              avtGradientExpression::CalculateGradient(fsle_ds, "component");
        }

        // Store the times and lengths for the exponent.
        for(size_t l=0; l<nTuples; ++l)
        {
          times->SetTuple1(l, remapTimes[l]);
          lengths->SetTuple1(l, remapLengths[l]);
        }

        // Compute the FSLE
        ComputeFSLE( jacobian, distx, disty, distz,
                     times, lengths, exponents, mask,
                     global_resolution[0],
                     global_resolution[1],
                     global_resolution[2] );

        jacobian[0]->Delete();
        jacobian[1]->Delete();
        jacobian[2]->Delete();

        bool haveAllExponents = true;

        // For each integral curve check it's mask value to see it
        // additional integration is required.
        for(size_t i=0; i<ics.size(); ++i)
        {
          avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];

          size_t l = ic->id; // The curve id is the index into the VTK data.

          if( mask->GetTuple1( l ) < 7 )
          {
            ic->maxSteps++;
            ic->status.ClearTerminationMet();
          }

          // Check to see if all exponents have been found.
          if( exponents->GetTuple1(l) == std::numeric_limits<float>::min() &&
              ic->maxSteps < maxSteps )
            haveAllExponents = false;
        }

        //cleanup.
        if (all_indices)   delete [] all_indices;
        if (index_counts)  delete [] index_counts;

        if (all_points)    delete [] all_points;
        if (point_counts)  delete [] point_counts;

        if (all_times)    delete [] all_times;
        if (time_counts)  delete [] time_counts;

        if (all_lengths)    delete [] all_lengths;
        if (length_counts)  delete [] length_counts;

        return haveAllExponents;
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::ComputeFLLE
//
//  Purpose:
//      Computes the FLLE given times.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

void avtLCSFilter::ComputeFLLE( vtkDataArray *times,
                                vtkDataArray *lengths,
                                vtkDataArray *exponents,
                                int x_max, int y_max, int z_max )
{
  //min and max values over all datasets of the tree.
  // double minv = std::numeric_limits<double>::max();
  // double maxv = std::numeric_limits<double>::min();

  size_t l = 0;

  for(int k=0, k1=1, k_1=-1; k<z_max; ++k, ++k1, ++k_1)
  {
    for(int j=0, j1=1, j_1=-1; j<y_max; ++j, ++j1, ++j_1)
    {
      for(int i=0, i1=1, i_1=-1; i<x_max; ++i, ++i1, ++i_1)
      {

        // std::cerr << times->GetTuple1(l) << "  "
        //        << lengths->GetTuple1(l) << "  ";


        
        // std::cerr << Value( i, j, k, times, x_max, y_max, z_max ) << "  "
        //        << Value( i, j, k, lengths, x_max, y_max, z_max ) << "  ";
//                << std::endl;
        
        // if( Value( i, j, k, lengths, x_max, y_max, z_max ) >= maxDistance )
        {
          double dx, dy, dz;

          // x,y,z components compute left,right
          // if( Value( i,   j, k, lengths, x_max, y_max, z_max ) ==
          //     Value( i1,  j, k, lengths, x_max, y_max, z_max ) &&
          //     Value( i,   j, k, lengths, x_max, y_max, z_max ) ==
          //     Value( i_1, j, k, lengths, x_max, y_max, z_max ) )
          //   dx = ( Value( i1,  j, k, times, x_max, y_max, z_max ) +
          //       Value( i_1, j, k, times, x_max, y_max, z_max ) ) / 2.0;
          // else
          //   dx = 0;
            
          // // x,y,z components compute top,bottom
          // if( Value( i, j,   k, lengths, x_max, y_max, z_max ) ==
          //     Value( i, j1,  k, lengths, x_max, y_max, z_max ) &&
          //     Value( i, j,   k, lengths, x_max, y_max, z_max ) ==
          //     Value( i, j_1, k, lengths, x_max, y_max, z_max ) )
          //   dy = ( Value( i, j1,  k, times, x_max, y_max, z_max ) +
          //       Value( i, j_1, k, times, x_max, y_max, z_max ) ) / 2.0;
          // else
          //   dy = 0;
            
          // // x,y,z components compute front,back
          // if( Value( i, j, k,   lengths, x_max, y_max, z_max ) ==
          //     Value( i, j, k1,  lengths, x_max, y_max, z_max ) &&
          //     Value( i, j, k,   lengths, x_max, y_max, z_max ) ==
          //     Value( i, j, k_1, lengths, x_max, y_max, z_max ) )
          //   dz = ( Value( i, j, k1,  times, x_max, y_max, z_max ) +
          //       Value( i, j, k_1, times, x_max, y_max, z_max ) ) / 2.0;
          // else
          //   dz = 0;

          dx = ( Value( i1,  j, k, times, x_max, y_max, z_max ) +
                 Value( i_1, j, k, times, x_max, y_max, z_max ) ) / 2.0;

          dy = ( Value( i, j1,  k, times, x_max, y_max, z_max ) +
                 Value( i, j_1, k, times, x_max, y_max, z_max ) ) / 2.0;
          
          dz = ( Value( i, j, k1,  times, x_max, y_max, z_max ) +
                 Value( i, j, k_1, times, x_max, y_max, z_max ) ) / 2.0;
          
          double dt, time = Value( i, j, k, times, x_max, y_max, z_max );
          
          if( dx >= dy && dx >= dz )
            dt = dx;
          else if( dy >= dx && dy >= dz ) 
            dt = dy;
          else if( dz >= dx && dz >= dy ) 
            dt = dz;

//        std::cerr << dt << "  " << dx << "  " << dy << "  " << dz << "  "
//                  << time << std::endl;

          minSizeValue = std::min(dt, minSizeValue);
          maxSizeValue = std::max(dt, maxSizeValue);
        
          double lambda = log( dt / time ) /
            Value( i, j, k, lengths, x_max, y_max, z_max );
              
          exponents->SetTuple1(l, lambda);
        }
        // else
        // {
        //   exponents->SetTuple1(l, 0);
        // }

        ++l;
      }
    }
  }
}


// ****************************************************************************
//  Method: avtLCSFilter::ComputeFSLE
//
//  Purpose:
//      Computes the FSLE given a Jacobian.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

void avtLCSFilter::ComputeFSLE( vtkDataArray *jacobian[3],
                                vtkDataArray *distx,
                                vtkDataArray *disty,
                                vtkDataArray *distz,
                                vtkDataArray *times,
                                vtkDataArray *lengths,
                                vtkDataArray *exponents,
                                vtkDataArray *mask,
                                int x_max, int y_max, int z_max )
{
  //min and max values over all datasets of the tree.
  // double minv = std::numeric_limits<double>::max();
  // double maxv = std::numeric_limits<double>::min();

  size_t l = 0;

  for(int k=0, k1=1, k_1=-1; k<z_max; ++k, ++k1, ++k_1)
  {
    for(int j=0, j1=1, j_1=-1; j<y_max; ++j, ++j1, ++j_1)
    {
      for(int i=0, i1=1, i_1=-1; i<x_max; ++i, ++i1, ++i_1)
      {
        double lambda = exponents->GetTuple1(l);

        // If the exponent was previously set skip checking it.
        if( lambda == std::numeric_limits<float>::min() )
        {
          // Check for a curve that has terminated which will not have
          // taken a step forward or backwards.
          if( floor( fabs(times->GetTuple1(l)) / maxStepLength + 0.5) !=
              numSteps )
          {
            // If a curve has terminated set the exponent to zero.
            lambda = 0;
            exponents->SetTuple1(l, lambda);
            mask->SetTuple1( l, 7 );
            
            // Counter to note that the neighbors do
            // not need additon advection.
            Increment( i1,   j,  k,   mask, x_max, y_max, z_max );
            Increment( i_1,  j,  k,   mask, x_max, y_max, z_max );
            Increment( i,   j1,  k,   mask, x_max, y_max, z_max );
            Increment( i,   j_1, k,   mask, x_max, y_max, z_max );
            Increment( i,   j,   k1,  mask, x_max, y_max, z_max );
            Increment( i,   j,   k_1, mask, x_max, y_max, z_max );
          }

          // Check the distances between neighbors.
          else
          {
            double *jac0 = jacobian[0]->GetTuple3(l);
            double *jac1 = jacobian[1]->GetTuple3(l);
            double *jac2 = jacobian[2]->GetTuple3(l);

            double dx, dy, dz;

            // It is possible that one neighbor has terminated but not
            // the other. However, there is not a way to detected this
            // case when using the gradient expression. As such,
            // currently both neighbors must be valid.

            // x,y,z components compute left,right
            if( Value( i,   j, k, times, x_max, y_max, z_max ) ==
                Value( i1,  j, k, times, x_max, y_max, z_max ) &&
                Value( i,   j, k, times, x_max, y_max, z_max ) ==
                Value( i_1, j, k, times, x_max, y_max, z_max ) )
              dx = avtVector(jac0[0], jac1[0], jac2[0]).length();
            else
              dx = 0;
            
            // x,y,z components compute top,bottom
            if( Value( i, j,   k, times, x_max, y_max, z_max ) ==
                Value( i, j1,  k, times, x_max, y_max, z_max ) &&
                Value( i, j,   k, times, x_max, y_max, z_max ) ==
                Value( i, j_1, k, times, x_max, y_max, z_max ) )
              dy = avtVector(jac0[1], jac1[1], jac2[1]).length();
            else
              dy = 0;
            
            // x,y,z components compute front,back
            if( Value( i, j, k,   times, x_max, y_max, z_max ) ==
                Value( i, j, k1,  times, x_max, y_max, z_max ) &&
                Value( i, j, k,   times, x_max, y_max, z_max ) ==
                Value( i, j, k_1, times, x_max, y_max, z_max ) )
              dz = avtVector(jac0[2], jac1[2], jac2[2]).length();
            else
              dz = 0;

            double size = 0, distance = 0;

            if( dx >= dy && dx >= dz ) 
            {
              size = dx;
              distance = distx->GetTuple1( l );
            }

            else if( dy >= dx && dy >= dz ) 
            {
              size = dy;
              distance = disty->GetTuple1( l );
            }

            else if( dz >= dx && dz >= dy ) 
            {
              size = dz;
              distance = distz->GetTuple1( l );
            }

//          if( l == 59 )
            // if( l == 34 )
            //   std::cerr << dx << "  " << dy << "  " << dz << "    "
            //          << size << "  " << distance << "    "
            //          << times->GetTuple1(l) << "    "
            //          << log( size / distance ) / fabs(times->GetTuple1(l))
            //          << std::endl;


            minSizeValue = std::min(size, minSizeValue);
            maxSizeValue = std::max(size, maxSizeValue);
        
            // Record the Lyapunov exponent if the max
            // size has been reached.
            if( maxSize < size )
            {
              lambda = log( size / distance ) / fabs(times->GetTuple1(l));
              
              exponents->SetTuple1(l, lambda);

              // Counter to note that the neighbors do
              // not need additon advection.
              Increment( i,    j,  k,   mask, x_max, y_max, z_max );
              Increment( i1,   j,  k,   mask, x_max, y_max, z_max );
              Increment( i_1,  j,  k,   mask, x_max, y_max, z_max );
              Increment( i,   j1,  k,   mask, x_max, y_max, z_max );
              Increment( i,   j_1, k,   mask, x_max, y_max, z_max );
              Increment( i,   j,   k1,  mask, x_max, y_max, z_max );
              Increment( i,   j,   k_1, mask, x_max, y_max, z_max );
            }
          }
        }

        // minv = std::min(lambda, minv);
        // maxv = std::max(lambda, maxv);  
        
        ++l;
      }
    }
  }
}


// ****************************************************************************
//  Method: avtLCSFilter::InBounds
//
//  Purpose:
//      Returns true if indexes are in bounds.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

int avtLCSFilter::InBounds( int x, int y, int z,
                            int x_max, int y_max, int z_max )
{
  if( 0 <= x && x < x_max &&
      0 <= y && y < y_max &&
      0 <= z && z < z_max )
    return (z * y_max + y) * x_max + x;
  else
    return -1;
}


// ****************************************************************************
//  Method: avtLCSFilter::Increment
//
//  Purpose:
//      Increments a counter
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

void avtLCSFilter::Increment( int x, int y, int z, vtkDataArray *array,
                              int x_max, int y_max, int z_max )
{
  int l = InBounds( x, y, z, x_max, y_max, z_max );
  
  if( 0 <= l && l < array->GetNumberOfTuples() )
  {      
    int cc = array->GetTuple1(l);
    ++cc;
    array->SetTuple1(l, cc);
  }
}


// ****************************************************************************
//  Method: avtLCSFilter::Value
//
//  Purpose:
//      Returns the value for a coordinate
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

double avtLCSFilter::Value( int x, int y, int z, vtkDataArray *array,
                            int x_max, int y_max, int z_max )
{
  int l = InBounds( x, y, z, x_max, y_max, z_max );

  if( 0 <= l && l < array->GetNumberOfTuples() )
    return array->GetTuple1(l);
  else
    return 0;
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateNativeMeshIterativeCalcOutput
//
//  Purpose:
//      Computes the IterativeCalc output (via sub-routines) after the PICS filter
//      has calculated the particle positions.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

void 
avtLCSFilter::CreateNativeMeshIterativeCalcOutput(std::vector<avtIntegralCurve*> &ics)
{
    //accumulate all of the points then do jacobian?
    //or do jacobian then accumulate?
    //picking the first.

    int    offset = 0;
    double minv   = std::numeric_limits<double>::max();
    double maxv   = std::numeric_limits<double>::min();
    int    count  = 0;

    CreateMultiBlockIterativeCalcOutput(GetInputDataTree(), GetDataTree(),
                                        ics, offset, minv, maxv, count);

    int nTuples = ics.size();

    if( 1 || count <= nTuples/10 )
    {
      if( minSizeValue == std::numeric_limits<double>::max() )
        minSizeValue = 0.0;
      
      if( maxSizeValue == std::numeric_limits<double>::min() )
        maxSizeValue = 0.0;
      
      char str[1028];
      
      SNPRINTF(str, 1028, "\n%d%% of the nodes (%d of %d nodes) "
               "exaimed produced a valid exponent (%f to %f). "
               "This may be due to too large of a size limit (%f), "
               "too small of an integration step (%f), or "
               "too few integration steps (%d out of %d where taken), or "
               "simply due to the nature of the data. "
               "The size range was from %f to %f. ",
               (int) (100.0 * (double) count / (double) nTuples),
               count, nTuples,
               minv, maxv,
               maxSize, maxStepLength, numSteps, maxSteps,
               minSizeValue, maxSizeValue );
      
      avtCallback::IssueWarning(str);
    }

    avtDataAttributes &dataatts = GetOutput()->GetInfo().GetAttributes();
    avtExtents* e = dataatts.GetThisProcsActualDataExtents();

    double range[2];
    range[0] = minv;
    range[1] = maxv;
    e->Set(range);

    e = dataatts.GetThisProcsOriginalDataExtents();
    e->Set(range);

    e = dataatts.GetThisProcsActualSpatialExtents();
    e->Set(global_bounds);
    e = dataatts.GetThisProcsOriginalSpatialExtents();
    e->Set(global_bounds);
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateMultiBlockIterativeCalcOutput
//
//  Purpose:
//      Computes the finial FSLE and similar values that are neighbor
//      dependent for the whole data set, using the final particle
//      locations, at the blocks native resolution.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

void
avtLCSFilter::CreateMultiBlockIterativeCalcOutput( avtDataTree_p inDT,
                                                   avtDataTree_p outDT,
                                                   std::vector<avtIntegralCurve*> &ics,
                                                   int &offset,
                                                   double &minv, double &maxv,
                                                   int &count)
{
    if (*inDT == NULL || *outDT == NULL)
        return;

    int nc = inDT->GetNChildren();

    if (nc <= 0 && !inDT->HasData())
        return;

    if (nc == 0)
    {
        //
        // there is only one dataset to process
        //
        vtkDataSet *in_ds = inDT->GetDataRepresentation().GetDataVTK();
        vtkDataSet *out_ds = outDT->GetDataRepresentation().GetDataVTK();

        int dom = inDT->GetDataRepresentation().GetDomain();
        std::string label = inDT->GetDataRepresentation().GetLabel();

        CreateSingleBlockIterativeCalcOutput(in_ds, out_ds, ics,
                                             offset, dom, minv, maxv, count);
    }
    else
    {
      //
      // there is more than one input dataset to process
      // and we need an output datatree for each
      //
      for (int j = 0; j < nc; j++)
      {
          if (inDT->ChildIsPresent(j))
            CreateMultiBlockIterativeCalcOutput(inDT->GetChild(j),
                                                outDT->GetChild(j),
                                                ics, offset, minv, maxv, count);
      }
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateSingleBlockIterativeCalcOutput
//
//  Purpose:
//      Computes the finial FSLE and similar values that are neighbor
//      dependent for a single block of a data set, using the final
//      particle locations, at the blocks native resolution.
//
//  Arguments:
//      in_ds   The block to calculate the value on
//      ics     The list of particles for all blocks on this MPI task.
//      domain  The domain number of in_ds
//      minv    The minimum value (output)
//      maxv    The maximum value (output)
//      count   The number of nodes with a valid exponent
//
//  Returns:    The new version of in_ds that includes the scalar
//              variable.  The calling function is responsible for
//              dereferencing this VTK object.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
//    Hank Childs, Tue Feb  5 08:12:33 PST 2013
//    Fix parallelization bug and memory leak.
//
// ****************************************************************************

void
avtLCSFilter::CreateSingleBlockIterativeCalcOutput( vtkDataSet *in_ds,
                                                    vtkDataSet *out_ds,
                                                    std::vector<avtIntegralCurve*> &ics,
                                                    int &offset, int domain,
                                                    double &minv, double &maxv,
                                                    int &count )
{
  //variable name.
  std::string var = std::string("operators/LCS/") + outVarName;

  // Set the grid points to the actual grid (i.e. replace the
  // uniform grid used to get the distances via the gradient
  // expression).
  if (out_ds->GetDataObjectType() == VTK_UNIFORM_GRID)
  {
    ((vtkUniformGrid*)out_ds)->
      SetExtent( ((vtkUniformGrid*)in_ds)->GetExtent() );
  }
  else if (out_ds->GetDataObjectType() == VTK_RECTILINEAR_GRID)
  {
    ((vtkRectilinearGrid*)out_ds)->
      SetXCoordinates( ((vtkRectilinearGrid*)in_ds)->GetXCoordinates() );
    ((vtkRectilinearGrid*)out_ds)->
      SetYCoordinates( ((vtkRectilinearGrid*)in_ds)->GetYCoordinates() );
    ((vtkRectilinearGrid*)out_ds)->
      SetZCoordinates( ((vtkRectilinearGrid*)in_ds)->GetZCoordinates() );
  }      
  else if (out_ds->GetDataObjectType() == VTK_STRUCTURED_GRID)
  {
    ((vtkStructuredGrid*)out_ds)->
      SetPoints( ((vtkStructuredGrid*)in_ds)->GetPoints() );
  }
  else
  {
    EXCEPTION1(VisItException,
               "Can only compute SingleBlockCreateIterativeCalcOutput on "
               "uniform, rectilinear, or structured grids. ");
  }

  vtkFloatArray *exponents = (vtkFloatArray *)
    out_ds->GetPointData()->GetArray(var.c_str());

  int nTuples = exponents->GetNumberOfTuples();

  for(size_t i=0; i<ics.size(); ++i)
  {
    avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];
    
    size_t index = ic->id;
    int l = (index-offset);

    double lambda = exponents->GetTuple1(l);
    
    if( lambda == std::numeric_limits<float>::min() )
    {
      lambda = 0;
      exponents->SetTuple1(l, lambda );
    }
    else
    {
      ic->status.ClearTerminationMet();
    }
    
    minv = std::min(lambda, minv);
    maxv = std::max(lambda, maxv);
    
    if( lambda != 0 )
      ++count;
  }

      
  // Remove the working arrays.
  out_ds->GetPointData()->RemoveArray("component");
  out_ds->GetPointData()->RemoveArray("times");
  out_ds->GetPointData()->RemoveArray("lengths");
  out_ds->GetPointData()->RemoveArray("mask");

  // Make the exponents the the active scalars.
  out_ds->GetPointData()->SetActiveScalars(var.c_str());

  //done with offset, increment it for the next call to this
  //function.
  offset += nTuples;

  //store this dataset in Cache for next time.
  // double bounds[6];
  // fsle_ds->GetBounds(bounds);
          
  // std::cout << "final size and bounds: "
  //          << PAR_Rank() << " " << leafSize << " "
  //          << bounds[0] << " " << bounds[1] << " " << bounds[2]
  //          << " " << bounds[3] << " " << bounds[4] << " "
  //          << bounds[5] << std::endl;

  // std::cerr << "Caching fsle_ds" << std::endl;
  
  
  //Store this dataset in Cache for next time.
  std::string str = CreateCacheString();
  
  StoreArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                          outVarName.c_str(), domain, -1,
                          str.c_str(), out_ds);
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateRectilinearGridIterativeCalcOutput
//
//  Purpose:
//      Computes the finial FSLE and similar values that are neighbor
//      dependent output (via sub-routines) after the PICS filter has
//      calculated the particle positions.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

void 
avtLCSFilter::CreateRectilinearGridIterativeCalcOutput(std::vector<avtIntegralCurve*> &ics)
{
    //root should now have index into global structure and all
    //matching end positions.
    if(PAR_Rank() != 0)
    {
        //std::cout << PAR_Rank() << " creating dummy output" << std::endl;
        avtDataTree* dummy = new avtDataTree();
        SetOutputDataTree(dummy);
    }
    else
    {
      if (fsle_ds->GetDataObjectType() != VTK_RECTILINEAR_GRID)
      {
        EXCEPTION1(VisItException,
                   "Can only compute CreateRectilinearGridIterativeCalcOutput on "
                   "rectilinear grids. ");
      }

      //variable name.
      std::string var = std::string("operators/LCS/") + outVarName;

      // Set the grid points to the actual grid (i.e. replace the
      // uniform grid used to get the distances via the gradient
      // expression).
      vtkFloatArray* lxcoord = vtkFloatArray::New();
      vtkFloatArray* lycoord = vtkFloatArray::New();
      vtkFloatArray* lzcoord = vtkFloatArray::New();
      
      vtkRectilinearGrid *fsle_rect_grid = (vtkRectilinearGrid *) fsle_ds;

      lxcoord->SetNumberOfTuples(global_resolution[0]);
      for (int i = 0; i < global_resolution[0]; i++)
      {
        double pcnt = 0;
        if (global_resolution[0] > 1)
          pcnt = ((double)i)/((double)global_resolution[0]-1);
        lxcoord->SetTuple1(i, global_bounds[0]*(1.0-pcnt) + global_bounds[1]*pcnt);
      }
      
      lycoord->SetNumberOfTuples(global_resolution[1]);
      for (int i = 0; i < global_resolution[1]; i++)
      {
        double pcnt = 0;
        if (global_resolution[1] > 1)
          pcnt = ((double)i)/((double)global_resolution[1]-1);
        lycoord->SetTuple1(i, global_bounds[2]*(1.0-pcnt) + global_bounds[3]*pcnt);
      }
      
      lzcoord->SetNumberOfTuples(global_resolution[2]);
      for (int i = 0; i < global_resolution[2]; i++)
      {
        double pcnt = 0;
        if (global_resolution[2] > 1)
          pcnt = ((double)i)/((double)global_resolution[2]-1);
        lzcoord->SetTuple1(i, global_bounds[4]*(1.0-pcnt) + global_bounds[5]*pcnt);
      }
      
      fsle_rect_grid->SetXCoordinates(lxcoord);
      fsle_rect_grid->SetYCoordinates(lycoord);
      fsle_rect_grid->SetZCoordinates(lzcoord);
      
      //cleanup
      lxcoord->Delete();
      lycoord->Delete();
      lzcoord->Delete();

      vtkFloatArray *exponents = (vtkFloatArray *)
        fsle_ds->GetPointData()->GetArray(var.c_str());

      int nTuples = exponents->GetNumberOfTuples();

      //min and max values over all datasets of the tree.
      double minv = std::numeric_limits<double>::max();
      double maxv = std::numeric_limits<double>::min();
      
      int count = 0;

      for(size_t i=0; i<ics.size(); ++i)
      {
        avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];

        size_t l = ic->id; // The curve id is the index into the VTK data.

        double lambda = exponents->GetTuple1(l);

        if( lambda == std::numeric_limits<float>::min() )
        {
          lambda = 0;
          exponents->SetTuple1(l, lambda );
        }
        else
        {
          ic->status.ClearTerminationMet();
        }

        minv = std::min(lambda, minv);
        maxv = std::max(lambda, maxv);

        if( lambda != 0 )
          ++count;
      }

      if( count <= nTuples/10 )
      {
        if( minSizeValue == std::numeric_limits<double>::max() )
          minSizeValue = 0.0;

        if( maxSizeValue == std::numeric_limits<double>::min() )
          maxSizeValue = 0.0;

        char str[1028];

        SNPRINTF(str, 1028, "\n%d%% of the nodes (%d of %d nodes) "
                 "exaimed produced a valid exponent (%f to %f). "
                 "This may be due to too large of a size limit (%f), "
                 "too small of an integration step (%f), or "
                 "too few integration steps (%d out of %d where taken), or "
                 "simply due to the nature of the data. "
                 "The size range was from %f to %f. ",
                 (int) (100.0 * (double) count / (double) nTuples),
                 count, nTuples,
                 minv, maxv,
                 maxSize, maxStepLength, numSteps, maxSteps,
                 minSizeValue, maxSizeValue );

        avtCallback::IssueWarning(str);
      }
      
      // Make the exponents the the active scalars.
      fsle_ds->GetPointData()->SetActiveScalars(var.c_str());

      // Remove the working arrays.
      fsle_ds->GetPointData()->RemoveArray("component");
      fsle_ds->GetPointData()->RemoveArray("times");
      fsle_ds->GetPointData()->RemoveArray("lengths");
      fsle_ds->GetPointData()->RemoveArray("mask");

      //store this dataset in Cache for next time.
      // double bounds[6];
      // fsle_ds->GetBounds(bounds);
          
      // std::cout << "final size and bounds: "
      //          << PAR_Rank() << " " << leafSize << " "
      //          << bounds[0] << " " << bounds[1] << " " << bounds[2]
      //          << " " << bounds[3] << " " << bounds[4] << " "
      //          << bounds[5] << std::endl;

      // std::cerr << "Caching fsle_ds" << std::endl;
      std::string str = CreateCacheString();
      StoreArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                              outVarName.c_str(), -1, -1,
                              str.c_str(), fsle_ds);
      
      int index = 0;//what does index mean in this context?
      avtDataTree* dt = new avtDataTree(fsle_ds,index);
      int x = 0;
      dt->GetAllLeaves(x);
      
      // std::cout << "total leaves:: " << x << std::endl;
      
      SetOutputDataTree(dt);
      
      //set atts.
      avtDataAttributes &dataatts = GetOutput()->GetInfo().GetAttributes();
      avtExtents* e = dataatts.GetThisProcsActualDataExtents();
      
      double range[2];
      range[0] = minv;
      range[1] = maxv;
      e->Set(range);
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::ReportWarnings() 
//
//  Purpose:
//      Reports any potential integration warnings
//
//  Programmer: Allen Sanderson
//  Creation:   20 August 2013
//
//  Modifications:
//
// ****************************************************************************

void
avtLCSFilter::ReportWarnings(std::vector<avtIntegralCurve *> &ics)
{
    if (ics.size() == 0)
        return;

    int numICs = ics.size();
//    int numPts = 0;
    int numEarlyTerminators = 0;
    int numStiff = 0;
    int numCritPts = 0;

    if (DebugStream::Level5())
        debug5 << "::CreateIntegralCurveOutput " << ics.size() << endl;

    //See how many pts, ics we have so we can preallocate everything.
    for (int i = 0; i < numICs; i++)
    {
        bool terminatedBecauseOfMaxSteps;
        bool encounteredNumericalProblems;

        if( doSize )
        {
            avtStreamlineIC *ic = dynamic_cast<avtStreamlineIC*>(ics[i]);
            terminatedBecauseOfMaxSteps  = ic->TerminatedBecauseOfMaxSteps();
            encounteredNumericalProblems = ic->EncounteredNumericalProblems();
        }
        else
        {
            avtLCSIC *ic = dynamic_cast<avtLCSIC*>(ics[i]);
            terminatedBecauseOfMaxSteps  = ic->TerminatedBecauseOfMaxSteps();
            encounteredNumericalProblems = ic->EncounteredNumericalProblems();
        }

        // NOT USED ??????????????????????????
        // size_t numSamps = (ic ? ic->GetNumberOfSamples() : 0);
        // if (numSamps > 1)
        //     numPts += numSamps;

        if (terminatedBecauseOfMaxSteps)
        {
            // Calculated only with avtStateRecorderIntegralCurve
            // if (ic->SpeedAtTermination() <= criticalPointThreshold)
            //     numCritPts++;
            // else
            numEarlyTerminators++;
        }

        if (encounteredNumericalProblems)
            numStiff++;
    }

    char str[4096] = "";

    if ((doDistance || doTime || doSize) && issueWarningForMaxStepsTermination)
    {
        SumIntAcrossAllProcessors(numEarlyTerminators);
        if (numEarlyTerminators > 0)
        {
          SNPRINTF(str, 4096,
                   "%s\n%d of your integral curves terminated because they "
                   "reached the maximum number of steps.  This may be indicative of your "
                   "time or distance criteria being too large or of other attributes being "
                   "set incorrectly (example: your step size is too small).  If you are "
                   "confident in your settings and want the particles to advect farther, "
                   "you should increase the maximum number of steps.  If you want to disable "
                   "this message, you can do this under the Advaced tab."
                   "  Note that this message does not mean that an error has occurred; it simply "
                   "means that VisIt stopped advecting particles because it reached the maximum "
                   "number of steps. (That said, this case happens most often when other attributes "
                   "are set incorrectly.)\n", str, numEarlyTerminators);
        }
    }

    if (issueWarningForCriticalPoints)
    {
        SumIntAcrossAllProcessors(numCritPts);
        if (numCritPts > 0)
        {
            SNPRINTF(str, 4096, 
                     "%s\n%d of your integral curves circled round and round a critical point (a zero"
                     " velocity location).  Normally, VisIt is able to advect the particle "
                     "to the critical point location and terminate.  However, VisIt was not able "
                     "to do this for these particles due to numerical issues.  In all likelihood, "
                     "additional steps will _not_ help this problem and only cause execution to "
                     "take longer.  If you want to disable this message, you can do this under "
                     "the Advanced tab.\n", str, numCritPts);
        }
    }

    if (issueWarningForStiffness)
    {
        SumIntAcrossAllProcessors(numStiff);
        if (numStiff > 0)
        {
            SNPRINTF(str, 4096, 
                     "%s\n%d of your integral curves were unable to advect because of \"stiffness\".  "
                     "When one component of a velocity field varies quickly and another stays "
                     "relatively constant, then it is not possible to choose step sizes that "
                     "remain within tolerances.  This condition is referred to as stiffness and "
                     "VisIt stops advecting in this case.  If you want to disable this message, "
                     "you can do this under the Advanced tab.\n", str,numStiff);
        }
    }

    if( strlen( str ) )
      avtCallback::IssueWarning(str);
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateCacheString
//
//  Purpose:
//      A routine that calculates a string for caching that encodes all the
//      parameters of the LCS: bounds, integration time, and variable name.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

std::string
avtLCSFilter::CreateCacheString(void)
{
  const int*    resolution = atts.GetResolution();
  const double* startPosition = atts.GetStartPosition();
  const double* endPosition = atts.GetEndPosition();
  const double* velocitySource = atts.GetVelocitySource();

  std::ostringstream os;

  int   cycle = (int)   GetInput()->GetInfo().GetAttributes().GetCycle();
  float time  = (float) GetInput()->GetInfo().GetAttributes().GetTime();

  os << cycle << "  "
     << time << "  "
     << atts.GetSourceType() << " "
     << resolution[0] << " "
     << resolution[1] << " "
     << resolution[2] << " "
     << atts.GetUseDataSetStart() << " "
     << startPosition[0] << " "
     << startPosition[1] << " "
     << startPosition[2] << " "
     << atts.GetUseDataSetEnd() << " "
     << endPosition[0] << " "
     << endPosition[1] << " "
     << endPosition[2] << " "
     << atts.GetIntegrationDirection() << " "
     << atts.GetMaxSteps() << " "
     << atts.GetOperationType() << " "
     << atts.GetOperatorType() << " "
     << atts.GetClampLogValues() << " "
     << atts.GetTerminationType() << " "
     << atts.GetTerminateBySize() << " "
     << atts.GetTermSize() << " "
     << atts.GetTerminateByDistance() << " "
     << atts.GetTermDistance() << " "
     << atts.GetTerminateByTime() << " "
     << atts.GetTermTime() << " "
     << atts.GetMaxStepLength() << " "
     << atts.GetLimitMaximumTimestep() << " "
     << atts.GetMaxTimeStep() << " "
     << atts.GetRelTol() << " "
     << atts.GetAbsTolSizeType() << " "
     << atts.GetAbsTolAbsolute() << " "
     << atts.GetAbsTolBBox() << " "
     << atts.GetFieldType() << " "
     << atts.GetFieldConstant() << " "
     << velocitySource[0] << " "
     << velocitySource[1] << " "
     << velocitySource[2] << " "
     << atts.GetIntegrationType() << " "
     << atts.GetParallelizationAlgorithmType() << " "
     << atts.GetMaxProcessCount() << " "
     << atts.GetMaxDomainCacheSize() << " "
     << atts.GetWorkGroupSize() << " "
     << atts.GetPathlines() << " "
     << atts.GetPathlinesOverrideStartingTimeFlag() << " "
     << atts.GetPathlinesOverrideStartingTime() << " "
     << atts.GetPathlinesCMFE() << " "
     << atts.GetForceNodeCenteredData() << " "
     << atts.GetIssueTerminationWarnings() << " "
     << atts.GetIssueStiffnessWarnings() << " "
     << atts.GetIssueCriticalPointsWarnings() << " "
     << atts.GetCriticalPointThreshold() << " ";

  return os.str();
}


// ****************************************************************************
//  Method: avtLCSFilter::GetCachedDataSet
//
//  Purpose:
//      Checks to see if we have already calculated the LCS.  Works for
//      both resampling and native options (realized through sub-routine calls).
//      This routine uses collective communication to decided whether
//      it can use a cached data set.
//      - For the native resolution, all domains on all MPI tasks must have
//      the LCS cached.
//      - For the resampled version, one MPI task somewhere must find it.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtDataTree_p
avtLCSFilter::GetCachedDataSet()
{
    avtDataTree_p rv = NULL;
    if (atts.GetSourceType() == LCSAttributes::NativeMesh)
    {
        rv = GetCachedNativeDataSet(GetInputDataTree());
        int looksOK = 1;
        if ((*rv == NULL) && (*(GetInputDataTree()) != NULL))
            looksOK = 0;
        looksOK = UnifyMinimumValue(looksOK); // if any fails, we all fail
        if (looksOK == 0)
            rv = NULL;
    }
    else //if (atts.GetSourceType() == LCSAttributes::RegularGrid)
    {
        rv = GetCachedResampledDataSet();
        int looksOK = (*rv == NULL ? 0 : 1);
        looksOK = UnifyMaximumValue(looksOK); // if one has it, we're all OK
        if (looksOK == 0)
            rv = NULL;
        else if ((looksOK == 1) && (*rv == NULL))
            rv = new avtDataTree();
    }
    return rv;
}

// ****************************************************************************
//  Method: avtLCSFilter::GetCachedNativeDataSet
//
//  Purpose:
//      Checks the cache to see if we have calculated the LCS on this
//      domain previously.  Checks to make sure parameters match: integration
//      time, etc.
//
//  Programmer: Hank Childs
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtDataTree_p
avtLCSFilter::GetCachedNativeDataSet(avtDataTree_p inDT)
{
    if (*inDT == NULL)
        return NULL;

    int nc = inDT->GetNChildren();

    if (nc <= 0 && !inDT->HasData())
    {
        // degenerate.  just return.
        return NULL;
    }

    if (nc == 0)
    {
        //
        // there is only one dataset to process
        //
        vtkDataSet *in_ds = inDT->GetDataRepresentation().GetDataVTK();
        int dom = inDT->GetDataRepresentation().GetDomain();
        std::string label = inDT->GetDataRepresentation().GetLabel();
        std::string str = CreateCacheString();
        vtkDataSet *rv = (vtkDataSet *)
                         FetchArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                                                 outVarName.c_str(), dom, -1, str.c_str());
        if (rv == NULL)
            return NULL;
        else
            return new avtDataTree(rv, dom, label);
    }

    //
    // there is more than one input dataset to process
    // and we need an output datatree for each
    //
    avtDataTree_p *outDT = new avtDataTree_p[nc];
    bool badOne = false;
    for (int j = 0; j < nc; j++)
    {
        if (inDT->ChildIsPresent(j))
        {
            outDT[j] = GetCachedNativeDataSet(inDT->GetChild(j));
            if (*(outDT[j]) == NULL)
                badOne = true;
        }
        else
        {
            outDT[j] = NULL;
        }
    }
    avtDataTree_p rv = NULL;
    if (!badOne) // if we don't have LCS for one domain, then just re-calc whole thing
        rv = new avtDataTree(nc, outDT);
    delete [] outDT;
    return rv;
}


// ****************************************************************************
//  Method: avtLCSFilter::GetCachedResampledDataSet
//
//  Purpose:
//      Checks the cache to see if we have calculated the LCS before.  It
//      also ensures that the parameters of previous calculations are the
//      same: integration time, bounds, variable, etc.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtDataTree_p
avtLCSFilter::GetCachedResampledDataSet()
{
    std::string str = CreateCacheString();
    vtkRectilinearGrid *rv = (vtkRectilinearGrid *)
                     FetchArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                                             outVarName.c_str(), -1, -1,
                                             str.c_str());

    if(rv != NULL)
    {
        return new avtDataTree(rv, -1);
    }

    return NULL;
}

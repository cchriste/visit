/*****************************************************************************
*
* Copyright (c) 2000 - 2015, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//  File: avtLCSFilter.C
// ************************************************************************* //

#include <avtLCSFilter.h>
#include <avtLCSIC.h>

// For now use the avtLCSIC as the state does not need to be recorded
// for the FSLE. That is because currently the integration is being
// done step by step rather than in chunks. However, the code is set up
// to use avtStreamlineIC. Which if the integration is done in chucks
// will probably be more efficient.

//#include <avtStreamlineIC.h>
#define avtStreamlineIC avtLCSIC

#include <avtExtents.h>
#include <avtMatrix.h>
#include <avtParallel.h>
#include <avtCallback.h>

#include <avtOriginatingSource.h>
#include <avtGradientExpression.h>
#include <vtkVisItScalarTree.h>

#include <VisItException.h>
#include <ImproperUseException.h>

#include <vtkMath.h>
#include <vtkUniformGrid.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkDoubleArray.h>
#include <vtkPointData.h>
#include <vtkImageReslice.h>
#include <vtkMatrix4x4.h>
#include <vtkImageGaussianSmooth.h>

#include <iostream>
#include <limits>
#include <cmath>

//#define PID (int) (0.31415*(double)nTuples)
#define PID (int) (37990)

template <class T1, class T2, class Pred = std::greater<T2> >
struct sort_pair_max_second {
    bool operator()(const std::pair<T1,T2>&left, const std::pair<T1,T2>&right) {
        Pred p;
        return p(left.second, right.second);
    }
};

template <class T1, class T2, class Pred = std::less<T2> >
struct sort_pair_min_second {
    bool operator()(const std::pair<T1,T2>&left, const std::pair<T1,T2>&right) {
        Pred p;
        return p(left.second, right.second);
    }
};

// ****************************************************************************
//  Method: avtLCSFilter constructor
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
//  Modifications:
//
//    Hank Childs, Wed Mar 28 08:36:34 PDT 2012
//    Initialize pathlines later.  Also set tolerances.
//
// ****************************************************************************

avtLCSFilter::avtLCSFilter() : seedVelocity(0,0,0)
{
    outVarRoot = std::string("operators/LCS/");

    //outVarName ="operators/LCS/mesh";
    //doPathlines();
    //SetPathlines(atts.GetPathlines(),
    //              atts.GetPathlinesOverrideStartingTimeFlag(),
    //              atts.GetPathlinesOverrideStartingTime(),
    //              atts.GetPathlinesCMFE());
    //SetPathlines(true,false,0,PICS_CONN_CMFE);
    //SetPathlines(false,false,0,PICS_CONN_CMFE);

    // These initializations prevent harmless UMRs when we do our first
    // cache lookups.
    global_bounds[0] = global_bounds[2] = global_bounds[4] = 0;
    global_bounds[1] = global_bounds[3] = global_bounds[5] = 1;
    global_resolution[0] = global_resolution[1] = global_resolution[2] = 10;
    absTol = 1e-6;
    relTol = 1e-7;

    nDim = 3;
    auxIdx = LCSAttributes::None;
    nAuxPts = 1;
    auxSpacing = 0;

    numSteps = 0;
    fsle_dt = 0;
    fsle_ds = 0;

    cgTensor = LCSAttributes::Right;
    eigenComponent = LCSAttributes::Smallest;

    minSizeValue =  std::numeric_limits<double>::max();
    maxSizeValue = -std::numeric_limits<double>::max();
}


// ****************************************************************************
//  Method: avtLCSFilter destructor
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
//  Modifications:
//
// ****************************************************************************

avtLCSFilter::~avtLCSFilter()
{
}


// ****************************************************************************
//  Method: avtLCSFilter::Create
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
// ****************************************************************************

avtFilter *avtLCSFilter::Create()
{
    return new avtLCSFilter();
}


// ****************************************************************************
//  Method: avtLCSFilter::SetAtts
//
//  Purpose:
//      Sets the state of the filter based on the attribute object.
//
//  Arguments:
//      a        The attributes to use.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
//  Modifications:
//
//    Hank Childs, Tue Mar 27 16:24:13 PDT 2012
//    Don't do pathlines if steady state is indicated.
//
//    Hank Childs, Wed Apr 11 11:35:16 PDT 2012
//    Add reverse flow.
//
// ****************************************************************************

void
avtLCSFilter::SetAtts(const AttributeGroup *a)
{
    atts = *(const LCSAttributes*)a;

    needsRecalculation =
      atts.ChangesRequireRecalculation(*(const LCSAttributes*)a);

    eigenComponent = atts.GetEigenComponent();
    clampLogValues = atts.GetClampLogValues();

    auxIdx = atts.GetAuxiliaryGrid();

    if( atts.GetOperationType() == LCSAttributes::IntegrationTime ||
        atts.GetOperationType() == LCSAttributes::ArcLength ||
        atts.GetOperationType() == LCSAttributes::AverageDistanceFromSeed )
    {
      nDim = 3;
      nAuxPts = 1;
      auxSpacing = 0;

      if( auxIdx != LCSAttributes::None )
      {
        avtCallback::IssueWarning("Requesting an auxiliary grid when none is needed. Ignoring request.");

        auxIdx = LCSAttributes::None;
      }
    }
    
    else if( auxIdx == LCSAttributes::None )
    {
      nDim = 3;
      nAuxPts = 1;
      auxSpacing = 0;
    }
    else if( auxIdx == LCSAttributes::TwoDim )
    {
      nDim = 2;
      nAuxPts = 4;
      auxSpacing = atts.GetAuxiliaryGridSpacing();
    }
    else if( auxIdx == LCSAttributes::ThreeDim )
    {
      nDim = 3;
      nAuxPts = 6;
      auxSpacing = atts.GetAuxiliaryGridSpacing();
    }

    cgTensor = atts.GetCauchyGreenTensor();
        
    int CMFEType = (atts.GetPathlinesCMFE() == LCSAttributes::CONN_CMFE
                    ? PICS_CONN_CMFE : PICS_POS_CMFE);

    SetPathlines(atts.GetPathlines(),
                 atts.GetPathlinesOverrideStartingTimeFlag(),
                 atts.GetPathlinesOverrideStartingTime(),
                 atts.GetPathlinesPeriod(),
                 CMFEType);

    SetIntegrationDirection(atts.GetIntegrationDirection());

    SetFieldType(atts.GetFieldType());
    SetFieldConstant(atts.GetFieldConstant());
    SetVelocitySource(atts.GetVelocitySource());

    SetIntegrationType(atts.GetIntegrationType());
    SetParallelizationAlgorithm(atts.GetParallelizationAlgorithmType(), 
                                atts.GetMaxProcessCount(),
                                atts.GetMaxDomainCacheSize(),
                                atts.GetWorkGroupSize());

    if (atts.GetIntegrationType() == LCSAttributes::DormandPrince)
    {
      if( atts.GetOperationType() ==  LCSAttributes::Lyapunov &&
            atts.GetTerminateBySize() )
        {
          EXCEPTION1(ImproperUseException,
                     "When performing FSLE the step size must be fixed. "
                     "Please select a different solver and "
                     "set the maximum time step.");
        }

        // For DoPri, the max time step is sent in to the PICS filter
        // as the max step length.
        double step;
        if (atts.GetLimitMaximumTimestep())
          step = atts.GetMaxTimeStep();
        else
          step = 0;

        SetMaxStepLength(step);
    }
    else
        SetMaxStepLength(atts.GetMaxStepLength());

    double absTol = 0.;
    bool doBBox = (atts.GetAbsTolSizeType() == LCSAttributes::FractionOfBBox);
    if (doBBox)
        absTol = atts.GetAbsTolBBox();
    else
        absTol = atts.GetAbsTolAbsolute();
    SetTolerances(atts.GetRelTol(), absTol, doBBox);

    SetTermination(atts.GetMaxSteps(),
                   atts.GetTerminateByDistance(),
                   atts.GetTermDistance(),
                   atts.GetTerminateByTime(),
                   atts.GetTermTime(),
                   atts.GetTerminateBySize(),
                   atts.GetTermSize());

    IssueWarningForAdvection(atts.GetIssueAdvectionWarnings());
    IssueWarningForBoundary(atts.GetIssueBoundaryWarnings());
    IssueWarningForMaxStepsTermination(atts.GetIssueTerminationWarnings());
    IssueWarningForStiffness(atts.GetIssueStiffnessWarnings());
    IssueWarningForCriticalPoints(atts.GetIssueCriticalPointsWarnings(),
                                  atts.GetCriticalPointThreshold());
}


// ****************************************************************************
//  Method: avtLCSFilter::Equivalent
//
//  Purpose:
//      Returns true if creating a new avtLCSFilter with the given
//      parameters would result in an equivalent avtLCSFilter.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
// ****************************************************************************

bool
avtLCSFilter::Equivalent(const AttributeGroup *a)
{
    return (atts == *(LCSAttributes*)a);
}


// ****************************************************************************
// Method: avtLCSFilter::SetVelocitySource
//
// Purpose: 
//   Sets the integral curve velocity source.
//
// Arguments:
//   vel : The velocity of the point.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

void
avtLCSFilter::SetVelocitySource(const double *p)
{
  seedVelocity.set(p);
}


// ****************************************************************************
//  Method: avtLCSFilter::GetInitialVelocities
//
//  Purpose:
//      Get the seed velocities out of the attributes.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

std::vector<avtVector>
avtLCSFilter::GetInitialVelocities(void)
{
    std::vector<avtVector> seedVels;

    seedVels.push_back( seedVelocity );

    return seedVels;
}


// ****************************************************************************
//  Method: avtLCSFilter::SetTermination
//
//  Purpose:
//      Sets the termination criteria for an integral curve.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

void
avtLCSFilter::SetTermination(int maxSteps_,
                              bool doDistance_, double maxDistance_,
                              bool doTime_,     double maxTime_,
                              bool doSize_,     double maxSize_)
{
    maxSteps = maxSteps_;
    doDistance = doDistance_;
    maxDistance = maxDistance_;
    doTime = doTime_;
    maxTime = maxTime_;
    doSize = doSize_;
    maxSize = maxSize_;
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateIntegralCurve
//
//  Purpose:
//      Create an uninitialized integral curve.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtIntegralCurve*
avtLCSFilter::CreateIntegralCurve(void)
{
  if( doSize ) 
    return (new avtStreamlineIC());
  else
    return (new avtLCSIC());
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateIntegralCurve
//
//  Purpose:
//      Create an integral curve with specific IDs and parameters.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtIntegralCurve*
avtLCSFilter::CreateIntegralCurve(const avtIVPSolver* model,
                                  avtIntegralCurve::Direction dir,
                                  const double& t_start,
                                  const avtVector &p_start,
                                  const avtVector& v_start, long ID)
{
    double t;

    if (doPathlines)
    {
        if (dir == avtIntegralCurve::DIRECTION_BACKWARD)
            t = seedTime0 - maxTime;
        else
            t = seedTime0 + maxTime;
    }
    else
    {
        if (dir == avtIntegralCurve::DIRECTION_BACKWARD)
            t = -maxTime;
        else
            t = maxTime;
    }

    if( doSize )
    {
      // For now use the avtLCSIC as the state does not need to be
      // recorded for the FSLE. That is because currently the
      // integration is being done step by step rather than in
      // chunks. However, the code is set up to use
      // avtStreamlineIC. Which if the integration is done in chucks
      // will probably be more efficient.

      // unsigned char attr = avtStateRecorderIntegralCurve::SAMPLE_POSITION;
      // attr |= avtStateRecorderIntegralCurve::SAMPLE_TIME;
      // attr |= avtStateRecorderIntegralCurve::SAMPLE_ARCLENGTH;
      
      // return
      //   (new avtStreamlineIC(numSteps, doDistance, maxDistance, doTime, t,
      //                        attr, model, dir, t_start, p_start, v_start, ID));
      return
        (new avtLCSIC(numSteps, doDistance, maxDistance, doTime, t,
                       model, dir, t_start, p_start, v_start, ID));
    }
    else
    {
      return
        (new avtLCSIC(maxSteps, doDistance, maxDistance, doTime, t,
                       model, dir, t_start, p_start, v_start, ID));
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::ModifyContract
//
//  Purpose:
//      Creates a contract the removes the operator-created-expression.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
// ****************************************************************************

avtContract_p
avtLCSFilter::ModifyContract(avtContract_p in_contract)
{
    avtDataRequest_p in_dr = in_contract->GetDataRequest();
    std::string var =  in_dr->GetOriginalVariable();
//    in_contract->SetReplicateSingleDomainOnAllProcessors(true);
//    in_contract->SetOnDemandStreaming(false);
//    in_contract->GetDataRequest();
    in_dr->SetUsesAllDomains(true);

    if( strncmp(var.c_str(), "operators/LCS/", strlen("operators/LCS/")) == 0)
    {
        std::string justTheVar = var.substr(strlen("operators/LCS/"));

        outVarName = justTheVar;

        avtDataRequest_p out_dr = new avtDataRequest(in_dr, justTheVar.c_str());
        //out_dr->SetDesiredGhostDataType(GHOST_NODE_DATA);
        //out_dr->SetDesiredGhostDataType(GHOST_ZONE_DATA);

        return avtPICSFilter::ModifyContract( new avtContract(in_contract,out_dr) );
    }
    else
    {
      outVarName = var;
      outVarRoot = "";
    }

    return avtPICSFilter::ModifyContract(in_contract);
}


// ****************************************************************************
//  Method: avtLCSFilter::UpdateDataObjectInfo
//
//  Purpose:
//      Tells output that we have a new variable.
//
//  Programmer: hchilds -- generated by xml2avt
//  Creation:   Mon Jan 10 07:15:51 PDT 2011
//
//  Modifications:
//    Brad Whitlock, Mon Apr  7 15:55:02 PDT 2014
//    Add filter metadata used in export.
//    Work partially supported by DOE Grant SC0007548.
//
// ****************************************************************************

void
avtLCSFilter::UpdateDataObjectInfo(void)
{
    avtDataAttributes  &in_dataatts =  GetInput()->GetInfo().GetAttributes();
    avtDataAttributes &out_dataatts = GetOutput()->GetInfo().GetAttributes();

    timeState = in_dataatts.GetTimeIndex();

    //the outvarname has been assigned and will be added.
    //outVarName = "velocity";

    if (outVarRoot != "" && outVarName != "")
    {
        std::string fullVarName = outVarRoot + outVarName;

        out_dataatts.RemoveVariable(in_dataatts.GetVariableName());

        if (! out_dataatts.ValidVariable(fullVarName) )
        {
            //atts.AddVariable(outVarName.c_str());
            out_dataatts.AddVariable((fullVarName).c_str());
            out_dataatts.SetActiveVariable(fullVarName.c_str());
            //atts.SetTopologicalDimension(3);
            out_dataatts.SetVariableDimension(1);
            out_dataatts.SetVariableType(AVT_SCALAR_VAR);
            out_dataatts.SetCentering(AVT_NODECENT);
        }
    }
    else if (outVarName != "")
    {
      if( atts.GetOperationType() == LCSAttributes::EigenVector )
      {
        out_dataatts.SetVariableDimension(3);
        out_dataatts.SetVariableType(AVT_VECTOR_VAR);
      }
    }

    avtPICSFilter::UpdateDataObjectInfo();

    out_dataatts.AddFilterMetaData("LCS");
}


// ****************************************************************************
//  Method: avtLCSFilter::PostExecute
//
//  Purpose:
//      
//
//  Programmer: Hari Krishna
//  Creation:   December 5, 2011
//
//  Modifications:
//
// ****************************************************************************

void 
avtLCSFilter::PostExecute(void)
{
    avtPICSFilter::PostExecute();
}

// ****************************************************************************
//  Method: avtLCSFilter::PreExecute
//
//  Purpose:
//      Initialize data attributes for this filter and its base type (PICS).
//
//  Programmer: Hari Krishna
//  Creation:   December 5, 2011
//
//  Modifications:
//
//    Hank Childs, Jul  6 14:17:47 PDT 2012
//    Set resolution for Z to be 1 for 2D meshes.
//
// ****************************************************************************

void 
avtLCSFilter::PreExecute(void)
{
    SetActiveVariable(outVarName.c_str());
    GetSpatialExtents(global_bounds);

    // Cache the time and cycle at the start because for pathlines
    // they will change to the end.
    cycleCached = (int)   GetInput()->GetInfo().GetAttributes().GetCycle();
    timeCached  = (float) GetInput()->GetInfo().GetAttributes().GetTime();

    if (GetInput()->GetInfo().GetAttributes().GetSpatialDimension() == 2)
    {
        // we set them to 0->1 earlier and GetSpatialExtents only sets the
        // X and Y parts of the extents for 2D.
        global_bounds[4] = 0;
        global_bounds[5] = 0;
    }

    if(atts.GetUseDataSetStart() == LCSAttributes::Subset)
    {
        double* a = atts.GetStartPosition();
        global_bounds[0] = a[0];
        global_bounds[2] = a[1];
        global_bounds[4] = a[2];
    }

    if(atts.GetUseDataSetEnd() == LCSAttributes::Subset)
    {
        double* a = atts.GetEndPosition();
        global_bounds[1] = a[0];
        global_bounds[3] = a[1];
        global_bounds[5] = a[2];
    }

    const int* res = atts.GetResolution();
    global_resolution[0] = res[0];
    global_resolution[1] = res[1];
    global_resolution[2] = res[2];
    if (global_bounds[4] == global_bounds[5])
        global_resolution[2] = 1;

    double minResolution = std::numeric_limits<double>::max();

    double resX = 0., resY = 0., resZ = 0.;

    if (global_resolution[0] > 1)
    {
      double pcnt = 1.0 / (double) (global_resolution[0]-1);

      resX = (global_bounds[1] - global_bounds[0]) * pcnt; 

      minResolution = std::min( resX, minResolution );
    }
      
    if (global_resolution[1] > 1)
    {
      double pcnt = 1.0 / (double) (global_resolution[1]-1);

      resY = (global_bounds[3] - global_bounds[2]) * pcnt; 
 
      minResolution = std::min( resY, minResolution );
    }
      
    if (global_resolution[2] > 1)
    {
      double pcnt = 1.0 / (double) (global_resolution[2]-1);

      resZ = (global_bounds[5] - global_bounds[4]) * pcnt; 

      minResolution = std::min( resZ, minResolution );
    }

    if( atts.GetOperationType() == LCSAttributes::Lyapunov &&
        doSize && maxSize <= minResolution )
    {
        char str[1028];

        SNPRINTF(str, 1028, "\nThe size limit for the FSLE is %f. "
                 "and is equal to or smaller than the resolution of the grid "
                 "(%f, %f, %f). ",
                 atts.GetTermSize(), resX, resY, resZ );

        avtCallback::IssueWarning(str);
        
//      EXCEPTION1(ImproperUseException, str );
    }

    avtPICSFilter::PreExecute();
}


// ****************************************************************************
//  Method: avtLCSFilter::Execute
//
//  Purpose:
//      Executes the LCS.  If we already have a cached version, then it
//      just returns that version.  If not, it calls PICS execute, which will
//      call our LCS set up routines via CreateIntegralCurveOutput.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

void
avtLCSFilter::Execute(void)
{
    avtDataTree_p dt = GetCachedDataSet();

    if (!needsRecalculation && *dt != NULL)
    {
        debug1 << "LCS: using cached version" << std::endl;
        if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
            if (PAR_Rank() != 0)
                dt = new avtDataTree();
        SetOutputDataTree(dt);
        return;
    }
    else
    {
      debug1 << "LCS: no cached version, must re-execute" << std::endl;

      avtPICSFilter::Execute();

      std::vector<avtIntegralCurve *> ics;
      GetTerminatedIntegralCurves(ics);
      
      ReportWarnings( ics );
    }
}

// ****************************************************************************
//  Method: avtLCSFilter::ContinueExecute
//
//  Purpose:
//      See if execution needs to continue.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

bool
avtLCSFilter::ContinueExecute()
{
    ++numSteps;

    if( atts.GetOperationType() == LCSAttributes::Lyapunov )
    {
      if( doSize )
      {
        std::vector<avtIntegralCurve *> ics;
        
        GetTerminatedIntegralCurves(ics);
        
        if (atts.GetSourceType() == LCSAttributes::NativeMesh)
        {
          if (NativeMeshIterativeCalc(ics) == true )
            return false;
          else
            return true;
        }
        else //if (atts.GetSourceType() == LCSAttributes::RegularGrid)
        {
          if (RectilinearGridIterativeCalc(ics) == true )
            return false;
          else
            return true;
        }
      }
    }

    return false;
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateIntegralCurveOutput
//
//  Purpose:
//      Computes the LCS output (via sub-routines) after the PICS filter has
//      calculated the final particle positions.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

void 
avtLCSFilter::CreateIntegralCurveOutput(std::vector<avtIntegralCurve*> &ics)
{
  if( atts.GetOperationType() == LCSAttributes::Lyapunov && doSize )
  {
      if (atts.GetSourceType() == LCSAttributes::NativeMesh)
        CreateNativeMeshIterativeCalcOutput(ics);
      else //if (atts.GetSourceType() == LCSAttributes::RegularGrid)
        CreateRectilinearGridIterativeCalcOutput(ics);
  }
  else
  {
      if (atts.GetSourceType() == LCSAttributes::NativeMesh)
          NativeMeshSingleCalc(ics);
      else //if (atts.GetSourceType() == LCSAttributes::RegularGrid)
          RectilinearGridSingleCalc(ics);
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::GetInitialLocations
//
//  Purpose:
//      Tells the PICS filter where to place the initial seed locations.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

std::vector<avtVector>
avtLCSFilter::GetInitialLocations()
{
    seedPoints.clear();

    if (atts.GetSourceType() == LCSAttributes::NativeMesh)
    {
        GetInitialLocationsFromNativeMesh(GetInputDataTree());
    }
    else //if (atts.GetSourceType() == LCSAttributes::RegularGrid)
    {
        GetInitialLocationsFromRectilinearGrid();
    }

    return seedPoints;
}


// ****************************************************************************
//  Method: avtLCSFilter::GetInitialLocationsFromMesh
//
//  Purpose:
//      Walks through an AVT data tree and sets up the initial locations from
//      each point in the mesh.
//
//  Arguments:
//      inDT          A pointer to a data tree.  
 //
//  Programmer: Hank Childs
//  Creation:   December 5, 2011
//
// ****************************************************************************

void
avtLCSFilter::GetInitialLocationsFromNativeMesh(avtDataTree_p inDT)
{
    const double offset[3][6][3] = { { { 0., 0., 0.}, { 0., 0., 0.},
                                       { 0., 0., 0.}, { 0., 0., 0.},
                                       { 0., 0., 0.}, { 0., 0., 0.} },
                                     
                                     { {-1., 0., 0.}, { 1., 0., 0.},
                                       { 0.,-1., 0.}, { 0., 1., 0.},
                                       { 0., 0.,-1.}, { 0., 0., 1.} },
                                     
                                     { {-1., 0., 0.}, { 1., 0., 0.},
                                       { 0.,-1., 0.}, { 0., 1., 0.},
                                       { 0., 0.,-1.}, { 0., 0., 1.} } };
    if (*inDT == NULL)
        return;

    int nc = inDT->GetNChildren();

    if (nc < 0 && !inDT->HasData())
    {
        return;
    }

    if (nc == 0)
    {
        //
        // there is only one dataset to process
        //
        vtkDataSet *in_ds = inDT->GetDataRepresentation().GetDataVTK();
        size_t pts = in_ds->GetNumberOfPoints();

        size_t numberOfSeeds = seedPoints.size();
        size_t totalNumberOfSeeds = numberOfSeeds + pts*nAuxPts;
        seedPoints.resize( totalNumberOfSeeds );

        double base[3], point[3];
        
        // Insert the auxiliary points - the base point is not needed.
        for(size_t i = 0; i < pts; ++i)
        {
          in_ds->GetPoint(i, base);

          for(size_t a = 0; a < nAuxPts; ++a)
          {
            for(size_t l = 0; l < 3; ++l)
              point[l] = base[l] + auxSpacing * offset[auxIdx][a][l];

            seedPoints[numberOfSeeds++].set(point);
          }
        }
    }
    else
    {
        //
        // there is more than one input dataset to process
        // and we need an output datatree for each
        //
        for (int j = 0; j < nc; j++)
        {
            if (inDT->ChildIsPresent(j))
            {
                GetInitialLocationsFromNativeMesh(inDT->GetChild(j));
            }
        }
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::GetInitialLocationsFromRectilinearGrid
//
//  Purpose:
//      Created a series of seeds points based on the user specified mesh
//
//  Programmer: Hank Childs
//  Creation:   December 5, 2011
//
// ****************************************************************************

void
avtLCSFilter::GetInitialLocationsFromRectilinearGrid()
{
    const double offset[3][6][3] = { { { 0., 0., 0.}, { 0., 0., 0.},
                                       { 0., 0., 0.}, { 0., 0., 0.},
                                       { 0., 0., 0.}, { 0., 0., 0.} },
                                     
                                     { {-1., 0., 0.}, { 1., 0., 0.},
                                       { 0.,-1., 0.}, { 0., 1., 0.},
                                       { 0., 0.,-1.}, { 0., 0., 1.} },

                                     { {-1., 0., 0.}, { 1., 0., 0.},
                                       { 0.,-1., 0.}, { 0., 1., 0.},
                                       { 0., 0.,-1.}, { 0., 0., 1.} } };

    size_t nTuples =
      global_resolution[0] * global_resolution[1] * global_resolution[2];

    //compute total number of seeds that will be generated.
    size_t numberOfSeeds = 0;
    size_t totalNumberOfSeeds = nAuxPts *
      global_resolution[0] * global_resolution[1] * global_resolution[2];
    
    seedPoints.resize(totalNumberOfSeeds);

    double base[3], point[3];
        
    //add sample points by looping over in x,y,z
    for(int k = 0; k < global_resolution[2]; ++k)
    {
        double zpcnt = 0;

        if (global_resolution[2] > 1)
          zpcnt = ((double)k)/((double)global_resolution[2]-1);

        base[2] = global_bounds[4]*(1.0-zpcnt) + global_bounds[5]*zpcnt;
        
        for(int j = 0; j < global_resolution[1]; ++j)
        {
            double ypcnt = 0;

            if (global_resolution[1] > 1)
              ypcnt = ((double)j)/((double)global_resolution[1]-1);

            base[1] = global_bounds[2]*(1.0-ypcnt) + global_bounds[3]*ypcnt;
            
            for(int i = 0; i < global_resolution[0]; ++i)
            {
                double xpcnt = 0;

                if (global_resolution[0] > 1)
                  xpcnt = ((double)i)/((double)global_resolution[0]-1);

                base[0] = (global_bounds[0]*(1.0-xpcnt) +
                           global_bounds[1]*xpcnt);
                
                for(size_t a = 0; a < nAuxPts; ++a)
                {
                  for(size_t l = 0; l < 3; ++l)
                    point[l] = base[l] + auxSpacing * offset[auxIdx][a][l];

                  seedPoints[numberOfSeeds++].set(point);
                }
            }
        }
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::NativeMeshSingleCalc
//
//  Purpose:
//      Computes the FTLE and similar values that are neighbor
//      independent after the particles have been advected.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

void avtLCSFilter::NativeMeshSingleCalc(std::vector<avtIntegralCurve*> &ics)
{
    //accumulate all of the points then do jacobian?
    //or do jacobian then accumulate?
    //picking the first.

    double minv   =  std::numeric_limits<double>::max();
    double maxv   = -std::numeric_limits<double>::max();
    int    offset = 0;

    avtDataTree_p outTree =
      MultiBlockSingleCalc(GetInputDataTree(), ics, offset, minv, maxv);

    if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
        if (PAR_Rank() != 0)
            outTree = new avtDataTree();

    SetOutputDataTree(outTree);

    avtDataAttributes &dataatts = GetOutput()->GetInfo().GetAttributes();
    avtExtents* e = dataatts.GetThisProcsActualDataExtents();

    double range[6];
    range[0] = minv;
    range[1] = maxv;
    range[2] = minv;
    range[3] = maxv;
    range[4] = minv;
    range[5] = maxv;
    e->Set(range);

    e = dataatts.GetThisProcsOriginalDataExtents();
    e->Set(range);

    e = dataatts.GetThisProcsActualSpatialExtents();
    e->Set(global_bounds);
    e = dataatts.GetThisProcsOriginalSpatialExtents();
    e->Set(global_bounds);
}


// ****************************************************************************
//  Method: avtLCSFilter::MultiBlockSingleCalc
//
//  Purpose:
//      Computes the FTLE and similar values that are neighbor
//      independent for the whole data set, using the final particle
//      locations, at the blocks native mesh resolution.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtDataTree_p
avtLCSFilter::MultiBlockSingleCalc( avtDataTree_p inDT,
                                    std::vector<avtIntegralCurve*> &ics,
                                    int &offset, double &minv, double &maxv )
{
    if (*inDT == NULL)
        return 0;

    int nc = inDT->GetNChildren();

    if (nc < 0 && !inDT->HasData())
    {
        return 0;
    }

    if (nc == 0)
    {
        //
        // there is only one dataset to process
        //
        vtkDataSet *in_ds = inDT->GetDataRepresentation().GetDataVTK();
        int dom = inDT->GetDataRepresentation().GetDomain();
        std::string label = inDT->GetDataRepresentation().GetLabel();

        vtkDataSet *out_ds =
          SingleBlockSingleCalc( in_ds, ics, offset, dom, minv, maxv );
        avtDataTree_p rv = new avtDataTree(out_ds, dom, label);
        out_ds->Delete();
        return rv;
    }
    else
    {
      //
      // there is more than one input dataset to process
      // and we need an output datatree for each
      //
      avtDataTree_p *outDT = new avtDataTree_p[nc];
      for (int j = 0; j < nc; j++)
      {
          if (inDT->ChildIsPresent(j))
            outDT[j] = MultiBlockSingleCalc( inDT->GetChild(j), ics, 
                                                    offset, minv, maxv );
          else
            outDT[j] = NULL;
      }
      avtDataTree_p rv = new avtDataTree(nc, outDT);
      delete [] outDT;
      return rv;
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::SingleBlockSingleCalc
//
//  Purpose:
//      Computes the FTLE and similar values that are neighbor
//      independent for a single block of a data set, using the final
//      particle locations, at the blocks native mesh resolution.
//
//  Arguments:
//      in_ds   The block to calculate the value on
//      ics     The list of particles for all blocks on this MPI task.
//      domain  The domain number of in_ds
//      minv    The minimum value (output)
//      maxv    The maximum value (output)
//
//  Returns:    The new version of in_ds that includes the scalar
//              variable.  The calling function is responsible for
//              dereferencing this VTK object.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
//  Modifications:
//
//    Hank Childs, Tue Feb  5 08:12:33 PST 2013
//    Fix parallelization bug and memory leak.
//
// ****************************************************************************

vtkDataSet *
avtLCSFilter::SingleBlockSingleCalc( vtkDataSet *in_ds,
                                     std::vector<avtIntegralCurve*> &ics,
                                     int &offset, int domain,
                                     double &minv, double &maxv )
{
    // Variable name and number of points.
    std::string var = outVarRoot + outVarName;

    int nTuples = in_ds->GetNumberOfPoints();

    // Storage for the points and times
    std::vector<avtVector> remapPoints(nTuples*nAuxPts);
    std::vector<double>    remapTimes(nTuples*nAuxPts);

    // Zero out the points.
    for(size_t i = 0; i < remapPoints.size(); ++i)
    {
      remapPoints[i] = avtVector(0,0,0);
      remapTimes[i] = 0;
    }

    // ARS - This code does not nothing of use that I can see. The
    // remapPoints just need to be zeroed out.

    // if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
    // {
    //     // The parallel synchronization for when data is replicated involves
    //     // a sum across all processors.  So we want remapPoints to have the
    //     // location of the particle on one processor, and zero on the rest.
    //     // Do that here.
    //     // Special care is needed for the case where the particle never
    //     // advected.  Then we need to put the initial location on just one
    //     // processor.  We do this on rank 0.
    //     std::vector<int> iHavePoint(nTuples*nAuxPts, 0);
    //     std::vector<int> anyoneHasPoint;

    //     for (size_t i = 0; i < ics.size(); ++i)
    //     {
    //         size_t index = ics[i]->id;
    //         size_t l = (index-offset);

    //         if(l < remapPoints.size()) ///TODO: l >=0 is always true
    //         {
    //             iHavePoint[l] = 1;
    //         }
    //     }

    //     UnifyMaximumValue(iHavePoint, anyoneHasPoint);
    //     avtVector zero(0,0,0);

    //     for (size_t i = 0; i < remapPoints.size(); ++i)
    //         if (PAR_Rank() == 0 && !anyoneHasPoint[i])
    //             remapPoints[i] = seedPoints.at(offset + i);
    //         else
    //             remapPoints[i] = zero;
    // }
    // else
    // {
    //   //copy the original seed points
    //   for(size_t i = 0; i < remapPoints.size(); ++i)
    //     remapPoints[i] = seedPoints.at(offset + i);
    // }

    // The processor has a partial set of the curves so some values in
    // remapPoint will be zero.
    for(size_t i = 0; i < ics.size(); ++i)
    {
        size_t index = ics[i]->id;
        size_t l = (index-offset);

        if(l < remapPoints.size())
        {
          if( atts.GetOperationType() == LCSAttributes::EigenValue ||
              atts.GetOperationType() == LCSAttributes::EigenVector ||
              atts.GetOperationType() == LCSAttributes::Lyapunov )
          {
            remapPoints.at(l) = ((avtLCSIC*)ics[i])->GetEndPoint();
          }
          else
          {
            double ave = 0;

            if( ((avtLCSIC*)ics[i])->GetNumSteps() )
              remapPoints.at(l) =
                avtVector( ((avtLCSIC*)ics[i])->GetTime(),
                           ((avtLCSIC*)ics[i])->GetDistance(),
                           (((avtLCSIC*)ics[i])->GetSummation0() /
                            (double) ((avtLCSIC*)ics[i])->GetNumSteps()) );
            else
              remapPoints.at(l) =
                avtVector( ((avtLCSIC*)ics[i])->GetTime(),
                           ((avtLCSIC*)ics[i])->GetDistance(),
                           0 );
          }
        }
    }

    //done with offset, increment it for the next call to this
    //function.
    offset += nTuples;

    //create new instance from old.
    vtkDataSet* out_grid = in_ds->NewInstance();
    out_grid->ShallowCopy(in_ds);

    //use static function in avtGradientExpression to calculate
    //gradients.  since this function only does scalar, break our
    //vectors into scalar components and calculate one at a time.
    vtkDoubleArray *outputArray = vtkDoubleArray::New();
    outputArray->SetName(var.c_str());
    if( atts.GetOperationType() == LCSAttributes::EigenVector )
      outputArray->SetNumberOfComponents(3);
    else
      outputArray->SetNumberOfComponents(1);
    outputArray->SetNumberOfTuples(nTuples);
    out_grid->GetPointData()->AddArray(outputArray);

    vtkDoubleArray *workingArray = vtkDoubleArray::New();
    workingArray->SetName("workingArray");
    workingArray->SetNumberOfComponents(1);
    workingArray->SetNumberOfTuples(nTuples);
    out_grid->GetPointData()->AddArray(workingArray);
    out_grid->GetPointData()->SetActiveScalars("workingArray");

    if( atts.GetOperationType() == LCSAttributes::EigenValue ||
        atts.GetOperationType() == LCSAttributes::EigenVector ||
        atts.GetOperationType() == LCSAttributes::Lyapunov )
    {
      vtkDataArray* jacobian[3];
    
      if( auxIdx == LCSAttributes::None )
      {
        for(int i = 0; i < 3; ++i)
        {
          for(size_t j = 0; j < (size_t)nTuples; ++j)
            workingArray->SetTuple1(j, remapPoints[j][i]);

          // remapPoints does not contain all of the values only the
          // ones for the integral curves on this processor. So sum
          // all of the values across all of the processors.
          if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
          {
            double *newvals = new double[nTuples];
            double *origvals = (double *) workingArray->GetVoidPointer(0);
            SumDoubleArrayAcrossAllProcessors(origvals, newvals, nTuples);
            // copy newvals back into origvals
            memcpy(origvals, newvals, nTuples*sizeof(double));
            delete [] newvals;
          }
          
          jacobian[i] =
            avtGradientExpression::CalculateGradient(out_grid, var.c_str());
        }
      }
      else //if( auxIdx == LCSAttributes::TwoDim ||
           //    auxIdx == LCSAttributes::ThreeDim )
      {
        double delta = 1.0 / (2.0 * auxSpacing);

        double *dx = new double[nTuples];
        double *dy = new double[nTuples];
        double *dz = new double[nTuples];

        for(int i = 0; i < 3; ++i)
        {
          jacobian[i] =
            avtExpressionDataTreeIterator::CreateArrayFromMesh(in_ds);
          jacobian[i]->SetNumberOfComponents(3);
          jacobian[i]->SetNumberOfTuples(nTuples);

          // Do the x, y, and possibly the z component.
          if( i <= auxIdx )
          {
            for(size_t j = 0, k = 0; j < nTuples; ++j, k+=nAuxPts)
            {
              dx[j] = (remapPoints[k+1][i] - remapPoints[k+0][i]) * delta;
              dy[j] = (remapPoints[k+3][i] - remapPoints[k+2][i]) * delta;

              if( auxIdx == LCSAttributes::ThreeDim )
                dz[j] = (remapPoints[k+5][i] - remapPoints[k+4][i]) * delta;
              else
                dz[j] = 0;
            }

            // remapPoints does not contain all of the values only the
            // ones for the integral curves on this processor. So sum
            // all of the values across all of the processors.
            if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
            {
              double *dd[3] = {dx, dy, dz};

              for(size_t j = 0; j < 3; ++j)
              {
                double *newvals = new double[nTuples];
                SumDoubleArrayAcrossAllProcessors(dd[j], newvals, nTuples);
                // copy newvals back into origvals
                memcpy(dd[j], newvals, nTuples*sizeof(double));
                delete [] newvals;
              }
            }

            for(size_t j = 0; j < nTuples; ++j)
              jacobian[i]->SetTuple3(j, dx[j], dy[j], dz[j]);
          }
          // For a 2D auxiliary grid just zero out the z grid. No need
          // to sum across all processors as this sets all values.
          else
          {
            for (size_t j = 0; j < nTuples; ++j)
              jacobian[i]->SetTuple3(j, 0., 0., 1.);
          }
        }

        delete dx;
        delete dy;
        delete dz;
      }

      //now have the jacobian - 3 arrays with 3 workingArrays.
      if( atts.GetOperationType() == LCSAttributes::EigenValue )
        ComputeEigenValues(jacobian, outputArray);
      else if( atts.GetOperationType() == LCSAttributes::EigenVector )
        ComputeEigenVectors(jacobian, workingArray, outputArray);
      else //if( atts.GetOperationType() == LCSAttributes::Lyapunov )
        ComputeLyapunovExponent(jacobian, outputArray);

      jacobian[0]->Delete();
      jacobian[1]->Delete();
      jacobian[2]->Delete();
    }

    // The value stored in the points is the arc length, integration
    // time, and average distance form the seed. So just move it into
    // the output array.
    else if( atts.GetOperatorType() == LCSAttributes::BaseValue )
    {
      int index = (atts.GetOperationType()-LCSAttributes::IntegrationTime);

      for(size_t j = 0; j < (size_t)nTuples; ++j)
        outputArray->SetTuple1(j, remapPoints[j][index]);

      // remapPoints does not contain all of the values only the ones
      // for the integral curves on this processor. So sum all of the
      // values across all of the processors.
      if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
      {
        double *newvals = new double[nTuples];
        double *origvals = (double *) outputArray->GetVoidPointer(0);
        SumDoubleArrayAcrossAllProcessors(origvals, newvals, nTuples);
        // copy newvals back into origvals
        memcpy(origvals, newvals, nTuples*sizeof(double));
        delete [] newvals;
      }
    }
    else if( atts.GetOperatorType() == LCSAttributes::Gradient )
    {
      int index = (atts.GetOperationType()-LCSAttributes::IntegrationTime);
      
      // The base value is used to clamp the log values to be only
      // positive or both positive and negative.
      double baseValue;
      
      if (clampLogValues == true )
        baseValue = 1.0;
      else
        baseValue = std::numeric_limits<double>::epsilon();
      
      for (size_t l = 0; l < nTuples; l++)
        workingArray->SetTuple1(l, remapPoints[l][index]);

      // remapPoints does not contain all of the values only the
      // ones for the integral curves on this processor. So sum
      // all of the values across all of the processors.
      if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
      {
        double *newvals = new double[nTuples];
        double *origvals = (double *) workingArray->GetVoidPointer(0);
        SumDoubleArrayAcrossAllProcessors(origvals, newvals, nTuples);
        // copy newvals back into origvals
        memcpy(origvals, newvals, nTuples*sizeof(double));
        delete [] newvals;
      }
      
      vtkDataArray* gradient =
        avtGradientExpression::CalculateGradient(out_grid, var.c_str());
      
      for (size_t l = 0; l < nTuples; l++)
      {
        double *grad = gradient->GetTuple3(l);
        
        double lambda = baseValue;
        lambda = std::max( lambda, grad[0]*grad[0] );
        lambda = std::max( lambda, grad[1]*grad[1] );
        lambda = std::max( lambda, grad[2]*grad[2] );
        lambda = log( sqrt( lambda ) );
        
        if( doTime )
          lambda /= maxTime;
        else if( doDistance )
          lambda /= maxDistance;
        
        outputArray->SetTuple1(l, lambda);
      }
      
      gradient->Delete();
    }

    if( atts.GetOperationType() == LCSAttributes::EigenVector )
    {
      minv = 0;
      maxv = 1;

      // for(int i = 0; i < nTuples; ++i)
      // {
      //   double *vals = outputArray->GetTuple3(i);
      //   double mag = sqrt(vals[0]*vals[0]+vals[1]*vals[1]+vals[2]*vals[2]);

      //   minv = std::min(mag, minv);
      //   maxv = std::max(mag, maxv);
      // }
    }
    else
    {
      for(int i = 0; i < nTuples; ++i)
      {
        minv = std::min(outputArray->GetTuple1(i), minv);
        maxv = std::max(outputArray->GetTuple1(i), maxv);
      }
    }

    outputArray->Delete();
    workingArray->Delete();

    // Set the vectors to be the active data
    if( atts.GetOperationType() == LCSAttributes::EigenVector )
      out_grid->GetPointData()->SetActiveVectors(var.c_str());
    else
      out_grid->GetPointData()->SetActiveScalars(var.c_str());

    // Remove the working array.
    out_grid->GetPointData()->RemoveArray("workingArray");

    //Store this dataset in Cache for next time.
    std::string str = CreateCacheString();
    StoreArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                            outVarName.c_str(), domain, -1,
                            str.c_str(), out_grid);

    // Calling function must free this.
    return out_grid;
}


// ****************************************************************************
//  Method: avtLCSFilter::RectilinearGridSingleCalc
//
//  Purpose:
//      Computes the FTLE and similar values that are neighbor
//      independent on a rectilinear grid.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
//    Mark C. Miller, Wed Aug 22 19:22:40 PDT 2012
//    Fix leak of all_indices, index_counts, all_points, result_counts on 
//    rank 0 (root).
// ****************************************************************************

void
avtLCSFilter::RectilinearGridSingleCalc(std::vector<avtIntegralCurve*> &ics)
{
    //variable name.
    std::string var = outVarRoot + outVarName;

    size_t nTuples =
          global_resolution[0] * global_resolution[1] * global_resolution[2];

    //algorithm sends index to global datastructure as well as end points.
    //Send List of index into global array to rank 0
    //Send end positions into global array to rank 0

    //loop over all the integral curves and add it back to the
    //original list of seeds.
    intVector indices(nTuples*nAuxPts);
    doubleVector points(nTuples*nAuxPts*3);
    doubleVector times(nTuples*nAuxPts);

    for(size_t i=0, j=0; i<ics.size(); ++i, j+=3)
    {
        indices[i] = ics[i]->id;
        times[i]   = ((avtLCSIC*)ics[i])->GetTime();

        if( atts.GetOperationType() == LCSAttributes::EigenValue ||
            atts.GetOperationType() == LCSAttributes::EigenVector ||
            atts.GetOperationType() == LCSAttributes::Lyapunov )
        {
          avtVector end_point = ((avtLCSIC*)ics[i])->GetEndPoint();
          
          points[j+0] = end_point[0];
          points[j+1] = end_point[1];
          points[j+2] = end_point[2];
        }
        else
        {
          points[j+0] = ((avtLCSIC*)ics[i])->GetTime();
          points[j+1] = ((avtLCSIC*)ics[i])->GetArcLength();

          if( ((avtLCSIC*)ics[i])->GetNumSteps() )
            points[j+2] = (((avtLCSIC*)ics[i])->GetSummation0() /
                           (double) ((avtLCSIC*)ics[i])->GetNumSteps());
          else
            points[j+2] = 0;
        }
    }

    int* all_indices = 0;
    int* index_counts = 0;

    double* all_times = 0;
    int *time_counts = 0;

    double* all_points = 0;
    int *point_counts = 0;

    Barrier();

    CollectIntArraysOnRootProc(all_indices, index_counts,
                               &indices.front(), (int)indices.size());

    CollectDoubleArraysOnRootProc(all_times, time_counts,
                                  &times.front(), (int)times.size());

    CollectDoubleArraysOnRootProc(all_points, point_counts,
                                  &points.front(), (int)points.size());

    Barrier();

    //root should now have index into global structure and all
    //matching end positions.
    if(PAR_Rank() != 0)
    {
        avtDataTree* dummy = new avtDataTree();
        SetOutputDataTree(dummy);
    }
    else
    {
        //rank 0
        //now create a rectilinear grid.
        vtkRectilinearGrid* rect_grid = vtkRectilinearGrid::New();

        vtkDoubleArray* lxcoord = vtkDoubleArray::New();
        vtkDoubleArray* lycoord = vtkDoubleArray::New();
        vtkDoubleArray* lzcoord = vtkDoubleArray::New();

        rect_grid->SetDimensions(global_resolution);

        lxcoord->SetNumberOfTuples(global_resolution[0]);
        for (int i = 0; i < global_resolution[0]; i++)
        {
            double pcnt = 0;
            if (global_resolution[0] > 1)
                pcnt = ((double)i)/((double)global_resolution[0]-1);
            lxcoord->SetTuple1(i, global_bounds[0]*(1.0-pcnt) + global_bounds[1]*pcnt);
        }

        lycoord->SetNumberOfTuples(global_resolution[1]);
        for (int i = 0; i < global_resolution[1]; i++)
        {
            double pcnt = 0;
            if (global_resolution[1] > 1)
                pcnt = ((double)i)/((double)global_resolution[1]-1);
            lycoord->SetTuple1(i, global_bounds[2]*(1.0-pcnt) + global_bounds[3]*pcnt);
        }

        lzcoord->SetNumberOfTuples(global_resolution[2]);
        for (int i = 0; i < global_resolution[2]; i++)
        {
            double pcnt = 0;
            if (global_resolution[2] > 1)
                pcnt = ((double)i)/((double)global_resolution[2]-1);
            lzcoord->SetTuple1(i, global_bounds[4]*(1.0-pcnt) + global_bounds[5]*pcnt);
        }

        rect_grid->SetXCoordinates(lxcoord);
        rect_grid->SetYCoordinates(lycoord);
        rect_grid->SetZCoordinates(lzcoord);

        //cleanup
        lxcoord->Delete();
        lycoord->Delete();
        lzcoord->Delete();

        vtkDoubleArray *outputArray = vtkDoubleArray::New();
        outputArray->SetName(var.c_str());
        if( atts.GetOperationType() == LCSAttributes::EigenVector )
          outputArray->SetNumberOfComponents(3);
        else
          outputArray->SetNumberOfComponents(1);
        outputArray->SetNumberOfTuples(nTuples);
        rect_grid->GetPointData()->AddArray(outputArray);

        vtkDoubleArray *workingArray = vtkDoubleArray::New();
        workingArray->SetName("workingArray");
        workingArray->SetNumberOfComponents(1);
        workingArray->SetNumberOfTuples(nTuples);
        rect_grid->GetPointData()->AddArray(workingArray);
        rect_grid->GetPointData()->SetActiveScalars("workingArray");
    
        //calculate jacobian in parts (x,y,z).
        std::vector<double> remapTimes(nTuples*nAuxPts);
        std::vector<avtVector> remapPoints(nTuples*nAuxPts);

        //update remapPoints with new value bounds from integral curves.
        int par_size = PAR_Size();
        size_t total = 0;
        for(int i = 0; i < par_size; ++i)
        {
            if(index_counts[i]*3 == point_counts[i])
            {
                total += index_counts[i];
            }
            else
            {
                EXCEPTION1(VisItException,
                           "Index count does not the result count." );
            }
        }

        for(size_t j = 0, k = 0; j < total; ++j, k += 3)
        {
            size_t index = all_indices[j];

            if(index < nTuples*nAuxPts)
            {
              remapTimes[index] = all_times[j];
              remapPoints[index].set( all_points[k+0],
                                      all_points[k+1],
                                      all_points[k+2]);
            }
            else
            {
              EXCEPTION1(VisItException,
                         "More integral curves were generatated than "
                         "grid points." );
            }
        }
      
        if( atts.GetOperationType() == LCSAttributes::EigenValue ||
            atts.GetOperationType() == LCSAttributes::EigenVector ||
            atts.GetOperationType() == LCSAttributes::Lyapunov )
        {
          vtkDataArray* jacobian[3];

          if( auxIdx == LCSAttributes::None )
          {
            for(int i = 0; i < 3; ++i)
            {
              for (size_t l = 0; l < nTuples; l++)
                workingArray->SetTuple1(l, remapPoints[l][i]);

              jacobian[i] =
                avtGradientExpression::CalculateGradient(rect_grid, var.c_str());
            }
          }
          else //if( auxIdx == LCSAttributes::TwoDim ||
               //    auxIdx == LCSAttributes::ThreeDim )
          {
            double delta = 1.0 / (2.0 * auxSpacing);
            
            for(int i = 0; i < 3; ++i)
            {
              jacobian[i] =
                avtExpressionDataTreeIterator::CreateArrayFromMesh(rect_grid);
              jacobian[i]->SetNumberOfComponents(3);
              jacobian[i]->SetNumberOfTuples(nTuples);
              
              double dx, dy, dz;
              
              // Do the x, y, and possibly the z component.
              if( i <= auxIdx )
              {
                for(size_t j = 0, k = 0; j < nTuples; ++j, k+=nAuxPts)
                {
                  dx = (remapPoints[k+1][i] - remapPoints[k+0][i]) * delta;
                  dy = (remapPoints[k+3][i] - remapPoints[k+2][i]) * delta;
                  
                  if( auxIdx == LCSAttributes::ThreeDim )
                    dz = (remapPoints[k+5][i] - remapPoints[k+4][i]) * delta;
                  else
                    dz = 0;
                  
                  jacobian[i]->SetTuple3(j, dx, dy, dz);
                }
              }
              else
              {
                for (size_t j = 0; j < nTuples; ++j)
                  jacobian[i]->SetTuple3(j, 0., 0., 1.);
              }
            }
          }

          if( atts.GetOperationType() == LCSAttributes::EigenValue )
            ComputeEigenValues(jacobian, outputArray);
          else if( atts.GetOperationType() == LCSAttributes::EigenVector )
          {
            ComputeEigenVectors(jacobian, workingArray, outputArray);

            bool clv = clampLogValues;
            clampLogValues = false;

            LCSAttributes::EigenComponent ec = eigenComponent;

            if( eigenComponent == LCSAttributes::Largest )
            {
              // Get the largest eigen values.
              eigenComponent = LCSAttributes::Smallest;
              ComputeLyapunovExponent(jacobian, workingArray);

              // Get the maximal values as seeds from the smallest eigen values.
              GetSeedPoints( rect_grid, true );
              
              // Get the minimal values as seeds from the smallest eigen values.
              GetSeedPoints( rect_grid, false );
            }
            else //if( eigenComponent == LCSAttributes::Smallest )
            {
              // Get the largest eigen values.
              eigenComponent = LCSAttributes::Largest;
              ComputeLyapunovExponent(jacobian, workingArray);

              // Get the maximal values as seeds from the largest eigen values.
              GetSeedPoints( rect_grid, true );
              
              // Get the minimal values as seeds from the largest eigen values.
              GetSeedPoints( rect_grid, false );
            }

            clampLogValues = clv;
            eigenComponent = ec;              
          }
          else if( atts.GetOperationType() == LCSAttributes::Lyapunov )
            ComputeLyapunovExponent(jacobian, outputArray);

          jacobian[0]->Delete();
          jacobian[1]->Delete();
          jacobian[2]->Delete();
        }

        // The value stored in the points is the arc length, integration
        // time, and average distance form the seed. So just move it into
        // the output array.
        else if( atts.GetOperatorType() == LCSAttributes::BaseValue )
        {
          int index = (atts.GetOperationType()-LCSAttributes::IntegrationTime);

          for (size_t l = 0; l < nTuples; l++)
            outputArray->SetTuple1(l, remapPoints[l][index]);
        }

        else if( atts.GetOperatorType() == LCSAttributes::Gradient )
        {
          int index = (atts.GetOperationType()-LCSAttributes::IntegrationTime);
          
          // The base value is used to clamp the log values to be only
          // positive or both positive and negative.
          double baseValue;

          if (clampLogValues == true )
            baseValue = 1.0;
          else
            baseValue = std::numeric_limits<double>::epsilon();

          for (size_t l = 0; l < nTuples; l++)
            workingArray->SetTuple1(l, remapPoints[l][index]);

          vtkDataArray* gradient =
            avtGradientExpression::CalculateGradient(rect_grid, var.c_str());

          for (size_t l = 0; l < nTuples; l++)
          {
            double *grad = gradient->GetTuple3(l);

            double lambda = baseValue;
            lambda = std::max( lambda, grad[0]*grad[0] );
            lambda = std::max( lambda, grad[1]*grad[1] );
            lambda = std::max( lambda, grad[2]*grad[2] );
            lambda = log( sqrt( lambda ) );

            if( doTime )
              lambda /= maxTime;
            else if( doDistance )
              lambda /= maxDistance;

            outputArray->SetTuple1(l, lambda);
          }

          gradient->Delete();
        }

        //min and max values over all datasets of the tree.
        double minv =  std::numeric_limits<double>::max();
        double maxv = -std::numeric_limits<double>::max();

        if( atts.GetOperationType() == LCSAttributes::EigenVector )
        {
          minv = 0;
          maxv = 1;

          // for(int i = 0; i < nTuples; ++i)
          // {
          //   double *vals = outputArray->GetTuple3(i);
          //   double mag = sqrt(vals[0]*vals[0]+vals[1]*vals[1]+vals[2]*vals[2]);

          //   minv = std::min(mag, minv);
          //   maxv = std::max(mag, maxv);
          // }
        }
        else
        {
          for(size_t l = 0; l < nTuples; ++l)
          {
            minv = std::min(outputArray->GetTuple1(l), minv);
            maxv = std::max(outputArray->GetTuple1(l), maxv);
          }
        }

        outputArray->Delete();
        workingArray->Delete();

        // Set the vectors to be the active data
        if( atts.GetOperationType() == LCSAttributes::EigenVector )
          rect_grid->GetPointData()->SetActiveVectors(var.c_str());
        else
          rect_grid->GetPointData()->SetActiveScalars(var.c_str());

        // Remove the working array.
        rect_grid->GetPointData()->RemoveArray("workingArray");

        if (all_indices)  delete [] all_indices;
        if (index_counts) delete [] index_counts;

        if (all_times)  delete [] all_times;
        if (time_counts) delete [] time_counts;

        if (all_points)   delete [] all_points;
        if (point_counts) delete [] point_counts;

        //store this dataset in Cache for next time.
        std::string str = CreateCacheString();
        StoreArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                                outVarName.c_str(), -1, -1,
                                str.c_str(), rect_grid);

        int index = 0;//what does index mean in this context?
        avtDataTree* dt = new avtDataTree(rect_grid,index);
        int x = 0;
        dt->GetAllLeaves(x);

        SetOutputDataTree(dt);

        //set atts.
        avtDataAttributes &dataatts = GetOutput()->GetInfo().GetAttributes();
        avtExtents* e = dataatts.GetThisProcsActualDataExtents();

        double range[6];
        range[0] = minv;
        range[1] = maxv;
        range[2] = minv;
        range[3] = maxv;
        range[4] = minv;
        range[5] = maxv;
        e->Set(range);
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::ComputeLeftCauchyGreenTensor2D
//
//  Purpose:
//      Given a Gradient in place compute the Right Cauchy Green Tensor.
//
//  Programmer: Allen Sanderson
//  Creation:   March 5, 2015
//
//  Modifications:
//
// ****************************************************************************

void avtLCSFilter::ComputeLeftCauchyGreenTensor2D(double **j)
{
    double *j0 = j[0];
    double *j1 = j[1];
    
    // From the gradients compute the left Cauchy-Green Tensor J*J^T

    // j0[0]  j0[1] |  j0[0]  j1[0]
    // j1[0]  j1[1] |  j0[1]  j1[1]

    double a = j0[0]*j0[0] + j0[1]*j0[1];
    double b = j0[0]*j1[0] + j0[1]*j1[1];

    double d = j1[0]*j1[0] + j1[1]*j1[1];

    j0[0] = a;       j0[1] = b;
    j1[0] = b;       j1[1] = d;
}


// ****************************************************************************
//  Method: avtLCSFilter::ComputeLeftCauchyGreenTensor3D
//
//  Purpose:
//      Given a Gradient in place compute the Right Cauchy Green Tensor.
//
//  Programmer: Allen Sanderson
//  Creation:   March 5, 2015
//
//  Modifications:
//
// ****************************************************************************

void avtLCSFilter::ComputeLeftCauchyGreenTensor3D(double **j)
{
    double *j0 = j[0];
    double *j1 = j[1];
    double *j2 = j[2];
    
    // From the gradients compute the right Cauchy-Green Tensor J*J^T   

    // j0[0]  j0[1] j0[2] |  j0[0]  j1[0]  j2[0]
    // j1[0]  j1[1] j1[2] |  j0[1]  j1[1]  j2[1]
    // j2[0]  j2[1] j2[2] |  j0[2]  j1[2]  j2[2]

    double a = j0[0]*j0[0] + j0[1]*j0[1] + j0[2]*j0[2];
    double b = j0[0]*j1[0] + j0[1]*j1[1] + j0[2]*j1[2];
    double c = j0[0]*j2[0] + j0[1]*j2[1] + j0[2]*j2[2];

    double d = j1[0]*j1[0] + j1[1]*j1[1] + j1[2]*j1[2];
    double e = j1[0]*j2[0] + j1[1]*j2[1] + j1[2]*j2[2];
 
    double f = j2[0]*j2[0] + j2[1]*j2[1] + j2[2]*j2[2];

    j0[0] = a;       j0[1] = b;       j0[2] = c;
    j1[0] = b;       j1[1] = d;       j1[2] = e;
    j2[0] = c;       j2[1] = e;       j2[2] = f;
}


// ****************************************************************************
//  Method: avtLCSFilter::ComputeRightCauchyGreenTensor2D
//
//  Purpose:
//      Given a Gradient in place compute the Right Cauchy Green Tensor.
//
//  Programmer: Allen Sanderson
//  Creation:   March 5, 2015
//
//  Modifications:
//
// ****************************************************************************

void avtLCSFilter::ComputeRightCauchyGreenTensor2D(double **j)
{
    double *j0 = j[0];
    double *j1 = j[1];
    
    // From the gradients compute the right Cauchy-Green Tensor J^T*J

    // j0[0]  j1[0] | j0[0]  j0[1]
    // j0[1]  j1[1] | j1[0]  j1[1]

    double a = j0[0]*j0[0] + j1[0]*j1[0];
    double b = j0[0]*j0[1] + j1[0]*j1[1];

    double d = j0[1]*j0[1] + j1[1]*j1[1];

    j0[0] = a;       j0[1] = b;
    j1[0] = b;       j1[1] = d;
}


// ****************************************************************************
//  Method: avtLCSFilter::ComputeRightCauchyGreenTensor3D
//
//  Purpose:
//      Given a Gradient in place compute the Right Cauchy Green Tensor.
//
//  Programmer: Allen Sanderson
//  Creation:   March 5, 2015
//
//  Modifications:
//
// ****************************************************************************

void avtLCSFilter::ComputeRightCauchyGreenTensor3D(double **j)
{
    double *j0 = j[0];
    double *j1 = j[1];
    double *j2 = j[2];

    // From the gradients compute the right Cauchy-Green Tensor J^T*J   

    // j0[0]  j1[0]  j2[0] | j0[0]  j0[1] j0[2]
    // j0[1]  j1[1]  j2[1] | j1[0]  j1[1] j1[2]
    // j0[2]  j1[2]  j2[2] | j2[0]  j2[1] j2[2]


    double a = j0[0]*j0[0] + j1[0]*j1[0] + j2[0]*j2[0];
    double b = j0[0]*j0[1] + j1[0]*j1[1] + j2[0]*j2[1];
    double c = j0[0]*j0[2] + j1[0]*j1[2] + j2[0]*j2[2];

    double d = j0[1]*j0[0] + j1[1]*j1[0] + j2[1]*j2[0];
    double e = j0[1]*j0[1] + j1[1]*j1[1] + j2[1]*j2[1];
 
    double f = j0[2]*j0[2] + j1[2]*j1[2] + j2[2]*j2[2];

    j0[0] = a;       j0[1] = b;       j0[2] = c;
    j1[0] = b;       j1[1] = d;       j1[2] = e;
    j2[0] = c;       j2[1] = e;       j2[2] = f;
}


// ****************************************************************************
//  Method: avtLCSFilter::Jacobi2D
//
//  Purpose:
//      Computes the eigen vectors given a symmetric Jacobian.
//
//  Programmer: Allen Sanderson
//  Creation:   March 5, 2015
//
//  Modifications:
//
// ****************************************************************************

int avtLCSFilter::Jacobi2D(double **j, double *w)
{
    double *j0 = j[0];
    double *j1 = j[1];

    // Assume a symetric matrix
    // a b
    // b c

    double a = j0[0];
    double b = j0[1];
    double c = j1[1];

    double trace = (a + c) / 2.0;
    double det = a*c - b*b;
    double sqrtr = sqrt(trace * trace - det);

    // Order the largest first to match VTK
    w[0] = trace + sqrtr;
    w[1] = trace - sqrtr;

    return 1;
}

// ****************************************************************************
//  Method: avtLCSFilter::Jacobi2D
//
//  Purpose:
//      Computes the eigen vectors given a symmetric Jacobian.
//
//  Programmer: Allen Sanderson
//  Creation:   March 5, 2015
//
//  Modifications:
//
// ****************************************************************************

int avtLCSFilter::Jacobi2D(double **j, double *w, double **v)
{
    double *j0 = j[0];
    double *j1 = j[1];
    
    // Assume a symetric matrix
    // a b
    // b c

    double a = j0[0];
    double b = j0[1];
    double c = j1[1];

    double trace = (a + c) / 2.0;
    double det = a*c - b*b;
    double sqrtr = sqrt(trace * trace - det);

    // Order the largest first to match VTK
    w[0] = trace + sqrtr;
    w[1] = trace - sqrtr;

    // Use the largest value to get the first vector.
    avtVector vec0 = avtVector( -b, a-w[0], 0.0 );
    vec0.normalize();
    avtVector vec1 = avtVector( vec0.y, -vec0.x, 0.0 );

    v[0][0] = vec0.x;   v[0][1] = vec0.y; 
    v[1][0] = vec1.x;   v[1][1] = vec1.y; 


    // // Sorted in decreasing order.
    // double eigenvals[2];
    // double *eigenvecs[2];

    // double outrow0[2];
    // double outrow1[2];
    
    // eigenvecs[0] = outrow0;
    // eigenvecs[1] = outrow1;

    // vtkMath::JacobiN(j, 2, w, eigenvecs);

    // avtVector vec0 = avtVector( eigenvecs[0][0], eigenvecs[1][0], 0.0 );
    // vec0.normalize();
    // avtVector vec1 = avtVector( vec0.y, -vec0.x, 0.0 );

    // v[0][0] = vec0.x;   v[0][1] = vec0.y; 
    // v[1][0] = vec1.x;   v[1][1] = vec1.y; 

    return 1;
}

// ****************************************************************************
//  Method: avtLCSFilter::Jacobi3D
//
//  Purpose:
//      Computes the eigen vectors given a symmetric Jacobian.
//
//  Programmer: Allen Sanderson
//  Creation:   March 5, 2015
//
//  Modifications:
//
// ****************************************************************************

int avtLCSFilter::Jacobi3D(double **j, double *w)
{
    double *j0 = j[0];
    double *j1 = j[1];
    double *j2 = j[2];

    // Assume a symetric matrix
    // a b c
    // b d e
    // c e f

    double a = j0[0];
    double b = j0[1];
    double c = j0[2];
    double d = j1[1];
    double e = j1[2];
    double f = j2[2];

    // Now calculate the eigen values
    double x = ( a + d + f ) / 3.0f;  // trace

    a -= x;
    d -= x;
    f -= x;

    // Det / 2;
    double q = (a*d*f + b*e*c + c*b*e - c*d*c - e*e*a - f*b*b) / 2.0f;
    double r = (a*a + b*b + c*c + b*b + d*d + e*e + c*c + e*e + f*f) / 6.0f;

    double D = (r*r*r - q*q);
    double phi = 0.0f;

    if( D < std::numeric_limits<double>::epsilon())
      phi = 0.0f;
    else
    {
      phi = atanf( sqrt(D)/q ) / 3.0f;
      
      if( phi < 0 )
          phi += M_PI;
    }

    const double sqrt3 = sqrt(3.0f);
    const double sqrtr = sqrt(r);

    double sinphi = 0.0f, cosphi = 0.0f;
    sinphi = sinf(phi);
    cosphi = cosf(phi);

    // Sorted in decreasing order.
    double w0 = x + 2.0*sqrtr*cosphi;
    double w1 = x - sqrtr*(cosphi - sqrt3*sinphi);
    double w2 = x - sqrtr*(cosphi + sqrt3*sinphi);

    if( w0 >= w1 && w0 >= w2 )
    {
      w[0] = w0;

      if( w1 >= w2 ) { w[1] = w1;       w[2] = w2; }
      else           { w[1] = w2;       w[2] = w1; }
    }
    else if( w1 >= w0 && w1 >= w2 )
    {
      w[0] = w1;

      if( w0 >= w2 ) { w[1] = w0;       w[2] = w2; }
      else           { w[1] = w2;       w[2] = w0; }
    }
    else if( w2 >= w0 && w2 >= w1 )
    {
      w[0] = w2;

      if( w0 >= w1 ) { w[1] = w0;       w[2] = w1; }
      else           { w[1] = w1;       w[2] = w0; }
    }

    return 1;
}


// ****************************************************************************
//  Method: avtLCSFilter::ComputeEigenValues
//
//  Purpose:
//      Computes the eigen vectors given a Jacobian.
//
//  Programmer: Allen Sanderson
//  Creation:   March 5, 2015
//
//  Modifications:
//
// ****************************************************************************

void avtLCSFilter::ComputeEigenValues(vtkDataArray *jacobian[3],
                                      vtkDataArray *valArray)
{
    size_t nTuples = valArray->GetNumberOfTuples();

    if( auxIdx == LCSAttributes::TwoDim )
    {
      for(size_t l = 0; l < nTuples; ++l)
      {
        double *input[2];
        input[0] = jacobian[0]->GetTuple3(l);
        input[1] = jacobian[1]->GetTuple3(l);

        if( cgTensor == LCSAttributes::Right )
          ComputeRightCauchyGreenTensor2D(input);
        else //if( cgTensor == LCSAttributes::Left )
          ComputeLeftCauchyGreenTensor2D(input);

        double eigenvals[2];
        Jacobi2D(input, eigenvals);

        if( eigenComponent == LCSAttributes::Largest )
          valArray->SetTuple1(l, eigenvals[0]);
        else // if( eigenComponent == LCSAttributes::Smallest )
          valArray->SetTuple1(l, eigenvals[1]);
      }
    }
    else
    {
      for(size_t l = 0; l < nTuples; ++l)
      {
        double *input[3];
        input[0] = jacobian[0]->GetTuple3(l);
        input[1] = jacobian[1]->GetTuple3(l);
        input[2] = jacobian[2]->GetTuple3(l);

        if( cgTensor == LCSAttributes::Right )
          ComputeRightCauchyGreenTensor3D(input);
        else //if( cgTensor == LCSAttributes::Left )
          ComputeLeftCauchyGreenTensor3D(input);

        double eigenvals[3];
        Jacobi3D(input, eigenvals);

        if( eigenComponent == LCSAttributes::Largest )
          valArray->SetTuple1(l, eigenvals[0]);
        else if( eigenComponent == LCSAttributes::Intermediate )
          valArray->SetTuple1(l, eigenvals[1]);
        else // if( eigenComponent == LCSAttributes::Smallest )
          valArray->SetTuple1(l, eigenvals[2]);
        }
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::ComputeEigenVectors
//
//  Purpose:
//      Computes the eigen vectors given a Jacobian.
//
//  Programmer: Allen Sanderson
//  Creation:   March 5, 2015
//
//  Modifications:
//
// ****************************************************************************

void avtLCSFilter::ComputeEigenVectors(vtkDataArray *jacobian[3],
                                       vtkDataArray *valArray,
                                       vtkDataArray *vecArray)
{
    size_t nTuples = valArray->GetNumberOfTuples();

    if( auxIdx == LCSAttributes::TwoDim )
    {
      for(size_t l = 0; l < nTuples; ++l)
      {
        double *input[2];
        input[0] = jacobian[0]->GetTuple3(l);
        input[1] = jacobian[1]->GetTuple3(l);

        if( cgTensor == LCSAttributes::Right )
          ComputeRightCauchyGreenTensor2D(input);
        else //if( cgTensor == LCSAttributes::Left )
          ComputeLeftCauchyGreenTensor2D(input);

        // Sorted in decreasing order.
        double eigenvals[2];
        double *eigenvecs[2];

        double outrow0[3];
        double outrow1[3];
        eigenvecs[0] = outrow0;
        eigenvecs[1] = outrow1;

        Jacobi2D(input, eigenvals, eigenvecs);

        if( eigenComponent == LCSAttributes::Largest )
        {
          eigenvecs[0][2] = 0;
          valArray->SetTuple1(l, eigenvals[0]);
          vecArray->SetTuple(l, eigenvecs[0]);
        }
        else // if( eigenComponent == LCSAttributes::Smallest )
        {
          eigenvecs[1][2] = 0;
          valArray->SetTuple1(l, eigenvals[1]);
          vecArray->SetTuple(l, eigenvecs[1]);
        }
      }
    }
    else
    {
      for(size_t l = 0; l < nTuples; ++l)
      {
        double *input[3];
        input[0] = jacobian[0]->GetTuple3(l);
        input[1] = jacobian[1]->GetTuple3(l);
        input[2] = jacobian[2]->GetTuple3(l);

        if( cgTensor == LCSAttributes::Right )
          ComputeRightCauchyGreenTensor3D(input);
        else //if( cgTensor == LCSAttributes::Left )
          ComputeLeftCauchyGreenTensor3D(input);

        // Sorted in decreasing order.
        double eigenvals[3];
        double *eigenvecs[3];

        double outrow0[3];
        double outrow1[3];
        double outrow2[3];
        eigenvecs[0] = outrow0;
        eigenvecs[1] = outrow1;
        eigenvecs[2] = outrow2;

        vtkMath::Jacobi(input, eigenvals, eigenvecs);

        if( eigenComponent == LCSAttributes::Largest )
        {
          valArray->SetTuple1(l, eigenvals[0]);
          vecArray->SetTuple(l, eigenvecs[0]);
        }
        else if( eigenComponent == LCSAttributes::Intermediate )
        {
          valArray->SetTuple1(l, eigenvals[1]);
          vecArray->SetTuple(l, eigenvecs[1]);
        }
        else // if( eigenComponent == LCSAttributes::Smallest )
        {
          valArray->SetTuple1(l, eigenvals[2]);
          vecArray->SetTuple(l, eigenvecs[2]);
        }
      }
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::ComputeLyapunovExponent
//
//  Purpose:
//      Computes the FTLE or FLLE given a Jacobian. Which is the
//      following: log of the square root of the maximum eigen value
//      of the right Caughy-Green Tensor with the result divided by
//      the time or distance.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
//  Modifications:
//
//    Hank Childs, Fri Sep  7 15:47:12 PDT 2012
//    Convert calculation to double precision, which prevents a "cliff" from
//    too large epsilon associated with float.
//
// ****************************************************************************

void avtLCSFilter::ComputeLyapunovExponent(vtkDataArray *jacobian[3],
                                           vtkDataArray *expArray)
{
    bool takeLog = doTime || doDistance;

    size_t nTuples = expArray->GetNumberOfTuples();

    // The base value is used to clamp the log values to be only
    // positive or both positive and negative.
    double baseValue, denominator = 1.0;

    // Clamp only if taking the log.
    if (takeLog && clampLogValues == true )
      baseValue = 1.0;
    else
      baseValue = -std::numeric_limits<double>::max();

    if( doTime )
      denominator /= maxTime;
    else if( doDistance )
      denominator /= maxDistance;

    if( auxIdx == LCSAttributes::TwoDim )
    {
      for(size_t l = 0; l < nTuples; ++l)
      {
        double *input[2];
        input[0] = jacobian[0]->GetTuple3(l);
        input[1] = jacobian[1]->GetTuple3(l);

        if( cgTensor == LCSAttributes::Right ) 
          ComputeRightCauchyGreenTensor2D(input);
        else //if( cgTensor == LCSAttributes::Left )
          ComputeLeftCauchyGreenTensor2D(input);

        // Get the eigen values.
        double  eigenvals[2];
        Jacobi2D( input, eigenvals );

        double lambda = baseValue;

        if( eigenComponent == LCSAttributes::Largest )
          lambda = sqrt( std::max( lambda, eigenvals[0] ) );
        else // if( eigenComponent == LCSAttributes::Smallest )
          lambda = sqrt( std::max( lambda, eigenvals[1] ) );

        if( takeLog )
          lambda = log( lambda );

        lambda *= denominator;

        expArray->SetTuple1(l, lambda);
      }
    }
    else
    {
      for(size_t l = 0; l < nTuples; ++l)
      {
        double *input[3];
        input[0] = jacobian[0]->GetTuple3(l);
        input[1] = jacobian[1]->GetTuple3(l);
        input[2] = jacobian[2]->GetTuple3(l);

        if( cgTensor == LCSAttributes::Right ) 
          ComputeRightCauchyGreenTensor3D(input);
        else //if( cgTensor == LCSAttributes::Left ) 
          ComputeLeftCauchyGreenTensor3D(input);

        // Get the eigen values.
        double eigenvals[3];
        Jacobi3D( input, eigenvals );

        double lambda = baseValue;

        if( eigenComponent == LCSAttributes::Largest )
          lambda = sqrt( std::max( lambda, eigenvals[0] ) );
        else if( eigenComponent == LCSAttributes::Intermediate )
          lambda = sqrt( std::max( lambda, eigenvals[1] ) );
        else // if( eigenComponent == LCSAttributes::Smallest )
          lambda = sqrt( std::max( lambda, eigenvals[2] ) );

        if( takeLog )
          lambda = log( lambda );

        lambda *= denominator;

        expArray->SetTuple1(l, lambda);
      }
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateIterativeCalcDataTree
//
//  Purpose:
//      Create the output tree for the whole data set, using the 
//      input tree using the blocks native resolution.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

avtDataTree_p
avtLCSFilter::CreateIterativeCalcDataTree(avtDataTree_p inDT)
{
    if (*inDT == NULL)
        return 0;
    
    int nc = inDT->GetNChildren();
    
    if (nc < 0 && !inDT->HasData())
    {
        return 0;
    }

    if (nc == 0)
    {
        //variable name.
        std::string var = outVarRoot + outVarName;

        //
        // there is only one dataset to process
        //
        vtkDataSet *in_ds = inDT->GetDataRepresentation().GetDataVTK();

        //create new instance from old.
        vtkDataSet* out_ds = in_ds->NewInstance();
        out_ds->ShallowCopy(in_ds);
        int nTuples = in_ds->GetNumberOfPoints();

        // Create storage for the components that need to be used
        // for calculating the exponent. All arrays but the exponent
        // array will be deleted when done.
        vtkDoubleArray *exponents = vtkDoubleArray::New();
        exponents->SetName(var.c_str());
        exponents->SetNumberOfTuples(nTuples);
        out_ds->GetPointData()->AddArray(exponents);
        // Will set the exponents to be the active scalars when
        // finished. In the mean time the component is the working
        // active scalars.
//      out_ds->GetPointData()->SetActiveScalars(var.c_str());

        for (size_t i = 0; i < (size_t)nTuples; i++)
          exponents->SetTuple1(i, std::numeric_limits<double>::min() );

        vtkDoubleArray *component = vtkDoubleArray::New();
        component->SetName("component");
        component->SetNumberOfTuples(nTuples);
        out_ds->GetPointData()->AddArray(component);
        out_ds->GetPointData()->SetActiveScalars("component");
        
        vtkDoubleArray *times = vtkDoubleArray::New();
        times->SetName("times");
        times->SetNumberOfTuples(nTuples);
        out_ds->GetPointData()->AddArray(times);

        //cleanup
        exponents->Delete();
        component->Delete();
        times->Delete();
        
        int dom = inDT->GetDataRepresentation().GetDomain();
        std::string label = inDT->GetDataRepresentation().GetLabel();
        avtDataTree_p rv = new avtDataTree(out_ds, dom, label);
        out_ds->Delete();
        return rv;
    }
    else
    {
      //
      // there is more than one input dataset to process
      // and we need an output datatree for each
      //
      avtDataTree_p *outDT = new avtDataTree_p[nc];
      for (int j = 0; j < nc; j++)
      {
          if (inDT->ChildIsPresent(j))
            outDT[j] = CreateIterativeCalcDataTree(inDT->GetChild(j));
          else
            outDT[j] = NULL;
      }
      avtDataTree_p rv = new avtDataTree(nc, outDT);
      delete [] outDT;
      return rv;
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateIterativeCalcDataSet
//
//  Purpose:
//      Create the output tree for the whole data set, using the 
//      input tree using the blocks native resolution.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

vtkDataSet*
avtLCSFilter::CreateIterativeCalcDataSet()
{
  //rank 0
  //variable name.
  std::string var = outVarRoot + outVarName;

  //now create a rectilinear grid.
  size_t nTuples =
    global_resolution[0] * global_resolution[1] * global_resolution[2];

          
  // The grid is stored so not to be created as each curve is
  // extended.
  vtkRectilinearGrid* rect_grid = vtkRectilinearGrid::New();

  vtkDoubleArray* lxcoord = vtkDoubleArray::New();
  vtkDoubleArray* lycoord = vtkDoubleArray::New();
  vtkDoubleArray* lzcoord = vtkDoubleArray::New();

  rect_grid->SetDimensions(global_resolution);
      
  lxcoord->SetNumberOfTuples(global_resolution[0]);
  for (int i = 0; i < global_resolution[0]; i++)
  {
      double pcnt = 0;
      if (global_resolution[0] > 1)
        pcnt = ((double)i)/((double)global_resolution[0]-1);
      lxcoord->SetTuple1(i, global_bounds[0]*(1.0-pcnt) + global_bounds[1]*pcnt);
  }

  lycoord->SetNumberOfTuples(global_resolution[1]);
  for (int i = 0; i < global_resolution[1]; i++)
  {
      double pcnt = 0;
      if (global_resolution[1] > 1)
        pcnt = ((double)i)/((double)global_resolution[1]-1);
      lycoord->SetTuple1(i, global_bounds[2]*(1.0-pcnt) + global_bounds[3]*pcnt);
  }

  lzcoord->SetNumberOfTuples(global_resolution[2]);
  for (int i = 0; i < global_resolution[2]; i++)
  {
      double pcnt = 0;
      if (global_resolution[2] > 1)
        pcnt = ((double)i)/((double)global_resolution[2]-1);
      lzcoord->SetTuple1(i, global_bounds[4]*(1.0-pcnt) + global_bounds[5]*pcnt);
  }
      
  rect_grid->SetXCoordinates(lxcoord);
  rect_grid->SetYCoordinates(lycoord);
  rect_grid->SetZCoordinates(lzcoord);
        
  //cleanup
  lxcoord->Delete();
  lycoord->Delete();
  lzcoord->Delete();

  // Create storage for the components that need to be used
  // for calculating the exponent. All arrays but the exponent
  // array will be deleted when done.
  vtkDoubleArray *exponents = vtkDoubleArray::New();
  exponents->SetName(var.c_str());
  exponents->SetNumberOfTuples(nTuples);
  rect_grid->GetPointData()->AddArray(exponents);
  // Will set the exponents to be the active scalars when
  // finished. In the mean time the component is the working
  // active scalars.
  // rect_grid->GetPointData()->SetActiveScalars(var.c_str());

  for (size_t i = 0; i < nTuples; i++)
    exponents->SetTuple1(i, std::numeric_limits<double>::min() );

  vtkDoubleArray *component = vtkDoubleArray::New();
  component->SetName("component");
  component->SetNumberOfTuples(nTuples);
  rect_grid->GetPointData()->AddArray(component);
  rect_grid->GetPointData()->SetActiveScalars("component");

  vtkDoubleArray *times = vtkDoubleArray::New();
  times->SetName("times");
  times->SetNumberOfTuples(nTuples);
  rect_grid->GetPointData()->AddArray(times);

  //cleanup
  exponents->Delete();
  component->Delete();
  times->Delete();

  return rect_grid;
}
  

// ****************************************************************************
//  Method: avtLCSFilter::NativeMeshIterativeCalc
//
//  Purpose:
//      Computes the FSLE and similar values that are neighbor
//      dependent on a native resolution grid.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
//    Mark C. Miller, Wed Aug 22 19:22:40 PDT 2012
//    Fix leak of all_indices, index_counts, all_result, result_counts on 
//    rank 0 (root).
// ****************************************************************************

bool
avtLCSFilter::NativeMeshIterativeCalc(std::vector<avtIntegralCurve*> &ics)
{
    int offset = 0;

    if( *fsle_dt == NULL )
    {
      fsle_dt = CreateIterativeCalcDataTree(GetInputDataTree());
      
      if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
        if (PAR_Rank() != 0)
          fsle_dt = new avtDataTree();

      SetOutputDataTree(fsle_dt);
    }

    return MultiBlockIterativeCalc(fsle_dt, ics, offset);
}


// ****************************************************************************
//  Method: avtLCSFilter::MultiBlockIterativeCalc
//
//  Purpose:
//      Computes the FSLE and similar values that are neighbor
//      dependent for the whole data set, using the final particle
//      locations, at the blocks native resolution.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

bool
avtLCSFilter::MultiBlockIterativeCalc(avtDataTree_p inDT,
                                     std::vector<avtIntegralCurve*> &ics,
                                     int &offset)
{
    if (*inDT == NULL)
        return true;

    int nc = inDT->GetNChildren();

    if (nc < 0 && !inDT->HasData())
        return true;

    if (nc == 0)
    {
        //
        // there is only one dataset to process
        //
        vtkDataSet *in_ds = inDT->GetDataRepresentation().GetDataVTK();

        return SingleBlockIterativeCalc( in_ds, ics, offset );
    }
    else
    {
      bool haveAllExponents = true;

      //
      // there is more than one input dataset to process
      // and we need an input datatree for each
      //
      for (int j = 0; j < nc; j++)
      {
        if (inDT->ChildIsPresent(j) )
        {
          if( MultiBlockIterativeCalc( inDT->GetChild(j), ics, offset ) == false )
            haveAllExponents = false;
        }
      }

      return haveAllExponents;
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::SingleBlockIterativeCalc
//
//  Purpose:
//      Computes the FSLE and similar values that are neighbor
//      dependent for a single block of a data set, using the final
//      particle locations, at the blocks native resolution.
//
//  Arguments:
//      out_ds  The block to calculate the FSLE on
//      ics     The list of particles for all blocks on this MPI task.
//
//  Returns:    The new version of in_ds that includes the FSLE scalar
//              variable.  The calling function is responsible for
//              dereferencing this VTK object.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
//    Hank Childs, Tue Feb  5 08:12:33 PST 2013
//    Fix parallelization bug and memory leak.
//
// ****************************************************************************

bool
avtLCSFilter::SingleBlockIterativeCalc( vtkDataSet *in_ds,
                                        std::vector<avtIntegralCurve*> &ics,
                                        int &offset )
{
    int dims[3];

    if (in_ds->GetDataObjectType() == VTK_UNIFORM_GRID)
    {
      ((vtkUniformGrid*)in_ds)->GetDimensions(dims);
    }      
    else if (in_ds->GetDataObjectType() == VTK_RECTILINEAR_GRID)
    {
      ((vtkRectilinearGrid*)in_ds)->GetDimensions(dims);
    }      
    else if (in_ds->GetDataObjectType() == VTK_STRUCTURED_GRID)
    {
      ((vtkStructuredGrid*)in_ds)->GetDimensions(dims);
    }      
    else
    {
      EXCEPTION1(VisItException,
                 "Can only compute SingleBlockIterativeCalc on "
                 "imagedata, rectilinear grids, or structured grids. ");
    }

    // Variable name and number of points.
    std::string var = outVarRoot + outVarName;

    int nTuples = in_ds->GetNumberOfPoints();
    
    // Storage for the points and times
    std::vector<avtVector> remapPoints(nTuples);
    std::vector<double>    remapTimes(nTuples);

    // Zero out the points.
    for(size_t i = 0; i < remapPoints.size(); ++i)
    {
      remapPoints[i] = avtVector(0,0,0);
      remapTimes[i] = 0;
    }

    // ARS - This code does not nothing of use that I can see. The
    // remapPoints just need to be zeroed out.

    // if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
    // {
    //     // The parallel synchronization for when data is replicated involves
    //     // a sum across all processors.  So we want remapPoints to have the
    //     // location of the particle on one processor, and zero on the rest.
    //     // Do that here.
    //     // Special care is needed for the case where the particle never
    //     // advected.  Then we need to put the initial location on just one
    //     // processor.  We do this on rank 0.
    //     std::vector<int> iHavePoint(nTuples, 0);
    //     std::vector<int> anyoneHasPoint;

    //     for (size_t idx = 0; idx < ics.size(); idx++)
    //     {
    //         size_t index = ics[idx]->id;
    //         size_t l = (index-offset);
    //         if(l < remapPoints.size()) ///l >= 0 is always true
    //         {
    //             iHavePoint[l] = 1;
    //         }
    //     }

    //     UnifyMaximumValue(iHavePoint, anyoneHasPoint);
    //     avtVector zero;
    //     zero.x = zero.y = zero.z = 0.;
    //     for (size_t i = 0; i < (size_t)nTuples; i++)
    //     {
    //         if (PAR_Rank() == 0 && !anyoneHasPoint[i])
    //         {
    //             remapPoints[i] = seedPoints.at(offset + i);
    //             remapTimes[i] = 0;
    //         }
    //         else
    //         {
    //             remapPoints[i] = zero;
    //             remapTimes[i] = 0;
    //         }
    //     }
    // }
    // else
    // {
    //     //copy the original seed points
    //     for(size_t i = 0; i < remapPoints.size(); ++i)
    //     {
    //         remapPoints[i] = seedPoints.at(offset + i);
    //         remapTimes[i] = 0;
    //     }
    // }

    for(size_t i = 0; i < ics.size(); ++i)
    {
        avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];

        size_t index = ic->id;
        int l = (int)(index-offset);

        if(l >= 0 && l < (int)remapPoints.size())
        {
          remapPoints.at(l) = ic->GetEndPoint();

          if( doPathlines )
            remapTimes.at(l) = ic->GetTime() - seedTime0;
          else
            remapTimes.at(l) = ic->GetTime();
        }
    }

    // Get the stored data arrays
    vtkDataArray* jacobian[3];
    
    vtkDoubleArray *exponents = (vtkDoubleArray *)
      in_ds->GetPointData()->GetArray(var.c_str());
    vtkDoubleArray *component = (vtkDoubleArray *)
      in_ds->GetPointData()->GetArray("component");
    vtkDoubleArray *times = (vtkDoubleArray *)
      in_ds->GetPointData()->GetArray("times");

    //use static function in avtGradientExpression to calculate
    //gradients.  since this function only does scalar, break our
    //vectors into scalar components and calculate one at a time.

    // Note the mesh is uniform with all distances being one.
    for(int i = 0; i < 3; ++i)
    {
        for(size_t j = 0; j < (size_t)nTuples; ++j)
            component->SetTuple1(j, remapPoints[j][i]);

        if (GetInput()->GetInfo().GetAttributes().DataIsReplicatedOnAllProcessors())
        {
            float *newvals = new float[nTuples];
            float *origvals = (float *) component->GetVoidPointer(0);
            SumFloatArrayAcrossAllProcessors(origvals, newvals, nTuples);
            // copy newvals back into origvals
            memcpy(origvals, newvals, nTuples*sizeof(float));
            delete [] newvals;
        }

        jacobian[i] =
          avtGradientExpression::CalculateGradient(in_ds, var.c_str());
    }

    // Store the times for the exponent.
    for(size_t l = 0; l < (size_t)nTuples; ++l)
    {
      times->SetTuple1(l, remapTimes[l]);
    }

    for (int i = 0; i < nTuples; i++)
      component->SetTuple1(i, std::numeric_limits<double>::epsilon());

    //now have the jacobian - 3 arrays with 3 components.
    ComputeLyapunovExponent(jacobian, component);
    
    jacobian[0]->Delete();
    jacobian[1]->Delete();
    jacobian[2]->Delete();
    
    // Compute the FSLE
    ComputeFSLE( component, times, exponents );

    bool haveAllExponents = true;

    // For each integral curve check it's mask value to see it
    // additional integration is required.
    for(size_t i=0; i<ics.size(); ++i)
    {
      avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];

      size_t index = ic->id;
      size_t l = (index-offset);

      int ms = ic->GetMaxSteps();

      if( ms < (unsigned int)maxSteps )
      {
        ic->SetMaxSteps(ms+1);
        ic->status.ClearTerminationMet();
      }

      // Check to see if all exponents have been found.
      if( exponents->GetTuple1(l) == std::numeric_limits<double>::min() &&
          ic->GetMaxSteps() < (unsigned int)maxSteps )
        haveAllExponents = false;
    }
    
    //done with offset, increment it for the next call to this
    //function.
    offset += nTuples;

    return haveAllExponents;
}


// ****************************************************************************
//  Method: avtLCSFilter::RectilinearGridIterativeCalc
//
//  Purpose:
//      Computes the FSLE and similar values that are neighbor
//      dependent on a rectilinear grid.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//    Mark C. Miller, Wed Aug 22 19:22:40 PDT 2012
//    Fix leak of all_indices, index_counts, all_result, result_counts on 
//    rank 0 (root).
// ****************************************************************************

bool
avtLCSFilter::RectilinearGridIterativeCalc( std::vector<avtIntegralCurve*> &ics )
{
    //algorithm sends index to global datastructure as well as end points.
    //Send List of index into global array to rank 0
    //Send end positions into global array to rank 0

    //loop over all the intelgral curves and add it back to the
    //original list of seeds.
    intVector indices(ics.size());
    doubleVector points(ics.size()*3);
    doubleVector times(ics.size());

    for(size_t i=0, j=0; i<ics.size(); ++i, j+=3)
    {
        avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];

        indices[i] = ic->id;
        avtVector point = ic->GetEndPoint();

        points[j+0] = point[0];
        points[j+1] = point[1];
        points[j+2] = point[2];

        if( doPathlines )
          times[i] = ic->GetTime() - seedTime0;
        else
          times[i] = ic->GetTime();
    }

    int* all_indices = 0;
    int* index_counts = 0;

    double* all_points = 0;
    int *point_counts = 0;

    double* all_times = 0;
    int *time_counts = 0;

    Barrier();

    CollectIntArraysOnRootProc(all_indices, index_counts,
                               &indices.front(), (int)indices.size());

    CollectDoubleArraysOnRootProc(all_points, point_counts,
                                  &points.front(), (int)points.size());

    CollectDoubleArraysOnRootProc(all_times, time_counts,
                                  &times.front(), (int)times.size());

    Barrier();

    //root should now have index into global structure and all
    //matching end positions.
    if(PAR_Rank() != 0)
    {
        return true;
    }
    else
    {
        //variable name.
        std::string var = outVarRoot + outVarName;

        //now global grid has been created.
        if( fsle_ds == 0 )
          fsle_ds = CreateIterativeCalcDataSet();

        // Get the stored data arrays
        vtkDoubleArray *exponents = (vtkDoubleArray *)
          fsle_ds->GetPointData()->GetArray(var.c_str());
        vtkDoubleArray *component = (vtkDoubleArray *)
          fsle_ds->GetPointData()->GetArray("component");
        vtkDoubleArray *times = (vtkDoubleArray *)
          fsle_ds->GetPointData()->GetArray("times");

        size_t nTuples = exponents->GetNumberOfTuples();

        // Storage for the points and times
        std::vector<avtVector> remapPoints(nTuples);
        std::vector<double> remapTimes(nTuples);

        //update remapPoints with new value bounds from integral curves.
        int par_size = PAR_Size();
        size_t total = 0;
        for(int i = 0; i < par_size; ++i)
        {
            if(index_counts[i]*3 != point_counts[i] ||
               index_counts[i]   != time_counts[i])
            {
              EXCEPTION1(VisItException,
                         "Index count does not the result count." );
            }

            total += index_counts[i];
        }

        for(size_t j=0, k=0; j<total; ++j, k+=3)
        {
            size_t index = all_indices[j];

            if(nTuples <= index)
            {
              EXCEPTION1(VisItException,
                         "More integral curves were generatated than "
                         "grid points." );
            }

            remapPoints[index].set( all_points[k+0],
                                    all_points[k+1],
                                    all_points[k+2]);

            remapTimes[index] = all_times[j];
        }

        // Store the times for the exponent.
        for(size_t l=0; l<nTuples; ++l)
          times->SetTuple1(l, remapTimes[l]);

        //use static function in avtGradientExpression to calculate
        //gradients.  since this function only does scalar, break our
        //vectors into scalar components and calculate one at a time.

        vtkDataArray* jacobian[3];

        for(int i = 0; i < 3; ++i)
        {
            // Store the point component by component
            for(size_t l=0; l<nTuples; ++l)
                component->SetTuple1(l, remapPoints[l][i]);

            jacobian[i] =
              avtGradientExpression::CalculateGradient(fsle_ds, "component");
        }

        for (size_t i = 0; i < nTuples; i++)
          component->SetTuple1(i, std::numeric_limits<double>::epsilon());

        //now have the jacobian - 3 arrays with 3 components.
        ComputeLyapunovExponent(jacobian, component);
        
        jacobian[0]->Delete();
        jacobian[1]->Delete();
        jacobian[2]->Delete();
      
        // Compute the FSLE
        ComputeFSLE( component, times, exponents );

        bool haveAllExponents = true;

        // For each integral curve check it's mask value to see it
        // additional integration is required.

        for(size_t i=0; i<ics.size(); ++i)
        {
          avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];

          int ms = ic->GetMaxSteps();

          if( ms < (unsigned int)maxSteps )
          {
            ic->SetMaxSteps(ms+1);
            ic->status.ClearTerminationMet();
          }

          size_t l = ic->id; // The curve id is the index into the VTK data.

          // Check to see if all exponents have been found.
          if( exponents->GetTuple1(l) == std::numeric_limits<double>::min() &&
              ic->GetMaxSteps() < (unsigned int)maxSteps )
            haveAllExponents = false;
        }

        //cleanup.
        if (all_indices)   delete [] all_indices;
        if (index_counts)  delete [] index_counts;

        if (all_points)    delete [] all_points;
        if (point_counts)  delete [] point_counts;

        if (all_times)    delete [] all_times;
        if (time_counts)  delete [] time_counts;

        return haveAllExponents;
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::ComputeFSLE
//
//  Purpose:
//      Computes the FSLE given the distances.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

void avtLCSFilter::ComputeFSLE( vtkDataArray *component,
                                vtkDataArray *times,
                                vtkDataArray *exponents )
{
  size_t nTuples = component->GetNumberOfTuples();

  for(size_t l = 0; l < nTuples; ++l)
  {
    double lambda = exponents->GetTuple1(l);

    // If the exponent was previously set skip checking it.
    if( lambda == std::numeric_limits<double>::min() )
    {
      // Check for a curve that has terminated which will not have
      // taken a step forward or backwards.
      if( floor( fabs(times->GetTuple1(l)) / maxStepLength + 0.5) != numSteps )
      {
        // If a curve has terminated set the exponent to zero.
        lambda = 0;
        exponents->SetTuple1(l, lambda);
      }            

      // Check the distances between neighbors.
      else
      {
        double size = component->GetTuple1(l);

        minSizeValue = std::min(size, minSizeValue);
        maxSizeValue = std::max(size, maxSizeValue);

        // Record the Lyapunov exponent if the max
        // size has been reached.
        if( maxSize < size )
        {
          lambda = log( size ) / fabs(times->GetTuple1(l));
              
          exponents->SetTuple1(l, lambda);
        }
      }
    }
  }
}


// ****************************************************************************
//  Method: avtLCSFilter::InBounds
//
//  Purpose:
//      Returns true if indexes are in bounds.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

int avtLCSFilter::InBounds( int x, int y, int z,
                            int x_max, int y_max, int z_max )
{
  if( 0 <= x && x < x_max &&
      0 <= y && y < y_max &&
      0 <= z && z < z_max )
    return (z * y_max + y) * x_max + x;
  else
    return -1;
}


// ****************************************************************************
//  Method: avtLCSFilter::Increment
//
//  Purpose:
//      Increments a counter
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

void avtLCSFilter::Increment( int x, int y, int z, vtkDataArray *array,
                              int x_max, int y_max, int z_max )
{
  int l = InBounds( x, y, z, x_max, y_max, z_max );
  
  if( 0 <= l && l < array->GetNumberOfTuples() )
  {      
    int cc = array->GetTuple1(l);
    ++cc;
    array->SetTuple1(l, cc);
  }
}


// ****************************************************************************
//  Method: avtLCSFilter::Value
//
//  Purpose:
//      Returns the value for a coordinate
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

double avtLCSFilter::Value( int x, int y, int z, vtkDataArray *array,
                            int x_max, int y_max, int z_max )
{
  int l = InBounds( x, y, z, x_max, y_max, z_max );

  if( 0 <= l && l < array->GetNumberOfTuples() )
    return array->GetTuple1(l);
  else
    return 0;
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateNativeMeshIterativeCalcOutput
//
//  Purpose:
//      Computes the IterativeCalc output (via sub-routines) after the PICS filter
//      has calculated the particle positions.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

void 
avtLCSFilter::CreateNativeMeshIterativeCalcOutput(std::vector<avtIntegralCurve*> &ics)
{
    //accumulate all of the points then do jacobian?
    //or do jacobian then accumulate?
    //picking the first.

    int    offset = 0;
    double minv   =  std::numeric_limits<double>::max();
    double maxv   = -std::numeric_limits<double>::max();
    int    count  = 0;

    CreateMultiBlockIterativeCalcOutput(GetInputDataTree(), GetDataTree(),
                                        ics, offset, minv, maxv, count);

    int nTuples = (int)ics.size();

    if( 1 || count <= nTuples/10 )
    {
      if( minSizeValue == std::numeric_limits<double>::max() )
        minSizeValue = 0.0;
      
      if( maxSizeValue == -std::numeric_limits<double>::max() )
        maxSizeValue = 0.0;
      
      char str[1028];
      
      SNPRINTF(str, 1028, "\n%d%% of the nodes (%d of %d nodes) "
               "exaimed produced a valid exponent (%f to %f). "
               "This may be due to too large of a size limit (%f), "
               "too small of an integration step (%f), or "
               "too few integration steps (%d out of %d where taken), or "
               "simply due to the nature of the data. "
               "The size range was from %f to %f. ",
               (int) (100.0 * (double) count / (double) nTuples),
               count, nTuples,
               minv, maxv,
               maxSize, maxStepLength, numSteps, maxSteps,
               minSizeValue, maxSizeValue );
      
      avtCallback::IssueWarning(str);
    }

    avtDataAttributes &dataatts = GetOutput()->GetInfo().GetAttributes();
    avtExtents* e = dataatts.GetThisProcsActualDataExtents();

    double range[2];
    range[0] = minv;
    range[1] = maxv;
    e->Set(range);

    e = dataatts.GetThisProcsOriginalDataExtents();
    e->Set(range);

    e = dataatts.GetThisProcsActualSpatialExtents();
    e->Set(global_bounds);
    e = dataatts.GetThisProcsOriginalSpatialExtents();
    e->Set(global_bounds);
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateMultiBlockIterativeCalcOutput
//
//  Purpose:
//      Computes the finial FSLE and similar values that are neighbor
//      dependent for the whole data set, using the final particle
//      locations, at the blocks native resolution.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

void
avtLCSFilter::CreateMultiBlockIterativeCalcOutput( avtDataTree_p inDT,
                                                   avtDataTree_p outDT,
                                                   std::vector<avtIntegralCurve*> &ics,
                                                   int &offset,
                                                   double &minv, double &maxv,
                                                   int &count)
{
    if (*inDT == NULL || *outDT == NULL)
        return;

    int nc = inDT->GetNChildren();

    if (nc < 0 && !inDT->HasData())
        return;

    if (nc == 0)
    {
        //
        // there is only one dataset to process
        //
        vtkDataSet  *in_ds =  inDT->GetDataRepresentation().GetDataVTK();
        vtkDataSet *out_ds = outDT->GetDataRepresentation().GetDataVTK();

        int dom = inDT->GetDataRepresentation().GetDomain();
        std::string label = inDT->GetDataRepresentation().GetLabel();

        CreateSingleBlockIterativeCalcOutput(in_ds, out_ds, ics,
                                             offset, dom, minv, maxv, count);
    }
    else
    {
      //
      // there is more than one input dataset to process
      // and we need an output datatree for each
      //
      for (int j = 0; j < nc; j++)
      {
          if (inDT->ChildIsPresent(j))
            CreateMultiBlockIterativeCalcOutput(inDT->GetChild(j),
                                                outDT->GetChild(j),
                                                ics, offset, minv, maxv, count);
      }
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateSingleBlockIterativeCalcOutput
//
//  Purpose:
//      Computes the finial FSLE and similar values that are neighbor
//      dependent for a single block of a data set, using the final
//      particle locations, at the blocks native resolution.
//
//  Arguments:
//      in_ds   The block to calculate the value on
//      ics     The list of particles for all blocks on this MPI task.
//      domain  The domain number of in_ds
//      minv    The minimum value (output)
//      maxv    The maximum value (output)
//      count   The number of nodes with a valid exponent
//
//  Returns:    The new version of in_ds that includes the scalar
//              variable.  The calling function is responsible for
//              dereferencing this VTK object.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
//    Hank Childs, Tue Feb  5 08:12:33 PST 2013
//    Fix parallelization bug and memory leak.
//
// ****************************************************************************

void
avtLCSFilter::CreateSingleBlockIterativeCalcOutput( vtkDataSet *in_ds,
                                                    vtkDataSet *out_ds,
                                                    std::vector<avtIntegralCurve*> &ics,
                                                    int &offset, int domain,
                                                    double &minv, double &maxv,
                                                    int &count )
{
  //variable name.
  std::string var = outVarRoot + outVarName;

  vtkDoubleArray *exponents = (vtkDoubleArray *)
    out_ds->GetPointData()->GetArray(var.c_str());

  int nTuples = exponents->GetNumberOfTuples();

  for(size_t i=0; i<ics.size(); ++i)
  {
    avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];
    
    size_t index = ic->id;
    size_t l = (index-offset);

    double lambda = exponents->GetTuple1(l);
    
    if( lambda == -std::numeric_limits<double>::max() )
    {
      lambda = 0;
      exponents->SetTuple1(l, lambda );
    }
    else
    {
      ++count;
      ic->status.ClearTerminationMet();

      if( clampLogValues && lambda < 0 )
      {
        lambda = 0;
        exponents->SetTuple1(l, lambda );
      }
    }
    
    minv = std::min(lambda, minv);
    maxv = std::max(lambda, maxv);
    
  }

  // Make the exponents the the active scalars.
  out_ds->GetPointData()->SetActiveScalars(var.c_str());

  // Remove the working arrays.
  out_ds->GetPointData()->RemoveArray("component");
  out_ds->GetPointData()->RemoveArray("times");

  //done with offset, increment it for the next call to this
  //function.
  offset += nTuples;
  
  //Store this dataset in Cache for next time.
  std::string str = CreateCacheString();  
  StoreArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                          outVarName.c_str(), domain, -1,
                          str.c_str(), out_ds);
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateRectilinearGridIterativeCalcOutput
//
//  Purpose:
//      Computes the finial FSLE and similar values that are neighbor
//      dependent output (via sub-routines) after the PICS filter has
//      calculated the particle positions.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
// ****************************************************************************

void 
avtLCSFilter::CreateRectilinearGridIterativeCalcOutput(std::vector<avtIntegralCurve*> &ics)
{
    //root should now have index into global structure and all
    //matching end positions.
    if(PAR_Rank() != 0)
    {
        avtDataTree* dummy = new avtDataTree();
        SetOutputDataTree(dummy);
    }
    else
    {
      if (fsle_ds->GetDataObjectType() != VTK_RECTILINEAR_GRID)
      {
        EXCEPTION1(VisItException,
                   "Can only compute CreateRectilinearGridIterativeCalcOutput on "
                   "rectilinear grids. ");
      }

      //variable name.
      std::string var = outVarRoot + outVarName;

      vtkDoubleArray *exponents = (vtkDoubleArray *)
        fsle_ds->GetPointData()->GetArray(var.c_str());

      int nTuples = exponents->GetNumberOfTuples();

      //min and max values over all datasets of the tree.
      double minv =  std::numeric_limits<double>::max();
      double maxv = -std::numeric_limits<double>::max();
      
      int count = 0;

      for(size_t i=0; i<ics.size(); ++i)
      {
        avtStreamlineIC * ic = (avtStreamlineIC *) ics[i];

        size_t l = ic->id; // The curve id is the index into the VTK data.

        double lambda = exponents->GetTuple1(l);

        if( lambda == -std::numeric_limits<double>::max() )
        {
          lambda = 0;
          exponents->SetTuple1(l, lambda );
        }
        else
        {
          ++count;
          ic->status.ClearTerminationMet();

          if( clampLogValues && lambda < 0 )
          {
            lambda = 0;
            exponents->SetTuple1(l, lambda );
          }
        }

        minv = std::min(lambda, minv);
        maxv = std::max(lambda, maxv);
      }

      if( count <= nTuples/10 )
      {
        if( minSizeValue == std::numeric_limits<double>::max() )
          minSizeValue = 0.0;

        if( maxSizeValue == -std::numeric_limits<double>::max() )
          maxSizeValue = 0.0;

        char str[1028];

        SNPRINTF(str, 1028, "\n%d%% of the nodes (%d of %d nodes) "
                 "exaimed produced a valid exponent (%f to %f). "
                 "This may be due to too large of a size limit (%f), "
                 "too small of an integration step (%f), or "
                 "too few integration steps (%d out of %d where taken), or "
                 "simply due to the nature of the data. "
                 "The size range was from %f to %f. ",
                 (int) (100.0 * (double) count / (double) nTuples),
                 count, nTuples,
                 minv, maxv,
                 maxSize, maxStepLength, numSteps, maxSteps,
                 minSizeValue, maxSizeValue );

        avtCallback::IssueWarning(str);
      }
      
      // Make the exponents the the active scalars.
      fsle_ds->GetPointData()->SetActiveScalars(var.c_str());

      // Remove the working arrays.
      fsle_ds->GetPointData()->RemoveArray("component");
      fsle_ds->GetPointData()->RemoveArray("times");

      std::string str = CreateCacheString();
      StoreArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                              outVarName.c_str(), -1, -1,
                              str.c_str(), fsle_ds);
      
      int index = 0;//what does index mean in this context?
      avtDataTree* dt = new avtDataTree(fsle_ds,index);
      int x = 0;
      dt->GetAllLeaves(x);
      
      SetOutputDataTree(dt);
      
      //set atts.
      avtDataAttributes &dataatts = GetOutput()->GetInfo().GetAttributes();
      avtExtents* e = dataatts.GetThisProcsActualDataExtents();
      
      double range[2];
      range[0] = minv;
      range[1] = maxv;
      e->Set(range);
    }
}


// ****************************************************************************
//  Method: avtLCSFilter::ReportWarnings() 
//
//  Purpose:
//      Reports any potential integration warnings
//
//  Programmer: Allen Sanderson
//  Creation:   20 August 2013
//
//  Modifications:
//
// ****************************************************************************

void
avtLCSFilter::ReportWarnings(std::vector<avtIntegralCurve *> &ics)
{
    int numICs = (int)ics.size();

    int numSize = 0;
    int numTime = 0;
    int numDistance = 0;
    int numBoundary = 0;

    int numEarlyTerminators = 0;
    int numStiff = 0;
    int numCritPts = 0;

    if (DebugStream::Level5())
    {
        debug5 << "::ReportWarnings " << ics.size() << endl;
    }

    //See how many pts, ics we have so we can preallocate everything.
    for (int i = 0; i < numICs; i++)
    {
        if( doSize )
        {
            avtStreamlineIC *ic = dynamic_cast<avtStreamlineIC*>(ics[i]);

            if (ic->CurrentVelocity().length() <= criticalPointThreshold)
              numCritPts++;

            if (ic->TerminatedBecauseOfMaxSteps())
              numEarlyTerminators++;
            
            if (ic->EncounteredNumericalProblems())
              numStiff++;

            if(ic->status.EncounteredSpatialBoundary() ||
               ic->status.ExitedSpatialBoundary() )
              numBoundary++;

            // if (doSize && ic->GetTime() < maxSize);
            //   numSize++;         
        }
        else
        {
            avtLCSIC *ic = dynamic_cast<avtLCSIC*>(ics[i]);

            if (ic->CurrentVelocity().length() <= criticalPointThreshold)
              numCritPts++;

            if (ic->TerminatedBecauseOfMaxSteps())
              numEarlyTerminators++;
            
            if (ic->EncounteredNumericalProblems())
              numStiff++;

            if(ic->status.EncounteredSpatialBoundary() ||
               ic->status.ExitedSpatialBoundary() )
              numBoundary++;

            if (doTime && ic->GetTime() < maxTime)
              numTime++;

            if (doDistance && ic->GetDistance() < maxDistance)
              numDistance++;
        }
    }

    char str[4096] = "";

    if (issueWarningForAdvection)
    {
        SumIntAcrossAllProcessors(numSize);
        SumIntAcrossAllProcessors(numTime);
        SumIntAcrossAllProcessors(numDistance);

        if (numSize || numTime || numDistance )
        {
          SNPRINTF(str, 4096,
                   "%s\n%d of your integral curves terminated before they reached "
                   "the maximum advection criteria.  This may be indicative of your "
                   "time, distance, or size criteria being too large. If you want to disable "
                   "this message, you can do this under the Advaced tab."
                   "  Note that this message does not mean that an error has occurred; it simply "
                   "means that VisIt stopped advecting particles before they reached the maximum.\n",
                   str, numSize+numTime+numDistance);
        }
    }

    if ((doDistance || doTime || doSize) && issueWarningForBoundary)
    {
        SumIntAcrossAllProcessors(numBoundary);
        if (numBoundary > 0)
        {
            SNPRINTF(str, 4096, 
                     "%s\n%d of your integral curves exited the domain. This will all likelihood, "
                     "skew the results of any relative gradient based (Eigen value/vector) calculations."
                     "If you want to disable this message, you can do this under "
                     "the Advanced tab.\n", str, numBoundary);
        }
    }

    if ((doDistance || doTime || doSize) && issueWarningForMaxStepsTermination)
    {
        SumIntAcrossAllProcessors(numEarlyTerminators);
        if (numEarlyTerminators > 0)
        {
          SNPRINTF(str, 4096,
                   "%s\n%d of your integral curves terminated because they "
                   "reached the maximum number of steps.  This may be indicative of your "
                   "time or distance criteria being too large or of other attributes being "
                   "set incorrectly (example: your step size is too small).  If you are "
                   "confident in your settings and want the particles to advect farther, "
                   "you should increase the maximum number of steps.  If you want to disable "
                   "this message, you can do this under the Advaced tab."
                   "  Note that this message does not mean that an error has occurred; it simply "
                   "means that VisIt stopped advecting particles because it reached the maximum "
                   "number of steps. (That said, this case happens most often when other attributes "
                   "are set incorrectly.)\n", str, numEarlyTerminators);
        }
    }

    if (issueWarningForCriticalPoints)
    {
        SumIntAcrossAllProcessors(numCritPts);
        if (numCritPts > 0)
        {
            SNPRINTF(str, 4096, 
                     "%s\n%d of your integral curves circled round and round a critical point (a zero"
                     " velocity location).  Normally, VisIt is able to advect the particle "
                     "to the critical point location and terminate.  However, VisIt was not able "
                     "to do this for these particles due to numerical issues.  In all likelihood, "
                     "additional steps will _not_ help this problem and only cause execution to "
                     "take longer.  If you want to disable this message, you can do this under "
                     "the Advanced tab.\n", str, numCritPts);
        }
    }

    if (issueWarningForStiffness)
    {
        SumIntAcrossAllProcessors(numStiff);
        if (numStiff > 0)
        {
            SNPRINTF(str, 4096, 
                     "%s\n%d of your integral curves were unable to advect because of \"stiffness\".  "
                     "When one component of a velocity field varies quickly and another stays "
                     "relatively constant, then it is not possible to choose step sizes that "
                     "remain within tolerances.  This condition is referred to as stiffness and "
                     "VisIt stops advecting in this case.  If you want to disable this message, "
                     "you can do this under the Advanced tab.\n", str, numStiff);
        }
    }

    if( strlen( str ) )
      avtCallback::IssueWarning(str);
}


// ****************************************************************************
//  Method: avtLCSFilter::CreateCacheString
//
//  Purpose:
//      A routine that calculates a string for caching that encodes all the
//      parameters of the LCS: bounds, integration time, and variable name.
//
//  Programmer: Allen Sanderson
//  Creation:   September 5, 2013
//
//  Modifications:
//
// ****************************************************************************

std::string
avtLCSFilter::CreateCacheString(void)
{
  const int*    resolution = atts.GetResolution();
  const double* startPosition = atts.GetStartPosition();
  const double* endPosition = atts.GetEndPosition();
  const double* velocitySource = atts.GetVelocitySource();

  std::ostringstream os;

  // Note the string is a brute force string. That is all attributes
  // are munged together regarless of whether they are used. Overly
  // simple but most attributes can not be changed unless an option is
  // selected. As such, for the most part the brute force approach is
  // acceptable.
  os << cycleCached << "  "
     << timeCached << "  "
     << atts.GetSourceType() << " "
     << resolution[0] << " "
     << resolution[1] << " "
     << resolution[2] << " "
     << atts.GetUseDataSetStart() << " "
     << startPosition[0] << " "
     << startPosition[1] << " "
     << startPosition[2] << " "
     << atts.GetUseDataSetEnd() << " "
     << endPosition[0] << " "
     << endPosition[1] << " "
     << endPosition[2] << " "
     << atts.GetAuxiliaryGrid() << " "
     << atts.GetAuxiliaryGridSpacing() << " "
     << atts.GetIntegrationDirection() << " "
     << atts.GetMaxSteps() << " "
     << atts.GetCauchyGreenTensor() << " "
     << atts.GetOperationType() << " "
     << atts.GetEigenComponent() << " "
     << atts.GetOperatorType() << " "
     << atts.GetClampLogValues() << " "
     << atts.GetTerminationType() << " "
     << atts.GetTerminateBySize() << " "
     << atts.GetTermSize() << " "
     << atts.GetTerminateByDistance() << " "
     << atts.GetTermDistance() << " "
     << atts.GetTerminateByTime() << " "
     << atts.GetTermTime() << " "
     << atts.GetMaxStepLength() << " "
     << atts.GetLimitMaximumTimestep() << " "
     << atts.GetMaxTimeStep() << " "
     << atts.GetRelTol() << " "
     << atts.GetAbsTolSizeType() << " "
     << atts.GetAbsTolAbsolute() << " "
     << atts.GetAbsTolBBox() << " "
     << atts.GetFieldType() << " "
     << atts.GetFieldConstant() << " "
     << velocitySource[0] << " "
     << velocitySource[1] << " "
     << velocitySource[2] << " "
     << atts.GetIntegrationType() << " "
     << atts.GetParallelizationAlgorithmType() << " "
     << atts.GetMaxProcessCount() << " "
     << atts.GetMaxDomainCacheSize() << " "
     << atts.GetWorkGroupSize() << " "
     << atts.GetPathlines() << " "
     << atts.GetPathlinesOverrideStartingTimeFlag() << " "
     << atts.GetPathlinesOverrideStartingTime() << " "
     << atts.GetPathlinesCMFE() << " "
     << atts.GetForceNodeCenteredData() << " "
     << atts.GetIssueTerminationWarnings() << " "
     << atts.GetIssueStiffnessWarnings() << " "
     << atts.GetIssueCriticalPointsWarnings() << " "
     << atts.GetCriticalPointThreshold() << " ";

  return os.str();
}


// ****************************************************************************
//  Method: avtLCSFilter::GetCachedDataSet
//
//  Purpose:
//      Checks to see if we have already calculated the LCS.  Works for
//      both resampling and native options (realized through sub-routine calls).
//      This routine uses collective communication to decided whether
//      it can use a cached data set.
//      - For the native resolution, all domains on all MPI tasks must have
//      the LCS cached.
//      - For the resampled version, one MPI task somewhere must find it.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtDataTree_p
avtLCSFilter::GetCachedDataSet()
{
    avtDataTree_p rv = NULL;
    if (atts.GetSourceType() == LCSAttributes::NativeMesh)
    {
        rv = GetCachedNativeDataSet(GetInputDataTree());
        int looksOK = 1;
        if ((*rv == NULL) && (*(GetInputDataTree()) != NULL))
            looksOK = 0;
        looksOK = UnifyMinimumValue(looksOK); // if any fails, we all fail
        if (looksOK == 0)
            rv = NULL;
    }
    else //if (atts.GetSourceType() == LCSAttributes::RegularGrid)
    {
        rv = GetCachedResampledDataSet();
        int looksOK = (*rv == NULL ? 0 : 1);
        looksOK = UnifyMaximumValue(looksOK); // if one has it, we're all OK
        if (looksOK == 0)
            rv = NULL;
        else if ((looksOK == 1) && (*rv == NULL))
            rv = new avtDataTree();
    }
    return rv;
}

// ****************************************************************************
//  Method: avtLCSFilter::GetCachedNativeDataSet
//
//  Purpose:
//      Checks the cache to see if we have calculated the LCS on this
//      domain previously.  Checks to make sure parameters match: integration
//      time, etc.
//
//  Programmer: Hank Childs
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtDataTree_p
avtLCSFilter::GetCachedNativeDataSet(avtDataTree_p inDT)
{
    if (*inDT == NULL)
        return NULL;

    int nc = inDT->GetNChildren();

    if (nc < 0 && !inDT->HasData())
    {
        return NULL;
    }

    if (nc == 0)
    {
        //
        // there is only one dataset to process
        //
        int domain = inDT->GetDataRepresentation().GetDomain();
        std::string label = inDT->GetDataRepresentation().GetLabel();
        std::string str = CreateCacheString();
        vtkDataSet *rv = (vtkDataSet *)
          FetchArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                                  outVarName.c_str(), domain, -1, str.c_str());
        if (rv == NULL)
            return NULL;
        else
            return new avtDataTree(rv, domain, label);
    }

    //
    // there is more than one input dataset to process
    // and we need an output datatree for each
    //
    avtDataTree_p *outDT = new avtDataTree_p[nc];
    bool badOne = false;
    for (int j = 0; j < nc; j++)
    {
        if (inDT->ChildIsPresent(j))
        {
            outDT[j] = GetCachedNativeDataSet(inDT->GetChild(j));
            if (*(outDT[j]) == NULL)
                badOne = true;
        }
        else
        {
            outDT[j] = NULL;
        }
    }

    avtDataTree_p rv = NULL;

    if (!badOne) // if we don't have LCS for one domain, then just re-calc whole thing
        rv = new avtDataTree(nc, outDT);
    delete [] outDT;
    return rv;
}


// ****************************************************************************
//  Method: avtLCSFilter::GetCachedResampledDataSet
//
//  Purpose:
//      Checks the cache to see if we have calculated the LCS before.  It
//      also ensures that the parameters of previous calculations are the
//      same: integration time, bounds, variable, etc.
//
//  Programmer: Hari Krishnan
//  Creation:   December 5, 2011
//
// ****************************************************************************

avtDataTree_p
avtLCSFilter::GetCachedResampledDataSet()
{
    std::string str = CreateCacheString();
    vtkRectilinearGrid *rv = (vtkRectilinearGrid *)
      FetchArbitraryVTKObject(SPATIAL_DEPENDENCE | DATA_DEPENDENCE,
                              outVarName.c_str(), -1, -1, str.c_str());

    if(rv != NULL)
    {
        return new avtDataTree(rv, -1);
    }

    return NULL;
}



// ****************************************************************************
//  Method: avtLCSFilter::GetSeedPoints
//
//  Purpose:
//
//  Programmer: Allen Sanderson
//  Creation:   March 25, 2015
//
// ****************************************************************************

void
avtLCSFilter::GetSeedPoints( vtkDataSet *in_ds, bool getMax )
{
  bool getMin = !getMax;

  double cx = (global_bounds[0]+global_bounds[1]) / 2.0;
  double cy = (global_bounds[2]+global_bounds[3]) / 2.0;
  double cz = (global_bounds[4]+global_bounds[5]) / 2.0;

  double x = global_bounds[0];
  double y = global_bounds[2];
  double z = global_bounds[4];
  
  double dx = ( (global_bounds[1] - global_bounds[0]) /
                (double) (global_resolution[0]-1) );
  
  double dy = ( (global_bounds[3] - global_bounds[2]) /
                (double) (global_resolution[1]-1) );
  
  double dz = ( (global_bounds[5] - global_bounds[4]) /
                (double) (global_resolution[2]-1) );
  
  vtkImageData *image_ds = vtkImageData::New();

  image_ds->SetDimensions(global_resolution);
  image_ds->SetOrigin(x,y,z);
  image_ds->SetSpacing(dx,dy,dz);
  image_ds->ShallowCopy( in_ds );

  // Extract a slice in the desired orientation
  static double axialElements[16] = { 1, 0, 0, 0,
                                      0, 1, 0, 0,
                                      0, 0, 1, 0,
                                      0, 0, 0, 1 };
  
  // Set the slice orientation
  vtkMatrix4x4 *resliceAxes = vtkMatrix4x4::New();
  resliceAxes->DeepCopy(axialElements);
  
  // Set the point through which to slice
  resliceAxes->SetElement(0, 3, cx);
  resliceAxes->SetElement(1, 3, cy);
  resliceAxes->SetElement(2, 3, cz);
  
  vtkImageReslice *reslice = vtkImageReslice::New();
  reslice->SetInputData( image_ds );
  reslice->SetOutputDimensionality(2);
  reslice->SetResliceAxes(resliceAxes);
  reslice->SetInterpolationModeToCubic();
  reslice->Update();

//          vtkImageGaussianSmooth *smooth = vtkImageGaussianSmooth::New();
//          smooth->SetInputData( reslice->GetOutput() );
//          smooth->SetDimensionality(2);
//          smooth->SetStandardDeviation(1, 1, 0);
// //       smooth->SetStandardDeviation(dx, dy, dz);
//          smooth->SetRadiusFactors(2.5, 2.5, 0);
//          smooth->Update();

  vtkImageData *slice_ds = vtkImageData::New();
  slice_ds->ShallowCopy(reslice->GetOutput());

  resliceAxes->Delete();
  reslice->Delete();
//  smooth->Delete();

  int dims[3];
  slice_ds->SetOrigin(x,y,cz);
  slice_ds->GetDimensions(dims);
  slice_ds->GetOrigin(x,y,z);
  slice_ds->GetSpacing(dx,dy,dz);
  
  vtkDoubleArray *tmpArray =
    (vtkDoubleArray *) slice_ds->GetPointData()->GetScalars();

  int nTuples = tmpArray->GetNumberOfTuples();

  // Get te FTLE minimal and maximal values.
  double ftle;
  double minFTLE =  std::numeric_limits<double>::max();
  double maxFTLE = -std::numeric_limits<double>::max();

  double edgeBoundary = 0.15;
  
  for(size_t l = 0; l < nTuples; ++l)
  {
    ftle = tmpArray->GetTuple1( l );
    
    if( maxFTLE < ftle || ftle < minFTLE )
    {
      double *gridPt = slice_ds->GetPoint( l );
      
      bool inBounds = true;
      
      // Discard points near the boundaries
      for (int i=0, j=0; i<nDim; ++i, j+=2)
      {
        double t = ((gridPt[i]          - global_bounds[j]) /
                    (global_bounds[j+1] - global_bounds[j]));
        
        if( t < edgeBoundary || 1.0-edgeBoundary < t )
        {
          inBounds = false;
          break;
        }
      }
      
      if( inBounds )
      {
        if( maxFTLE < ftle )
          maxFTLE = ftle;
        else
          minFTLE = ftle;
      }
    }
  }
  
  double threshold;

  if( getMax )
    threshold = maxFTLE - (maxFTLE-minFTLE) * 0.1;
  else //if( getMin )
    threshold = minFTLE + (maxFTLE-minFTLE) * 0.01;

  std::vector< std::pair< avtVector, double > > ptList;

  for(size_t l = 0; l < nTuples; ++l)
  {
    ftle = tmpArray->GetTuple1( l );

    if( (getMin && ftle < threshold) || (getMax && threshold < ftle) )          
    {
      double *gridPt = slice_ds->GetPoint( l );
      
      bool inBounds = true;
      
      // Discard points near the boundaries
      for (int i=0, j=0; i<nDim; ++i, j+=2)
      {
        double t = ((gridPt[i]          - global_bounds[j]) /
                    (global_bounds[j+1] - global_bounds[j]));
        
        if( t < edgeBoundary || 1.0-edgeBoundary < t )
        {
          inBounds = false;
          break;
        }
      }
      
      if( inBounds )
      {
        ptList.push_back( std::pair< avtVector,
                             double >( avtVector( gridPt[0],
                                                  gridPt[1],
                                                  gridPt[2] ),
                                       ftle ) );
      }
    }
  }
  
  // Sort the points either descending or ascending.
  if( getMax )
    std::sort( ptList.begin(), ptList.end(),
               sort_pair_max_second< avtVector, double >() ); 
  else //if( getMin )
    std::sort( ptList.begin(), ptList.end(),
               sort_pair_min_second< avtVector, double >() ); 

  std::vector< std::pair< avtVector, double > >::iterator iter =
    ptList.begin();

  double radius = 5.0;
  double distance = radius * sqrt(dx*dx+dy*dy);

  // Start the first point and remove all those that are too close.
  while( iter != ptList.end() )
  {
    std::vector< std::pair< avtVector, double > >::iterator iter2 =
      ptList.end();
    
    --iter2;

    while( iter2 != iter )
    {
      if( avtVector( (*iter).first[0] - (*iter2).first[0],
                     (*iter).first[1] - (*iter2).first[1],
                     (*iter).first[2] - (*iter2).first[2] ).length() <
          distance )
      {
        ptList.erase( iter2 );
      }
      
      --iter2;
    }
    
    ++iter;
  }
  
  if( getMax )
    std::cerr << "Have " << ptList.size() << " max seed points "<< std::endl;
  else
    std::cerr << "Have " << ptList.size() << " min seed points "<< std::endl;
  
  if( ptList.size() > 10 ) ptList.resize(10);

  vtkDoubleArray *seedPts = vtkDoubleArray::New();
  
  if( getMax )
    seedPts->SetName("Seed Points - Maximal");
  else
    seedPts->SetName("Seed Points - Minimal");

  // Set the number of components before setting the number of tuples
  // for proper memory allocation.
  seedPts->SetNumberOfComponents( 3 );
  seedPts->SetNumberOfTuples( ptList.size() );

  in_ds->GetFieldData()->AddArray(seedPts);

  for (int i = 0; i < ptList.size(); ++i)
  {
    std::cerr << ptList[i].second << "     "
              << ptList[i].first.x << "  "
              << ptList[i].first.y << "  "
              << ptList[i].first.z << "  "
              << std::endl;
    
    seedPts->SetTuple3(i,
                       ptList[i].first.x,
                       ptList[i].first.y,
                       ptList[i].first.z );
  }
  
  seedPts->Delete();

  slice_ds->Delete();
  image_ds->Delete();
}

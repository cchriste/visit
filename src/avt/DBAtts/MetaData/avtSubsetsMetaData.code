Function: Print
Declaration: void Print(ostream &, int = 0) const;
Definition:
// ****************************************************************************
//  Method: avtSubsetsMetaData::Print
//
//  Purpose: Print out subset meta-data object information.
//
//  Programmer: Mark C. Miller
//  Creation:   August 18, 2009
// ****************************************************************************

inline void
Indent(ostream &out, int indent)
{
    for (int i = 0 ; i < indent ; i++)
    {
        out << "\t";
    }
}
void
avtSubsetsMetaData::Print(ostream &out, int indent) const
{
    size_t i;

    avtVarMetaData::Print(out, indent);

    Indent(out, indent);
    out << "catName =\"" << catName << "\"" << endl;

    Indent(out, indent);
    out << "catCount = " << catCount << endl;

    Indent(out, indent);
    out << "isChunkCat = " << isChunkCat << endl;

    Indent(out, indent);
    out << "isMaterialCat = " << isMaterialCat << endl;

    Indent(out, indent);
    out << "isUnionOfChunks = " << isUnionOfChunks << endl;

    Indent(out, indent);
    out << "hasPartialCells = " << hasPartialCells << endl;

    Indent(out, indent);
    out << "decompMode = " << DecompMode_ToString(decompMode) << endl;

    Indent(out, indent);
    out << "maxTopoDim = " << maxTopoDim << endl;

    if (nameScheme.size() == 1)
    {
        Indent(out, indent);
        out << "nameScheme = \"" << nameScheme[0] << "\"" << endl;
    }
    else
    {
        Indent(out, indent);
        out << "nameScheme = ..." << endl;
        for (i = 0; i < 50 && i < catCount; i++)
        {
            Indent(out, indent+1);
            out << "set[" << i << "] has name \"" << nameScheme[i] << "\"";
            if (i < colorScheme.size())
                out << " and color \"" << colorScheme[i] << "\"";
            out << endl;
        }
        if (catCount >= 50)
        {
            if (catCount > 51)
            {
                Indent(out, indent+1); 
                out << "." << endl;
            }
            if (catCount > 52)
            {
                Indent(out, indent+1); 
                out << "." << endl;
            }
            if (catCount > 53)
            {
                Indent(out, indent+1); 
                out << "." << endl;
            }
            for (i = catCount-50; i < catCount; i++)
            {
                Indent(out, indent+1);
                out << "set[" << i << "] has name \"" << nameScheme[i] << "\"";
                if (i < colorScheme.size())
                    out << " and color \"" << colorScheme[i] << "\"";
                out << endl;
            }
        } 
    }

    if (setsToChunksMaps.size())
    {
        i = 0;
        while (i < setsToChunksMaps.size())
        {
            Indent(out, indent);
            out << "set[" << setsToChunksMaps[i++] << "] exists on chunks..." << endl;
            int n = setsToChunksMaps[i++];
            Indent(out, indent+1);
            for (int j = 0; j < n; j++, i++)
            {
                if (j == 0)
                    out << setsToChunksMaps[i];
                else
                    out << ", " << setsToChunksMaps[i];
                if (j == n-1)
                    out << endl;
            }
        }
    }

    if (graphEdges.size())
    {
        Indent(out, indent);
        out << "graphEdges..." << endl;
        for (i = 0; i < 100 && i < graphEdges.size(); i += 2)
        {
            Indent(out, indent+1);
            out << "set[" << graphEdges[2*i  ] << "] is parent of "
                   "set[" << graphEdges[2*i+1] << "]" << endl;
        }
        if (graphEdges.size() > 100)
        {
            if (graphEdges.size() > 102)
            {
               Indent(out, indent+1); 
               out << "." << endl;
            }
            if (graphEdges.size() > 104)
            {
               Indent(out, indent+1); 
               out << "." << endl;
            }
            if (graphEdges.size() > 106)
            {
               Indent(out, indent+1); 
               out << "." << endl;
            }
            for (i = graphEdges.size() - 100; i < graphEdges.size(); i += 2)
            {
                Indent(out, indent+1);
                out << "set[" << graphEdges[2*i  ] << "] is parent of "
                       "set[" << graphEdges[2*i+1] << "]" << endl;
            }
        }
    }
}

Function: AddGraphEdge
Declaration: void AddGraphEdge(int head, int tail);
Definition:
// ****************************************************************************
//  Method: avtSubsetsMetaData::AddGraphEdge
//
//  Purpose: Add an edge to the subset inclusion graph indicating that the
//  set identified at the 'tail' is the child of (e.g. contained in) the set
//  identified at the head.
//
//  Programmer: Mark C. Miller
//  Creation:   August 18, 2009
// ****************************************************************************

void
avtSubsetsMetaData::AddGraphEdge(int head, int tail)
{
    graphEdges.push_back(head);
    graphEdges.push_back(tail);
}

Function: SetChunksForSet
Declaration: void SetChunksForSet(int setId, std::vector<int> &chunks);
Definition:
// ****************************************************************************
//  Method: avtSubsetsMetaData::SetChunksForSet
//
//  Purpose: Indicate which chunks a given set exists on.
//
//  Programmer: Mark C. Miller
//  Creation:   August 18, 2009
// ****************************************************************************

void avtSubsetsMetaData::SetChunksForSet(int setId, std::vector<int> &chunks)
{
    SetChunksForSet(setId, &chunks[0], (int) chunks.size());
}

Function: avtSubsetsMetaData1
Declaration: avtSubsetsMetaData(const char *catName, int catCount, int maxTopoDim);
Definition:
// ****************************************************************************
//  Method: avtSubsetsMetaData constructor
//
//  Purpose: convenient constructor
//
//  Programmer: Mark C. Miller
//  Creation:   August 18, 2009
// ****************************************************************************
avtSubsetsMetaData::avtSubsetsMetaData(const char *catName, int catCount, int maxTopoDim)
    : avtVarMetaData(avtSubsetsMetaData::TmfsStruct)
{
    avtSubsetsMetaData::Init();
    this->catName = catName;
    this->catCount = catCount;
    this->maxTopoDim = maxTopoDim;
}

Function: AddArrayForNameScheme
Declaration: void AddArrayForNameScheme(const char *name, const int *data, int len);
Definition:
// ****************************************************************************
//  Method: avtSubsetsMetaData::AddArrayForNameScheme
//
//  Purpose: Add integer array data to be used in name scheme
//
//  Programmer: Mark C. Miller
//  Creation:   August 18, 2009
// ****************************************************************************
void
avtSubsetsMetaData::AddArrayForNameScheme(const char *name, const int *data, int len)
{
    nameSchemeArrayNames.push_back(name);
    nameSchemeArrayOffsets.push_back(nameSchemeArrayData.size());
    for (int i = 0; i < len; i++)
        nameSchemeArrayData.push_back(data[i]);
}

Function: AddArrayForNameScheme2
Declaration: void AddArrayForNameScheme(const std::string name, const std::vector<int> &data);
Definition:
// ****************************************************************************
//  Method: avtSubsetsMetaData::AddArrayForNameScheme
//
//  Purpose: Add integer array data to be used in name scheme
//
//  Programmer: Mark C. Miller
//  Creation:   August 18, 2009
// ****************************************************************************
void
avtSubsetsMetaData::AddArrayForNameScheme(const std::string name, const std::vector<int> &data)
{
    AddArrayForNameScheme(name.c_str(), &data[0], (int) data.size());
}

Function: GetNameSchemeArray
Declaration: const int *GetNameSchemeArray(int i);
Definition:
// ****************************************************************************
//  Method: avtSubsetsMetaData::AddArrayForNameScheme
//
//  Purpose: Add integer array data to be used in name scheme
//
//  Programmer: Mark C. Miller
//  Creation:   August 18, 2009
// ****************************************************************************
const int*
avtSubsetsMetaData::GetNameSchemeArray(int i)
{
    if (i < 0 || i > nameSchemeArrayOffsets.size())
        return 0;
    return &nameSchemeArrayData[nameSchemeArrayOffsets[i]];
}

Function: GetNameSchemeArray2
Declaration: const int *GetNameSchemeArray(const char *);
Definition:
// ****************************************************************************
//  Method: avtSubsetsMetaData::AddArrayForNameScheme
//
//  Purpose: Add integer array data to be used in name scheme
//
//  Programmer: Mark C. Miller
//  Creation:   August 18, 2009
// ****************************************************************************
const int*
avtSubsetsMetaData::GetNameSchemeArray(const char *name)
{
    std::vector<std::string>::iterator it =
        find(nameSchemeArrayNames.begin(), nameSchemeArrayNames.end(), name);
    if (it == nameSchemeArrayNames.end())
        return 0;

    return GetNameSchemeArray((int) distance(nameSchemeArrayNames.begin(),it));
}

Function: avtSubsetsMetaData2
Declaration: avtSubsetsMetaData(const std::string &catName, int catCount, int maxTopoDim);
Definition:
// ****************************************************************************
//  Method: avtSubsetsMetaData constructor
//
//  Purpose: convenient constructor
//
//  Programmer: Mark C. Miller
//  Creation:   August 18, 2009
// ****************************************************************************
avtSubsetsMetaData::avtSubsetsMetaData(const std::string &catName, int catCount, int maxTopoDim)
    : avtVarMetaData(avtSubsetsMetaData::TmfsStruct)
{
    *this = avtSubsetsMetaData(catName.c_str(), catCount, maxTopoDim);
}

Function: SetChunksForSet2
Declaration: void SetChunksForSet(int setId, const int *chunks, int len);
Definition:
// ****************************************************************************
//  Method: avtSubsetsMetaData::SetChunksForSet
//
//  Purpose: Indicate which chunks a given set exists on.
//
//  Programmer: Mark C. Miller
//  Creation:   August 18, 2009
// ****************************************************************************

void avtSubsetsMetaData::SetChunksForSet(int setId, const int *chunks, int len)
{
    setsToChunksMaps.push_back(setId);
    setsToChunksMaps.push_back(len);
    for (int i = 0; i < len; i++)
        setsToChunksMaps.push_back(chunks[i]);
}

Function: GetNameForSet
Declaration: const char *GetNameForSet(int setId);
Definition:
typedef struct _DBnamescheme
{
    char *fmt;              /* orig. format string */
    const char **fmtptrs;   /* ptrs into first (printf) part of fmt for each conversion spec. */
    int fmtlen;             /* len of first part of fmt */
    int ncspecs;            /* # of conversion specs in first part of fmt */
    char delim;             /* delimiter char used for parts of fmt */
    int nembed;             /* number of last embedded string encountered */
    char *embedstrs[DB_MAX_EXPSTRS]; /* ptrs to copies of embedded strings */
    int narrefs;            /* number of array refs in conversion specs */
    char **arrnames;        /* array names used by array refs */
    const int **arrvals;    /* pointer to actual array data assoc. with each name */
    char **exprstrs;        /* expressions to be evaluated for each conv. spec. */
} DBnamescheme;

// ****************************************************************************
//  Method: avtSubsetsMetaData::GetNameForSet
//
//  Purpose: Return name for a set. If the namescheme is explicit, this
//      function just looks up the name. Otherwise, it uses the nameschem
//      to generate the the name.
//
//  Programmer: Mark C. Miller
//  Creation:   August 18, 2009
// ****************************************************************************

Function: SetNameScheme
Declaration: SetNameScheme(const char **ns_or_names, int cnt=1);
Definition:
// ****************************************************************************
//  Method: avtSubsetsMetaData::SetNameScheme
//
//  Purpose: Sets the namescheme (printf style) used to name sets in this
//      category. The ns_or_names argument can be an explicit list of names
//      which is VERY EXPENSIVE to store, or a single 'namescheme'.
//
//  Programmer: Mark C. Miller
//  Creation:   August 18, 2009
// ****************************************************************************
void avtSubsetsMetaData::SetNameScheme(const char **ns_or_names, cnt)
{
    if (cnt == 1)
    {
        nameScheme.push_back(ns_or_names[0]);
        DBMakeNamescheme(ns_or_names[0]);
    }
    else
    {
        for (int i = 0; i < cnt; i++)
            nameScheme.push_back(ns_or_names[i]);
    }
}

Function: avtSubsetsMetaData
Declaration: avtSubsetsMetaData();
Definition:
avtSubsetsMetaData::avtSubsetsMetaData() : avtVarMetaData(avtSubsetsMetaData::TmfsStruct)
{
    avtSubsetsMetaData::Init();
}


/*****************************************************************************
*
* Copyright (c) 2000 - 2008, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-400142
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

#include <avtSILMetaData.h>
#include <DataNode.h>
#include <ImproperUseException.h>
#include <BadIndexException.h>
#include <avtSILCollectionMetaData.h>

// Type map format string
const char *avtSILMetaData::TypeMapFormatString = "sa*i*i*i";

// ****************************************************************************
// Method: avtSILMetaData::avtSILMetaData
//
// Purpose: 
//   Constructor for the avtSILMetaData class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:18 PST 2007
//
// Modifications:
//   
// ****************************************************************************

avtSILMetaData::avtSILMetaData() : 
    AttributeSubject(avtSILMetaData::TypeMapFormatString)
{
    meshName = "mesh";
    // create pre-defined collection classes (currently just "whole")
    int wholeCollectionClassId = collections.size();
    avtSILCollectionMetaData wholeCollectionClass("whole", meshName, 1, -1, -1, -1, NULL);
    AddCollections(wholeCollectionClass);
    classIds.push_back(wholeCollectionClassId);
    classDisjointFlags.push_back(1);
    // initially, we don't know the storage chunk class id
    theStorageChunkClassId = -1;
}

// ****************************************************************************
// Method: avtSILMetaData::avtSILMetaData
//
// Purpose: 
//   Copy constructor for the avtSILMetaData class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:18 PST 2007
//
// Modifications:
//   
// ****************************************************************************

avtSILMetaData::avtSILMetaData(const avtSILMetaData &obj) : 
    AttributeSubject(avtSILMetaData::TypeMapFormatString)
{
    AttributeGroupVector::const_iterator pos;

    meshName = obj.meshName;
    // *** Copy the collections field ***
    // Delete the AttributeGroup objects and clear the vector.
    for(pos = collections.begin(); pos != collections.end(); ++pos)
        delete *pos;
    collections.clear();
    if(obj.collections.size() > 0)
        collections.reserve(obj.collections.size());
    // Duplicate the collections from obj.
    for(pos = obj.collections.begin(); pos != obj.collections.end(); ++pos)
    {
        avtSILCollectionMetaData *oldavtSILCollectionMetaData = (avtSILCollectionMetaData *)(*pos);
        avtSILCollectionMetaData *newavtSILCollectionMetaData = new avtSILCollectionMetaData(*oldavtSILCollectionMetaData);
        collections.push_back(newavtSILCollectionMetaData);
    }

    classIds = obj.classIds;
    classDisjointFlags = obj.classDisjointFlags;
    theStorageChunkClassId = obj.theStorageChunkClassId;

    SelectAll();
}

// ****************************************************************************
// Method: avtSILMetaData::~avtSILMetaData
//
// Purpose: 
//   Destructor for the avtSILMetaData class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:18 PST 2007
//
// Modifications:
//   
// ****************************************************************************

avtSILMetaData::~avtSILMetaData()
{
    AttributeGroupVector::iterator pos;

    // Destroy the collections field.
    for(pos = collections.begin(); pos != collections.end(); ++pos)
        delete *pos;
}

// ****************************************************************************
// Method: avtSILMetaData::operator = 
//
// Purpose: 
//   Assignment operator for the avtSILMetaData class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:18 PST 2007
//
// Modifications:
//   
// ****************************************************************************

avtSILMetaData& 
avtSILMetaData::operator = (const avtSILMetaData &obj)
{
    if (this == &obj) return *this;
    AttributeGroupVector::const_iterator pos;

    meshName = obj.meshName;
    // *** Copy the collections field ***
    // Delete the AttributeGroup objects and clear the vector.
    for(pos = collections.begin(); pos != collections.end(); ++pos)
        delete *pos;
    collections.clear();
    if(obj.collections.size() > 0)
        collections.reserve(obj.collections.size());
    // Duplicate the collections from obj.
    for(pos = obj.collections.begin(); pos != obj.collections.end(); ++pos)
    {
        avtSILCollectionMetaData *oldavtSILCollectionMetaData = (avtSILCollectionMetaData *)(*pos);
        avtSILCollectionMetaData *newavtSILCollectionMetaData = new avtSILCollectionMetaData(*oldavtSILCollectionMetaData);
        collections.push_back(newavtSILCollectionMetaData);
    }

    classIds = obj.classIds;
    classDisjointFlags = obj.classDisjointFlags;
    theStorageChunkClassId = obj.theStorageChunkClassId;

    SelectAll();
    return *this;
}

// ****************************************************************************
// Method: avtSILMetaData::operator == 
//
// Purpose: 
//   Comparison operator == for the avtSILMetaData class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:18 PST 2007
//
// Modifications:
//   
// ****************************************************************************

bool
avtSILMetaData::operator == (const avtSILMetaData &obj) const
{
    int i;

    bool collections_equal = (obj.collections.size() == collections.size());
    for(i = 0; (i < collections.size()) && collections_equal; ++i)
    {
        // Make references to avtSILCollectionMetaData from AttributeGroup *.
        const avtSILCollectionMetaData &collections1 = *((const avtSILCollectionMetaData *)(collections[i]));
        const avtSILCollectionMetaData &collections2 = *((const avtSILCollectionMetaData *)(obj.collections[i]));
        collections_equal = (collections1 == collections2);
    }

    // Create the return value
    return ((meshName == obj.meshName) &&
            collections_equal &&
            (classIds == obj.classIds) &&
            (classDisjointFlags == obj.classDisjointFlags) &&
            (theStorageChunkClassId == obj.theStorageChunkClassId));
}

// ****************************************************************************
// Method: avtSILMetaData::operator != 
//
// Purpose: 
//   Comparison operator != for the avtSILMetaData class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:18 PST 2007
//
// Modifications:
//   
// ****************************************************************************

bool
avtSILMetaData::operator != (const avtSILMetaData &obj) const
{
    return !(this->operator == (obj));
}

// ****************************************************************************
// Method: avtSILMetaData::TypeName
//
// Purpose: 
//   Type name method for the avtSILMetaData class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:18 PST 2007
//
// Modifications:
//   
// ****************************************************************************

const std::string
avtSILMetaData::TypeName() const
{
    return "avtSILMetaData";
}

// ****************************************************************************
// Method: avtSILMetaData::CopyAttributes
//
// Purpose: 
//   CopyAttributes method for the avtSILMetaData class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:18 PST 2007
//
// Modifications:
//   
// ****************************************************************************

bool
avtSILMetaData::CopyAttributes(const AttributeGroup *atts)
{
    if(TypeName() != atts->TypeName())
        return false;

    // Call assignment operator.
    const avtSILMetaData *tmp = (const avtSILMetaData *)atts;
    *this = *tmp;

    return true;
}

// ****************************************************************************
// Method: avtSILMetaData::CreateCompatible
//
// Purpose: 
//   CreateCompatible method for the avtSILMetaData class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:18 PST 2007
//
// Modifications:
//   
// ****************************************************************************

AttributeSubject *
avtSILMetaData::CreateCompatible(const std::string &tname) const
{
    AttributeSubject *retval = 0;
    if(TypeName() == tname)
        retval = new avtSILMetaData(*this);
    // Other cases could go here too. 

    return retval;
}

// ****************************************************************************
// Method: avtSILMetaData::NewInstance
//
// Purpose: 
//   NewInstance method for the avtSILMetaData class.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:18 PST 2007
//
// Modifications:
//   
// ****************************************************************************

AttributeSubject *
avtSILMetaData::NewInstance(bool copy) const
{
    AttributeSubject *retval = 0;
    if(copy)
        retval = new avtSILMetaData(*this);
    else
        retval = new avtSILMetaData;

    return retval;
}

// ****************************************************************************
// Method: avtSILMetaData::SelectAll
//
// Purpose: 
//   Selects all attributes.
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:18 PST 2007
//
// Modifications:
//   
// ****************************************************************************

void
avtSILMetaData::SelectAll()
{
    Select(0, (void *)&meshName);
    Select(1, (void *)&collections);
    Select(2, (void *)&classIds);
    Select(3, (void *)&classDisjointFlags);
    Select(4, (void *)&theStorageChunkClassId);
}

// ****************************************************************************
// Method: avtSILMetaData::CreateSubAttributeGroup
//
// Purpose: 
//   Contains SIL metadata attributes
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:18 PST 2007
//
// Modifications:
//   
// ****************************************************************************

AttributeGroup *
avtSILMetaData::CreateSubAttributeGroup(int)
{
    return new avtSILCollectionMetaData;
}

///////////////////////////////////////////////////////////////////////////////
// Set property methods
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Get property methods
///////////////////////////////////////////////////////////////////////////////

const AttributeGroupVector &
avtSILMetaData::GetCollections() const
{
    return collections;
}

AttributeGroupVector &
avtSILMetaData::GetCollections()
{
    return collections;
}

///////////////////////////////////////////////////////////////////////////////
// Select property methods
///////////////////////////////////////////////////////////////////////////////

void
avtSILMetaData::SelectCollections()
{
    Select(1, (void *)&collections);
}

///////////////////////////////////////////////////////////////////////////////
// AttributeGroupVector convenience methods.
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
// Method: avtSILMetaData::AddCollections
//
// Purpose: 
//   Contains SIL metadata attributes
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:18 PST 2007
//
// Modifications:
//   
// ****************************************************************************

void
avtSILMetaData::AddCollections(const avtSILCollectionMetaData &obj)
{
    avtSILCollectionMetaData *newavtSILCollectionMetaData = new avtSILCollectionMetaData(obj);
    collections.push_back(newavtSILCollectionMetaData);

    // Indicate that things have changed by selecting it.
    Select(1, (void *)&collections);
}

// ****************************************************************************
// Method: avtSILMetaData::ClearCollections
//
// Purpose: 
//   Contains SIL metadata attributes
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:18 PST 2007
//
// Modifications:
//   
// ****************************************************************************

void
avtSILMetaData::ClearCollections()
{
    AttributeGroupVector::iterator pos;

    for(pos = collections.begin(); pos != collections.end(); ++pos)
        delete *pos;
    collections.clear();

    // Indicate that things have changed by selecting the list.
    Select(1, (void *)&collections);
}

// ****************************************************************************
// Method: avtSILMetaData::RemoveCollections
//
// Purpose: 
//   Contains SIL metadata attributes
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:18 PST 2007
//
// Modifications:
//   
// ****************************************************************************

void
avtSILMetaData::RemoveCollections(int index)
{
    AttributeGroupVector::iterator pos = collections.begin();

    // Iterate through the vector "index" times. 
    for(int i = 0; i < index; ++i)
        ++pos;

    // If pos is still a valid iterator, remove that element.
    if(pos != collections.end())
    {
        delete *pos;
        collections.erase(pos);
    }

    // Indicate that things have changed by selecting the list.
    Select(1, (void *)&collections);
}

// ****************************************************************************
// Method: avtSILMetaData::GetNumCollections
//
// Purpose: 
//   Contains SIL metadata attributes
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:18 PST 2007
//
// Modifications:
//   
// ****************************************************************************

int
avtSILMetaData::GetNumCollections() const
{
    return collections.size();
}

// ****************************************************************************
// Method: avtSILMetaData::GetCollections
//
// Purpose: 
//   Contains SIL metadata attributes
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:18 PST 2007
//
// Modifications:
//   
// ****************************************************************************

avtSILCollectionMetaData &
avtSILMetaData::GetCollections(int i)
{
    return *((avtSILCollectionMetaData *)collections[i]);
}

// ****************************************************************************
// Method: avtSILMetaData::GetCollections
//
// Purpose: 
//   Contains SIL metadata attributes
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:18 PST 2007
//
// Modifications:
//   
// ****************************************************************************

const avtSILCollectionMetaData &
avtSILMetaData::GetCollections(int i) const
{
    return *((avtSILCollectionMetaData *)collections[i]);
}

// ****************************************************************************
// Method: avtSILMetaData::operator []
//
// Purpose: 
//   Contains SIL metadata attributes
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:18 PST 2007
//
// Modifications:
//   
// ****************************************************************************

avtSILCollectionMetaData &
avtSILMetaData::operator [] (int i)
{
    return *((avtSILCollectionMetaData *)collections[i]);
}

// ****************************************************************************
// Method: avtSILMetaData::operator []
//
// Purpose: 
//   Contains SIL metadata attributes
//
// Note:       Autogenerated by xml2atts.
//
// Programmer: xml2atts
// Creation:   Fri Mar 9 16:13:18 PST 2007
//
// Modifications:
//   
// ****************************************************************************

const avtSILCollectionMetaData &
avtSILMetaData::operator [] (int i) const
{
    return *((avtSILCollectionMetaData *)collections[i]);
}

///////////////////////////////////////////////////////////////////////////////
// User-defined methods.
///////////////////////////////////////////////////////////////////////////////

// ****************************************************************************
//  Method: avtSILMetaData default constructor 
//
//  Programmer:  Mark C. Miller
//  Creation:    02Sep03 
//
// ****************************************************************************
avtSILMetaData::avtSILMetaData(const std::string &_meshName)
    : AttributeSubject(avtSILMetaData::TypeMapFormatString)
{
    meshName = _meshName;

    // initially, we don't know the storage chunk class id
    theStorageChunkClassId = -1;

    // create pre-defined collection classes (currently just "whole")
    int wholeCollectionClassId = collections.size();
    avtSILCollectionMetaData wholeCollectionClass("whole", _meshName, 1, -1, -1, -1, NULL);
    AddCollections(wholeCollectionClass);

    classDisjointFlags.push_back(1);
    classIds.push_back(wholeCollectionClassId);
}

// ****************************************************************************
//  Method: avtSILMetaData::Print
//
//  Programmer:  Mark C. Miller
//  Creation:    02Sep03 
//
// ****************************************************************************
inline void
Indent(ostream &out, int indent)
{
    for (int i = 0 ; i < indent ; i++)
    {
        out << "\t";
    }
}
void
avtSILMetaData::Print(ostream& out, int indent) const
{
    int i;

    Indent(out, indent);
    out << "Mesh Name = " << meshName.c_str() << endl;

    Indent(out, indent);
    out << "Number of collection classes = " << classIds.size() << endl;

    Indent(out, indent);
    out << "Collection class names are..." << endl;
    for (i = 0; i < classIds.size(); i++)
    {
       Indent(out, indent+8);
       out << GetCollections(classIds[i]).GetClassName().c_str() << endl;
    }

    Indent(out, indent);
    out << "The storage chunk class = " <<
       GetCollections(theStorageChunkClassId).GetClassName().c_str() << endl;

    Indent(out, indent);
    out << "Collection details are..." << endl;
    for (i = 0; i < collections.size(); i++)
       GetCollections(i).Print(out,indent+8);

}

// ****************************************************************************
//  Method: avtSILMetaData::GetCollectionClassId
//
//  Programmer:  Mark C. Miller
//  Creation:    02Sep03 
//
// ****************************************************************************
int
avtSILMetaData::GetCollectionClassId(const std::string& className) const
{
    for (int i = 0; i < classIds.size(); i++)
    {
        const avtSILCollectionMetaData &obj = GetCollections(classIds[i]);
        if (className == obj.GetClassName())
            return classIds[i];
    }
    return -1;
}

// ****************************************************************************
//  Method: avtSILMetaData::AddCollectionClass
//
//  Purpose: Add a collection class to SIL metadata. A collection class is an
//  awful lot like a collection. In fact, it can be thought of as being
//  implemented as a collection on the whole though if hideFromWhole is true,
//  it won't be 'visible' on the whole from inside VisIt.
//
//  Collection class names must be unique. Only one collection class can be
//  created that has isStorageChunkClass true. Finally, the count of the number
//  of members in the collection class is a global count over the SIL of
//  sets of the associated class. For example, if you are creating a collection
//  class for patches in a block-structured AMR mesh, the numMembers you
//  would pass here is the total number of patches over all levels. Each
//  'entry' in the collection class uniquely identifies one of the patches.
//
//  Programmer:  Mark C. Miller
//  Creation:    02Sep03 
//
//  Modifications:
//    Brad Whitlock, Tue Mar 6 11:56:49 PDT 2007
//    Made it use methods for autogeneration.
//
// ****************************************************************************
int
avtSILMetaData::AddCollectionClass(const std::string &className,
   const std::string &defaultMemberBasename, int numMembers,
   int pairwiseDisjoint, bool hideFromWhole, bool isStorageChunkClass)
{
    int newCollectionClassId = collections.size();

    // make sure the number of members is sane
    if (numMembers <= 0)
    {
        EXCEPTION1(ImproperUseException, className);
    }

    // make sure the class name is unique
    for (int i = 0; i < classIds.size(); i++)
    {
        const avtSILCollectionMetaData &obj = GetCollections(classIds[i]);
        if (className == obj.GetClassName())
        {
            EXCEPTION1(ImproperUseException, className);
        }
    }

    // create the collection class entry
    avtSILCollectionMetaData newCollectionClass(className, defaultMemberBasename,
        numMembers, -1, -1, -1, NULL);
    AddCollections(newCollectionClass);

    classDisjointFlags.push_back(pairwiseDisjoint);
    classIds.push_back(newCollectionClassId);

    if (isStorageChunkClass)
    {
        if (theStorageChunkClassId != -1)
        {
            EXCEPTION1(ImproperUseException, className);
        }
 
        theStorageChunkClassId = newCollectionClassId;
    }

    return newCollectionClassId;
}

// ****************************************************************************
//  Method: avtSILMetaData::AddCollection 
//
//  Purpose: Add a collection to SIL meta data. A collection can be created
//  'from scratch' or in terms of another collection. In the former mode,
//  the caller does NOT specify either the collectionIdOfChildren of
//  indicesOfChildren arguments. In the later mode, the caller specifies
//  both of these arguments. The indicesOfChildren argument enumerates which
//  sets in the collection identified by collectionIdOfChildren, are in the
//  collection being here defined and, consequently, subsets of the set
//  identified by the pair <collectionIdOfParent,indexOfParent>.
//
//  Programmer:  Mark C. Miller
//  Creation:    02Sep03 
//
// ****************************************************************************
int
avtSILMetaData::AddCollection(
   const std::string &classOfCollection, const std::string &defaultMemberBasename,
   int collectionSize, int collectionIdOfParent, int indexOfParent,
   int collectionIdOfChildren, int *indicesOfChildren)
{
    int newCollectionId = GetNumCollections();

    if(collectionIdOfParent < 0 || collectionIdOfParent >= GetNumCollections())
    {
        EXCEPTION2(BadIndexException, collectionIdOfParent, GetNumCollections());
    }

    avtSILCollectionMetaData &parentCollection = GetCollections(collectionIdOfParent);
    if (indexOfParent < 0 || indexOfParent >= parentCollection.GetSize())
    {
        EXCEPTION2(BadIndexException, indexOfParent, parentCollection.GetSize());
    }

    if (collectionIdOfChildren < 0 && indicesOfChildren != NULL)
    {
        EXCEPTION1(ImproperUseException, classOfCollection);
    }

    if (collectionIdOfChildren >= 0)
    {
        avtSILCollectionMetaData &childrenCollection = GetCollections(collectionIdOfChildren);
        if (classOfCollection != childrenCollection.GetClassName())
        {
            EXCEPTION1(ImproperUseException, classOfCollection);
        }

        if (indicesOfChildren)
        {
            for (int i = 0; i < collectionSize; i++)
            {
                if (indicesOfChildren[i] >= childrenCollection.GetSize())
                {
                    EXCEPTION2(BadIndexException, indicesOfChildren[i], childrenCollection.GetSize());
                }
            }
        }  
    }

    avtSILCollectionMetaData newCollection(classOfCollection, defaultMemberBasename,
        collectionSize, collectionIdOfParent, indexOfParent,
        collectionIdOfChildren, indicesOfChildren);
    AddCollections(newCollection);

    return newCollectionId;
}

// ****************************************************************************
//  Method: avtSILMetaData::Validate
//
//  Purpose: check a SIL meta data object for errors.
//
//  Programmer:  Mark C. Miller
//  Creation:    02Sep03 
//
// ****************************************************************************
void
avtSILMetaData::Validate()
{
    if (theStorageChunkClassId == -1)
    {
        EXCEPTION0(ImproperUseException);
    }

    for (int i = 0; i < GetNumCollections(); i++)
    {
        const avtSILCollectionMetaData &coll = GetCollections(i);
  
        if ((coll.collectionIdOfChildren > 0) &&
            (GetCollections(coll.collectionIdOfChildren).GetType() != avtSILCollectionMetaData::Class))
        {
            if (coll.indicesOfChildren.size() == 0)
            {
                EXCEPTION0(ImproperUseException);
            }
   
            const avtSILCollectionMetaData &childColl = GetCollections(coll.collectionIdOfChildren);
  
            if (coll.collectionSize > childColl.collectionSize)
            {
                EXCEPTION0(ImproperUseException);
            }
   
            for (int j = 0; j < coll.collectionSize; j++)
            {
                if ((coll.indicesOfChildren[i] < 0) ||
                    (coll.indicesOfChildren[i] >= childColl.collectionSize))
                {
                    EXCEPTION2(BadIndexException, coll.indicesOfChildren[i],
                               childColl.collectionSize);
                }
            }
        }
    }
}


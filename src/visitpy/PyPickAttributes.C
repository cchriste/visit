#include <PyPickAttributes.h>
#include <ObserverToCallback.h>
#include <ColorAttribute.h>

// ****************************************************************************
// Module: PyPickAttributes
//
// Purpose: 
//   This class contains attributes used for pick.
//
// Note:       Autogenerated by xml2python. Do not modify by hand!
//
// Programmer: xml2python
// Creation:   Wed May 14 09:43:14 PDT 2003
//
// ****************************************************************************

//
// This struct contains the Python type information and a PickAttributes.
//
struct PickAttributesObject
{
    PyObject_HEAD
    PickAttributes *data;
    bool owns;
};

//
// Internal prototypes
//
static PyObject *NewPickAttributes();

static PyObject *
PickAttributes_Notify(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    obj->data->Notify();
    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_SetClearWindow(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;

    int ival;
    if(!PyArg_ParseTuple(args, "i", &ival))
        return NULL;

    // Set the clearWindow in the object.
    obj->data->SetClearWindow(ival != 0);

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_GetClearWindow(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetClearWindow()?1L:0L);
    return retval;
}

static PyObject *
PickAttributes_SetFulfilled(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;

    int ival;
    if(!PyArg_ParseTuple(args, "i", &ival))
        return NULL;

    // Set the fulfilled in the object.
    obj->data->SetFulfilled(ival != 0);

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_GetFulfilled(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetFulfilled()?1L:0L);
    return retval;
}

static PyObject *
PickAttributes_SetValidPick(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;

    int ival;
    if(!PyArg_ParseTuple(args, "i", &ival))
        return NULL;

    // Set the validPick in the object.
    obj->data->SetValidPick(ival != 0);

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_GetValidPick(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetValidPick()?1L:0L);
    return retval;
}

static PyObject *
PickAttributes_SetPickLetter(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;

    char *str;
    if(!PyArg_ParseTuple(args, "s", &str))
        return NULL;

    // Set the pickLetter in the object.
    obj->data->SetPickLetter(std::string(str));

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_GetPickLetter(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    PyObject *retval = PyString_FromString(obj->data->GetPickLetter().c_str());
    return retval;
}

static PyObject *
PickAttributes_SetZoneNumber(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;

    int ival;
    if(!PyArg_ParseTuple(args, "i", &ival))
        return NULL;

    // Set the zoneNumber in the object.
    obj->data->SetZoneNumber(ival);

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_GetZoneNumber(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetZoneNumber()));
    return retval;
}

static PyObject *
PickAttributes_SetTimeStep(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;

    int ival;
    if(!PyArg_ParseTuple(args, "i", &ival))
        return NULL;

    // Set the timeStep in the object.
    obj->data->SetTimeStep(ival);

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_GetTimeStep(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetTimeStep()));
    return retval;
}

static PyObject *
PickAttributes_SetDomain(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;

    int ival;
    if(!PyArg_ParseTuple(args, "i", &ival))
        return NULL;

    // Set the domain in the object.
    obj->data->SetDomain(ival);

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_GetDomain(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetDomain()));
    return retval;
}

static PyObject *
PickAttributes_SetDimension(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;

    int ival;
    if(!PyArg_ParseTuple(args, "i", &ival))
        return NULL;

    // Set the dimension in the object.
    obj->data->SetDimension(ival);

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_GetDimension(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(long(obj->data->GetDimension()));
    return retval;
}

static PyObject *
PickAttributes_SetDatabaseName(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;

    char *str;
    if(!PyArg_ParseTuple(args, "s", &str))
        return NULL;

    // Set the databaseName in the object.
    obj->data->SetDatabaseName(std::string(str));

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_GetDatabaseName(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    PyObject *retval = PyString_FromString(obj->data->GetDatabaseName().c_str());
    return retval;
}

static PyObject *
PickAttributes_SetActiveVariable(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;

    char *str;
    if(!PyArg_ParseTuple(args, "s", &str))
        return NULL;

    // Set the activeVariable in the object.
    obj->data->SetActiveVariable(std::string(str));

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_GetActiveVariable(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    PyObject *retval = PyString_FromString(obj->data->GetActiveVariable().c_str());
    return retval;
}

static PyObject *
PickAttributes_SetPickPoint(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;

    float *fvals = obj->data->GetPickPoint();
    if(!PyArg_ParseTuple(args, "fff", &fvals[0], &fvals[1], &fvals[2]))
    {
        PyObject     *tuple;
        if(!PyArg_ParseTuple(args, "O", &tuple))
            return NULL;

        if(PyTuple_Check(tuple))
        {
            if(PyTuple_Size(tuple) != 3)
                return NULL;

            PyErr_Clear();
            for(int i = 0; i < PyTuple_Size(tuple); ++i)
            {
                PyObject *item = PyTuple_GET_ITEM(tuple, i);
                if(PyFloat_Check(item))
                    fvals[i] = float(PyFloat_AS_DOUBLE(item));
                else if(PyInt_Check(item))
                    fvals[i] = float(PyInt_AS_LONG(item));
                else if(PyLong_Check(item))
                    fvals[i] = float(PyLong_AsDouble(item));
                else
                    fvals[i] = 0.;
            }
        }
        else
            return NULL;
    }

    // Mark the pickPoint in the object as modified.
    obj->data->SelectPickPoint();

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_GetPickPoint(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    // Allocate a tuple the with enough entries to hold the pickPoint.
    PyObject *retval = PyTuple_New(3);
    const float *pickPoint = obj->data->GetPickPoint();
    for(int i = 0; i < 3; ++i)
        PyTuple_SET_ITEM(retval, i, PyFloat_FromDouble(double(pickPoint[i])));
    return retval;
}

static PyObject *
PickAttributes_SetCellPoint(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;

    float *fvals = obj->data->GetCellPoint();
    if(!PyArg_ParseTuple(args, "fff", &fvals[0], &fvals[1], &fvals[2]))
    {
        PyObject     *tuple;
        if(!PyArg_ParseTuple(args, "O", &tuple))
            return NULL;

        if(PyTuple_Check(tuple))
        {
            if(PyTuple_Size(tuple) != 3)
                return NULL;

            PyErr_Clear();
            for(int i = 0; i < PyTuple_Size(tuple); ++i)
            {
                PyObject *item = PyTuple_GET_ITEM(tuple, i);
                if(PyFloat_Check(item))
                    fvals[i] = float(PyFloat_AS_DOUBLE(item));
                else if(PyInt_Check(item))
                    fvals[i] = float(PyInt_AS_LONG(item));
                else if(PyLong_Check(item))
                    fvals[i] = float(PyLong_AsDouble(item));
                else
                    fvals[i] = 0.;
            }
        }
        else
            return NULL;
    }

    // Mark the cellPoint in the object as modified.
    obj->data->SelectCellPoint();

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_GetCellPoint(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    // Allocate a tuple the with enough entries to hold the cellPoint.
    PyObject *retval = PyTuple_New(3);
    const float *cellPoint = obj->data->GetCellPoint();
    for(int i = 0; i < 3; ++i)
        PyTuple_SET_ITEM(retval, i, PyFloat_FromDouble(double(cellPoint[i])));
    return retval;
}

static PyObject *
PickAttributes_SetNodes(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;

    intVector  &vec = obj->data->GetNodes();
    PyObject   *tuple;
    if(!PyArg_ParseTuple(args, "O", &tuple))
        return NULL;

    if(PyTuple_Check(tuple))
    {
        vec.resize(PyTuple_Size(tuple));
        for(int i = 0; i < PyTuple_Size(tuple); ++i)
        {
            PyObject *item = PyTuple_GET_ITEM(tuple, i);
            if(PyFloat_Check(item))
                vec[i] = int(PyFloat_AS_DOUBLE(item));
            else if(PyInt_Check(item))
                vec[i] = int(PyInt_AS_LONG(item));
            else if(PyLong_Check(item))
                vec[i] = int(PyLong_AsLong(item));
            else
                vec[i] = 0;
        }
    }
    else if(PyFloat_Check(tuple))
    {
        vec.resize(1);
        vec[0] = int(PyFloat_AS_DOUBLE(tuple));
    }
    else if(PyInt_Check(tuple))
    {
        vec.resize(1);
        vec[0] = int(PyInt_AS_LONG(tuple));
    }
    else if(PyLong_Check(tuple))
    {
        vec.resize(1);
        vec[0] = int(PyLong_AsLong(tuple));
    }
    else
        return NULL;

    // Mark the nodes in the object as modified.
    obj->data->SelectNodes();

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_GetNodes(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    // Allocate a tuple the with enough entries to hold the nodes.
    const intVector &nodes = obj->data->GetNodes();
    PyObject *retval = PyTuple_New(nodes.size());
    for(int i = 0; i < nodes.size(); ++i)
        PyTuple_SET_ITEM(retval, i, PyInt_FromLong(long(nodes[i])));
    return retval;
}

static PyObject *
PickAttributes_SetUserSelectedVars(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;

    stringVector  &vec = obj->data->GetUserSelectedVars();
    PyObject     *tuple;
    if(!PyArg_ParseTuple(args, "O", &tuple))
        return NULL;

    if(PyTuple_Check(tuple))
    {
        vec.resize(PyTuple_Size(tuple));
        for(int i = 0; i < PyTuple_Size(tuple); ++i)
        {
            PyObject *item = PyTuple_GET_ITEM(tuple, i);
            if(PyString_Check(item))
                vec[i] = std::string(PyString_AS_STRING(item));
            else
                vec[i] = std::string("");
        }
    }
    else if(PyString_Check(tuple))
    {
        vec.resize(1);
        vec[0] = std::string(PyString_AS_STRING(tuple));
    }
    else
        return NULL;

    // Mark the userSelectedVars in the object as modified.
    obj->data->SelectUserSelectedVars();

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_GetUserSelectedVars(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    // Allocate a tuple the with enough entries to hold the userSelectedVars.
    const stringVector &userSelectedVars = obj->data->GetUserSelectedVars();
    PyObject *retval = PyTuple_New(userSelectedVars.size());
    for(int i = 0; i < userSelectedVars.size(); ++i)
        PyTuple_SET_ITEM(retval, i, PyString_FromString(userSelectedVars[i].c_str()));
    return retval;
}

static PyObject *
PickAttributes_SetVarInfo(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;

    // NOT IMPLEMENTED!!!
    // name=varInfo, type=attVector

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_GetVarInfo(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    // NOT IMPLEMENTED!!!
    // name=varInfo, type=attVector
    PyObject *retval = NULL;
    return retval;
}

static PyObject *
PickAttributes_SetUseNodeCoords(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;

    int ival;
    if(!PyArg_ParseTuple(args, "i", &ival))
        return NULL;

    // Set the useNodeCoords in the object.
    obj->data->SetUseNodeCoords(ival != 0);

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_GetUseNodeCoords(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetUseNodeCoords()?1L:0L);
    return retval;
}

static PyObject *
PickAttributes_SetLogicalCoords(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;

    int ival;
    if(!PyArg_ParseTuple(args, "i", &ival))
        return NULL;

    // Set the logicalCoords in the object.
    obj->data->SetLogicalCoords(ival != 0);

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_GetLogicalCoords(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetLogicalCoords()?1L:0L);
    return retval;
}

static PyObject *
PickAttributes_SetNodeCoords(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;

    stringVector  &vec = obj->data->GetNodeCoords();
    PyObject     *tuple;
    if(!PyArg_ParseTuple(args, "O", &tuple))
        return NULL;

    if(PyTuple_Check(tuple))
    {
        vec.resize(PyTuple_Size(tuple));
        for(int i = 0; i < PyTuple_Size(tuple); ++i)
        {
            PyObject *item = PyTuple_GET_ITEM(tuple, i);
            if(PyString_Check(item))
                vec[i] = std::string(PyString_AS_STRING(item));
            else
                vec[i] = std::string("");
        }
    }
    else if(PyString_Check(tuple))
    {
        vec.resize(1);
        vec[0] = std::string(PyString_AS_STRING(tuple));
    }
    else
        return NULL;

    // Mark the nodeCoords in the object as modified.
    obj->data->SelectNodeCoords();

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_GetNodeCoords(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    // Allocate a tuple the with enough entries to hold the nodeCoords.
    const stringVector &nodeCoords = obj->data->GetNodeCoords();
    PyObject *retval = PyTuple_New(nodeCoords.size());
    for(int i = 0; i < nodeCoords.size(); ++i)
        PyTuple_SET_ITEM(retval, i, PyString_FromString(nodeCoords[i].c_str()));
    return retval;
}

static PyObject *
PickAttributes_SetRayPoint1(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;

    float *fvals = obj->data->GetRayPoint1();
    if(!PyArg_ParseTuple(args, "fff", &fvals[0], &fvals[1], &fvals[2]))
    {
        PyObject     *tuple;
        if(!PyArg_ParseTuple(args, "O", &tuple))
            return NULL;

        if(PyTuple_Check(tuple))
        {
            if(PyTuple_Size(tuple) != 3)
                return NULL;

            PyErr_Clear();
            for(int i = 0; i < PyTuple_Size(tuple); ++i)
            {
                PyObject *item = PyTuple_GET_ITEM(tuple, i);
                if(PyFloat_Check(item))
                    fvals[i] = float(PyFloat_AS_DOUBLE(item));
                else if(PyInt_Check(item))
                    fvals[i] = float(PyInt_AS_LONG(item));
                else if(PyLong_Check(item))
                    fvals[i] = float(PyLong_AsDouble(item));
                else
                    fvals[i] = 0.;
            }
        }
        else
            return NULL;
    }

    // Mark the rayPoint1 in the object as modified.
    obj->data->SelectRayPoint1();

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_GetRayPoint1(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    // Allocate a tuple the with enough entries to hold the rayPoint1.
    PyObject *retval = PyTuple_New(3);
    const float *rayPoint1 = obj->data->GetRayPoint1();
    for(int i = 0; i < 3; ++i)
        PyTuple_SET_ITEM(retval, i, PyFloat_FromDouble(double(rayPoint1[i])));
    return retval;
}

static PyObject *
PickAttributes_SetRayPoint2(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;

    float *fvals = obj->data->GetRayPoint2();
    if(!PyArg_ParseTuple(args, "fff", &fvals[0], &fvals[1], &fvals[2]))
    {
        PyObject     *tuple;
        if(!PyArg_ParseTuple(args, "O", &tuple))
            return NULL;

        if(PyTuple_Check(tuple))
        {
            if(PyTuple_Size(tuple) != 3)
                return NULL;

            PyErr_Clear();
            for(int i = 0; i < PyTuple_Size(tuple); ++i)
            {
                PyObject *item = PyTuple_GET_ITEM(tuple, i);
                if(PyFloat_Check(item))
                    fvals[i] = float(PyFloat_AS_DOUBLE(item));
                else if(PyInt_Check(item))
                    fvals[i] = float(PyInt_AS_LONG(item));
                else if(PyLong_Check(item))
                    fvals[i] = float(PyLong_AsDouble(item));
                else
                    fvals[i] = 0.;
            }
        }
        else
            return NULL;
    }

    // Mark the rayPoint2 in the object as modified.
    obj->data->SelectRayPoint2();

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_GetRayPoint2(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    // Allocate a tuple the with enough entries to hold the rayPoint2.
    PyObject *retval = PyTuple_New(3);
    const float *rayPoint2 = obj->data->GetRayPoint2();
    for(int i = 0; i < 3; ++i)
        PyTuple_SET_ITEM(retval, i, PyFloat_FromDouble(double(rayPoint2[i])));
    return retval;
}

static PyObject *
PickAttributes_SetNeedTransformMessage(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;

    int ival;
    if(!PyArg_ParseTuple(args, "i", &ival))
        return NULL;

    // Set the needTransformMessage in the object.
    obj->data->SetNeedTransformMessage(ival != 0);

    Py_INCREF(Py_None);
    return Py_None;
}

static PyObject *
PickAttributes_GetNeedTransformMessage(PyObject *self, PyObject *args)
{
    PickAttributesObject *obj = (PickAttributesObject *)self;
    PyObject *retval = PyInt_FromLong(obj->data->GetNeedTransformMessage()?1L:0L);
    return retval;
}



static struct PyMethodDef PickAttributes_methods[] = {
    {"Notify", PickAttributes_Notify, METH_VARARGS},
    {"SetClearWindow", PickAttributes_SetClearWindow, METH_VARARGS},
    {"GetClearWindow", PickAttributes_GetClearWindow, METH_VARARGS},
    {"SetFulfilled", PickAttributes_SetFulfilled, METH_VARARGS},
    {"GetFulfilled", PickAttributes_GetFulfilled, METH_VARARGS},
    {"SetValidPick", PickAttributes_SetValidPick, METH_VARARGS},
    {"GetValidPick", PickAttributes_GetValidPick, METH_VARARGS},
    {"SetPickLetter", PickAttributes_SetPickLetter, METH_VARARGS},
    {"GetPickLetter", PickAttributes_GetPickLetter, METH_VARARGS},
    {"SetZoneNumber", PickAttributes_SetZoneNumber, METH_VARARGS},
    {"GetZoneNumber", PickAttributes_GetZoneNumber, METH_VARARGS},
    {"SetTimeStep", PickAttributes_SetTimeStep, METH_VARARGS},
    {"GetTimeStep", PickAttributes_GetTimeStep, METH_VARARGS},
    {"SetDomain", PickAttributes_SetDomain, METH_VARARGS},
    {"GetDomain", PickAttributes_GetDomain, METH_VARARGS},
    {"SetDimension", PickAttributes_SetDimension, METH_VARARGS},
    {"GetDimension", PickAttributes_GetDimension, METH_VARARGS},
    {"SetDatabaseName", PickAttributes_SetDatabaseName, METH_VARARGS},
    {"GetDatabaseName", PickAttributes_GetDatabaseName, METH_VARARGS},
    {"SetActiveVariable", PickAttributes_SetActiveVariable, METH_VARARGS},
    {"GetActiveVariable", PickAttributes_GetActiveVariable, METH_VARARGS},
    {"SetPickPoint", PickAttributes_SetPickPoint, METH_VARARGS},
    {"GetPickPoint", PickAttributes_GetPickPoint, METH_VARARGS},
    {"SetCellPoint", PickAttributes_SetCellPoint, METH_VARARGS},
    {"GetCellPoint", PickAttributes_GetCellPoint, METH_VARARGS},
    {"SetNodes", PickAttributes_SetNodes, METH_VARARGS},
    {"GetNodes", PickAttributes_GetNodes, METH_VARARGS},
    {"SetUserSelectedVars", PickAttributes_SetUserSelectedVars, METH_VARARGS},
    {"GetUserSelectedVars", PickAttributes_GetUserSelectedVars, METH_VARARGS},
    {"SetVarInfo", PickAttributes_SetVarInfo, METH_VARARGS},
    {"GetVarInfo", PickAttributes_GetVarInfo, METH_VARARGS},
    {"SetUseNodeCoords", PickAttributes_SetUseNodeCoords, METH_VARARGS},
    {"GetUseNodeCoords", PickAttributes_GetUseNodeCoords, METH_VARARGS},
    {"SetLogicalCoords", PickAttributes_SetLogicalCoords, METH_VARARGS},
    {"GetLogicalCoords", PickAttributes_GetLogicalCoords, METH_VARARGS},
    {"SetNodeCoords", PickAttributes_SetNodeCoords, METH_VARARGS},
    {"GetNodeCoords", PickAttributes_GetNodeCoords, METH_VARARGS},
    {"SetRayPoint1", PickAttributes_SetRayPoint1, METH_VARARGS},
    {"GetRayPoint1", PickAttributes_GetRayPoint1, METH_VARARGS},
    {"SetRayPoint2", PickAttributes_SetRayPoint2, METH_VARARGS},
    {"GetRayPoint2", PickAttributes_GetRayPoint2, METH_VARARGS},
    {"SetNeedTransformMessage", PickAttributes_SetNeedTransformMessage, METH_VARARGS},
    {"GetNeedTransformMessage", PickAttributes_GetNeedTransformMessage, METH_VARARGS},
    {NULL, NULL}
};

//
// Type functions
//

static void
PickAttributes_dealloc(PyObject *v)
{
   PickAttributesObject *obj = (PickAttributesObject *)v;
   if(obj->owns)
       delete obj->data;
}

static int
PickAttributes_compare(PyObject *v, PyObject *w)
{
    PickAttributes *a = ((PickAttributesObject *)v)->data;
    PickAttributes *b = ((PickAttributesObject *)w)->data;
    return (*a == *b) ? 0 : -1;
}

static PyObject *
PickAttributes_getattr(PyObject *self, char *name)
{
    if(strcmp(name, "clearWindow") == 0)
        return PickAttributes_GetClearWindow(self, NULL);
    if(strcmp(name, "fulfilled") == 0)
        return PickAttributes_GetFulfilled(self, NULL);
    if(strcmp(name, "validPick") == 0)
        return PickAttributes_GetValidPick(self, NULL);
    if(strcmp(name, "pickLetter") == 0)
        return PickAttributes_GetPickLetter(self, NULL);
    if(strcmp(name, "zoneNumber") == 0)
        return PickAttributes_GetZoneNumber(self, NULL);
    if(strcmp(name, "timeStep") == 0)
        return PickAttributes_GetTimeStep(self, NULL);
    if(strcmp(name, "domain") == 0)
        return PickAttributes_GetDomain(self, NULL);
    if(strcmp(name, "dimension") == 0)
        return PickAttributes_GetDimension(self, NULL);
    if(strcmp(name, "databaseName") == 0)
        return PickAttributes_GetDatabaseName(self, NULL);
    if(strcmp(name, "activeVariable") == 0)
        return PickAttributes_GetActiveVariable(self, NULL);
    if(strcmp(name, "pickPoint") == 0)
        return PickAttributes_GetPickPoint(self, NULL);
    if(strcmp(name, "cellPoint") == 0)
        return PickAttributes_GetCellPoint(self, NULL);
    if(strcmp(name, "nodes") == 0)
        return PickAttributes_GetNodes(self, NULL);
    if(strcmp(name, "userSelectedVars") == 0)
        return PickAttributes_GetUserSelectedVars(self, NULL);
    if(strcmp(name, "useNodeCoords") == 0)
        return PickAttributes_GetUseNodeCoords(self, NULL);
    if(strcmp(name, "logicalCoords") == 0)
        return PickAttributes_GetLogicalCoords(self, NULL);
    if(strcmp(name, "nodeCoords") == 0)
        return PickAttributes_GetNodeCoords(self, NULL);
    if(strcmp(name, "rayPoint1") == 0)
        return PickAttributes_GetRayPoint1(self, NULL);
    if(strcmp(name, "rayPoint2") == 0)
        return PickAttributes_GetRayPoint2(self, NULL);
    if(strcmp(name, "needTransformMessage") == 0)
        return PickAttributes_GetNeedTransformMessage(self, NULL);

    return Py_FindMethod(PickAttributes_methods, self, name);
}

static int
PickAttributes_setattr(PyObject *self, char *name, PyObject *args)
{
    // Create a tuple to contain the arguments since all of the Set
    // functions expect a tuple.
    PyObject *tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(tuple, 0, args);
    Py_INCREF(args);
    bool retval = false;

    if(strcmp(name, "clearWindow") == 0)
        retval = (PickAttributes_SetClearWindow(self, tuple) != NULL);
    else if(strcmp(name, "fulfilled") == 0)
        retval = (PickAttributes_SetFulfilled(self, tuple) != NULL);
    else if(strcmp(name, "validPick") == 0)
        retval = (PickAttributes_SetValidPick(self, tuple) != NULL);
    else if(strcmp(name, "pickLetter") == 0)
        retval = (PickAttributes_SetPickLetter(self, tuple) != NULL);
    else if(strcmp(name, "zoneNumber") == 0)
        retval = (PickAttributes_SetZoneNumber(self, tuple) != NULL);
    else if(strcmp(name, "timeStep") == 0)
        retval = (PickAttributes_SetTimeStep(self, tuple) != NULL);
    else if(strcmp(name, "domain") == 0)
        retval = (PickAttributes_SetDomain(self, tuple) != NULL);
    else if(strcmp(name, "dimension") == 0)
        retval = (PickAttributes_SetDimension(self, tuple) != NULL);
    else if(strcmp(name, "databaseName") == 0)
        retval = (PickAttributes_SetDatabaseName(self, tuple) != NULL);
    else if(strcmp(name, "activeVariable") == 0)
        retval = (PickAttributes_SetActiveVariable(self, tuple) != NULL);
    else if(strcmp(name, "pickPoint") == 0)
        retval = (PickAttributes_SetPickPoint(self, tuple) != NULL);
    else if(strcmp(name, "cellPoint") == 0)
        retval = (PickAttributes_SetCellPoint(self, tuple) != NULL);
    else if(strcmp(name, "nodes") == 0)
        retval = (PickAttributes_SetNodes(self, tuple) != NULL);
    else if(strcmp(name, "userSelectedVars") == 0)
        retval = (PickAttributes_SetUserSelectedVars(self, tuple) != NULL);
    else if(strcmp(name, "useNodeCoords") == 0)
        retval = (PickAttributes_SetUseNodeCoords(self, tuple) != NULL);
    else if(strcmp(name, "logicalCoords") == 0)
        retval = (PickAttributes_SetLogicalCoords(self, tuple) != NULL);
    else if(strcmp(name, "nodeCoords") == 0)
        retval = (PickAttributes_SetNodeCoords(self, tuple) != NULL);
    else if(strcmp(name, "rayPoint1") == 0)
        retval = (PickAttributes_SetRayPoint1(self, tuple) != NULL);
    else if(strcmp(name, "rayPoint2") == 0)
        retval = (PickAttributes_SetRayPoint2(self, tuple) != NULL);
    else if(strcmp(name, "needTransformMessage") == 0)
        retval = (PickAttributes_SetNeedTransformMessage(self, tuple) != NULL);

    Py_DECREF(tuple);
    return retval ? 0 : -1;
}

static int
PickAttributes_print(PyObject *v, FILE *fp, int flags)
{
    PickAttributesObject *obj = (PickAttributesObject *)v;

    if(obj->data->GetClearWindow())
        fprintf(fp, "clearWindow = 1\n");
    else
        fprintf(fp, "clearWindow = 0\n");
    if(obj->data->GetFulfilled())
        fprintf(fp, "fulfilled = 1\n");
    else
        fprintf(fp, "fulfilled = 0\n");
    if(obj->data->GetValidPick())
        fprintf(fp, "validPick = 1\n");
    else
        fprintf(fp, "validPick = 0\n");
    fprintf(fp, "pickLetter = \"%s\"\n", obj->data->GetPickLetter().c_str());
    fprintf(fp, "zoneNumber = %d\n", obj->data->GetZoneNumber());
    fprintf(fp, "timeStep = %d\n", obj->data->GetTimeStep());
    fprintf(fp, "domain = %d\n", obj->data->GetDomain());
    fprintf(fp, "dimension = %d\n", obj->data->GetDimension());
    fprintf(fp, "databaseName = \"%s\"\n", obj->data->GetDatabaseName().c_str());
    fprintf(fp, "activeVariable = \"%s\"\n", obj->data->GetActiveVariable().c_str());
    {   const float *pickPoint = obj->data->GetPickPoint();
        fprintf(fp, "pickPoint = (");
        for(int i = 0; i < 3; ++i)
        {
            fprintf(fp, "%g", pickPoint[i]);
            if(i < 2)
                fprintf(fp, ", ");
        }
        fprintf(fp, ")\n");
    }
    {   const float *cellPoint = obj->data->GetCellPoint();
        fprintf(fp, "cellPoint = (");
        for(int i = 0; i < 3; ++i)
        {
            fprintf(fp, "%g", cellPoint[i]);
            if(i < 2)
                fprintf(fp, ", ");
        }
        fprintf(fp, ")\n");
    }
    {   const intVector &nodes = obj->data->GetNodes();
        fprintf(fp, "nodes = (");
        for(int i = 0; i < nodes.size(); ++i)
        {
            fprintf(fp, "%d", nodes[i]);
            if(i < nodes.size() - 1)
                fprintf(fp, ", ");
        }
        fprintf(fp, ")\n");
    }
    {   const stringVector &userSelectedVars = obj->data->GetUserSelectedVars();
        fprintf(fp, "userSelectedVars = (");
        for(int i = 0; i < userSelectedVars.size(); ++i)
        {
            fprintf(fp, "\"%s\"", userSelectedVars[i].c_str());
            if(i < userSelectedVars.size() - 1)
                fprintf(fp, ", ");
        }
        fprintf(fp, ")\n");
    }
    //varInfo
    if(obj->data->GetUseNodeCoords())
        fprintf(fp, "useNodeCoords = 1\n");
    else
        fprintf(fp, "useNodeCoords = 0\n");
    if(obj->data->GetLogicalCoords())
        fprintf(fp, "logicalCoords = 1\n");
    else
        fprintf(fp, "logicalCoords = 0\n");
    {   const stringVector &nodeCoords = obj->data->GetNodeCoords();
        fprintf(fp, "nodeCoords = (");
        for(int i = 0; i < nodeCoords.size(); ++i)
        {
            fprintf(fp, "\"%s\"", nodeCoords[i].c_str());
            if(i < nodeCoords.size() - 1)
                fprintf(fp, ", ");
        }
        fprintf(fp, ")\n");
    }
    {   const float *rayPoint1 = obj->data->GetRayPoint1();
        fprintf(fp, "rayPoint1 = (");
        for(int i = 0; i < 3; ++i)
        {
            fprintf(fp, "%g", rayPoint1[i]);
            if(i < 2)
                fprintf(fp, ", ");
        }
        fprintf(fp, ")\n");
    }
    {   const float *rayPoint2 = obj->data->GetRayPoint2();
        fprintf(fp, "rayPoint2 = (");
        for(int i = 0; i < 3; ++i)
        {
            fprintf(fp, "%g", rayPoint2[i]);
            if(i < 2)
                fprintf(fp, ", ");
        }
        fprintf(fp, ")\n");
    }
    if(obj->data->GetNeedTransformMessage())
        fprintf(fp, "needTransformMessage = 1\n");
    else
        fprintf(fp, "needTransformMessage = 0\n");

    return 0;
}

//
// The doc string for the class.
//
static char *PickAttributes_Purpose = "This class contains attributes used for pick.";

//
// The type description structure
//
static PyTypeObject PickAttributesType =
{
    //
    // Type header
    //
    PyObject_HEAD_INIT(&PyType_Type)
    0,                                   // ob_size
    "PickAttributes",                    // tp_name
    sizeof(PickAttributesObject),        // tp_basicsize
    0,                                   // tp_itemsize
    //
    // Standard methods
    //
    (destructor)PickAttributes_dealloc,  // tp_dealloc
    (printfunc)PickAttributes_print,     // tp_print
    (getattrfunc)PickAttributes_getattr, // tp_getattr
    (setattrfunc)PickAttributes_setattr, // tp_setattr
    (cmpfunc)PickAttributes_compare,     // tp_compare
    (reprfunc)0,                         // tp_repr
    //
    // Type categories
    //
    0,                                   // tp_as_number
    0,                                   // tp_as_sequence
    0,                                   // tp_as_mapping
    //
    // More methods
    //
    0,                                   // tp_hash
    0,                                   // tp_call
    0,                                   // tp_str
    0,                                   // tp_getattro
    0,                                   // tp_setattro
    0,                                   // tp_as_buffer
    Py_TPFLAGS_CHECKTYPES,               // tp_flags
    PickAttributes_Purpose,              // tp_doc
    0,                                   // tp_traverse
    0,                                   // tp_clear
    0,                                   // tp_richcompare
    0                                    // tp_weaklistoffset
};

//
// Helper functions for object allocation.
//

static PickAttributes *defaultAtts = 0;

static PyObject *
NewPickAttributes()
{
    PickAttributesObject *newObject;
    newObject = PyObject_NEW(PickAttributesObject, &PickAttributesType);
    if(newObject == NULL)
        return NULL;
    if(defaultAtts)
        newObject->data = new PickAttributes(*defaultAtts);
    else
        newObject->data = new PickAttributes;
    newObject->owns = true;
    return (PyObject *)newObject;
}

static PyObject *
WrapPickAttributes(const PickAttributes *attr)
{
    PickAttributesObject *newObject;
    newObject = PyObject_NEW(PickAttributesObject, &PickAttributesType);
    if(newObject == NULL)
        return NULL;
    newObject->data = (PickAttributes *)attr;
    newObject->owns = false;
    return (PyObject *)newObject;
}

///////////////////////////////////////////////////////////////////////////////
//
// Interface that is exposed to the VisIt module.
//
///////////////////////////////////////////////////////////////////////////////

PyObject *
PickAttributes_new(PyObject *self, PyObject *args)
{
    if (!PyArg_ParseTuple(args, ""))
        return NULL;
    return (PyObject *)NewPickAttributes();
}

//
// Plugin method table. These methods are added to the visitmodule's methods.
//
static PyMethodDef PickAttributesMethods[] = {
    {"PickAttributes", PickAttributes_new, METH_VARARGS},
    {NULL,      NULL}        /* Sentinel */
};

static Observer *PickAttributesObserver = 0;
static bool PickAttributesEnableLogging = true;

static void
PyPickAttributes_WriteLog(Subject *subj, void *data)
{
    PickAttributes *atts = (PickAttributes *)subj;
    FILE *logFile = (FILE *)data;

    if(!PickAttributesEnableLogging || (logFile == NULL))
        return;

    fprintf(logFile, "# PickAttributes_WriteLog()\n");
}

void
PyPickAttributes_StartUp(PickAttributes *subj, FILE *logFile)
{
    if(subj == 0)
        return;

    PyPickAttributes_SetDefaults(subj);

    //
    // Create the observer that will be notified when the attributes change.
    //
    if(PickAttributesObserver == 0)
    {
        PickAttributesObserver = new ObserverToCallback(subj,
            PyPickAttributes_WriteLog, (void *)logFile);
    }

    PickAttributesEnableLogging = true;
}

void
PyPickAttributes_CloseDown()
{
    delete defaultAtts;
    defaultAtts = 0;
    delete PickAttributesObserver;
    PickAttributesObserver = 0;
}

PyMethodDef *
PyPickAttributes_GetMethodTable(int *nMethods)
{
    *nMethods = 1;
    return PickAttributesMethods;
}

bool
PyPickAttributes_Check(PyObject *obj)
{
    return (obj->ob_type == &PickAttributesType);
}

PickAttributes *
PyPickAttributes_FromPyObject(PyObject *obj)
{
    PickAttributesObject *obj2 = (PickAttributesObject *)obj;
    return obj2->data;
}

PyObject *
PyPickAttributes_NewPyObject()
{
    return NewPickAttributes();
}

PyObject *
PyPickAttributes_WrapPyObject(const PickAttributes *attr)
{
    return WrapPickAttributes(attr);
}

void
PyPickAttributes_SetLogging(bool val)
{
    PickAttributesEnableLogging = val;
}

void
PyPickAttributes_SetDefaults(const PickAttributes *atts)
{
    if(defaultAtts)
        delete defaultAtts;

    defaultAtts = new PickAttributes(*atts);
}

